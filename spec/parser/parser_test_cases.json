["nil", "true", "false", "1", "+1", "-1", "1_i64", "+1_i64", "-1_i64", "1_u128", "1_i128", "1.0", "+1.0", "-1.0", "1.0_f32", "+1.0_f32", "-1.0_f32", "2.3_f32", "'a'", "\"foo\"", "\"\"", "\"hello \\\\\\n     world\"", "\"hello \\\\\\r\\n     world\"", "%Q{hello \\\\n world}", "%q{hello \\\\n world}", "%q{hello \\#{foo} world}", ":foo", ":foo!", ":foo?", ":\"foo\"", ":\u304b\u305f\u306a", ":+", ":-", ":*", ":/", ":==", ":<", ":<=", ":>", ":>=", ":!", ":!=", ":=~", ":!~", ":&", ":|", ":^", ":~", ":**", ":&**", ":>>", ":<<", ":%", ":[]", ":[]?", ":[]=", ":<=>", ":===", ":[]=", ":[]?", ":\"\\\\\\\\foo\"", ":\"\\\\\"foo\"", ":\"\\\\\"foo\\\\\"\"", ":\"\\\\a\\\\b\\\\n\\\\r\\\\t\\\\v\\\\f\\\\e\"", ":\"\\\\u{61}\"", ":\"\"", "[1, 2]", "[\n1, 2]", "[1,\n 2,]", "1 + 2", "1 +\n2", "1 +2", "1 -2", "1 +2.0", "1 -2.0", "1 +2_i64", "1 -2_i64", "1\n+2", "1;+2", "1 - 2", "1 -\n2", "1\n-2", "1;-2", "1 * 2", "1 * -2", "2 * 3 + 4 * 5", "1 / 2", "1 / -2", "2 / 3 + 4 / 5", "2 * (3 + 4)", "a = 1; b = 2; c = 3; a-b-c", "a = 1; b = 2; c = 3; a-b -c", "1/2", "1 + /foo/", "1+0", "a = 1; a /b", "a = 1; a/b", "a = 1; (a)/b", "_ = 1", "@foo/2", "@@foo/2", "1+2*3", "foo[] /2", "foo[1] /2", "[1] /2", "2**3**4", "foo%i", "foo%q", "foo%Q", "foo%r", "foo%x", "foo%w", "foo %i", "foo %q", "foo %Q", "foo %r", "foo %x", "foo %w", "foo %i()", "foo %q()", "foo %Q()", "foo %r()", "foo %x()", "foo %w()", "foo % i()", "foo % q()", "foo % Q()", "foo % r()", "foo % x()", "foo % w()", "!1", "- 1", "+ 1", "~ 1", "1.~", "1.!", "1 && 2", "1 || 2", "&- 1", "&+ 1", "1 <=> 2", "1 !~ 2", "a = 1", "a = b = 2", "a[] = 1", "a.[] = 1", "a, b = 1, 2", "a, b = 1", "_, _ = 1, 2", "a[0], a[1] = 1, 2", "a[], a[] = 1, 2", "a.foo, a.bar = 1, 2", "x = 0; a, b = x += 1", "a, b = 1, 2 if 3", "*a = 1", "*a = 1, 2", "*_ = 1, 2", "*a, b = 1", "a, *b = 1", "a, *b = 1, 2", "*a, b = 1, 2, 3, 4", "a, b, *c = 1", "a, b, *c = 1, 2", "_, *_, _, _ = 1, 2, 3", "*a.foo, a.bar = 1", "a.foo, *a.bar = 1", "@a, b = 1, 2", "@@a, b = 1, 2", "\u3042.\u3044, \u3046.\u3048.\u304a = 1, 2", "def foo\n1\nend", "def downto(n)\n1\nend", "def foo ; 1 ; end", "def foo; end", "def foo(var); end", "def foo(\nvar); end", "def foo(\nvar\n); end", "def foo(var1, var2); end", "def foo; 1; 2; end", "def foo=(value); end", "def foo(n); foo(n -1); end", "def type(type); end", "def <=(other, file = 1); end", "def >=(other, file = 1); end", "def ==(other, file = 1); end", "def !=(other, file = 1); end", "def []=(other, file = 1); end", "def ===(other, file = 1); end", "def <=(*args, **opts); end", "def >=(*args, **opts); end", "def ==(*args, **opts); end", "def !=(*args, **opts); end", "def []=(*args, **opts); end", "def ===(*args, **opts); end", "def <=(*args, **opts, &); end", "def >=(*args, **opts, &); end", "def ==(*args, **opts, &); end", "def !=(*args, **opts, &); end", "def []=(*args, **opts, &); end", "def ===(*args, **opts, &); end", "def foo(#{kw} foo); end", "def foo(@#{kw}); end", "def foo(@@#{kw}); end", "def foo(x @#{kw}); end", "def foo(x @@#{kw}); end", "def foo(#{name} foo); end", "macro foo(#{name} foo); end", "foo(#{name})", "foo #{name}", "def self.foo\n1\nend", "def self.foo()\n1\nend", "def self.foo=\n1\nend", "def self.foo=()\n1\nend", "def Foo.foo\n1\nend", "def Foo::Bar.foo\n1\nend", "def foo; a; end", "def foo(a); a; end", "def foo; a = 1; a; end", "def foo; a = 1; a {}; end", "def foo; a = 1; x { a }; end", "def foo; x { |a| a }; end", "def foo; x { |_| 1 }; end", "def foo; x { |a, *b| b }; end", "def foo(var = 1); end", "def foo(var : Int); end", "def foo(var : self); end", "def foo(var : self?); end", "def foo(var : self.class); end", "def foo(var : self*); end", "def foo(var : Int | Double); end", "def foo(var : Int?); end", "def foo(var : Int*); end", "def foo(var : Int**); end", "def foo(var : Int -> Double); end", "def foo(var : Int, Float -> Double); end", "def foo(var : (Int, Float -> Double)); end", "def foo(var : (Int, Float) -> Double); end", "def foo(var : Char[256]); end", "def foo(var : Char[N]); end", "def foo(var : Int32 = 1); end", "def foo(var : Int32 -> = 1); end", "def foo; yield; end", "def foo; yield 1; end", "def foo; yield 1; yield; end", "def foo; yield(1); end", "def foo(a, b = a); end", "def foo(&block); end", "def foo(&); end", "def foo(&\n); end", "def foo(a, &block); end", "def foo(a, &block : Int -> Double); end", "def foo(a, & : Int -> Double); end", "def foo(a, &block : Int, Float -> Double); end", "def foo(a, &block : Int, self -> Double); end", "def foo(a, &block : -> Double); end", "def foo(a, &block : Int -> ); end", "def foo(a, &block : self -> self); end", "def foo(a, &block : Foo); end", "def foo; with a yield; end", "def foo; with a yield 1; end", "def foo; a = 1; with a yield a; end", "def foo(@var); end", "def foo(@var); 1; end", "def foo(@var = 1); 1; end", "def foo(@@var); end", "def foo(@@var); 1; end", "def foo(@@var = 1); 1; end", "def foo(&@block); end", "def foo(@[Foo] var); end", "def foo(@[Foo] outer inner); end", "def foo(@[Foo]  var); end", "def foo(a, @[Foo] var); end", "def foo(a, @[Foo] &block); end", "def foo(@[Foo] @var); end", "def foo(@[Foo] var : Int32); end", "def foo(@[Foo] @[Bar] var : Int32); end", "def foo(@[Foo] &@block); end", "def foo(@[Foo] *args); end", "def foo(@[Foo] **args); end", "def foo(\n&block\n); end", "def foo(&block :\n Int ->); end", "def foo(&block : Int ->\n); end", "def foo(a, &block : *Int -> ); end", "def foo(x, *args, y = 2); 1; end", "def foo(x, *args, y = 2, w, z = 3); 1; end", "def foo(x, *, y); 1; end", "def foo(x, *, y, &); 1; end", "def foo(**args)\n1\nend", "def foo(x, **args)\n1\nend", "def foo(x, **args, &block)\n1\nend", "def foo(**args)\nargs\nend", "def foo(x = 1, **args)\n1\nend", "def foo(**args : Foo)\n1\nend", "def foo(**args : **Foo)\n1\nend", "def foo(x y); y; end", "def foo(x @var); end", "def foo(x @@var); end", "def foo(\"bar qux\" y); y; end", "macro foo(**args)\n1\nend", "abstract def foo", "abstract def foo; 1", "abstract def foo\n1", "abstract def foo(x)", "def foo(x : U) forall U; end", "def foo(x : U) forall T, U; end", "def foo(x : U) : Int32 forall T, U; end", "foo", "foo()", "foo(1)", "foo 1", "foo 1\n", "foo 1;", "foo 1, 2", "foo (1 + 2), 3", "foo(1 + 2)", "foo -1.0, -2.0", "foo(\n1)", "::foo", "foo + 1", "foo +1", "foo +1.0", "foo +1_i64", "foo = 1; foo +1", "foo = 1; foo(+1)", "foo = 1; foo -1", "foo = 1; foo(-1)", "foo = 1; b = 2; foo -b", "foo = 1; b = 2; foo +b", "foo = 1; foo a: 1", "foo = 1; foo {}", "foo = 1; foo &x", "def foo(x)\n x\nend; foo = 1; b = 2; foo -b", "def foo(x)\n x\nend; foo = 1; b = 2; foo +b", "foo(&block)", "foo &block", "a.foo &block", "a.foo(&block)", "foo(&.block)", "foo &.block", "foo &./(1)", "foo &.%(1)", "foo &.block(1)", "foo &.+(2)", "foo &.bar.baz", "foo(&.bar.baz)", "foo &.block[]", "foo &.block[0]", "foo &.block=(0)", "foo &.block = 0", "foo &.block[] = 1", "foo &.block[0] = 1", "foo &.[]", "foo &.[0]", "foo &.[] = 1", "foo &.[0] = 1", "foo(&.is_a?(T))", "foo(&.!)", "foo(&.responds_to?(:foo))", "foo &.each {\n}", "foo &.each do\nend", "foo &.@bar", "foo &.@bar.baz", "foo(&.@bar.baz)", "foo &.@bar[baz]", "foo &.@bar.@baz", "foo(&.as(T))", "foo(&.as(T).bar)", "foo &.as(T)", "foo &.as(T).bar", "foo(&.as?(T))", "foo(&.as?(T).bar)", "foo &.as?(T)", "foo &.as?(T).bar", "foo(\n  &.block\n)", "foo.[0]", "foo.[0] = 1", "foo(a: 1, b: 2)", "foo(1, a: 1, b: 2)", "foo a: 1, b: 2", "foo 1, a: 1, b: 2", "foo 1, a: 1, b: 2\n1", "foo(a: 1\n)", "foo(\na: 1,\n)", "foo(\"foo bar\": 1, \"baz\": 2)", "foo \"foo bar\": 1, \"baz\": 2", "foo(Foo: 1, Bar: 2)", "x.foo(a: 1, b: 2)", "x.foo a: 1, b: 2 ", "x[a: 1, b: 2]", "x[a: 1, b: 2,]", "x[{1}]", "x[+ 1]", "foo(a: 1, &block)", "foo a: 1, &block", "foo a: b(1) do\nend", "Foo.bar x.y do\nend", "x = 1; foo x do\nend", "x = 1; foo x { }", "x = 1; foo x {\n}", "foo x do\nend", "foo x, y do\nend", "foo(bar do\nend)", "foo(bar { })", "(bar do\nend)", "(bar do\nend)", "(foo bar do\nend)", "(baz; bar do\nend)", "(bar {})", "(a;\nb)", "1.x; foo do\nend", "x = 1; foo.bar x do\nend", "a b c d e do; end", "a b c d e {}", "a b c d e do 1 end do 2 end { 3 } do 4 end", "a b c d e { 1 } { 2 } do 3 end { 4 }", "a b c d e 1, 2 do; end", "a b c d e 1, 2 {}", "a 1, (2), b do end", "a 1, (2), b {}", "foo do\n//\nend", "foo x do\n//\nend", "foo(x) do\n//\nend", "foo !false", "!a && b", "foo.bar.baz", "f.x Foo.new", "f.x = Foo.new", "f.x = - 1", "f.x += 2", "f.x -= 2", "f.x *= 2", "f.x /= 2", "f.x //= 2", "f.x %= 2", "f.x |= 2", "f.x &= 2", "f.x ^= 2", "f.x **= 2", "f.x <<= 2", "f.x >>= 2", "f.x &+= 2", "f.x &-= 2", "f.x &*= 2", "def #{op}; end;", "def #{op}(); end;", "def self.#{op}; end;", "def self.#{op}(); end;", "1 #{op} 2", "n #{op} 2", "foo(n #{op} 2)", "foo(0, n #{op} 2)", "foo(a: n #{op} 2)", "foo(z: 0, a: n #{op} 2)", "def #{op}(); end", "foo = 1; ->foo.#{op}(Int32)", "->Foo.#{op}(Int32)", "foo = 1; ->foo.#{op}(Int32)", "->Foo.#{op}(Int32)", "foo.#{name}", "foo.#{name} 1, 2", "foo.#{name}(1, 2)", "foo.#{name}(1, 2) { 3 }", "foo.#{name} do end", "a = 1; a #{op}= 1", "a = 1; a #{op}=\n1", "a.b #{op}=\n1", "a = 1; a &&= 1", "a = 1; a ||= 1", "a = 1; a[2] &&= 3", "a = 1; a[2] ||= 3", "if foo; 1; end", "if foo\n1\nend", "if foo; 1; else; 2; end", "if foo\n1\nelse\n2\nend", "if foo; 1; elsif bar; 2; else 3; end", "include Foo", "include Foo\nif true; end", "extend Foo", "extend Foo\nif true; end", "extend self", "unless foo; 1; end", "unless foo; 1; else; 2; end", "class Foo; end", "class Foo\nend", "class Foo\ndef foo; end; end", "class Foo < Bar; end", "class Foo(T); end", "class Foo(T1); end", "class Foo(Type); end", "abstract class Foo; end", "abstract struct Foo; end", "class Foo < self; end", "module Foo(*T); end", "class Foo(*T); end", "class Foo(T, *U); end", "x : Foo(A, *B, C)", "x : *T -> R", "def foo(x : *T -> R); end", "foo result : Int32; result", "foo(x: result : Int32); result", "foo(\n        begin\n          result : Int32 = 1\n          result\n        end\n      )", "foo(x:\n        begin\n          result : Int32 = 1\n          result\n        end\n      )", "struct Foo; end", "Foo()", "Foo(T)", "Foo(T | U)", "Foo(Bar(T | U))", "Foo(Bar())", "Foo(T?)", "Foo(1)", "Foo(T, 1)", "Foo(T, U, 1)", "Foo(T, 1, U)", "Foo(typeof(1))", "Foo(typeof(1), typeof(2))", "Foo({X, Y})", "Foo({X, Y,})", "Foo({*X, *{Y}})", "Foo({->})", "Foo({String, ->})", "Foo({String, ->, ->})", "[] of {String, ->}", "x([] of Foo, Bar.new)", "foo[bar { 1 }]", "foo.[bar { 1 }]", "foo.[](bar { 1 })", "foo[bar do; 1; end]", "foo.[bar do; 1; end]", "foo.[](bar do; 1; end)", "Foo(x: U)", "Foo(x: U, y: V)", "Foo(X: U, Y: V)", "Foo(\"foo bar\": U)", "Foo(\"foo\": U, \"bar\": V)", "Foo({x: X})", "Foo({x: X, y: Y})", "Foo({X: X, Y: Y})", "Foo(T, {x: X})", "Foo({x: X, typeof: Y})", "Foo({\"foo bar\": X})", "Foo({\"foo\": X, \"bar\": Y})", "Foo{\"x\" => \"y\"}", "::Foo{\"x\" => \"y\"}", "Foo(*T)", "Foo(X, sizeof(Int32))", "Foo(X, instance_sizeof(Int32))", "Foo(X, alignof(Int32))", "Foo(X, instance_alignof(Int32))", "Foo(X, offsetof(Foo, @a))", "Foo(\n)", "Foo(\nT\n)", "Foo(\nT,\nU,\n)", "Foo(\nx:\nT,\ny:\nU,\n)", "module Foo; end", "module Foo\ndef foo; end; end", "module Foo(T); end", "while true; end;", "while true; 1; end;", "until true; end;", "until true; 1; end;", "foo do; 1; end", "foo do |a|; 1; end", "foo { 1 }", "foo { |a| 1 }", "foo { |a, b| 1 }", "foo { |a, b, | 1 }", "1.foo do; 1; end", "a b() {}", "foo { |a, (b, c), (d, e)| a; b; c; d; e }", "foo { |(_, c)| c }", "foo { |(_, c, )| c }", "foo { |(a, (b, (c, d)))| }", "foo { |(a, *b, c)| }", "1 ? 2 : 3", "1 ? a : b", "1 ? a : b ? c : 3", "a ? 1 : b ? 2 : c ? 3 : 0", "a ? 1\n              : b", "a ? 1 :\n              b ? 2 :\n              c ? 3\n              : 0", "a ? 1\n              : b ? 2\n              : c ? 3\n              : 0", "a ?\n              b ? b1 : b2\n              : c ? 3\n              : 0", "1 if 3", "1 unless 3", "r = 1; r.x += 2", "foo if 3", "foo unless 3", "a = 1; a += 10 if a += 20", "puts a if true", "puts ::foo", "puts __FILE__", "puts __DIR__", "puts __LINE__", "puts _", "x = 2; foo do bar x end", "#{keyword}", "#{keyword};", "#{keyword} 1", "#{keyword} 1, 2", "#{keyword} {1, 2}", "#{keyword} {1 => 2}", "#{keyword} 1 if true", "#{keyword} if true", "#{keyword} *1", "#{keyword} *1, 2", "#{keyword} 1, *2", "#{keyword} *{1, 2}", "yield", "yield;", "yield 1", "yield 1 if true", "yield if true", "Int", "Int[]", "def []; end", "def []?; end", "def []=(value); end", "def self.[]; end", "def self.[]?; end", "Int[8]", "Int[8, 4]", "Int[8, 4,]", "Int[8]?", "x[0] ? 1 : 0", "def [](x); end", "foo[0] = 1", "foo[0] = 1 if 2", "begin; 1; end;", "begin; 1; 2; 3; end;", "self", "@foo", "@foo = 1", "-@foo", "var.@foo", "var.@foo.@bar", "@@foo", "@@foo = 1", "-@@foo", "call @foo.bar", "call \"foo\"", "def foo; end; if false; 1; else; 2; end", "A.new(\"x\", B.new(\"y\"))", "foo [1]", "foo.bar [1]", "class Foo; end\nwhile true; end", "while true; end\nif true; end", "(1)\nif true; end", "begin\n1\nend\nif true; end", "Foo::Bar", "lib LibC\nend", "lib LibC\nfun getchar\nend", "lib LibC\nfun getchar(...)\nend", "lib LibC\nfun getchar : Int\nend", "lib LibC\nfun getchar : (->)?\nend", "lib LibC\nfun getchar(Int, Float)\nend", "lib LibC\nfun getchar(a : Int, b : Float)\nend", "lib LibC\nfun getchar(a : Int)\nend", "lib LibC\nfun getchar(a : Int, b : Float) : Int\nend", "lib LibC; fun getchar(a : Int, b : Float) : Int; end", "lib LibC; fun foo(a : Int*); end", "lib LibC; fun foo(a : Int**); end", "lib LibC; fun foo : Int*; end", "lib LibC; fun foo : Int**; end", "lib LibC; fun foo(a : ::B, ::C -> ::D); end", "lib LibC; type A = B; end", "lib LibC; type A = B*; end", "lib LibC; type A = B**; end", "lib LibC; type A = B.class; end", "lib LibC; struct Foo; end end", "lib LibC; struct Foo; x : Int; y : Float; end end", "lib LibC; struct Foo; x : Int*; end end", "lib LibC; struct Foo; x : Int**; end end", "lib LibC; struct Foo; x, y, z : Int; end end", "lib LibC; union Foo; end end", "lib LibC; enum Foo; A\nB; C\nD = 1; end end", "lib LibC; enum Foo; A = 1; B; end end", "lib LibC; Foo = 1; end", "lib LibC\nfun getch = GetChar\nend", "lib LibC\\nfun getch = \"get.char\"\\nend", "lib LibC\\nfun getch = \"get.char\" : Int32\\nend", "lib LibC\\nfun getch = \"get.char\"(x : Int32)\\nend", "lib LibC\n$errno : Int32\n$errno2 : Int32\nend", "lib LibC\n$errno : B, C -> D\nend", "lib LibC\n$errno = Foo : Int32\nend", "lib LibC\nalias Foo = Bar\nend", "lib LibC; struct Foo; include Bar; end; end", "lib LibC\nfun SomeFun\nend", "lib Foo::Bar\nend", "fun foo(x : Int32) : Int64\nx\nend", "lib LibC; {{ 1 }}; end", "lib LibC; {% if 1 %}2{% end %}; end", "lib LibC; struct Foo; {{ 1 }}; end; end", "lib LibC; struct Foo; {% if 1 %}2{% end %}; end; end", "1 .. 2", "1 ... 2", "(1 .. )", "(1 ... )", "foo(1.., 2)", "1..;", "1..\n2..", "{1.. => 2};", "..2", "...2", "foo..2", "foo ..2", "foo(..2)", "x[..2]", "x[1, ..2]", "{..2}", "[..2]", "A = 1", "puts %w(one two)", "puts %w{one two}", "puts %i(one two)", "puts {{1}}", "puts {{\n1\n}}", "puts {{*1}}", "puts {{**1}}", "{{a = 1 if 2}}", "{% a = 1 %}", "{%\na = 1\n%}", "{% a = 1 if 2 %}", "{% if 1; 2; end %}", "{%\nif 1; 2; end\n%}", "{% if 1\n  x\nend %}", "{% x if 1 %}", "{% unless 1; 2; end %}", "{% unless 1; 2; else 3; end %}", "{% unless 1\n  x\nend %}", "{% x unless 1 %}", "{%\n1\n2\n3\n%}", "{% if 1; 2; end; %}", "{% if 1; 2; end; 3 %}", "{%\nif 1; 2; end; 3\n%}", "{% 2 if 1; 3 %}", "{%\n2 if 1; 3\n%}", "{% if 1; 2; elsif 3; 4; else; 5; end; 6 %}", "{% unless 1; 2; end; %}", "{% unless 1; 2; end; 3 %}", "{%\nunless 1; 2; end; 3\n%}", "{% 2 unless 1; 3 %}", "{%\n2 unless 1; 3\n%}", "{{ 1 // 2 }}", "{{ //.options }}", "[] of Int", "[1, 2] of Int", "::A::B", "macro foo;end", "macro [];end", "macro foo; 1 + 2; end", "macro foo(x); 1 + 2; end", "macro foo(x)\\n 1 + 2; end", "macro foo; 1 + 2 {{foo}} 3 + 4; end", "macro foo; 1 + 2 {{ foo }} 3 + 4; end", "macro foo;bar{% for x in y %}body{% end %}baz;end", "macro foo;bar{% for x, y in z %}body{% end %}baz;end", "macro foo;bar{% if x %}body{% end %}baz;end", "macro foo;bar{% if x %}body{% else %}body2{%end%}baz;end", "macro foo;bar{% if x %}body{% elsif y %}body2{%end%}baz;end", "macro foo;bar{% if x %}body{% elsif y %}body2{% else %}body3{%end%}baz;end", "macro foo;bar{% unless x %}body{% end %}baz;end", "macro foo;bar{% for x in y %}\\  \n   body{% end %}baz;end", "macro foo;bar{% for x in y %}\\  \n   body{% end %}\\   baz;end", "macro foo; 1 + 2 {{foo}}\\ 3 + 4; end", "macro foo(\na = 0\n)\nend", "macro foo;{% verbatim do %}1{% foo %}2{% end %};end", "macro foo\n{%\nif 1\n2\nelse\n3\nend\n%}end", "macro foo\neenum\nend", "macro foo\n'\\''\nend", "macro foo\n'\\\\'\nend", "macro foo\\n\"\\\\'\"\\nend", "macro foo\\n\"\\\\\\\\\"\\nend", "macro foo;bar(end: 1);end", "def foo;bar(end: 1);end", "macro foo(@[Foo] var);end", "macro foo(@[Foo] outer inner);end", "macro foo(@[Foo]  var);end", "macro foo(a, @[Foo] var);end", "macro foo(a, @[Foo] &block);end", "macro foo(@[Foo] *args);end", "macro foo(@[Foo] **args);end", "macro foo=;end", "macro `;end", "macro <<;end", "macro <;end", "macro <=;end", "macro ==;end", "macro ===;end", "macro !=;end", "macro =~;end", "macro !~;end", "macro >>;end", "macro >;end", "macro >=;end", "macro +;end", "macro -;end", "macro *;end", "macro /;end", "macro //;end", "macro ~;end", "macro %;end", "macro &;end", "macro |;end", "macro ^;end", "macro **;end", "macro []?;end", "macro []=;end", "macro <=>;end", "macro &+;end", "macro &-;end", "macro &*;end", "macro &**;end", "def foo;{{@type}};end", "macro foo;bar{% begin %}body{% end %}baz;end", "macro x\n%{}\nend", "def foo : Int32\n1\nend", "def foo(x) : Int32\n1\nend", "abstract def foo : Int32", "abstract def foo(x) : Int32", "{% for x in y %}body{% end %}", "{% for _, x, _ in y %}body{% end %}", "{% if x %}body{% end %}", "{% begin %}{% if true %}if true{% end %}\n{% if true %}end{% end %}{% end %}", "{{ foo }}", "macro foo;%var;end", "macro foo;%var{1, x} = hello;end", "macro foo;%var if true;end", "macro foo;var if true;end", "macro foo;if %var;true;end;end", "macro foo;if var;true;end;end", "macro foo;%var unless true;end", "macro foo;var unless true;end", "macro foo;unless %var;true;end;end", "macro foo;unless var;true;end;end", "macro foo;%#{ch}[#{ch}];end", "a = 1; pointerof(a)", "pointerof(@a)", "a = 1; pointerof(a)", "pointerof(@a)", "sizeof(X)", "instance_sizeof(X)", "alignof(X)", "instance_alignof(X)", "offsetof(X, @a)", "offsetof(X, 1)", "foo.is_a?(Const)", "foo.is_a?(Foo | Bar)", "foo.is_a? Const", "foo.responds_to?(:foo)", "foo.responds_to? :foo", "if foo.responds_to? :foo\nx = 1\nend", "is_a?(Const)", "responds_to?(:foo)", "nil?", "nil?(  )", "foo.nil?", "foo.nil?(  )", "foo &.nil?", "foo &.baz.qux do\nend", "{{ foo.nil? }}", "{{ foo &.nil? }}", "{{ foo.nil?(foo) }}", "{{ nil?(foo) }}", "foo.!", "foo.!.!", "foo.!(  )", "foo &.!", "sizeof(\n  Int32\n)", "instance_sizeof(\n  Int32\n)", "alignof(\n  Int32\n)", "instance_alignof(\n  Int32\n)", "typeof(\n  1\n)", "offsetof(\n  Foo,\n  @foo\n)", "pointerof(\n  foo\n)", "1.as(\n  Int32\n)", "1.as?(\n  Int32\n)", "1.is_a?(\n  Int32\n)", "1.responds_to?(\n  :foo\n)", "1.nil?(\n)", "1.!(\n)", "/foo/", "/foo/i", "/foo/m", "/foo/x", "/foo/imximx", "/fo\\so/", "/fo\\#{1}o/", "/(fo\\#{\"bar\"}\\#{1}o)/", "%r(foo(bar))", "/ /", "/=/", "/ hi /", "self / number", "a == / /", "/ /", "/ /; / /", "/ /\n/ /", "a = / /", "(/ /)", "a = /=/", "a; if / /; / /; elsif / /; / /; end", "a; if / /\n/ /\nelsif / /\n/ /\nend", "a; unless / /; / /; else; / /; end", "a\nunless / /\n/ /\nelse\n/ /\nend", "a\nwhile / /; / /; end", "a\nwhile / /\n/ /\nend", "[/ /, / /]", "{/ / => / /, / / => / /}", "{/ /, / /}", "begin; / /; end", "begin\n/ /\nend", "/\\//", "/\\ /", "%r(/)", "%r(\\/)", "%r(\\ )", "a()/3", "a() /3", "a.b() /3", "def foo(x = / /); end", "begin 1 end / 2", "1 =~ 2", "1.=~(2)", "def =~; end", "$~", "$~.foo", "$0", "$1", "$1?", "foo $1", "$~ = 1", "$?", "$?.foo", "foo $?", "$? = 1", "foo /a/", "foo(/a/)", "foo(//)", "foo(regex: //)", "foo(/ /)", "foo(/ /, / /)", "foo a, / /", "foo /;/", "foo out x; x", "foo(out x); x", "foo out @x; @x", "foo(out @x); @x", "foo out _", "foo z: out x; x", "{1 => 2, 3 => 4}", "{1 =>\n2, 3 =>\n4}", "{A::B => 1, C::D => 2}", "{a: 1}", "{a: 1, b: 2}", "{A: 1, B: 2}", "{\"foo\": 1}", "{\"foo\": 1, \"bar\": 2}", "{} of Int => Double", "{} of Int32 -> Int32 => Int32", "require \"foo\"", "require \"foo\"; [1]", "case 1; when 1; 2; else; 3; end", "case 1; when 0, 1; 2; else; 3; end", "case 1\nwhen 1\n2\nelse\n3\nend", "case 1\nwhen 1\n2\nend", "case / /; when / /; / /; else; / /; end", "case / /\nwhen / /\n/ /\nelse\n/ /\nend", "case 1; when 1 then 2; else; 3; end", "case 1; when x then 2; else; 3; end", "case 1\nwhen 1\n2\nend\nif a\nend", "case\n1\nwhen 1\n2\nend\nif a\nend", "case 1\nwhen .foo\n2\nend", "case 1\nwhen .responds_to?(:foo)\n2\nend", "case 1\nwhen .is_a?(T)\n2\nend", "case 1\nwhen .as(T)\n2\nend", "case 1\nwhen .as?(T)\n2\nend", "case 1\nwhen .!()\n2\nend", "case when 1\n2\nend", "case \nwhen 1\n2\nend", "case {1, 2}\nwhen {3, 4}\n5\nend", "case {1, 2}\nwhen {3, 4}, {5, 6}\n7\nend", "case {1, 2}\nwhen {.foo, .bar}\n5\nend", "case {1, 2}\nwhen foo\n5\nend", "case a\nwhen b\n1 / 2\nelse\n1 / 2\nend", "case a\nwhen b\n/ /\n\nelse\n/ /\nend", "case 1; end", "case foo; end", "case\nend", "case;end", "case 1\nelse\n2\nend", "a = 1\ncase 1\nwhen a then 1\nend", "case\nwhen true\n1\nend", "case;when true;1;end", "case 1\nin Int32; 2; end", "case 1\nin Int32.class; 2; end", "case 1\nin Foo(Int32); 2; end", "case 1\nin false; 2; end", "case 1\nin true; 2; end", "case 1\nin nil; 2; end", "case 1\nin .bar?; 2; end", "case {1}\nin {Int32}; 2; end", "case {1}\nin {Int32.class}; 2; end", "case {1}\nin {Foo(Int32)}; 2; end", "case {1}\nin {false}; 2; end", "case {1}\nin {true}; 2; end", "case {1}\nin {nil}; 2; end", "case {1}\nin {.bar?}; 2; end", "case {1}\nin {_}; 2; end", "case 1; when 2 then /foo/; end", "select\nwhen foo\n2\nend", "select\nwhen foo\n2\nwhen bar\n4\nend", "select\nwhen foo\n2\nelse\n3\nend", "def foo(x); end; x", "def foo; / /; end", "\"foo\\#{bar}baz\"", "qux \"foo\\#{bar do end}baz\"", "\"\\#{1\n}\"", "\"foo\\#{\"bar\"}baz\"", "lib LibFoo\nend\nif true\nend", "foo(\n1\n)", "a = 1\nfoo - a", "a = 1\nfoo -a", "a : Foo", "a : Foo | Int32", "@a : Foo", "@a : Foo | Int32", "@@a : Foo", "a : Foo = 1", "@a : Foo = 1", "@@a : Foo = 1", "Foo?", "a : Foo*", "a : Foo[12]", "Foo()?", "a : Foo()*", "a : Foo()[12]", "a = uninitialized Foo; a", "@a = uninitialized Foo", "@@a = uninitialized Foo", "()", "(1; 2; 3)", "begin; rescue; end", "begin; 1; rescue; 2; end", "begin; 1; ensure; 2; end", "begin\n1\nensure\n2\nend", "begin; 1; rescue Foo; 2; end", "begin; 1; rescue ::Foo; 2; end", "begin; 1; rescue Foo | Bar; 2; end", "begin; 1; rescue ::Foo | ::Bar; 2; end", "begin; 1; rescue ex : Foo | Bar; 2; end", "begin; 1; rescue ex : ::Foo | ::Bar; 2; end", "begin; 1; rescue ex; 2; end", "begin; 1; rescue; 2; else; 3; end", "begin; 1; rescue ex; 2; end; ex", "def foo(); 1; rescue; 2; end", "1.tap do; 1; rescue; 2; end", "-> do; 1; rescue; 2; end", "1.tap do |x|; 1; rescue; x; end", "1 rescue 2", "x = 1 rescue 2", "x = 1 ensure 2", "a = 1; a rescue a", "a = 1; yield a rescue a", "1 ensure 2", "1 rescue 2", "foo ensure 2", "foo rescue 2", "a = 1; a ensure a", "a = 1; yield a ensure a", "1 <= 2 <= 3", "1 == 2 == 3 == 4", "-> do end", "-> { }", "->() { }", "->(x : Int32) { }", "->(x : Int32) { x }", "->(x) { x }", "x = 1; ->{ x }", "f ->{ a do\n end\n }", "-> : Int32 { }", "->\n:\nInt32\n{\n}", "->() : Int32 { }", "->() : Int32 do end", "->(x : Int32) : Int32 { }", "->#{method}", "foo = 1; ->foo.#{method}", "->Foo.#{method}", "->@foo.#{method}", "->@@foo.#{method}", "->::#{method}", "->::Foo.#{method}", "->Foo::Bar::Baz.foo", "->foo(Int32, Float64)", "foo = 1; ->foo.bar(Int32)", "->foo(Void*)", "call ->foo", "[] of ->\n", "foo &->bar", "foo.bar = {} of Int32 => Int32", "alias Foo = Bar", "alias Foo::Bar = Baz", "def foo\n1\nend\nif 1\nend", "1.as Bar", "1.as(Bar)", "foo.as(Bar)", "foo.bar.as(Bar)", "call(foo.as Bar, Baz)", "as(Bar)", "1.as? Bar", "1.as?(Bar)", "as?(Bar)", "typeof(1)", "typeof(a = 1); a", "puts ~1", "foo\n.bar", "foo\n   .bar", "foo\n\n  .bar", "foo\n  #comment\n  .bar", "{1}", "{1, 2, 3}", "{A::B}", "{\n1,\n2\n}", "{\n1\n}", "{\n{1}\n}", "{\"\".id}", "foo { a = 1 }; a", "foo.bar(1).baz", "b.c ||= 1", "b.c &&= 1", "a = 1; class Foo; @x = a; end", "@[Foo]", "@[Foo()]", "@[Foo(1)]", "@[Foo(\"hello\")]", "@[Foo(1, foo: 2)]", "@[Foo(1, foo: 2\n)]", "@[Foo(\n1, foo: 2\n)]", "@[Foo::Bar]", "lib LibC\n@[Bar]; end", "Foo(_)", "{% if true %}\n{% end %}\n{% if true %}\n{% end %}", "fun foo : Int32; 1; end; 2", "[] of ->;", "[] of ->\n1", "def foo(x, *y); 1; end", "macro foo(x, *y);end", "def foo(x = 1, *y); 1; end", "def foo(x, *y : Int32); 1; end", "def foo(*y : *T); 1; end", "foo *bar", "foo(*bar)", "foo x, *bar", "foo(x, *bar, *baz, y)", "foo.bar=(*baz)", "foo.bar= *baz", "foo.bar = (1).abs", "foo[*baz]", "foo[*baz] = 1", "foo **bar", "foo(**bar)", "foo 1, **bar", "foo(1, **bar)", "foo 1, **bar, &block", "foo(1, **bar, &block)", "private def foo; end", "protected def foo; end", "`foo`", "`foo\\#{1}bar`", "`foo\\``", "%x(`which(foo)`)", "def `(cmd); 1; end", "def foo(bar = 1\n); 2; end", "Set {1, 2, 3}", "Set() {1, 2, 3}", "Set(Int32) {1, 2, 3}", "{*1}", "{*1, 2}", "{1, *2}", "{*1, *2}", "{1, *2, 3, *4, 5}", "[*1]", "[*1, 2]", "[1, *2]", "[*1, *2]", "[1, *2, 3, *4, 5]", "Set {*1, 2, *3}", "[*[*[1]], *[2]]", "case 1\nwhen {*2}; 3; end", "x = {*1}", "{*1 * 2}", "[*1 ** 2]", "Set {*{1} * 2}", "foo(Bar) { 1 }", "foo Bar { 1 }", "foo(Bar { 1 })", "\n\n__LINE__", "__FILE__", "__DIR__", "def foo(x = __LINE__); end", "def foo(x = __FILE__); end", "def foo(x = __DIR__); end", "macro foo(x = __LINE__);end", "1 \\\n + 2", "1\\\n + 2", "1 \\\r\n + 2", "1\\\r\n + 2", "\"hello \" \\\\\\n \"world\"", "\"hello \"\\\\\\n\"world\"", "\"hello \" \\\\\\r\\n \"world\"", "\"hello \"\\\\\\r\\n\"world\"", "\"hello \\#{1}\" \\\\\\n \"\\#{2} world\"", "\"hello \\#{1}\" \\\\\\r\\n \"\\#{2} world\"", "<<-HERE\nHello, mom! I am HERE.\nHER dress is beautiful.\nHE is OK.\n  HERESY\nHERE", "<<-HERE\n   One\n  Zero\n  HERE", "<<-HERE\n   One \\n Two\n  Zero\n  HERE", "<<-HERE\n   One\n\n  Zero\n  HERE", "<<-HERE\n   One\n \n  Zero\n  HERE", "<<-HERE\n   \\#{1}One\n  \\#{2}Zero\n  HERE", "<<-HERE\n  foo\\#{1}bar\n   baz\n  HERE", "<<-HERE\r\n   One\r\n  Zero\r\n  HERE", "<<-HERE\r\n   One\r\n  Zero\r\n  HERE\r\n", "<<-SOME\n  Sa\n  Se\n  SOME", "<<-HERE\n  \\#{1} \\#{2}\n  HERE", "<<-HERE\n  \\#{1} \\n \\#{2}\n  HERE", "<<-HERE\nHERE", "<<-HERE1; <<-HERE2\nHERE1\nHERE2", "<<-HERE1; <<-HERE2\nhere1\nHERE1\nHERE2", "<<-HERE1; <<-HERE2\nHERE1\nhere2\nHERE2", "<<-'HERE'\n  hello \\n world\n  \\#{1}\n  HERE", "<<-'HERE COMES HEREDOC'\n  hello \\n world\n  \\#{1}\n  HERE COMES HEREDOC", "<<-EOF.x\n  foo\nEOF", "<<-'EOF'.x\n  foo\nEOF", "<<-FOO\n\t1\n\tFOO", "<<-FOO\n \t1\n \tFOO", "<<-FOO\n \t 1\n \t FOO", "<<-FOO\n\t 1\n\t FOO", "x, y = <<-FOO, <<-BAR\nhello\nFOO\nworld\nBAR", "x, y, z = <<-FOO, <<-BAR, <<-BAZ\nhello\nFOO\nworld\nBAR\n!\nBAZ", "enum Foo; A\nB; C\nD = 1; end", "enum Foo; A = 1; B; end", "enum Foo : UInt16; end", "enum Foo : UInt16 ; end", "enum Foo : UInt16 # comment\nend", "enum Foo; def foo; 1; end; end", "enum Foo; A = 1\ndef foo; 1; end; end", "enum Foo; A = 1\ndef foo; 1; end\ndef bar; 2; end\nend", "enum Foo; A = 1\ndef self.foo; 1; end\nend", "enum Foo::Bar; A = 1; end", "enum Foo; @@foo = 1\n A \n end", "enum Foo; private def foo; 1; end; end", "enum Foo; protected def foo; 1; end; end", "enum Foo; {{1}}; end", "enum Foo; {% if 1 %}2{% end %}; end", "enum Foo; macro foo;end; end", "enum Foo; @[Bar]; end", "1.[](2)", "1.[]?(2)", "1.[]=(2, 3)", "a @b-1\nc", "4./(2)", "foo[\n1\n]", "foo[\nfoo[\n1\n]\n]", "if (\ntrue\n)\n1\nend", "my_def def foo\nloop do\nend\nend", "foo(*{1})", "foo *{1}", "a.b/2", "a.b /2/", "a.b / 2", "a/b", "T/1", "T::U/1", "::T/1", "asm(\"nop\" \n)", "asm(\"nop\" : : )", "asm(\"nop\" ::)", "asm(\"nop\" :: : :)", "asm(\"nop\" ::: :)", "asm(\"nop\" ::::)", "asm(\"nop\" : \"a\"(0))", "asm(\"nop\" : \"a\"(0) : \"b\"(1))", "asm(\"nop\" : \"a\"(0) : \"b\"(1), \"c\"(2))", "asm(\"nop\" : \"a\"(0), \"b\"(1) : \"c\"(2), \"d\"(3))", "asm(\"nop\" :: \"b\"(1), \"c\"(2))", "asm(\"nop\" :: \"b\"(1), \"c\"(2) ::)", "asm(\n\"nop\"\n:\n\"a\"(0)\n:\n\"b\"(1),\n\"c\"(2)\n)", "asm(\n\"nop\"\n:\n\"a\"(0),\n\"b\"(1)\n:\n\"c\"(2),\n\"d\"(3)\n)", "asm(\"nop\" :: \"b\"(1), \"c\"(2) : \"eax\", \"ebx\" : \"volatile\", \"alignstack\", \"intel\")", "asm(\"nop\" :: \"b\"(1), \"c\"(2) : \"eax\", \"ebx\"\n: \"volatile\", \"alignstack\"\n,\n\"intel\"\n)", "asm(\"nop\" :::: \"volatile\")", "asm(\"bl trap\" :::: \"unwind\")", "foo begin\nbar do\nend\nend", "foo 1.bar do\nend", "return 1.bar do\nend", "#{keyword} : Int32", "property #{keyword} : Int32", "call(foo : A, end : B)", "call foo : A, end : B", "case :foo; when :bar; 2; end", "Foo.foo(count: 3).bar { }", "\n      class Foo\n        def bar\n          print as Foo\n        end\n      end\n    ", "Foo?", "Foo::Bar?", "Foo(T)?", "Foo??", "{1 => 2 / 3}", "a { |x| x } / b", "1 if /x/", "foo bar.baz(1) do\nend", "1 rescue 2 if 3", "1 ensure 2 if 3", "yield foo do\nend", "x.y=(1).to_s", "1 ** -x", "foo.Bar", "{% begin %}%#{open} %s #{close}{% end %}", "{% begin %}%q#{open} %s #{close}{% end %}", "{% begin %}%Q#{open} %s #{close}{% end %}", "{% begin %}%i#{open} %s #{close}{% end %}", "{% begin %}%w#{open} %s #{close}{% end %}", "{% begin %}%x#{open} %s #{close}{% end %}", "{% begin %}%r#{open}\\A#{close}{% end %}", "foo(bar:\"a\", baz:\"b\")", "foo(bar:a, baz:b)", "{foo:\"a\", bar:\"b\"}", "{foo:'a', bar:'b'}", "{foo:a, bar:b}", "[\n1\n]", "[\n1,2\n]", "{[] of Foo, Bar::Baz.new}", "{[] of Foo, ::Bar::Baz.new}", "{[] of Foo, Bar::Baz + 2}", "{[] of Foo, Bar::Baz * 2}", "{[] of Foo, Bar::Baz ** 2}", "{[] of Foo, ::foo}", "{[] of Foo, self.foo}", "macro foo; bar class: 1; end", "class Foo \"a\" end", "class Foo 'a' end", "class Foo [1] end", "class Foo {1} end", "class Foo ->{} end", "class Foo ->(x : Bar){} end", "class Foo :Bar end", "class Foo :bar end", "class Foo %x() end", "class Foo %w() end", "class Foo %() end", "class Foo < Bar :Qux end", "class Foo include Bar end", "struct Foo \"a\" end", "struct Foo 'a' end", "struct Foo [1] end", "struct Foo {1} end", "struct Foo ->{} end", "struct Foo ->(x : Bar){} end", "struct Foo :Bar end", "struct Foo :bar end", "struct Foo %x() end", "struct Foo %w() end", "struct Foo %() end", "struct Foo < Bar :Qux end", "struct Foo include Bar end", "module Foo \"a\" end", "module Foo 'a' end", "module Foo [1] end", "module Foo {1} end", "module Foo ->{} end", "module Foo ->(x : Bar){} end", "module Foo :Bar end", "module Foo :bar end", "module Foo %x() end", "module Foo %w() end", "module Foo %() end", "module Foo include Bar end", "%w{one  two}", "%w{one\ntwo}", "%w{one\ttwo}", "%w{\n}", "%w{one\\ two}", "%w{one{} two}", "%w{\\{one}", "%w{one\\}}", "%i(one\\ two)", "%i{(one two)}", "%i((one two))", "%i(foo(bar) baz)", "%i{foo\\nbar baz}", "annotation Foo; end", "annotation Foo\n\nend", "annotation Foo::Bar\n\nend", "annotation Foo\\nend\\nrequire \"bar\""]