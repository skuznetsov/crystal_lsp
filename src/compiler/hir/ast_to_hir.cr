# AST to HIR Lowering
#
# Converts Crystal AST (from parser) to High-Level IR for analysis.
# This is the first stage of the codegen pipeline.
#
# See docs/codegen_architecture.md for full specification.

require "./hir"
require "./debug_hooks"
require "../frontend/ast"
require "../mir/mir"
require "../../runtime"
require "../semantic/macro_expander"
require "../semantic/symbol_table"

module Crystal::HIR
  # Error raised during AST to HIR conversion
  class LoweringError < Exception
    getter node : CrystalV2::Compiler::Frontend::Node?
    getter details : String

    def initialize(@details : String, @node : CrystalV2::Compiler::Frontend::Node? = nil)
      super(@details)
    end
  end

  # Context for lowering a single function
  class LoweringContext
    getter function : Function
    getter module : Module
    getter arena : CrystalV2::Compiler::Frontend::ArenaLike

    # Current block being built
    property current_block : BlockId

    # Variable name → ValueId mapping per scope
    @locals : Hash(String, ValueId)
    @self_id : ValueId?

    # Scope stack for nested scopes
    @scope_stack : Array(ScopeId)

    # Type cache
    @type_cache : Hash(String, TypeRef)

    # Value → Type mapping for type inference
    @value_types : Hash(ValueId, TypeRef)
    @values : Hash(ValueId, Value)
    @type_literal_values : Set(ValueId)
    # Type literals produced by `.class` calls (distinct from direct type refs like `Int32`).
    # These should be converted to String when used as call arguments.
    @dot_class_literals : Set(ValueId)

    def initialize(@function : Function, @module : Module, @arena)
      @current_block = @function.entry_block
      @locals = {} of String => ValueId
      @self_id = nil
      @scope_stack = [@function.scopes[0].id] # Function scope
      @type_cache = {} of String => TypeRef
      @value_types = {} of ValueId => TypeRef
      @values = {} of ValueId => Value
      @type_literal_values = Set(ValueId).new
      @dot_class_literals = Set(ValueId).new
    end

    def mark_dot_class_literal(id : ValueId)
      @dot_class_literals.add(id)
    end

    def dot_class_literal?(id : ValueId) : Bool
      @dot_class_literals.includes?(id)
    end

    # Get current scope
    def current_scope : ScopeId
      @scope_stack.last
    end

    # Push new scope
    def push_scope(kind : ScopeKind) : ScopeId
      scope_id = @function.create_scope(kind, current_scope)
      @scope_stack << scope_id
      scope_id
    end

    # Pop scope
    def pop_scope : ScopeId
      @scope_stack.pop
    end

    # Create new block in current scope
    def create_block : BlockId
      @function.create_block(current_scope)
    end

    # Get block by ID
    def get_block(id : BlockId) : Block
      @function.get_block(id)
    end

    # Switch to a different block
    def switch_to_block(id : BlockId)
      @current_block = id
    end

    # Get current block ID
    def current_block_id : BlockId
      @current_block
    end

    # Add instruction to current block
    def emit(value : Value) : Value
      get_block(@current_block).add(value)
      @value_types[value.id] = value.type # Track type for inference
      @values[value.id] = value
      if value.is_a?(Literal) && value.value.is_a?(Nil) && value.type.id >= TypeRef::FIRST_USER_TYPE
        @type_literal_values.add(value.id)
        STDERR.puts "[TYPE_LITERAL] id=#{value.id} type=#{value.type.id}" if ENV["DEBUG_TYPE_LITERAL"]?
      end
      value
    end

    def value_for(id : ValueId) : Value?
      @values[id]?
    end

    # Add instruction to a specific block (used for inserting before phi nodes)
    def emit_to_block(block_id : BlockId, value : Value) : Value
      get_block(block_id).add(value)
      @value_types[value.id] = value.type
      @values[value.id] = value
      if value.is_a?(Literal) && value.value.is_a?(Nil) && value.type.id >= TypeRef::FIRST_USER_TYPE
        @type_literal_values.add(value.id)
        STDERR.puts "[TYPE_LITERAL] id=#{value.id} type=#{value.type.id}" if ENV["DEBUG_TYPE_LITERAL"]?
      end
      value
    end

    # Look up the type of a value by ID
    def type_of(id : ValueId) : TypeRef
      @value_types[id]? || TypeRef::VOID
    end

    # Register type for a value (used for params not emitted via emit)
    def register_type(id : ValueId, type : TypeRef)
      @value_types[id] = type
    end

    def type_literal?(id : ValueId) : Bool
      @type_literal_values.includes?(id)
    end

    def mark_type_literal(id : ValueId)
      @type_literal_values.add(id)
    end

    # Set terminator for current block
    def terminate(term : Terminator)
      get_block(@current_block).terminator = term
    end

    # Next value ID
    def next_id : ValueId
      @function.next_value_id
    end

    # Register local variable
    def register_local(name : String, value_id : ValueId)
      @locals[name] = value_id
      @function.get_scope(current_scope).add_local(value_id)
      @self_id = value_id if name == "self"
    end

    # Lookup local variable
    def lookup_local(name : String) : ValueId?
      if name == "self"
        if self_id = @self_id
          return self_id
        end
      end
      @locals[name]?
    end

    # Save current locals state (for branching)
    def save_locals : Hash(String, ValueId)
      @locals.dup
    end

    # Restore locals state (for else branch)
    def restore_locals(saved : Hash(String, ValueId))
      @locals = saved.dup
      if self_id = @locals["self"]?
        @self_id = self_id
      else
        @self_id = nil
      end
    end

    # Get all current locals
    def all_locals : Hash(String, ValueId)
      @locals
    end

    # Get or create type ref
    def get_type(name : String) : TypeRef
      @type_cache[name]? || begin
        type_ref = case name
                   when "Void"    then TypeRef::VOID
                   when "Nil"     then TypeRef::NIL
                   when "Bool"    then TypeRef::BOOL
                   when "Int8"    then TypeRef::INT8
                   when "Int16"   then TypeRef::INT16
                   when "Int32"   then TypeRef::INT32
                   when "Int64"   then TypeRef::INT64
                   when "Int128"  then TypeRef::INT128
                   when "UInt8"   then TypeRef::UINT8
                   when "UInt16"  then TypeRef::UINT16
                   when "UInt32"  then TypeRef::UINT32
                   when "UInt64"  then TypeRef::UINT64
                   when "UInt128" then TypeRef::UINT128
                   when "Float32" then TypeRef::FLOAT32
                   when "Float64" then TypeRef::FLOAT64
                   when "Char"    then TypeRef::CHAR
                   when "String"  then TypeRef::STRING
                   when "Symbol"  then TypeRef::SYMBOL
                   else
                     # User-defined type
                     @module.intern_type(TypeDescriptor.new(TypeKind::Class, name))
                   end
        @type_cache[name] = type_ref
        type_ref
      end
    end
  end

  # Instance variable info for class layout
  record IVarInfo, name : String, type : TypeRef, offset : Int32,
    default_expr_id : CrystalV2::Compiler::Frontend::ExprId? = nil,
    default_arena : CrystalV2::Compiler::Frontend::ArenaLike? = nil

  # Class variable info
  record ClassVarInfo, name : String, type : TypeRef, initial_value : Int64?

  # Class type info (is_struct=true for value types)
  record ClassInfo, name : String, type_ref : TypeRef, ivars : Array(IVarInfo), class_vars : Array(ClassVarInfo), size : Int32, is_struct : Bool = false, parent_name : String? = nil

  # Macro parameter metadata (internal/external names + prefix).
  record MacroParamInfo, name : String, external_name : String? = nil, prefix : String = ""

  # Lowering timing entry (used for exclusive time accounting).
  private struct LowerMethodTiming
    getter name : String
    getter requested : String
    getter start : Time::Instant
    property child_ms : Float64

    def initialize(@name : String, @requested : String, @start : Time::Instant, @child_ms : Float64)
    end
  end

  private struct LowerMethodStats
    property resolve_ms : Float64
    property resolve_calls : Int32
    property infer_ms : Float64
    property infer_calls : Int32

    def initialize
      @resolve_ms = 0.0
      @resolve_calls = 0
      @infer_ms = 0.0
      @infer_calls = 0
    end
  end

  # Class-level accessor entry (class_getter/class_setter/class_property)
  record ClassAccessorEntry,
    owner : String,
    spec : CrystalV2::Compiler::Frontend::AccessorSpec,
    arena : CrystalV2::Compiler::Frontend::ArenaLike,
    kind : Symbol

  # Generic class template (not yet specialized)
  record GenericClassTemplate,
    name : String,                                    # Base name like "Box"
    type_params : Array(String),                      # ["T"] or ["K", "V"]
    node : CrystalV2::Compiler::Frontend::ClassNode,  # Original AST node for re-lowering
    arena : CrystalV2::Compiler::Frontend::ArenaLike, # Arena for looking up body ExprIds
    is_struct : Bool = false

  # Context saved when module method registration is deferred (lazy mode).
  # Stores enough information to register a single method from a module on demand.
  record DeferredModuleContext,
    module_full_name : String,
    type_param_snapshot : Hash(String, String),   # full @type_param_map at include time
    mod_arena : CrystalV2::Compiler::Frontend::ArenaLike,
    namespace_override : String?

  # Main AST to HIR converter
  class AstToHir
    alias AstNode = CrystalV2::Compiler::Frontend::Node
    alias ExprId = CrystalV2::Compiler::Frontend::ExprId

    private struct CallSignature
      getter base_name : String
      getter arity : Int32
      getter has_block : Bool

      def initialize(@base_name : String, @arity : Int32, @has_block : Bool)
      end
    end

    private struct DefParamStats
      getter param_count : Int32
      getter required : Int32
      getter has_splat : Bool
      getter has_double_splat : Bool
      getter has_block : Bool
      getter has_named_only : Bool
      getter typed_param_count : Int32
      getter type_param_names : Array(String)
      getter has_non_type_param_annotation : Bool

      def initialize(
        @param_count : Int32,
        @required : Int32,
        @has_splat : Bool,
        @has_double_splat : Bool,
        @has_block : Bool,
        @has_named_only : Bool,
        @typed_param_count : Int32,
        @type_param_names : Array(String),
        @has_non_type_param_annotation : Bool,
      )
      end
    end

    private record CallsiteArgs, types : Array(TypeRef), literals : Array(Bool)?, enum_names : Array(String?)?

    private class InitParamsCapture
      property params : Array({String, TypeRef})
      property source : Symbol

      def initialize
        @params = [] of {String, TypeRef}
        @source = :none
      end
    end

    # Zero-copy method name parsing - single pass extracts all parts.
    # Parses: "Owner#method$TypeSuffix" or "Owner.method$TypeSuffix"
    # Returns struct with owner, method, suffix, separator - all as byte slices sharing original buffer.
    private struct MethodNameParts
      getter owner : String     # "Owner" or "Owner(T)" - always present
      getter method : String?   # "method" part after # or . (nil if no separator)
      getter suffix : String?   # type suffix after $ (nil if no $)
      getter separator : Char?  # '#' or '.' or nil
      getter base : String      # "Owner#method" or "Owner.method" without suffix
      getter is_instance : Bool # true if separator is #
      getter is_class : Bool    # true if separator is .

      def initialize(@owner, @method, @suffix, @separator, @base, @is_instance, @is_class)
      end
    end

    private struct MethodNamePartsCompact
      getter owner : String
      getter method : String?
      getter separator : Char?
      getter base : String

      def initialize(@owner, @method, @separator, @base)
      end
    end

    private struct TypeNameContextKey
      getter override : String?
      getter current : String?
      getter locals_hash : UInt64
      getter type_params_hash : UInt64

      def initialize(@override : String?, @current : String?, @locals_hash : UInt64, @type_params_hash : UInt64)
      end

      def hash : UInt64
        h = 0_u64
        h &+= @override.try(&.hash) || 0_u64
        h &+= (@current.try(&.hash) || 0_u64) &* 31_u64
        h &+= @locals_hash &* 131_u64
        h &+= @type_params_hash &* 521_u64
        h
      end

      def ==(other : TypeNameContextKey) : Bool
        @override == other.override &&
          @current == other.current &&
          @locals_hash == other.locals_hash &&
          @type_params_hash == other.type_params_hash
      end
    end

    private struct BlockLookupKey
      getter func_name : String
      getter arg_count : Int32
      getter args_hash : UInt64
      getter receiver_base : String?
      getter has_args : Bool

      def initialize(@func_name : String, @arg_count : Int32, @args_hash : UInt64, @receiver_base : String?, @has_args : Bool)
      end

      def hash : UInt64
        h = @func_name.hash
        h &+= @arg_count.to_u64 &* 31_u64
        h &+= @args_hash &* 131_u64
        h &+= @receiver_base.try(&.hash) || 0_u64
        h &+= @has_args ? 7_u64 : 0_u64
        h
      end

      def ==(other : BlockLookupKey) : Bool
        @func_name == other.func_name &&
          @arg_count == other.arg_count &&
          @args_hash == other.args_hash &&
          @receiver_base == other.receiver_base &&
          @has_args == other.has_args
      end
    end

    private struct FunctionLookupKey
      getter func_name : String
      getter arg_count : Int32
      getter args_hash : UInt64
      getter has_block : Bool
      getter has_args : Bool
      getter has_splat : Bool
      getter has_named : Bool
      getter unknown_args : Bool

      def initialize(@func_name : String, @arg_count : Int32, @args_hash : UInt64, @has_block : Bool, @has_args : Bool, @has_splat : Bool, @has_named : Bool, @unknown_args : Bool)
      end

      def hash : UInt64
        h = @func_name.hash
        h &+= @arg_count.to_u64 &* 31_u64
        h &+= @args_hash &* 131_u64
        h &+= (@has_block ? 7_u64 : 0_u64)
        h &+= (@has_args ? 17_u64 : 0_u64)
        h &+= (@has_splat ? 23_u64 : 0_u64)
        h &+= (@has_named ? 29_u64 : 0_u64)
        h &+= (@unknown_args ? 37_u64 : 0_u64)
        h
      end

      def ==(other : FunctionLookupKey) : Bool
        @func_name == other.func_name &&
          @arg_count == other.arg_count &&
          @args_hash == other.args_hash &&
          @has_block == other.has_block &&
          @has_args == other.has_args &&
          @has_splat == other.has_splat &&
          @has_named == other.has_named &&
          @unknown_args == other.unknown_args
      end
    end

    private struct FunctionLookupEntry
      getter result : Tuple(String, CrystalV2::Compiler::Frontend::DefNode)?
      getter base_epoch : Int32

      def initialize(@result : Tuple(String, CrystalV2::Compiler::Frontend::DefNode)?, @base_epoch : Int32)
      end
    end

    # Parse method name in single pass - O(n) instead of O(3n) for three separate splits
    @[AlwaysInline]
    private def parse_method_name(name : String) : MethodNameParts
      name_id = name.object_id
      if name_id == @method_name_parts_last_id
        if last = @method_name_parts_last
          record_cache_stat("method_name_parts", true)
          return last
        end
      end
      if cached = @method_name_parts_cache[name_id]?
        record_cache_stat("method_name_parts", true)
        @method_name_parts_last_id = name_id
        @method_name_parts_last = cached
        return cached
      end
      record_cache_stat("method_name_parts", false)
      sep_idx : Int32? = nil
      sep_char : Char? = nil
      dollar_idx : Int32? = nil

      # Single pass to find both separators
      i = 0
      while i < name.bytesize
        byte = name.to_unsafe[i]
        case byte
        when '#'.ord
          sep_idx = i
          sep_char = '#'
        when '.'.ord
          # Only use . as separator if we haven't seen # yet
          if sep_idx.nil?
            sep_idx = i
            sep_char = '.'
          end
        when '$'.ord
          dollar_idx = i
          break # $ is always last, no need to continue
        end
        i += 1
      end

      # Extract parts using byte_slice (zero-copy)
      if sep_idx
        owner = name.byte_slice(0, sep_idx)
        if dollar_idx
          method = name.byte_slice(sep_idx + 1, dollar_idx - sep_idx - 1)
          suffix = name.byte_slice(dollar_idx + 1)
          base = name.byte_slice(0, dollar_idx)
        else
          method = name.byte_slice(sep_idx + 1)
          suffix = nil
          base = name
        end
      else
        owner = dollar_idx ? name.byte_slice(0, dollar_idx) : name
        method = nil
        suffix = dollar_idx ? name.byte_slice(dollar_idx + 1) : nil
        base = dollar_idx ? name.byte_slice(0, dollar_idx) : name
      end

      parts = MethodNameParts.new(
        owner: owner,
        method: method,
        suffix: suffix,
        separator: sep_char,
        base: base,
        is_instance: sep_char == '#',
        is_class: sep_char == '.'
      )
      @method_name_parts_cache[name_id] = parts
      @method_name_parts_last_id = name_id
      @method_name_parts_last = parts
      parts
    end

    # Parse method name without touching caches (avoid Hash churn in hot paths).
    @[AlwaysInline]
    private def parse_method_name_uncached(name : String) : MethodNameParts
      sep_idx : Int32? = nil
      sep_char : Char? = nil
      dollar_idx : Int32? = nil

      i = 0
      while i < name.bytesize
        byte = name.to_unsafe[i]
        case byte
        when '#'.ord
          sep_idx = i
          sep_char = '#'
        when '.'.ord
          if sep_idx.nil?
            sep_idx = i
            sep_char = '.'
          end
        when '$'.ord
          dollar_idx = i
          break
        end
        i += 1
      end

      if sep_idx
        owner = name.byte_slice(0, sep_idx)
        if dollar_idx
          method = name.byte_slice(sep_idx + 1, dollar_idx - sep_idx - 1)
          suffix = name.byte_slice(dollar_idx + 1, name.bytesize - dollar_idx - 1)
          base = name.byte_slice(0, dollar_idx)
        else
          method = name.byte_slice(sep_idx + 1, name.bytesize - sep_idx - 1)
          suffix = nil
          base = name
        end
      else
        owner = name
        method = nil
        if dollar_idx
          suffix = name.byte_slice(dollar_idx + 1, name.bytesize - dollar_idx - 1)
          base = name.byte_slice(0, dollar_idx)
        else
          suffix = nil
          base = name
        end
      end

      is_instance = sep_char == '#'
      is_class = sep_char == '.'
      MethodNameParts.new(owner, method, suffix, sep_char, base, is_instance, is_class)
    end

    @[AlwaysInline]
    private def parse_method_name_compact(name : String) : MethodNamePartsCompact
      name_id = name.object_id
      if name_id == @method_name_compact_last_id
        if last = @method_name_compact_last
          return last
        end
      end
      if cached = @method_name_compact_cache[name_id]?
        @method_name_compact_last_id = name_id
        @method_name_compact_last = cached
        return cached
      end
      sep_idx : Int32? = nil
      sep_char : Char? = nil
      dollar_idx : Int32? = nil

      i = 0
      while i < name.bytesize
        byte = name.to_unsafe[i]
        case byte
        when '#'.ord
          sep_idx = i
          sep_char = '#'
        when '.'.ord
          if sep_idx.nil?
            sep_idx = i
            sep_char = '.'
          end
        when '$'.ord
          dollar_idx = i
          break
        end
        i += 1
      end

      if sep_idx
        owner = name.byte_slice(0, sep_idx)
        method = if dollar_idx
                   name.byte_slice(sep_idx + 1, dollar_idx - sep_idx - 1)
                 else
                   name.byte_slice(sep_idx + 1, name.bytesize - sep_idx - 1)
                 end
        base = if dollar_idx
                 name.byte_slice(0, dollar_idx)
               else
                 name
               end
      else
        owner = name
        method = nil
        base = if dollar_idx
                 name.byte_slice(0, dollar_idx)
               else
                 name
               end
      end

      parts = MethodNamePartsCompact.new(owner, method, sep_char, base)
      @method_name_compact_cache[name_id] = parts
      @method_name_compact_last_id = name_id
      @method_name_compact_last = parts
      parts
    end

    @[AlwaysInline]
    private def strip_type_suffix_uncached(name : String) : String
      if dollar = name.index('$')
        name.byte_slice(0, dollar)
      else
        name
      end
    end

    @[AlwaysInline]
    private def method_short_from_name(name : String) : String?
      sep_idx : Int32? = nil
      dollar_idx : Int32? = nil
      i = name.bytesize - 1
      while i >= 0
        byte = name.to_unsafe[i]
        if byte == '$'.ord
          dollar_idx = i
        elsif byte == '#'.ord || byte == '.'.ord
          sep_idx = i
          break
        end
        i -= 1
      end
      return nil unless sep_idx
      end_idx = dollar_idx || name.bytesize
      name.byte_slice(sep_idx + 1, end_idx - sep_idx - 1)
    end

    @[AlwaysInline]
    private def method_owner_from_name(name : String) : String
      sep_idx = name.index('#') || name.index('.')
      sep_idx ? name.byte_slice(0, sep_idx) : name
    end

    # Quick check helpers that don't allocate
    @[AlwaysInline]
    private def has_method_separator?(name : String) : Bool
      i = 0
      while i < name.bytesize
        byte = name.to_unsafe[i]
        return true if byte == '#'.ord || byte == '.'.ord
        i += 1
      end
      false
    end

    @[AlwaysInline]
    private def instance_method?(name : String) : Bool
      i = 0
      while i < name.bytesize
        return true if name.to_unsafe[i] == '#'.ord
        i += 1
      end
      false
    end

    @[AlwaysInline]
    private def class_method?(name : String) : Bool
      i = 0
      while i < name.bytesize
        return true if name.to_unsafe[i] == '.'.ord
        i += 1
      end
      false
    end

    # Legacy helpers for compatibility - use parse_method_name for hot paths
    @[AlwaysInline]
    private def strip_type_suffix(name : String) : String
      parse_method_name_compact(name).base
    end

    @[AlwaysInline]
    private def method_owner(name : String) : String
      parse_method_name_compact(name).owner
    end

    @[AlwaysInline]
    private def method_part(name : String) : String?
      parse_method_name_compact(name).method
    end

    @[AlwaysInline]
    private def method_separator(name : String) : Char?
      parse_method_name_compact(name).separator
    end

    @[AlwaysInline]
    private def method_suffix(name : String) : String?
      if dollar = name.index('$')
        name.byte_slice(dollar + 1, name.bytesize - dollar - 1)
      else
        nil
      end
    end

    @[AlwaysInline]
    private def suffix_param_count(suffix : String) : Int32
      return 0 if suffix == "block"
      # Strip trailing _block — it represents the & block parameter,
      # not a regular parameter, so it shouldn't be counted.
      effective = suffix.ends_with?("_block") ? suffix[0, suffix.size - 6] : suffix
      return 0 if effective.empty?
      count = 1
      i = 0
      while i < effective.bytesize
        count += 1 if effective.to_unsafe[i] == '_'.ord
        i += 1
      end
      count
    end

    @[AlwaysInline]
    private def strip_generic_args(name : String) : String
      i = 0
      while i < name.bytesize
        if name.to_unsafe[i] == '('.ord
          return name.byte_slice(0, i)
        end
        i += 1
      end
      name
    end

    @[AlwaysInline]
    private def strip_generic_receiver_from_base_name(base_name : String) : String
      if base_name.includes?('#') || base_name.includes?('.')
        parts = parse_method_name_compact(base_name)
        if parts.separator && parts.method
          owner_base = strip_generic_args(parts.owner)
          return parts.separator == '#' ? "#{owner_base}##{parts.method.not_nil!}" : "#{owner_base}.#{parts.method.not_nil!}"
        end
      end
      strip_generic_args(base_name)
    end

    @[AlwaysInline]
    private def slice_eq?(slice : Slice(UInt8)?, name : String) : Bool
      return false unless slice
      return false unless slice.size == name.bytesize
      i = 0
      name_ptr = name.to_unsafe
      while i < slice.size
        return false if slice[i] != name_ptr[i]
        i += 1
      end
      true
    end

    # Platform-specific LibC type aliases (fallback for unevaluated macro conditionals)
    # On 64-bit systems (aarch64-darwin, x86_64-*):
    # Includes both LibC:: prefixed and bare names for direct use
    LIBC_TYPE_ALIASES = {
      # With LibC:: prefix
      "LibC::Char"      => "UInt8",
      "LibC::UChar"     => "UInt8",
      "LibC::SChar"     => "Int8",
      "LibC::Short"     => "Int16",
      "LibC::UShort"    => "UInt16",
      "LibC::Int"       => "Int32",
      "LibC::UInt"      => "UInt32",
      "LibC::Long"      => "Int64",  # 64-bit
      "LibC::ULong"     => "UInt64", # 64-bit
      "LibC::LongLong"  => "Int64",
      "LibC::ULongLong" => "UInt64",
      "LibC::Float"     => "Float32",
      "LibC::Double"    => "Float64",
      "LibC::SizeT"     => "UInt64", # 64-bit: ULong -> UInt64
      "LibC::SSizeT"    => "Int64",  # 64-bit: Long -> Int64
      "LibC::PtrDiffT"  => "Int64",  # 64-bit: Long -> Int64
      "LibC::OffT"      => "Int64",  # 64-bit
      "LibC::ModeT"     => "UInt16", # darwin
      "LibC::PidT"      => "Int32",
      "LibC::UidT"      => "UInt32",
      "LibC::GidT"      => "UInt32",
      "LibC::TimeT"     => "Int64",  # 64-bit
      "LibC::ClockT"    => "UInt64", # darwin
      # Without LibC:: prefix (for macro conditionals that define these)
      "Short"  => "Int16",
      "UShort" => "UInt16",
      "Int"    => "Int32",
      "UInt"   => "UInt32",
      "Long"   => "Int64",  # 64-bit
      "ULong"  => "UInt64", # 64-bit
      "SizeT"  => "UInt64", # 64-bit
      "SSizeT" => "Int64",  # 64-bit
    }

    BUILTIN_TYPE_NAMES = {
      "Void", "Nil", "Bool",
      "Int", "Int8", "Int16", "Int32", "Int64", "Int128",
      "UInt", "UInt8", "UInt16", "UInt32", "UInt64", "UInt128",
      "Float32", "Float64",
      "Char", "String", "Symbol",
      "Pointer", "Proc", "Tuple", "NamedTuple",
    }

    BUILTIN_GENERIC_BASES = {
      "Array", "Hash", "Set", "Slice", "Pointer", "StaticArray",
      "Tuple", "NamedTuple", "Proc", "Range", "Iterator", "Enumerable",
    }

    private def builtin_type_ref_for(name : String) : TypeRef?
      case name
      when "Void"    then TypeRef::VOID
      when "Nil"     then TypeRef::NIL
      when "Bool"    then TypeRef::BOOL
      when "Int"     then TypeRef::INT32 # Abstract Int defaults to Int32
      when "Int8"    then TypeRef::INT8
      when "Int16"   then TypeRef::INT16
      when "Int32"   then TypeRef::INT32
      when "Int64"   then TypeRef::INT64
      when "Int128"  then TypeRef::INT128
      when "UInt"    then TypeRef::UINT32 # Abstract UInt defaults to UInt32
      when "UInt8"   then TypeRef::UINT8
      when "UInt16"  then TypeRef::UINT16
      when "UInt32"  then TypeRef::UINT32
      when "UInt64"  then TypeRef::UINT64
      when "UInt128" then TypeRef::UINT128
      when "Float32" then TypeRef::FLOAT32
      when "Float64" then TypeRef::FLOAT64
      when "Char"    then TypeRef::CHAR
      when "String"  then TypeRef::STRING
      when "Symbol"  then TypeRef::SYMBOL
      when "Pointer" then TypeRef::POINTER
      else
        nil
      end
    end

    # Top-level user-defined `def main` is renamed to avoid clashing with the C entrypoint.
    TOP_LEVEL_MAIN_BASE = "__crystal_user_main"
    # Marker for top-level `fun` definitions (C ABI). Stored in DefNode.receiver.
    FUN_DEF_RECEIVER = "__fun__"

    getter module : Module
    property arena : CrystalV2::Compiler::Frontend::ArenaLike

    # Pre-registered function signatures for forward reference support
    @function_types : Hash(String, TypeRef)

    # Index of function base names (without $ type suffix) for fast prefix lookups
    # Maps base name -> true (existence check)
    @function_base_names : Set(String)
    @method_bases_by_name : Hash(String, Set(String))
    @instance_method_names_by_owner : Hash(String, Set(String))

    # Cached return type for a function base name (without $ suffix).
    # This is used for method resolution when only the base name is known.
    @function_base_return_types : Hash(String, TypeRef)
    # Enum return type names for functions whose declared return is an enum.
    @function_enum_return_names : Hash(String, String)

    # Public accessor for enum names (used by MIR lowering to register enum types)
    def enum_names : Set(String)
      if enum_info = @enum_info
        enum_info.keys.to_set
      else
        Set(String).new
      end
    end
    # Functions whose return value is a type literal (e.g., EventLoop.backend_class).
    @function_return_type_literals : Set(String)

    # Class type information
    getter class_info : Hash(String, ClassInfo)
    @class_info_by_type_id : Hash(TypeId, ClassInfo)
    @class_info_version : Int32
    @classes_with_subclasses : Set(String)
    @children_by_parent : Hash(String, Set(String))
    # Module-level class vars (modules don't have ClassInfo entries)
    @module_class_vars : Hash(String, Array(ClassVarInfo))
    # Track lib struct/union types for field access lowering.
    @lib_structs : Set(String)

    # Initialize parameters for each class (for new() generation)
    @init_params : Hash(String, Array({String, TypeRef}))

    # Current class being lowered (for ivar access)
    @current_class : String?
    # Override namespace used for resolving short type names (module mixins).
    @current_namespace_override : String?

    # Union type descriptors for debug info (keyed by MIR::TypeRef)
    getter union_descriptors : Hash(MIR::TypeRef, MIR::UnionDescriptor)

    # AST of function definitions for inline expansion
    @function_defs : Hash(String, CrystalV2::Compiler::Frontend::DefNode)
    @function_def_arenas : Hash(String, CrystalV2::Compiler::Frontend::ArenaLike)
    @function_def_overloads : Hash(String, Array(String))
    @function_defs_cache_size : Int32
    @function_defs_processed_for_overloads : Int32 = 0
    @function_param_stats : Hash(String, DefParamStats)
    @function_type_keys_by_base : Hash(String, Array(String))
    @function_type_keys_by_base_size : Int32
    @function_types_processed_for_keys : Int32 = 0
    @function_type_keys_processed : Set(String)

    # ═══════════════════════════════════════════════════════════════════════════
    # HYBRID METHOD INDEX + CACHE (Option D optimization)
    # ═══════════════════════════════════════════════════════════════════════════
    #
    # Instead of building strings in hot loops for parent class method lookup,
    # we maintain a reverse index and cache lookup results.
    #
    # @method_index: Maps {base_class, method_name} → [full_function_names]
    #   - base_class is stripped of generics: "Array(Int32)" → "Array"
    #   - method_name is the method part without type suffix
    #   - Populated at def registration time
    #
    # @parent_lookup_cache: Caches results of parent chain lookups
    #   - Key: original lookup name (e.g., "Child#method$Int32")
    #   - Value: {DefNode, Arena, resolved_name} or nil if not found
    #
    # This gives O(1) lookup after first access, with zero allocations in hot path.
    #
    alias ParentLookupResult = {CrystalV2::Compiler::Frontend::DefNode, CrystalV2::Compiler::Frontend::ArenaLike, String}

    # Nested hash: base_owner → (method_name → [full_function_names])
    # Avoids Tuple(String,String) key hashing; two single-String lookups instead.
    @method_index : Hash(String, Hash(String, Array(String))) = {} of String => Hash(String, Array(String))
    @method_index_built : Bool = false
    @method_index_size_at_build : Int32 = 0
    @method_index_processed_count : Int32 = 0
    @method_index_last_owner : String? = nil
    @method_index_last_method : String? = nil
    @method_index_last_candidates : Array(String)? = nil
    @parent_lookup_cache : Hash(String, ParentLookupResult?) = {} of String => ParentLookupResult?
    # Second-tier cache: maps base name ("Owner#method") → parent class that defines it.
    # All overloads of the same method share this, avoiding repeated parent chain walks.
    @parent_class_for_method : Hash(String, String?) = {} of String => String?
    # Pre-computed parent chains: owner → [parent1, parent2, ..., Object]
    # Eliminates repeated @class_info hash lookups during parent walks.
    @parent_chains : Hash(String, Array(String)) = {} of String => Array(String)

    # Functions that contain yield (candidates for inline)
    @yield_functions : Set(String)
    # Functions whose explicit returns are all `return yield` (block-return-dependent).
    @yield_return_functions : Set(String)
    @yield_return_checked : Set(String)

    # Cache for def_contains_yield? keyed by DefNode object_id → Bool.
    # Same DefNode always yields the same result regardless of fallback arena.
    @yield_check_cache : Hash(UInt64, Bool) = {} of UInt64 => Bool
    # Cache for def_contains_block_call? keyed by DefNode object_id → Bool.
    @block_call_check_cache : Hash(UInt64, Bool) = {} of UInt64 => Bool
    # Cache for resolve_arena_for_def keyed by DefNode object_id → resolved arena.
    @arena_for_def_cache : Hash(UInt64, CrystalV2::Compiler::Frontend::ArenaLike) = {} of UInt64 => CrystalV2::Compiler::Frontend::ArenaLike
    # Deduplicated set of unique arenas (by object_id) for resolve_arena_for_def candidates.
    @unique_def_arenas : Hash(UInt64, CrystalV2::Compiler::Frontend::ArenaLike) = {} of UInt64 => CrystalV2::Compiler::Frontend::ArenaLike
    # Cached list of unique arenas to avoid per-call allocations.
    @unique_def_arenas_list : Array(CrystalV2::Compiler::Frontend::ArenaLike) = [] of CrystalV2::Compiler::Frontend::ArenaLike
    @unique_def_arenas_list_size : Int32 = 0
    # Cached per-path arena list to avoid scanning all arenas for resolve_arena_for_def.
    @unique_def_arenas_by_path : Hash(String, Array(CrystalV2::Compiler::Frontend::ArenaLike)) = {} of String => Array(CrystalV2::Compiler::Frontend::ArenaLike)
    # Cache for max body index per DefNode to avoid repeated scans.
    @def_body_max_index_cache : Hash(UInt64, Int32) = {} of UInt64 => Int32

    # Cache for yield_function_name_for: method_name → yield function name (or nil)
    @yield_name_cache : Hash(String, String?) = {} of String => String?
    # Pre-built map of stripped base names → original yield function names (avoids O(N) scan)
    @yield_functions_stripped_map : Hash(String, String) = {} of String => String
    @yield_functions_stripped_map_size : Int32 = 0
    # Cache for strip_generic_receiver_from_method_name: last-hit + direct-mapped table
    @strip_generic_receiver_last_id : UInt64 = 0
    @strip_generic_receiver_last : String? = nil
    # Direct-mapped cache for strip_generic_receiver (reduces hash churn).
    @strip_generic_receiver_table_keys : Array(UInt64) = Array(UInt64).new(2048, 0_u64)
    @strip_generic_receiver_table_vals : Array(String?) = Array(String?).new(2048, nil)
    @strip_generic_receiver_table_mask : UInt64 = 2047_u64
    # Content-keyed cache for strip_generic_receiver to avoid per-call allocations.
    @strip_generic_receiver_name_cache : Hash(String, String) = {} of String => String
    @strip_generic_receiver_name_cache_size : Int32 = 0
    @strip_generic_receiver_name_cache_limit : Int32 = 20000
    # Cache for function_def_overloads stripped receiver lookups: stripped base → overload list
    @function_def_overloads_stripped_cache : Hash(String, Array(String)) = {} of String => Array(String)
    # Incremental index: stripped base → overload list (avoid full scan per lookup)
    @function_def_overloads_stripped_index : Hash(String, Array(String)) = {} of String => Array(String)
    # Cache for function_def_overloads results by base_name (cleared on rebuild)
    @function_def_overloads_cache : Hash(String, Array(String)) = {} of String => Array(String)
    @function_def_overloads_cache_size : Int32 = 0
    # Precomputed base -> stripped base (generic receiver removed) to avoid per-call stripping.
    @function_def_overloads_stripped_by_base : Hash(String, String) = {} of String => String
    # Cache parsed method name parts to avoid repeated scans in hot paths.
    @method_name_parts_cache : Hash(UInt64, MethodNameParts) = {} of UInt64 => MethodNameParts
    @method_name_parts_last_id : UInt64 = 0
    @method_name_parts_last : MethodNameParts? = nil
    @type_param_map_hash_owner : UInt64 = 0
    @type_param_map_hash_value : UInt64 = 0
    @resolved_type_name_cache_last_ctx_key : TypeNameContextKey? = nil
    @resolved_type_name_cache_last_ctx_map : Hash(String, ResolvedTypeNameCacheEntry)? = nil
    @resolved_type_name_last_entry_ctx : TypeNameContextKey? = nil
    @resolved_type_name_last_entry_name_id : UInt64 = 0
    @resolved_type_name_last_entry_value : String? = nil
    @resolved_type_name_last_entry_epoch : Int32 = 0
    # Lightweight owner/method cache used in def lookup (avoids parse_method_name).
    @method_name_compact_cache : Hash(UInt64, MethodNamePartsCompact) = {} of UInt64 => MethodNamePartsCompact
    @method_name_compact_last_id : UInt64 = 0
    @method_name_compact_last : MethodNamePartsCompact? = nil
    # Recursion guard for substitute_type_params_in_type_name.
    @substitute_type_params_stack : Set(String) = Set(String).new
    @substitute_type_params_depth : Int32 = 0
    # Cache for substitute_type_params_in_type_name — invalidated on type_param_map/current_class change.
    @subst_cache : Hash(String, String) = {} of String => String
    @subst_cache_class : String? = nil
    @subst_cache_gen : UInt64 = 0
    @subst_cache_last_gen : UInt64 = 0
    # Cache for split_generic_type_args (pure function of input string).
    @split_generic_args_cache : Hash(String, Array(String)) = {} of String => Array(String)
    # Recursion guard for unresolved_generic_type_arg? to avoid cyclic alias/union loops.
    @unresolved_generic_arg_stack : Set(String) = Set(String).new
    @unresolved_generic_arg_depth : Int32 = 0

    # Cached ENV lookups — avoid repeated C library getenv() calls.
    @env_cache : Hash(String, String?) = {} of String => String?
    # Fast-path: if no DEBUG_*/CRYSTAL_V2_* env vars are set, all env_has? calls return false immediately
    @any_debug_env_set : Bool = ENV.keys.any? { |k| k.starts_with?("DEBUG_") || k.starts_with?("CRYSTAL_V2_") }
    # Cache block function def lookup by callsite shape.
    @block_lookup_cache : Hash(BlockLookupKey, Tuple(String, CrystalV2::Compiler::Frontend::DefNode)?) = {} of BlockLookupKey => Tuple(String, CrystalV2::Compiler::Frontend::DefNode)?
    @block_lookup_cache_size : Int32 = 0
    # Cache function def lookup by callsite shape.
    @function_lookup_cache : Hash(FunctionLookupKey, FunctionLookupEntry) = Hash(FunctionLookupKey, FunctionLookupEntry).new(initial_capacity: 16384)
    @function_lookup_cache_size : Int32 = 0
    @function_lookup_last_name_id : UInt64 = 0
    @function_lookup_last_arg_count : Int32 = -1
    @function_lookup_last_args_hash : UInt64 = 0
    @function_lookup_last_flags : UInt8 = 0_u8
    @function_lookup_last_result : Tuple(String, CrystalV2::Compiler::Frontend::DefNode)? = nil
    @function_lookup_last_result_valid : Bool = false
    @function_lookup_last_base_epoch : Int32 = 0
    @function_lookup_args_hash_owner : UInt64 = 0
    @function_lookup_args_hash_value : UInt64 = 0
    @function_lookup_base_epoch : Hash(String, Int32) = {} of String => Int32
    # Debug-only: lower node histogram (enabled via DEBUG_LOWER_HISTO)
    @lower_histo_counts : Hash(String, Int32) = {} of String => Int32
    @lower_histo_last : Time::Instant? = nil
    @lower_histo_since_check : Int32 = 0
    @lower_histo_total : Int64 = 0

    # ═══════════════════════════════════════════════════════════════════════════
    # FUNCTION LOWERING STATE MACHINE
    # ═══════════════════════════════════════════════════════════════════════════
    #
    # Unified state tracking for lazy function lowering. Replaces the previous
    # 4-collection approach (@lowered_functions, @lowering_functions,
    # @pending_lower_functions, @inside_lowering) with a single source of truth.
    #
    # State transitions:
    #   NotStarted → Pending (queued when inside another lowering)
    #   NotStarted → InProgress (direct lowering when not nested)
    #   Pending → InProgress (picked up from work queue)
    #   InProgress → Completed (lowering finished)
    #
    enum FunctionLoweringState
      NotStarted # Never seen or not yet queued
      Pending    # Queued for lowering (deferred due to nesting)
      InProgress # Currently being lowered
      Completed  # Successfully lowered
    end

    # Per-function lowering state
    @function_lowering_states : Hash(String, FunctionLoweringState) = Hash(String, FunctionLoweringState).new(initial_capacity: 32768)
    # Queue for pending lower requests to avoid O(n^2) scans of the state hash.
    @pending_function_queue : Array(String) = [] of String
    # Pending queue source counts (debug only): stripped base name → enqueue count.
    @pending_source_counts : Hash(String, Int32) = {} of String => Int32
    # Pending queue sample names (debug only): stripped base name → sample full names.
    @pending_source_samples : Hash(String, Array(String)) = {} of String => Array(String)
    # Monomorphization counters (debug only): base name → count.
    @mono_source_counts : Hash(String, Int32) = {} of String => Int32
    # Monomorphization samples (debug only): base name → specialized names.
    @mono_source_samples : Hash(String, Array(String)) = {} of String => Array(String)
    @mono_sources_reported : Bool = false
    # Monomorphization caller context counts (debug only): "base@caller" → count
    @mono_caller_counts : Hash(String, Int32) = {} of String => Int32

    # Tracks nesting depth of lowering operations.
    # When > 0, new lower requests are queued instead of executed immediately.
    @lowering_depth : Int32 = 0
    # Allow a shallow amount of recursive lowering before deferring to the queue.
    # 0 = current behavior (defer as soon as inside lowering).
    @lowering_depth_limit : Int32 = ENV["CRYSTAL_V2_LOWER_DEPTH_LIMIT"]?.try(&.to_i?) || 0
    # Tracks nesting depth of force_lower_function_for_return_type to prevent
    # unbounded recursion when inferring return types triggers more return type inferences.
    @force_lower_return_type_depth : Int32 = 0
    # When true, skip expensive infer_concrete_return_type_from_body during
    # monomorphization triggered by ensure_monomorphized_type (lowering path).
    # Return types will be inferred lazily when the method is actually called.
    @defer_body_return_inference : Bool = false

    # Helper: get function state (defaults to NotStarted)
    private def function_state(name : String) : FunctionLoweringState
      @function_lowering_states[name]? || FunctionLoweringState::NotStarted
    end

    # Helper: check if function can be lowered (not already in progress or completed)
    private def can_start_lowering?(name : String) : Bool
      state = function_state(name)
      state.not_started? || state.pending?
    end

    # Helper: check if we're inside a lowering operation
    private def inside_lowering? : Bool
      @lowering_depth > @lowering_depth_limit
    end

    # Helper: get all pending functions
    private def pending_functions : Array(String)
      @pending_function_queue
    end

    # ═══════════════════════════════════════════════════════════════════════════
    # METHOD INDEX HELPERS (Option D optimization)
    # ═══════════════════════════════════════════════════════════════════════════

    # Register a function def and update the method index for fast parent lookups.
    # Call this instead of directly assigning to @function_defs.
    private def register_function_def(
      full_name : String,
      def_node : CrystalV2::Compiler::Frontend::DefNode,
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
    )
      @function_defs[full_name] = def_node
      @function_def_arenas[full_name] = arena
      base_name = strip_type_suffix(full_name)
      @function_lookup_base_epoch[base_name] = (@function_lookup_base_epoch[base_name]? || 0) + 1
      @function_lookup_last_result_valid = false

      # Update method index: base_owner → method_name → [full_names]
      parts = parse_method_name_compact(full_name)
      if parts.separator && parts.method
        base_owner = strip_generic_args(parts.owner)
        method_name = parts.method.not_nil!
        owner_methods = @method_index[base_owner]?
        unless owner_methods
          owner_methods = Hash(String, Array(String)).new
          @method_index[base_owner] = owner_methods
        end
        list = owner_methods[method_name]?
        if list
          list << full_name
        else
          owner_methods[method_name] = [full_name]
        end
      end
    end

    # Lazily build the method index from all registered function defs.
    # Called before parent lookups to ensure the index is populated.
    # Incremental: only processes new entries since last build (tracked by counter).
    private def ensure_method_index_built
      current_size = @function_defs.size
      return if @method_index_built && current_size == @method_index_size_at_build
      count = 0
      @function_defs.each_key do |full_name|
        count += 1
        next if count <= @method_index_processed_count
        parts = parse_method_name_compact(full_name)
        next unless parts.separator && parts.method
        base_owner = strip_generic_args(parts.owner)
        method_name = parts.method.not_nil!
        owner_methods = @method_index[base_owner]?
        unless owner_methods
          owner_methods = Hash(String, Array(String)).new
          @method_index[base_owner] = owner_methods
        end
        list = owner_methods[method_name]?
        if list
          list << full_name
        else
          owner_methods[method_name] = [full_name]
        end
      end
      @method_index_processed_count = count
      @method_index_built = true
      @method_index_size_at_build = current_size
      # NOTE: We intentionally do NOT invalidate nil cache entries here.
      # New function_defs added during lowering are typically for the CURRENT class
      # being lowered, not for PARENT classes. Parent methods are registered during
      # class registration (before lowering starts). Clearing nil entries on every
      # index rebuild caused O(N*D*H) repeated lookups during the lowering phase.
    end

    # Get pre-computed parent chain for a class owner.
    private def get_parent_chain(owner : String) : Array(String)
      if chain = @parent_chains[owner]?
        return chain
      end
      chain = [] of String
      seen = Set(String).new
      seen << owner
      if ci = @class_info[owner]?
        p = ci.parent_name
        while p
          break if seen.includes?(p) # cycle detection
          seen << p
          chain << p
          p = @class_info[p]?.try(&.parent_name)
        end
      end
      @parent_chains[owner] = chain
      chain
    end

    # Lookup a method through parent class chain using cached index.
    # Returns {DefNode, Arena, resolved_name} or nil if not found.
    # Results are cached for O(1) subsequent lookups.
    #
    # Strategy:
    # Find a method overload in a specific parent class using the method index.
    # Returns ParentLookupResult or nil if the parent doesn't have the method.
    private def find_method_in_parent_via_index(
      parent : String,
      method : String,
      suffix : String?,
    ) : ParentLookupResult?
      base_parent = strip_generic_args(parent)
      owner_methods = @method_index[base_parent]?
      return nil unless owner_methods
      candidates = owner_methods[method]?
      return nil unless candidates

      # Try exact suffix match first
      candidates.each do |candidate_name|
        candidate_parts = parse_method_name(candidate_name)
        next unless candidate_parts.owner == parent || strip_generic_args(candidate_parts.owner) == base_parent

        if suffix
          if candidate_parts.suffix == suffix
            if def_node = @function_defs[candidate_name]?
              arena = @function_def_arenas[candidate_name]
              return {def_node, arena, candidate_name}
            end
          end
        else
          if candidate_parts.suffix.nil?
            if def_node = @function_defs[candidate_name]?
              arena = @function_def_arenas[candidate_name]
              return {def_node, arena, candidate_name}
            end
          end
        end
      end

      # Fallback: any candidate from this parent (regardless of suffix).
      # When the suffix doesn't match any candidate exactly, prefer untyped (generic)
      # overloads over typed ones with matching arity.  This ensures that e.g.
      # IO#puts(obj : _) is chosen over IO#puts(string : String) when the subclass
      # calls puts with an Int32.
      expected_arity = suffix ? parse_types_from_suffix(suffix).size : 0
      best_untyped : ParentLookupResult? = nil
      best_untyped_splat : ParentLookupResult? = nil
      best_arity_match : ParentLookupResult? = nil
      best_required_match : ParentLookupResult? = nil
      first_found : ParentLookupResult? = nil
      candidates.each do |candidate_name|
        candidate_parts = parse_method_name(candidate_name)
        next unless candidate_parts.owner == parent || strip_generic_args(candidate_parts.owner) == base_parent
        if def_node = @function_defs[candidate_name]?
          arena = @function_def_arenas[candidate_name]
          result = {def_node, arena, candidate_name}
          first_found ||= result
          # Check if this is an untyped (generic) overload with matching arity
          if params = def_node.params
            real_params = params.reject { |p| p.is_block || named_only_separator?(p) }
            has_splat = real_params.any?(&.is_splat)
            param_count = real_params.count { |p| !p.is_splat && !p.is_double_splat }
            required = real_params.count { |p| !p.is_splat && !p.is_double_splat && p.default_value.nil? }
            # Arity check: splat absorbs any; exact count; or within required..param_count range (defaults)
            arity_ok = has_splat || param_count == expected_arity || (expected_arity >= required && expected_arity <= param_count)
            next unless arity_ok || expected_arity == 0
            # Track best arity-matching candidate (typed or untyped)
            best_arity_match ||= result
            # Prefer candidates where required param count matches expected arity exactly
            if required == expected_arity && !has_splat
              best_required_match ||= result
            end
            all_untyped = real_params.all? do |p|
              p.is_splat || p.is_double_splat || p.type_annotation.nil? ||
                (ann = p.type_annotation) && String.new(ann) == "_"
            end
            if all_untyped
              if has_splat
                # Splat overloads are a last resort — prefer non-splat exact arity matches
                best_untyped_splat ||= result
              else
                best_untyped = result
                break
              end
            end
          else
            # No params = no-arg version. Only pick if we expect 0 args.
            if expected_arity == 0
              best_untyped = result
              break
            end
          end
        end
      end
      chosen = best_untyped || best_untyped_splat || best_required_match || best_arity_match || first_found
      return chosen if chosen

      nil
    end

    # Two-tier caching strategy for parent method lookup:
    # Tier 1: @parent_lookup_cache keyed by full name → exact result (per-overload)
    # Tier 2: @parent_class_for_method keyed by base name → parent class (shared across overloads)
    # Tier 2 eliminates redundant parent chain walks for different overloads of the same method.
    private def lookup_parent_method(
      name : String,
      name_parts : MethodNameParts,
    ) : ParentLookupResult?
      # Tier 1: check full-name cache
      if @parent_lookup_cache.has_key?(name)
        return @parent_lookup_cache[name]
      end

      # Ensure method index is built from all function_defs
      ensure_method_index_built

      result : ParentLookupResult? = nil

      if name_parts.is_instance && name_parts.method
        owner = name_parts.owner
        method = name_parts.method.not_nil!
        suffix = name_parts.suffix
        base_key = name_parts.base

        # Tier 2: check parent class cache (shared across all overloads of same method)
        if @parent_class_for_method.has_key?(base_key)
          if found_parent = @parent_class_for_method[base_key]
            # Direct lookup in the known parent class — skip chain walk entirely
            result = find_method_in_parent_via_index(found_parent, method, suffix)
          end
          # If cached as nil: no parent has this method, result stays nil
        else
          # Full parent chain walk (first time for this base method)
          found_parent_name : String? = nil

          # Use pre-computed parent chain to avoid repeated @class_info lookups
          chain = get_parent_chain(owner)
          chain.each do |parent|
            # Try index-based lookup
            if found = find_method_in_parent_via_index(parent, method, suffix)
              result = found
              found_parent_name = parent
              break
            end
            # Check if index had candidates at all (even if no match)
            base_parent = strip_generic_args(parent)
            owner_methods = @method_index[base_parent]?
            index_had_candidates = owner_methods ? owner_methods.has_key?(method) : false

            # Fallback: direct hash lookup with string building.
            # Skip when index is built (all function_defs are indexed, making
            # fallback redundant) or when index had candidates for this parent.
            if !index_had_candidates && !@method_index_built
              # Build parent method name: "Parent#method"
              parent_base = "#{parent}##{method}"

              # Try with suffix first
              if suffix
                parent_mangled = "#{parent_base}$#{suffix}"
                if def_node = @function_defs[parent_mangled]?
                  arena = @function_def_arenas[parent_mangled]
                  result = {def_node, arena, parent_mangled}
                  found_parent_name = parent
                end
              end

              # Try base name
              if result.nil?
                if def_node = @function_defs[parent_base]?
                  arena = @function_def_arenas[parent_base]
                  result = {def_node, arena, parent_base}
                  found_parent_name = parent
                end
              end

              # Try any overload with matching prefix
              if result.nil?
                mangled_prefix = "#{parent_base}$"
                function_def_overloads(parent_base).each do |key|
                  next if key == parent_base
                  next unless key.starts_with?(mangled_prefix)
                  if def_node = @function_defs[key]?
                    arena = @function_def_arenas[key]
                    result = {def_node, arena, key}
                    found_parent_name = parent
                    break
                  end
                end
              end
            end

            break if result
          end

          # Store parent class for all future overloads of this method
          @parent_class_for_method[base_key] = found_parent_name
        end
      end

      # Cache full result (even if nil to avoid repeated lookups)
      @parent_lookup_cache[name] = result
      result
    end

    # Clear parent lookup cache (call when class hierarchy changes)
    private def invalidate_parent_lookup_cache
      @parent_lookup_cache.clear
      @parent_class_for_method.clear
      @parent_chains.clear
    end

    # Call-site argument types for lazily lowered functions (mangled name -> arg types).
    @pending_arg_types : Hash(String, CallsiteArgs)
    @pending_arg_types_by_arity : Hash(String, Hash(Int32, Array(CallsiteArgs)))
    @pending_arg_types_seen_by_arity : Hash(String, Hash(Int32, Set(String)))
    @pending_arg_types_by_signature : Hash(CallSignature, Array(CallsiteArgs))
    @function_def_has_splat : Hash(String, Bool)
    @function_def_has_double_splat : Hash(String, Bool)
    @recorded_arg_types_by_signature : Hash(CallSignature, Array(CallsiteArgs))
    @recorded_arg_types_seen_by_signature : Hash(CallSignature, Set(String))
    # Call-site type parameter bindings for lazily lowered functions (mangled name -> map).
    @pending_type_param_maps : Hash(String, Hash(String, String))
    # Captured type parameter bindings for module methods copied into concrete classes.
    @function_type_param_maps : Hash(String, Hash(String, String))
    # Namespace overrides for module instance methods copied into concrete classes.
    @function_namespace_overrides : Hash(String, String)

    # Generic class templates (base name -> template)
    @generic_templates : Hash(String, GenericClassTemplate)
    # Additional generic class reopenings (base name -> templates)
    @generic_reopenings : Hash(String, Array(GenericClassTemplate))

    # Already monomorphized generic classes (specialized name -> true)
    @monomorphized : Set(String)

    # Debug counters
    @template_reg_counter : Int32?
    @mono_counter : Int32?

    # Method resolution cache (per-lowering scope).
    @method_resolution_cache : Hash(String, String)
    @method_resolution_cache_scope : String?
    @generic_split_cache : Hash(String, NamedTuple(base: String, args: String)?)
    @callsite_method_cache : Hash(String, String)
    @callsite_method_cache_scope : String?
    # Method resolution cache for inheritance lookups (class_name + method).
    @method_inheritance_cache : Hash(String, String?)
    @class_method_inheritance_cache : Hash(String, String?)
    @allocator_debug_counts : Hash(String, Int32)
    @allocator_debug_total : Int32
    @lower_method_debug_counts : Hash(String, Int32)
    @lower_method_debug_total : Int32
    @lower_method_ns_counts : Hash(String, Int32)
    @method_inheritance_cache_function_size : Int32
    @method_inheritance_cache_class_info_version : Int32
    @method_inheritance_cache_module_version : Int32

    # Pending monomorphizations (deferred until after all templates are registered)
    @pending_monomorphizations : Array({String, Array(String), String})
    @defer_monomorphization : Bool
    # Suppress monomorphization while scanning specialized class bodies.
    @suppress_monomorphization : Bool
    # Only lower bodies for monomorphized classes when explicitly enabled.
    @eager_monomorphization : Bool

    # Current type parameter substitutions for generic lowering
    @type_param_map : Hash(String, String)

    # Current method name being lowered (for super calls)
    @current_method : String?
    # Track whether the current method is a class/module method (self.)
    @current_method_is_class : Bool
    # Track which module provided the current _super body (to avoid infinite recursion)
    @current_super_source_module : String?
    # Current def node (used for parameter type inference in bodies).
    @current_def_node : CrystalV2::Compiler::Frontend::DefNode?

    # Locals available for resolving typeof(...) in type positions (per def)
    @current_typeof_locals : Hash(String, TypeRef)?
    # Optional body context for local-type inference when resolving identifiers.
    @infer_body_context : Array(ExprId)?
    # Guard against recursive inference loops (arena object_id + expr index).
    @infer_expr_stack : Set(UInt64)
    @infer_type_cache : Hash(UInt64, {Int32, TypeRef})
    @infer_type_cache_version : Int32
    @infer_type_guarded : Hash(UInt64, Int32)
    @infer_type_cache_scope : String?
    @infer_local_type_cache : Hash({UInt64, String, String?}, {Int32, TypeRef})
    @infer_local_type_nil_cache : Set({UInt64, String, String?})
    @infer_local_type_cache_scope : String?
    # Optional debug counters for inference recursion guard hits.
    @debug_infer_guard_enabled : Bool
    @infer_guard_hits : Int32
    @infer_guard_last_report : Time::Instant?
    # Optional lowering timing stack (only used when DEBUG_LOWER_METHOD_TIME is set).
    @lower_method_time_stack : Array(LowerMethodTiming)
    @lower_method_stats_stack : Array(LowerMethodStats)

    # Macro definitions (name -> {MacroDefNode, arena})
    @macro_defs : Hash(String, {CrystalV2::Compiler::Frontend::MacroDefNode, CrystalV2::Compiler::Frontend::ArenaLike})
    # Macro parameter lists (name -> MacroParamInfo)
    @macro_params : Hash(String, Array(MacroParamInfo))

    # Class-level accessors (full method name -> entry)
    @class_accessor_entries : Hash(String, ClassAccessorEntry)

    # Module AST definitions (name -> list of {node, arena}) for mixin expansion.
    # Many stdlib "modules" provide instance methods meant to be included into classes/structs.
    @module_defs : Hash(String, Array({CrystalV2::Compiler::Frontend::ModuleNode, CrystalV2::Compiler::Frontend::ArenaLike}))
    # Track concrete types that include a module for module-typed receiver fallback.
    @module_includers : Hash(String, Set(String))
    @module_includer_keys_by_suffix : Hash(String, Set(String))
    @module_includers_version : Int32
    # Reverse mapping: track which modules each class includes (for method lookup)
    @class_included_modules : Hash(String, Array(String))
    @union_type_cache : Hash(UInt32, Bool)
    @debug_cache_histo : Bool
    @debug_cache_stats : Hash(String, Tuple(Int32, Int32))
    @debug_cache_last : Time::Instant?
    # Modules that have `extend self` applied (treat defs without receiver as class methods).
    @module_extend_self : Set(String)
    # Lazy module method registration: defer DefNode processing during monomorphization.
    # Maps class_name → list of deferred module contexts for on-demand resolution.
    @deferred_module_contexts : Hash(String, Array(DeferredModuleContext))
    @lazy_module_methods : Bool
    @module_defs_cache_version : Int32
    @module_def_lookup_cache_version : Int32
    @module_def_lookup_cache : Hash(String, Tuple(CrystalV2::Compiler::Frontend::DefNode, CrystalV2::Compiler::Frontend::ArenaLike)?)
    @module_class_def_lookup_cache : Hash(String, Tuple(CrystalV2::Compiler::Frontend::DefNode, CrystalV2::Compiler::Frontend::ArenaLike)?)
    @instance_method_names_cache : Hash(String, Array(String))
    @instance_method_names_cache_version : Int32

    # Type aliases (alias_name -> target_type_name)
    @type_aliases : Hash(String, String)

    # Track which allocators have been generated (to avoid duplicates for reopened classes)
    @generated_allocators : Set(String)
    @deferred_allocators : Set(String)

    # Type cache to prevent infinite recursion in type_ref_for_name/create_union_type
    @type_cache : Hash(String, TypeRef)
    @type_cache_keys_by_component : Hash(String, Set(String))
    @type_cache_keys_by_generic_prefix : Hash(String, Set(String))
    @type_name_normalize_cache : Hash(String, String)
    # Cache for normalize_declared_type_name keyed on (type_name, context, subst_cache_gen).
    @normalize_decl_cache : Hash({String, String?, UInt64}, String)
    # Guard against recursive union construction (A | B where A aliases back to union).
    @union_in_progress : Set(String)

    private struct ResolvedTypeNameCacheEntry
      getter value : String
      getter epoch : Int32

      def initialize(@value : String, @epoch : Int32)
      end
    end

    # Cache resolved type names per namespace to avoid repeated context scans.
    @resolved_type_name_cache_global : Hash(String, ResolvedTypeNameCacheEntry)
    @resolved_type_name_cache_by_ctx : Hash(TypeNameContextKey, Hash(String, ResolvedTypeNameCacheEntry))
    @resolved_type_name_cache_epoch : Int32
    @resolved_type_name_invalidations : Hash(String, Int32)
    # Cache resolved class names for .class/.metaclass type literals.
    @type_literal_class_cache : Hash(String, String?)
    # Temporary cache for type_name_exists? lookups (used during signature collection).
    @type_name_exists_cache : Hash(String, Bool)?
    # Signature scan mode: avoid deep namespace walks while collecting method names.
    @signature_scan_mode : Bool
    # Optional debug histogram for type name resolution hot paths.
    @debug_resolve_histo_enabled : Bool
    @debug_resolve_histo : Hash(String, Int32)?
    @debug_resolve_histo_last_report : Time::Instant?
    @debug_resolve_histo_calls : Int32

    # Temporary arena switching context for cross-file yield inlining:
    # {caller_arena, callee_arena}
    @inline_arenas : Array(CrystalV2::Compiler::Frontend::ArenaLike)? = nil

    # While inlining yield-functions, we must preserve caller locals for the block body.
    # Otherwise callee locals (especially `self`) can leak into the caller and break ivar access.
    @inline_caller_locals_stack : Array(Hash(String, ValueId)) = [] of Hash(String, ValueId)
    # Preserve caller class/method so block bodies resolve unqualified calls in caller scope.
    @inline_caller_class_stack : Array(String?) = [] of String?
    @inline_caller_method_stack : Array(String?) = [] of String?
    @inline_caller_method_is_class_stack : Array(Bool) = [] of Bool
    # Preserve caller type-parameter bindings for block bodies during yield inlining.
    @inline_caller_type_param_map_stack : Array(Hash(String, String)) = [] of Hash(String, String)
    # Loop-carried locals for inline yield contexts (used to keep phi-bound values stable).
    @inline_loop_vars_stack : Array(Set(String)) = [] of Set(String)

    # While inlining yield-functions, substitute `yield` with the call-site block body.
    # Use a stack to support nested inlining (a block body may itself contain `yield`).
    @inline_yield_block_stack : Array(CrystalV2::Compiler::Frontend::BlockNode) = [] of CrystalV2::Compiler::Frontend::BlockNode
    @inline_yield_block_arena_stack : Array(CrystalV2::Compiler::Frontend::ArenaLike) = [] of CrystalV2::Compiler::Frontend::ArenaLike
    # Block parameter types for the current inline-yield context (aligned with @inline_yield_block_stack).
    @inline_yield_block_param_types_stack : Array(Array(TypeRef)?) = [] of Array(TypeRef)?
    # Cached return type names for inline-yield blocks (aligned with @inline_yield_block_stack).
    @inline_yield_block_return_stack : Array(String?) = [] of String?

    # Track currently inlined yield-functions to avoid infinite inline recursion on stdlib code.
    @inline_yield_name_stack : Array(String) = [] of String
    # Track when we are lowering an inlined block body to keep non-local returns intact.
    @inline_yield_block_body_depth : Int32 = 0
    # Track when we are lowering proc literal bodies (returns should not escape).
    @inline_yield_proc_depth : Int32 = 0
    # Counter for generating unique proc function names
    @proc_function_counter : Int32 = 0
    # Track captured values for proc closures: FuncPointer ValueId → Array of parent ValueIds
    @proc_captures_by_value = {} of ValueId => Array(ValueId)

    # Inline return handling for yield-function inlining.
    class InlineReturnContext
      getter exit_block : BlockId
      getter incoming : Array({BlockId, ValueId})
      getter function_id : FunctionId

      def initialize(@exit_block : BlockId, @incoming : Array({BlockId, ValueId}), @function_id : FunctionId)
      end
    end

    struct InlineReturnOverride
      getter active : Bool
      getter context : InlineReturnContext?

      def initialize(@active : Bool, @context : InlineReturnContext?)
      end
    end

    @inline_yield_return_stack : Array(InlineReturnContext) = [] of InlineReturnContext
    @inline_yield_return_override_stack : Array(InlineReturnOverride) = [] of InlineReturnOverride
    # Loop context stack: tracks exit_block (for break) and cond_block (for next)
    @loop_exit_stack : Array(BlockId) = [] of BlockId
    @loop_cond_stack : Array(BlockId) = [] of BlockId
    @loop_phi_stack : Array(Hash(String, Phi)) = [] of Hash(String, Phi)
    # Track break blocks and their variable values for exit phi construction
    @loop_break_info_stack : Array(Array({BlockId, Hash(String, ValueId)})) = [] of Array({BlockId, Hash(String, ValueId)})
    # Track break values for while expression result (break VALUE passes value out of while)
    @loop_break_value_stack : Array(Array({BlockId, ValueId})) = [] of Array({BlockId, ValueId})
    @virtual_targets_lowered : Set({String, String, UInt64, UInt8}) = Set({String, String, UInt64, UInt8}).new
    # Cache for collect_subclasses — class hierarchy doesn't change during compilation.
    @subclasses_cache : Hash(String, Array(String)) = {} of String => Array(String)
    # Track assigned local names for the current def (used to disambiguate
    # bare identifier receivers vs top-level function calls).
    @assigned_vars_stack : Array(Set(String)) = [] of Set(String)
    # Track virtual targets so newly-registered subclasses can be lowered later.
    record VirtualTarget, method_name : String, arg_types : Array(TypeRef), has_block : Bool, has_splat : Bool
    @virtual_targets_by_parent : Hash(String, Array(VirtualTarget)) = {} of String => Array(VirtualTarget)
    @virtual_targets_recorded : Set(String) = Set(String).new

    # Captures computed for block literals (body_block -> captures).
    @block_captures : Hash(BlockId, Array(CapturedVar)) = {} of BlockId => Array(CapturedVar)
    # Map block node object ids to the arena they were created in.
    @block_node_arenas : Hash(UInt64, CrystalV2::Compiler::Frontend::ArenaLike) = {} of UInt64 => CrystalV2::Compiler::Frontend::ArenaLike
    # Map block node object ids to their defining scope (class/method).
    @block_owner : Hash(UInt64, {class_name: String?, method_name: String?, is_class: Bool}) = {} of UInt64 => {class_name: String?, method_name: String?, is_class: Bool}
    @block_owner_self_ids : Hash(UInt64, ValueId) = {} of UInt64 => ValueId
    # Map block node object ids to the function being lowered when the block was registered.
    # Used to detect whether a `return` inside a yield block should exit the current function.
    @block_owner_function_ids : Hash(UInt64, FunctionId) = {} of UInt64 => FunctionId
    @last_block_arena_id : UInt64 = 0_u64
    @last_block_arena : CrystalV2::Compiler::Frontend::ArenaLike?

    # Track declared type names for locals (used to resolve module-typed receivers).
    @current_typeof_local_names : Hash(String, String)?
    @current_typeof_local_names_hash : UInt64
    @current_typeof_local_names_hash_owner : UInt64?
    # Short name index for class/struct lookups (short -> full names).
    @short_type_index : Hash(String, Set(String))
    @top_level_type_names : Set(String)
    @top_level_class_kinds : Hash(String, Bool)
    # Track constant definitions and inferred types for constant resolution.
    @constant_defs : Set(String)
    getter constant_types : Hash(String, TypeRef)
    getter constant_literal_values : Hash(String, CrystalV2::Compiler::Semantic::MacroValue)
    @nested_type_names : Hash(String, Set(String))

    # Track top-level `def main` so we can remap calls and avoid entrypoint collisions.
    @top_level_main_defined : Bool

    # Source text per arena (used to reconstruct macro literal text from spans).
    @sources_by_arena : Hash(CrystalV2::Compiler::Frontend::ArenaLike, String)
    # Cached line counts per arena source (used for span validation).
    @line_counts_by_arena : Hash(CrystalV2::Compiler::Frontend::ArenaLike, Int32)
    # Source path per arena (used for diagnostics).
    @paths_by_arena : Hash(CrystalV2::Compiler::Frontend::ArenaLike, String)
    # Extra source snippets (macro expansion/reparse) to keep slices alive.
    @extra_sources_by_arena : Hash(CrystalV2::Compiler::Frontend::ArenaLike, Array(String))
    @last_splat_context : String?
    @type_literal_values : Set(ValueId)
    @debug_callsite : String?
    @pending_def_annotations : Array(Tuple(CrystalV2::Compiler::Frontend::AnnotationNode, CrystalV2::Compiler::Frontend::ArenaLike))
    @pending_primitive_kind : String? = nil

    # Deferred classvar initializations to be processed at start of __crystal_main.
    # Stores: {expr_id, arena, owning_class_name}
    @deferred_classvar_inits : Array(Tuple(CrystalV2::Compiler::Frontend::ExprId, CrystalV2::Compiler::Frontend::ArenaLike, String))

    # Deferred constant initializations (non-numeric constants like string literals).
    # Stores: {owner_name, const_name, value_expr_id, arena}
    @deferred_constant_inits : Array(Tuple(String, String, CrystalV2::Compiler::Frontend::ExprId, CrystalV2::Compiler::Frontend::ArenaLike))

    def initialize(
      @arena,
      module_name : String = "main",
      sources_by_arena : Hash(CrystalV2::Compiler::Frontend::ArenaLike, String)? = nil,
      paths_by_arena : Hash(CrystalV2::Compiler::Frontend::ArenaLike, String)? = nil,
    )
      @module = Module.new(module_name)
      @function_types = Hash(String, TypeRef).new(initial_capacity: 8192)
      @function_base_names = Set(String).new(initial_capacity: 8192)
      @method_bases_by_name = Hash(String, Set(String)).new(initial_capacity: 4096)
      @instance_method_names_by_owner = Hash(String, Set(String)).new(initial_capacity: 2048)
      @function_base_return_types = Hash(String, TypeRef).new(initial_capacity: 8192)
      @function_enum_return_names = {} of String => String
      @function_return_type_literals = Set(String).new
      @class_info = Hash(String, ClassInfo).new(initial_capacity: 2048)
      @class_info_by_type_id = {} of TypeId => ClassInfo
      @class_info_version = 0
      @classes_with_subclasses = Set(String).new
      @children_by_parent = {} of String => Set(String)
      @module_class_vars = {} of String => Array(ClassVarInfo)
      @class_var_infer_stack = Set(String).new
      @lib_structs = Set(String).new
      @init_params = {} of String => Array({String, TypeRef})
      @current_class = nil
      @current_namespace_override = nil
      @current_method = nil
      @current_method_is_class = false
      @current_super_source_module = nil
      @current_def_node = nil
      @current_typeof_locals = nil
      @infer_body_context = nil
      @infer_expr_stack = Set(UInt64).new
      @infer_type_cache = {} of UInt64 => {Int32, TypeRef}
      @infer_type_cache_version = 0
      @infer_type_guarded = {} of UInt64 => Int32
      @infer_type_cache_scope = nil
      @infer_local_type_cache = {} of {UInt64, String, String?} => {Int32, TypeRef}
      @infer_local_type_nil_cache = Set({UInt64, String, String?}).new
      @infer_local_type_cache_scope = nil
      @debug_infer_guard_enabled = env_has?("DEBUG_INFER_GUARD")
      @infer_guard_hits = 0
      @infer_guard_last_report = nil
      @lower_method_time_stack = [] of LowerMethodTiming
      @lower_method_stats_stack = [] of LowerMethodStats
      @union_descriptors = {} of MIR::TypeRef => MIR::UnionDescriptor
      @function_defs = Hash(String, CrystalV2::Compiler::Frontend::DefNode).new(initial_capacity: 32768)
      @function_def_arenas = Hash(String, CrystalV2::Compiler::Frontend::ArenaLike).new(initial_capacity: 32768)
      @function_def_overloads = Hash(String, Array(String)).new(initial_capacity: 8192)
      @function_defs_cache_size = 0
      @function_param_stats = {} of String => DefParamStats
      @function_type_keys_by_base = Hash(String, Array(String)).new(initial_capacity: 8192)
      @function_type_keys_by_base_size = 0
      @function_type_keys_processed = Set(String).new(initial_capacity: 16384)
      @function_def_overloads_cache = {} of String => Array(String)
      @function_def_overloads_cache_size = 0
      @yield_functions = Set(String).new
      @yield_return_functions = Set(String).new
      @yield_return_checked = Set(String).new
      # Note: @lowered_functions and @lowering_functions removed.
      # Use @function_lowering_states with FunctionLoweringState enum instead.
      @pending_arg_types = {} of String => CallsiteArgs
      @pending_arg_types_by_arity = {} of String => Hash(Int32, Array(CallsiteArgs))
      @pending_arg_types_seen_by_arity = {} of String => Hash(Int32, Set(String))
      @pending_arg_types_by_signature = {} of CallSignature => Array(CallsiteArgs)
      @function_def_has_splat = {} of String => Bool
      @function_def_has_double_splat = {} of String => Bool
      @recorded_arg_types_by_signature = {} of CallSignature => Array(CallsiteArgs)
      @recorded_arg_types_seen_by_signature = {} of CallSignature => Set(String)
      @pending_type_param_maps = Hash(String, Hash(String, String)).new(initial_capacity: 4096)
      @function_type_param_maps = Hash(String, Hash(String, String)).new(initial_capacity: 8192)
      @function_namespace_overrides = Hash(String, String).new(initial_capacity: 4096)
      @generic_templates = {} of String => GenericClassTemplate
      @generic_reopenings = {} of String => Array(GenericClassTemplate)
      @monomorphized = Set(String).new(initial_capacity: 32768)
      @pending_monomorphizations = [] of {String, Array(String), String}
      @defer_monomorphization = true # Start in deferred mode
      @suppress_monomorphization = false
      @eager_monomorphization = env_has?("CRYSTAL_V2_EAGER_MONO")
      @method_resolution_cache = Hash(String, String).new(initial_capacity: 8192)
      @method_resolution_cache_scope = nil
      @generic_split_cache = Hash(String, NamedTuple(base: String, args: String)?).new(initial_capacity: 4096)
      @callsite_method_cache = Hash(String, String).new(initial_capacity: 8192)
      @callsite_method_cache_scope = nil
      @method_inheritance_cache = Hash(String, String?).new(initial_capacity: 8192)
      @class_method_inheritance_cache = Hash(String, String?).new(initial_capacity: 4096)
      @allocator_debug_counts = {} of String => Int32
      @allocator_debug_total = 0
      @lower_method_debug_counts = {} of String => Int32
      @lower_method_debug_total = 0
      @lower_method_ns_counts = {} of String => Int32
      @method_inheritance_cache_function_size = 0
      @method_inheritance_cache_class_info_version = 0
      @method_inheritance_cache_module_version = 0
      @type_param_map = Hash(String, String).new(initial_capacity: 4096)
      @macro_defs = {} of String => {CrystalV2::Compiler::Frontend::MacroDefNode, CrystalV2::Compiler::Frontend::ArenaLike}
      @macro_params = {} of String => Array(MacroParamInfo)
      @class_accessor_entries = {} of String => ClassAccessorEntry
      @module_defs = {} of String => Array({CrystalV2::Compiler::Frontend::ModuleNode, CrystalV2::Compiler::Frontend::ArenaLike})
      @module_includers = {} of String => Set(String)
      @module_includer_keys_by_suffix = {} of String => Set(String)
      @module_includers_version = 0
      @class_included_modules = {} of String => Array(String)
      @union_type_cache = {} of UInt32 => Bool
      @debug_cache_histo = !env_get("DEBUG_CACHE_HISTO").nil?
      @debug_cache_stats = {} of String => Tuple(Int32, Int32)
      @debug_cache_last = @debug_cache_histo ? Time.instant : nil
      @module_extend_self = Set(String).new
      @deferred_module_contexts = {} of String => Array(DeferredModuleContext)
      @lazy_module_methods = false
      @module_defs_cache_version = 0
      @module_def_lookup_cache_version = 0
      @module_def_lookup_cache = {} of String => Tuple(CrystalV2::Compiler::Frontend::DefNode, CrystalV2::Compiler::Frontend::ArenaLike)?
      @module_class_def_lookup_cache = {} of String => Tuple(CrystalV2::Compiler::Frontend::DefNode, CrystalV2::Compiler::Frontend::ArenaLike)?
      @instance_method_names_cache = {} of String => Array(String)
      @instance_method_names_cache_version = 0
      @type_aliases = {} of String => String
      @generated_allocators = Set(String).new
      @deferred_allocators = Set(String).new
      @type_cache = {} of String => TypeRef
      @type_cache_keys_by_component = {} of String => Set(String)
      @type_cache_keys_by_generic_prefix = {} of String => Set(String)
      @type_name_normalize_cache = Hash(String, String).new(initial_capacity: 4096)
      @normalize_decl_cache = Hash({String, String?, UInt64}, String).new(initial_capacity: 4096)
      @union_in_progress = Set(String).new
      @resolved_type_name_cache_global = Hash(String, ResolvedTypeNameCacheEntry).new(initial_capacity: 8192)
      @resolved_type_name_cache_by_ctx = {} of TypeNameContextKey => Hash(String, ResolvedTypeNameCacheEntry)
      @resolved_type_name_cache_epoch = 0
      @resolved_type_name_invalidations = {} of String => Int32
      @type_literal_class_cache = {} of String => String?
      @type_name_exists_cache = nil
      @signature_scan_mode = false
      @debug_resolve_histo_enabled = env_has?("DEBUG_RESOLVE_HISTO")
      @debug_resolve_histo = nil
      @debug_resolve_histo_last_report = nil
      @debug_resolve_histo_calls = 0
      @short_type_index = {} of String => Set(String)
      @top_level_type_names = Set(String).new
      @top_level_class_kinds = {} of String => Bool
      @current_typeof_local_names = nil
      @current_typeof_local_names_hash = 0_u64
      @current_typeof_local_names_hash_owner = nil
      @top_level_main_defined = false
      @block_captures = {} of BlockId => Array(CapturedVar)
      @block_node_arenas = {} of UInt64 => CrystalV2::Compiler::Frontend::ArenaLike
      @block_owner = {} of UInt64 => {class_name: String?, method_name: String?, is_class: Bool}
      @block_owner_self_ids = {} of UInt64 => ValueId
      @block_owner_function_ids = {} of UInt64 => FunctionId
      @sources_by_arena = sources_by_arena || {} of CrystalV2::Compiler::Frontend::ArenaLike => String
      @line_counts_by_arena = {} of CrystalV2::Compiler::Frontend::ArenaLike => Int32
      @paths_by_arena = paths_by_arena || {} of CrystalV2::Compiler::Frontend::ArenaLike => String
      @extra_sources_by_arena = {} of CrystalV2::Compiler::Frontend::ArenaLike => Array(String)
      @last_splat_context = nil
      @type_literal_values = Set(ValueId).new
      @constant_defs = Set(String).new
      @constant_types = {} of String => TypeRef
      @constant_literal_values = {} of String => CrystalV2::Compiler::Semantic::MacroValue
      @nested_type_names = {} of String => Set(String)
      @debug_callsite = nil
      @pending_def_annotations = [] of Tuple(CrystalV2::Compiler::Frontend::AnnotationNode, CrystalV2::Compiler::Frontend::ArenaLike)
      @deferred_classvar_inits = [] of Tuple(CrystalV2::Compiler::Frontend::ExprId, CrystalV2::Compiler::Frontend::ArenaLike, String)
      @deferred_constant_inits = [] of Tuple(String, String, CrystalV2::Compiler::Frontend::ExprId, CrystalV2::Compiler::Frontend::ArenaLike)
      @pending_offsetof_constants = [] of Tuple(String, CrystalV2::Compiler::Frontend::ExprId, CrystalV2::Compiler::Frontend::ArenaLike, String?)
    end

    private def with_debug_callsite(label : String?, &)
      return yield unless DebugHooks::ENABLED && label

      previous = @debug_callsite
      @debug_callsite = label
      begin
        yield
      ensure
        @debug_callsite = previous
      end
    end

    # Cached ENV lookup — avoids repeated C library getenv() calls.
    # ENV values never change during compilation, so caching is safe.
    @[AlwaysInline]
    private def env_get(key : String) : String?
      @env_cache.fetch(key) do
        val = ENV[key]?
        @env_cache[key] = val
        val
      end
    end

    @[AlwaysInline]
    private def env_has?(key : String) : Bool
      return false unless @any_debug_env_set
      !env_get(key).nil?
    end

    private def debug_env_filter_match?(env_key : String, *texts : String) : Bool
      value = env_get(env_key)
      return false unless value
      return true if value.empty? || value == "1" || value == "true"
      tokens = value.split(',').map(&.strip).reject(&.empty?)
      return true if tokens.empty?
      texts.any? do |text|
        tokens.any? { |token| text.includes?(token) }
      end
    end

    private def debug_hook_filter_match?(*texts : String) : Bool
      return false unless DebugHooks::ENABLED
      debug_env_filter_match?("DEBUG_HOOK_FILTER", *texts)
    end

    private def clear_pending_effect_annotations : Nil
      @pending_def_annotations.clear
      @pending_primitive_kind = nil
    end

    def seed_top_level_type_names(names : Enumerable(String)) : Nil
      names.each do |name|
        @top_level_type_names.add(name)
        if idx = name.index('(')
          base = name[0, idx]
          @top_level_type_names.add(base) unless base.empty?
        end
      end
    end

    def seed_top_level_class_kinds(kinds : Enumerable(Tuple(String, Bool))) : Nil
      kinds.each { |name, is_struct| @top_level_class_kinds[name] = is_struct }
    end

    def seed_nested_type_names(names : Hash(String, Set(String))) : Nil
      names.each do |owner, nested|
        set = @nested_type_names[owner]? || Set(String).new
        nested.each { |name| set << name }
        @nested_type_names[owner] = set
      end
    end

    private def effect_annotation_name(node : CrystalV2::Compiler::Frontend::AnnotationNode) : String?
      name = resolve_annotation_name(node.name)
      return nil unless name
      return name if name.in?("NoEscape", "Transfer", "ThreadShared", "FFIExposed", "ReturnsAlias", "Taints")
      nil
    end

    private def taint_tag_from_expr(expr_id : CrystalV2::Compiler::Frontend::ExprId) : String?
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::SymbolNode
        tag = String.new(node.name)
        tag.starts_with?(':') ? tag[1..] : tag
      when CrystalV2::Compiler::Frontend::StringNode
        String.new(node.value)
      when CrystalV2::Compiler::Frontend::IdentifierNode
        String.new(node.name)
      else
        nil
      end
    end

    private def taint_named_arg_truthy?(expr_id : CrystalV2::Compiler::Frontend::ExprId) : Bool
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::BoolNode
        node.value
      when CrystalV2::Compiler::Frontend::NilNode
        false
      else
        true
      end
    end

    private def apply_taint_tag(summary : MethodEffectSummary, tag : String) : MethodEffectSummary
      normalized = tag.downcase
      case normalized
      when "thread_shared", "threadshared", "thread-shared"
        summary.thread_shared = true
      when "ffi_exposed", "ffiexposed", "ffi-exposed", "ffi"
        summary.ffi_exposed = true
      end
      summary
    end

    private def apply_taints_annotation(
      node : CrystalV2::Compiler::Frontend::AnnotationNode,
      summary : MethodEffectSummary,
    ) : MethodEffectSummary
      node.args.each do |arg_id|
        if tag = taint_tag_from_expr(arg_id)
          summary = apply_taint_tag(summary, tag)
        end
      end

      if named_args = node.named_args
        named_args.each do |named_arg|
          next unless taint_named_arg_truthy?(named_arg.value)
          summary = apply_taint_tag(summary, String.new(named_arg.name))
        end
      end

      summary
    end

    private def remember_effect_annotation(
      node : CrystalV2::Compiler::Frontend::AnnotationNode,
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : Nil
      with_arena(arena) do
        name = resolve_annotation_name(node.name)
        if name == "Primitive"
          # Extract symbol argument: @[Primitive(:binary)] → "binary"
          if node.args.size == 1
            arg = arena[node.args[0]]
            if arg.is_a?(CrystalV2::Compiler::Frontend::SymbolNode)
              kind = String.new(arg.name)
              kind = kind.lstrip(':')
              @pending_primitive_kind = kind
              STDERR.puts "[PRIM_DETECT] Detected @[Primitive(:#{kind})] pending_primitive_kind set" if env_get("DEBUG_PRIMITIVES")
            else
              STDERR.puts "[PRIM_DETECT] Primitive arg is #{arg.class}, not SymbolNode" if env_get("DEBUG_PRIMITIVES")
            end
          else
            STDERR.puts "[PRIM_DETECT] Primitive has #{node.args.size} args (expected 1)" if env_get("DEBUG_PRIMITIVES")
          end
          return
        elsif name == "AlwaysInline"
          # Store for later use (currently informational)
          return
        end
        return unless effect_annotation_name(node)
      end
      @pending_def_annotations << {node, arena}
    end

    private def register_pending_method_effects(full_name : String, _param_count : Int32) : Nil
      return if @pending_def_annotations.empty?

      summary = MethodEffectSummary.new
      @pending_def_annotations.each do |annotation_node, annotation_arena|
        with_arena(annotation_arena) do
          case effect_annotation_name(annotation_node)
          when "NoEscape"
            summary.no_escape = true
          when "Transfer"
            summary.transfer = true
          when "ThreadShared"
            summary.thread_shared = true
          when "FFIExposed"
            summary.ffi_exposed = true
          when "ReturnsAlias"
            summary.returns_alias = true
          when "Taints"
            summary = apply_taints_annotation(annotation_node, summary)
          end
        end
      end

      clear_pending_effect_annotations
      @module.add_method_effect(full_name, summary) unless summary.empty?
    end

    private def fun_def?(node : CrystalV2::Compiler::Frontend::DefNode) : Bool
      if recv = node.receiver
        String.new(recv) == FUN_DEF_RECEIVER
      else
        false
      end
    end

    private def push_unique_module_name(list : Array(String), name : String) : Bool
      return false if list.includes?(name)
      list << name
      true
    end

    private def record_module_inclusion(module_name : String, class_name : String) : Nil
      # Resolve type aliases in the module name (e.g., Engine::MatchData -> PCRE2::MatchData)
      resolved_module_name = resolve_module_alias_for_include(module_name)
      if debug_env_filter_match?("DEBUG_MODULE_INCLUDE", module_name, class_name, resolved_module_name)
        STDERR.puts "[DEBUG_MODULE_INCLUDE] #{class_name} <= #{module_name} (resolved: #{resolved_module_name})"
      end
      cache_bump = false
      set = @module_includers[resolved_module_name]? || begin
        new_set = Set(String).new
        @module_includers[resolved_module_name] = new_set
        new_set
      end
      unless set.includes?(class_name)
        set.add(class_name)
        cache_bump = true
      end
      @module.register_module_includer(resolved_module_name, class_name)
      module_base = strip_generic_args(resolved_module_name)
      parts = module_base.split("::")
      parts.each_index do |idx|
        suffix = parts[idx..].join("::")
        (@module_includer_keys_by_suffix[suffix] ||= Set(String).new) << resolved_module_name
      end
      # Also record reverse mapping (class -> modules it includes)
      class_set = @class_included_modules[class_name]? || begin
        new_list = [] of String
        @class_included_modules[class_name] = new_list
        new_list
      end
      cache_bump = true if push_unique_module_name(class_set, resolved_module_name)
      # Also record includes on the base class name (Array(T) -> Array) so
      # generic instantiations can resolve module methods via base lookup.
      class_base = strip_generic_args(class_name)
      if class_base != class_name && !class_base.empty?
        base_set = @class_included_modules[class_base]? || begin
          new_list = [] of String
          @class_included_modules[class_base] = new_list
          new_list
        end
        cache_bump = true if push_unique_module_name(base_set, resolved_module_name)
      end
      @module_includers_version += 1 if cache_bump
      debug_hook("module.include", "#{class_name} <= #{resolved_module_name}")
    end

    # Resolve type aliases for module names like Engine::MatchData -> Regex::PCRE::MatchData
    private def resolve_module_alias_for_include(module_name : String) : String
      return module_name if module_name.empty?

      candidates = [] of String
      candidates << module_name

      if current = @current_class
        if current.includes?("::")
          parts = current.split("::")
          parts.pop
          while parts.size > 0
            candidates << "#{parts.join("::")}::#{module_name}"
            parts.pop
          end
        end
      end

      candidates.each do |candidate|
        resolved = resolve_module_alias_prefix(candidate)
        return resolved if @module_defs.has_key?(resolved)
      end

      module_name
    end

    private def resolve_module_alias_prefix(module_name : String) : String
      return resolve_type_alias_chain(module_name) unless module_name.includes?("::")

      parts = module_name.split("::")
      (parts.size - 1).downto(1) do |i|
        prefix = parts[0, i].join("::")
        resolved_prefix = resolve_type_alias_chain(prefix)
        if resolved_prefix != prefix
          result = ([resolved_prefix] + parts[i..]).join("::")
          # If the resolved prefix lost its namespace (e.g. Regex::Engine → PCRE2),
          # re-qualify under the original prefix's namespace so we get Regex::PCRE2::MatchData.
          unless result.includes?("::") && @module_defs.has_key?(result)
            if !resolved_prefix.includes?("::") && i > 0
              ns = parts[0, i - 1].join("::")
              requalified = ns.empty? ? result : "#{ns}::#{result}"
              result = requalified if @module_defs.has_key?(requalified)
            end
          end
          return result
        end
      end

      resolve_type_alias_chain(module_name)
    end

    private def named_only_separator?(param : CrystalV2::Compiler::Frontend::Parameter) : Bool
      param.is_splat && param.name.nil? && param.external_name.nil?
    end

    # Extract the literal value from an AST parameter's default expression.
    # Returns the raw value string (e.g., "10", "true") or nil if not a simple literal.
    private def extract_param_default_literal(param : CrystalV2::Compiler::Frontend::Parameter) : String?
      return nil unless default_expr_id = param.default_value
      node = @arena[default_expr_id]
      case node
      when CrystalV2::Compiler::Frontend::NumberNode
        String.new(node.value)
      when CrystalV2::Compiler::Frontend::BoolNode
        node.value ? "true" : "false"
      when CrystalV2::Compiler::Frontend::NilNode
        nil # nil defaults are handled differently (union types)
      else
        nil
      end
    end

    # Register a function type and maintain the base name index
    private def register_function_type(full_name : String, return_type : TypeRef)
      # Fix: Don't overwrite a concrete, nilable return type with an unrelated type.
      # This prevents pollution from inline context leaking into Hash/Array method types.
      # The bug: when Unicode.upcase is inlined into Char#upcase(io, options), the Hash#[]?
      # return type gets incorrectly inferred as IO from the outer context's local variable.
      if old_type = @function_types[full_name]?
        old_name = get_type_name_from_ref(old_type)
        new_name = get_type_name_from_ref(return_type)
        # If existing type is a union/nilable (contains "|") and new type is a plain type
        # that doesn't match the container type, keep the existing type.
        if old_name.includes?(" | ") && !new_name.includes?(" | ")
          # Extract owner from full_name (e.g., "Hash(...)" from "Hash(...)#method$args")
          owner = method_owner(strip_type_suffix(full_name))
          # If the new type is unrelated to the owner (e.g., IO for Hash method), skip update
          if !new_name.includes?(strip_generic_args(owner)) &&
             !old_name.includes?(new_name) &&
             new_name != "Void" && new_name != "Nil"
            # Don't overwrite a good nilable type with a suspicious singleton type
            return
          end
        end
      end
      @function_types[full_name] = return_type
      # Extract base name (without $ type suffix) for fast lookups
      base_name = strip_type_suffix(full_name)
      @function_base_names.add(base_name)
      if hash_idx = base_name.rindex('#')
        owner = base_name[0, hash_idx]
        method_name = base_name[(hash_idx + 1)..]
        (@method_bases_by_name[method_name] ||= Set(String).new) << base_name
        (@instance_method_names_by_owner[owner] ||= Set(String).new) << method_name
      end
      # Cache a representative return type for the base name.
      # Prefer a non-VOID return type when available.
      if return_type != TypeRef::VOID
        cached = @function_base_return_types[base_name]?
        if cached.nil? || cached == TypeRef::VOID || (cached == TypeRef::NIL && return_type != TypeRef::NIL)
          @function_base_return_types[base_name] = return_type
        end
      end
      # Debug hook: extract class and method from base_name (Class#method or Class.method)
      parts = parse_method_name_compact(base_name)
      if method_name = parts.method
        debug_hook_method_register(full_name, parts.owner, method_name)
      else
        debug_hook_method_register(full_name, "", base_name)
      end
      if debug_env_filter_match?("DEBUG_METHOD_RETURN", full_name, base_name)
        debug_hook("method.return", "name=#{full_name} type=#{get_type_name_from_ref(return_type)}")
      end
    end

    private def enum_return_name_for(function_name : String) : String?
      if enum_name = @function_enum_return_names[function_name]?
        return enum_name
      end
      base_name = strip_type_suffix(function_name)
      if enum_name = @function_enum_return_names[base_name]?
        return enum_name
      end

      # Fallback: derive enum return name from the def's return type annotation.
      def_node = @function_defs[function_name]? || @function_defs[base_name]?
      return nil unless def_node
      rt = def_node.return_type
      return nil unless rt

      owner = function_context_from_name(base_name)
      old_class = @current_class
      @current_class = owner if owner
      resolved = resolve_type_name_in_context(String.new(rt))
      @current_class = old_class
      if enum_name = resolve_enum_name(resolved)
        @function_enum_return_names[function_name] = enum_name
        @function_enum_return_names[base_name] = enum_name
        return enum_name
      end

      nil
    end

    # Check if a function exists with given base name (fast O(1) lookup)
    private def has_function_base?(base_name : String) : Bool
      @function_base_names.includes?(base_name)
    end

    private def abstract_def?(full_name : String) : Bool
      def_node = @function_defs[full_name]? || begin
        base_name = parse_method_name_compact(full_name).base
        @function_defs[base_name]?
      end
      return false unless def_node
      return true if def_node.is_abstract
      body = def_node.body
      return true if body.nil?
      body.empty?
    end

    private def class_has_subclasses?(class_name : String) : Bool
      @classes_with_subclasses.includes?(class_name)
    end

    private def record_class_parent(child_name : String, parent_name : String?) : Nil
      return unless parent_name
      @classes_with_subclasses.add(parent_name)
      short_name = last_namespace_component(parent_name)
      if short_name != parent_name
        @classes_with_subclasses.add(short_name)
      end
      parent_base = strip_generic_args(parent_name)
      keys = Set(String).new
      keys << parent_name
      keys << parent_base if parent_base != parent_name
      short = last_namespace_component(parent_name)
      keys << short if short != parent_name
      short_base = last_namespace_component(parent_base)
      keys << short_base if short_base != parent_base
      keys.each do |key|
        (@children_by_parent[key] ||= Set(String).new) << child_name
      end

      # If this parent already has recorded virtual targets, lower them for the new child.
      # Use cached ancestor chain to avoid repeated hash lookups.
      ancestor_chain = get_ancestor_chain(parent_name)
      ancestor_chain.each do |ancestor|
        lower_virtual_targets_for_child(child_name, ancestor)
      end
    end

    # Cache of ancestor chains to avoid repeated hash lookups during class registration.
    @ancestor_chain_cache : Hash(String, Array(String))?

    private def get_ancestor_chain(class_name : String) : Array(String)
      @ancestor_chain_cache ||= {} of String => Array(String)
      cache = @ancestor_chain_cache.not_nil!

      if cached = cache[class_name]?
        return cached
      end

      chain = [class_name]
      visited = Set(String).new
      visited.add(class_name)
      current = @class_info[class_name]?.try(&.parent_name)
      while current
        break if visited.includes?(current) # Cycle detection
        if chain.size > 100
          STDERR.puts "[ANCESTOR_CHAIN] chain too long for #{class_name}: #{chain.first(10).join(" -> ")} ... (#{chain.size} entries)"
          break
        end
        chain << current
        visited.add(current)
        current = @class_info[current]?.try(&.parent_name)
      end

      cache[class_name] = chain
      chain
    end

    private def record_virtual_target(
      parent_name : String,
      method_name : String,
      arg_types : Array(TypeRef),
      has_block : Bool,
      has_splat : Bool,
    ) : Nil
      key = "#{parent_name}|#{method_name}|#{arg_types.map(&.id).join(",")}|#{has_block ? 1 : 0}|#{has_splat ? 1 : 0}"
      return if @virtual_targets_recorded.includes?(key)
      @virtual_targets_recorded.add(key)

      entry = VirtualTarget.new(method_name, arg_types.dup, has_block, has_splat)
      (@virtual_targets_by_parent[parent_name] ||= [] of VirtualTarget) << entry
      if env_get("DEBUG_VIRTUAL_TARGETS")
        type_ids = arg_types.map(&.id).join(",")
        STDERR.puts "[VIRTUAL_TARGET] record parent=#{parent_name} method=#{method_name} args=[#{type_ids}] block=#{has_block ? 1 : 0} splat=#{has_splat ? 1 : 0}"
      end

      # If subclasses are already known, lower the recorded target for them immediately.
      if children = @children_by_parent[parent_name]?
        children.each do |child_name|
          lower_virtual_targets_for_child(child_name, parent_name)
        end
      end
    end

    private def lower_virtual_targets_for_child(child_name : String, parent_name : String) : Nil
      targets = @virtual_targets_by_parent[parent_name]?
      return unless targets
      if env_get("DEBUG_VIRTUAL_TARGETS")
        STDERR.puts "[VIRTUAL_TARGET] lower child=#{child_name} parent=#{parent_name} targets=#{targets.size}"
      end

      targets.each do |target|
        base_name = "#{child_name}##{target.method_name}"
        if resolved = lookup_function_def_for_call(base_name, target.arg_types.size, target.has_block, target.arg_types, target.has_splat)
          resolved_name = resolved[0]
          lower_function_if_needed(resolved_name)
          resolved_base = strip_type_suffix(resolved_name)
          lower_function_if_needed(resolved_base) unless resolved_name == resolved_base
        else
          candidate = mangle_function_name(base_name, target.arg_types, target.has_block)
          lower_function_if_needed(candidate)
          lower_function_if_needed(base_name) unless candidate == base_name
        end
      end
    end

    private def class_inherits_from?(child_name : String, parent_name : String) : Bool
      return true if child_name == parent_name
      # Use cached ancestor chain to avoid repeated hash lookups
      chain = get_ancestor_chain(child_name)
      chain.includes?(parent_name)
    end

    private def collect_subclasses(parents : Enumerable(String)) : Array(String)
      results = [] of String
      visited = Set(String).new
      queue = parents.to_a
      queue.each { |parent| visited.add(parent) }
      idx = 0
      while idx < queue.size
        parent = queue[idx]
        idx += 1
        if children = @children_by_parent[parent]?
          children.each do |child|
            next if visited.includes?(child)
            visited.add(child)
            results << child
            queue << child
          end
        end
      end
      results
    end

    # Cached version of collect_subclasses for a single parent.
    # Class hierarchy is fixed after registration, so results are stable.
    private def collect_subclasses_cached(parent : String) : Array(String)
      @subclasses_cache[parent] ||= collect_subclasses([parent])
    end

    # Compute a fast hash of arg types for virtual dispatch dedup keys.
    # Avoids string allocation from arg_types.map(&.id).join(",").
    private def arg_types_hash(arg_types : Array(TypeRef)) : UInt64
      h = 0_u64
      arg_types.each { |t| h = (h &* 31_u64) &+ t.id.to_u64 }
      h
    end

    # Build flags byte for virtual dispatch dedup key.
    private def vdispatch_flags(has_block : Bool, is_union : Bool = false, is_module : Bool = false) : UInt8
      f = 0_u8
      f |= 1_u8 if has_block
      f |= 2_u8 if is_union
      f |= 4_u8 if is_module
      f
    end

    # Get class info by name
    def get_class_info(name : String) : ClassInfo?
      @class_info[name]?
    end

    # Enum info: name -> {member_name -> value}
    @enum_info : Hash(String, Hash(String, Int64))?
    # Enum base types: name -> underlying type
    @enum_base_types : Hash(String, TypeRef)?
    # Map enum value literals to their enum type names (for method resolution).
    @enum_value_types : Hash(ValueId, String)?
    # Map enum ivar/class var names to their enum type names.
    @enum_ivar_types : Hash(String, Hash(String, String))?
    @enum_cvar_types : Hash(String, Hash(String, String))?
    # Track active class-var inference to avoid recursion.
    @class_var_infer_stack : Set(String)

    private def enum_base_type_for_node(node : CrystalV2::Compiler::Frontend::EnumNode) : TypeRef
      if base = node.base_type
        type_ref_for_name(String.new(base))
      else
        TypeRef::INT32
      end
    end

    private def register_enum_base_type(enum_name : String, base_type : TypeRef)
      enum_base_types = @enum_base_types ||= {} of String => TypeRef
      enum_base_types[enum_name] = base_type
    end

    private def enum_base_type(enum_name : String) : TypeRef
      @enum_base_types.try(&.[enum_name]?) || TypeRef::INT32
    end

    private def resolve_enum_name(name : String) : String?
      return nil unless enum_info = @enum_info
      return name if enum_info.has_key?(name)
      short_name = last_namespace_component(name)
      return short_name if short_name != name && enum_info.has_key?(short_name)
      if short_name != name
        matches = enum_info.keys.select { |key| key.ends_with?("::#{short_name}") }
        return matches.first if matches.size == 1
      end
      matches = enum_info.keys.select { |key| key.ends_with?("::#{name}") }
      return matches.first if matches.size == 1
      nil
    end

    # Track a value as an enum type if the type name is a known enum
    # Call this after registering a local/param to associate it with its enum type
    private def track_enum_value(value_id : ValueId, type_name : String)
      return if type_name.empty?

      candidates = [] of String
      if type_name.includes?('|')
        candidates = split_union_type_name(type_name).map(&.strip)
      elsif type_name.ends_with?('?')
        candidates << type_name[0, type_name.size - 1]
      else
        candidates << type_name
      end

      candidates.each do |candidate|
        resolved = resolve_type_name_in_context(candidate)
        resolved = resolve_type_alias_chain(resolved)
        if enum_name = resolve_enum_name(resolved)
          (@enum_value_types ||= {} of ValueId => String)[value_id] = enum_name
          break
        end
      end
    end

    # Register an enum type (pass 1)
    def register_enum(node : CrystalV2::Compiler::Frontend::EnumNode)
      enum_name = String.new(node.name)
      @enum_info ||= {} of String => Hash(String, Int64)
      if @enum_info.not_nil!.has_key?(enum_name)
        unless @enum_base_types.try(&.has_key?(enum_name))
          register_enum_base_type(enum_name, enum_base_type_for_node(node))
        end
        register_enum_methods(node, enum_name)
        # Register Enum as included module so enum instances can dispatch Enum methods
        enum_list = @class_included_modules[enum_name] ||= [] of String
        push_unique_module_name(enum_list, "Enum")
        return
      end

      members = {} of String => Int64
      current_value = 0_i64

      node.members.each do |member|
        member_name = String.new(member.name)
        # If member has explicit value, use it
        if val_id = member.value
          val_node = @arena[val_id]
          if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
            current_value = String.new(val_node.value).to_i64? || current_value
          end
        end
        members[member_name] = current_value
        current_value += 1
      end

      # Extract members from macro conditionals in body (e.g., {% if flag?(:unix) %})
      extract_enum_members_from_body(node, members)

      @enum_info.not_nil![enum_name] = members
      invalidate_type_cache_for_namespace(enum_name)
      register_enum_base_type(enum_name, enum_base_type_for_node(node))
      register_enum_methods(node, enum_name)
      # Register Enum as included module so enum instances can dispatch Enum methods
      enum_list = @class_included_modules[enum_name] ||= [] of String
      push_unique_module_name(enum_list, "Enum")
      attach_enum_instance_methods(enum_name)
    end

    # Register an enum type with explicit name (for nested enums)
    def register_enum_with_name(node : CrystalV2::Compiler::Frontend::EnumNode, full_enum_name : String)
      full_enum_name = resolve_class_name_for_definition(full_enum_name)
      @enum_info ||= {} of String => Hash(String, Int64)
      if @enum_info.not_nil!.has_key?(full_enum_name)
        unless @enum_base_types.try(&.has_key?(full_enum_name))
          register_enum_base_type(full_enum_name, enum_base_type_for_node(node))
        end
        register_enum_methods(node, full_enum_name)
        # Register Enum as included module so enum instances can dispatch Enum methods
        enum_list = @class_included_modules[full_enum_name] ||= [] of String
        push_unique_module_name(enum_list, "Enum")
        return
      end

      members = {} of String => Int64
      current_value = 0_i64

      node.members.each do |member|
        member_name = String.new(member.name)
        # If member has explicit value, use it
        if val_id = member.value
          val_node = @arena[val_id]
          if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
            current_value = String.new(val_node.value).to_i64? || current_value
          end
        end
        members[member_name] = current_value
        current_value += 1
      end

      # Extract members from macro conditionals in body (e.g., {% if flag?(:unix) %})
      extract_enum_members_from_body(node, members)

      @enum_info.not_nil![full_enum_name] = members
      invalidate_type_cache_for_namespace(full_enum_name)
      base_type = enum_base_type_for_node(node)
      register_enum_base_type(full_enum_name, base_type)
      debug_hook_enum_register(full_enum_name, @module.get_type_descriptor(base_type).try(&.name) || "?")
      register_enum_methods(node, full_enum_name)
      # Register Enum as included module so enum instances can dispatch Enum methods
      enum_list = @class_included_modules[full_enum_name] ||= [] of String
      push_unique_module_name(enum_list, "Enum")
      attach_enum_instance_methods(full_enum_name)
    end

    # Lazy-discover an enum definition from sibling Crystal stdlib files.
    # When a type like Crystal::NumberKind is referenced but its enum members
    # aren't registered (because the defining file wasn't in the require chain),
    # search sibling .cr files for the enum definition, parse it, and register it.
    @lazy_enum_searched = Set(String).new

    private def lazy_discover_enum_from_source(qualified_name : String) : Bool
      return false if @enum_info.try(&.has_key?(qualified_name))
      return false if @lazy_enum_searched.includes?(qualified_name)
      @lazy_enum_searched << qualified_name

      # Extract bare enum name (last component after ::)
      bare_name = qualified_name.includes?("::") ? qualified_name.split("::").last : qualified_name
      # Extract module prefix for matching (e.g., "Crystal" from "Crystal::NumberKind")
      module_prefix = qualified_name.includes?("::") ? qualified_name.rpartition("::")[0] : ""

      # Search directories of already-loaded files for sibling .cr files
      searched_dirs = Set(String).new
      @paths_by_arena.each_value do |path|
        dir = File.dirname(path)
        next if searched_dirs.includes?(dir)
        searched_dirs << dir

        Dir.glob(File.join(dir, "*.cr")).each do |cr_file|
          # Skip already-loaded files
          next if @paths_by_arena.values.includes?(cr_file)

          # Quick check: does the file likely contain the enum?
          begin
            source = File.read(cr_file)
          rescue
            next
          end
          next unless source.includes?("enum #{bare_name}")

          # Parse the file
          begin
            lexer = CrystalV2::Compiler::Frontend::Lexer.new(source)
            parser = CrystalV2::Compiler::Frontend::Parser.new(lexer)
            program = parser.parse_program
          rescue
            next
          end

          # Walk AST to find and register the enum
          if find_and_register_enum_from_ast(program.arena, program.roots, qualified_name, bare_name, module_prefix)
            return true
          end
        end
      end

      false
    end

    # Walk a parsed AST to find a specific enum and register it.
    private def find_and_register_enum_from_ast(
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      roots : Array(CrystalV2::Compiler::Frontend::ExprId),
      qualified_name : String,
      bare_name : String,
      module_prefix : String,
    ) : Bool
      roots.each do |root_id|
        node = arena[root_id]
        case node
        when CrystalV2::Compiler::Frontend::ModuleNode
          mod_name = String.new(node.name)
          if body = node.body
            # Check if this module matches the prefix
            if module_prefix == mod_name || module_prefix.starts_with?("#{mod_name}::")
              remaining_prefix = module_prefix == mod_name ? "" : module_prefix[(mod_name.size + 2)..]
              body.each do |child_id|
                child = arena[child_id]
                case child
                when CrystalV2::Compiler::Frontend::EnumNode
                  enum_name = String.new(child.name)
                  if enum_name == bare_name
                    full_name = mod_name.empty? ? enum_name : "#{mod_name}::#{enum_name}"
                    saved_arena = @arena
                    @arena = arena
                    register_enum_with_name(child, full_name)
                    @arena = saved_arena
                    return true if @enum_info.try(&.has_key?(qualified_name))
                  end
                when CrystalV2::Compiler::Frontend::ModuleNode
                  if find_and_register_enum_from_ast(arena, [child_id], qualified_name, bare_name, remaining_prefix)
                    return true
                  end
                when CrystalV2::Compiler::Frontend::ClassNode
                  if find_and_register_enum_from_ast(arena, [child_id], qualified_name, bare_name, remaining_prefix)
                    return true
                  end
                end
              end
            end
          end
        when CrystalV2::Compiler::Frontend::ClassNode
          cls_name = String.new(node.name)
          if body = node.body
            if module_prefix == cls_name || module_prefix.starts_with?("#{cls_name}::")
              remaining_prefix = module_prefix == cls_name ? "" : module_prefix[(cls_name.size + 2)..]
              body.each do |child_id|
                child = arena[child_id]
                if child.is_a?(CrystalV2::Compiler::Frontend::EnumNode)
                  enum_name = String.new(child.name)
                  if enum_name == bare_name
                    full_name = "#{cls_name}::#{enum_name}"
                    saved_arena = @arena
                    @arena = arena
                    register_enum_with_name(child, full_name)
                    @arena = saved_arena
                    return true if @enum_info.try(&.has_key?(qualified_name))
                  end
                end
              end
            end
          end
        when CrystalV2::Compiler::Frontend::EnumNode
          # Top-level enum (no module wrapper)
          enum_name = String.new(node.name)
          if enum_name == bare_name && module_prefix.empty?
            saved_arena = @arena
            @arena = arena
            register_enum_with_name(node, qualified_name)
            @arena = saved_arena
            return true if @enum_info.try(&.has_key?(qualified_name))
          end
        end
      end
      false
    end

    def register_constant(node : CrystalV2::Compiler::Frontend::ConstantNode, owner_name : String? = nil)
      const_name = String.new(node.name)
      record_constant_definition(owner_name, const_name, node.value, @arena)
    end

    def register_constant_value(
      name : String,
      value_id : ExprId,
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      owner_name : String? = nil,
    )
      record_constant_definition(owner_name, name, value_id, arena)
    end

    # Register a macro definition (pass 1)
    def register_macro(node : CrystalV2::Compiler::Frontend::MacroDefNode, scope_name : String? = nil)
      macro_name = String.new(node.name)
      key = scope_name ? "#{scope_name}::#{macro_name}" : macro_name
      @macro_defs[key] = {node, @arena}
      @macro_params[key] = extract_macro_params(node)
    end

    private def lookup_macro_entry(method_name : String, scope_name : String? = nil)
      if scope = scope_name
        scoped = "#{scope}::#{method_name}"
        if env_get("DEBUG_RECORD_LOOKUP") && method_name == "record"
          STDERR.puts "[DEBUG_RECORD_LOOKUP] scope=#{scope} scoped=#{scoped} has_scoped=#{@macro_defs.has_key?(scoped)} has_global=#{@macro_defs.has_key?(method_name)}"
        end
        if entry = @macro_defs[scoped]?
          return {entry, scoped}
        end
      end
      if entry = @macro_defs[method_name]?
        if env_get("DEBUG_RECORD_LOOKUP") && method_name == "record"
          STDERR.puts "[DEBUG_RECORD_LOOKUP] scope=(none) has_global=true"
        end
        return {entry, method_name}
      end
      if env_get("DEBUG_RECORD_LOOKUP") && method_name == "record"
        STDERR.puts "[DEBUG_RECORD_LOOKUP] scope=#{scope_name || "(none)"} has_global=false"
      end
      nil
    end

    private def lookup_macro_entry_with_inheritance(method_name : String, scope_name : String)
      if entry = lookup_macro_entry(method_name, scope_name)
        return entry
      end

      visited = Set(String).new
      current = scope_name
      while current && !visited.includes?(current)
        visited << current
        if modules = @class_included_modules[current]?
          modules.each do |mod_name|
            if entry = lookup_macro_entry(method_name, mod_name)
              return entry
            end
          end
        end

        parent = @class_info[current]?.try(&.parent_name) || @module.class_parents[current]?
        break unless parent

        if entry = lookup_macro_entry(method_name, parent)
          return entry
        end
        current = parent
      end

      nil
    end

    private def macro_def_maybe_defines_type?(
      macro_def : CrystalV2::Compiler::Frontend::MacroDefNode,
      macro_arena : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : Bool
      old_arena = @arena
      @arena = macro_arena
      begin
        return macro_expr_maybe_defines_type?(macro_def.body)
      ensure
        @arena = old_arena
      end
      false
    end

    private def macro_text_defines_type?(text : String) : Bool
      text.includes?("class") || text.includes?("struct") ||
        text.includes?("module") || text.includes?("enum") ||
        text.includes?("def")
    end

    private def macro_expr_maybe_defines_type?(expr_id : ExprId) : Bool
      return false if expr_id.invalid?
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        if raw_text = macro_literal_raw_text(node)
          return macro_text_defines_type?(raw_text)
        end
      when CrystalV2::Compiler::Frontend::MacroIfNode
        return true if macro_expr_maybe_defines_type?(node.then_body)
        if else_body = node.else_body
          return true if macro_expr_maybe_defines_type?(else_body)
        end
      when CrystalV2::Compiler::Frontend::MacroForNode
        return true if macro_expr_maybe_defines_type?(node.body)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        return true if macro_expr_maybe_defines_type?(node.expression)
      end
      false
    end

    private def register_nested_types_from_macro_expansion(class_name : String, expr_id : ExprId)
      return if expr_id.invalid?
      member = unwrap_visibility_member(@arena[expr_id])
      if env_get("DEBUG_MACRO_TYPE_REG")
        STDERR.puts "[DEBUG_MACRO_TYPE_REG] expanded root=#{member.class}"
      end
      case member
      when CrystalV2::Compiler::Frontend::BlockNode
        member.body.each do |child_id|
          register_nested_types_from_macro_expansion(class_name, child_id)
        end
      when CrystalV2::Compiler::Frontend::ClassNode
        nested_name = String.new(member.name)
        full_name = "#{class_name}::#{nested_name}"
        if env_get("DEBUG_MACRO_TYPE_REG")
          STDERR.puts "[DEBUG_MACRO_TYPE_REG] register class #{full_name}"
        end
        register_class_with_name(member, full_name)
      when CrystalV2::Compiler::Frontend::ModuleNode
        nested_name = String.new(member.name)
        full_name = "#{class_name}::#{nested_name}"
        if env_get("DEBUG_MACRO_TYPE_REG")
          STDERR.puts "[DEBUG_MACRO_TYPE_REG] register module #{full_name}"
        end
        register_module_with_name(member, full_name)
      when CrystalV2::Compiler::Frontend::EnumNode
        nested_name = String.new(member.name)
        full_name = "#{class_name}::#{nested_name}"
        if env_get("DEBUG_MACRO_TYPE_REG")
          STDERR.puts "[DEBUG_MACRO_TYPE_REG] register enum #{full_name}"
        end
        register_enum_with_name(member, full_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        result = try_evaluate_macro_condition(member.condition)
        if result == true
          register_nested_types_from_macro_expansion(class_name, member.then_body)
        elsif result == false
          if else_body = member.else_body
            register_nested_types_from_macro_expansion(class_name, else_body)
          end
        else
          register_nested_types_from_macro_expansion(class_name, member.then_body)
          if else_body = member.else_body
            register_nested_types_from_macro_expansion(class_name, else_body)
          end
        end
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_class(member, class_name)
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_class(member, class_name)
      end
    end

    private def register_class_members_from_expansion(
      class_name : String,
      expr_id : ExprId,
      defined_class_method_full_names : Set(String),
      visited_extends : Set(String),
      ivars : Array(IVarInfo)? = nil,
      offset_ref : Pointer(Int32)? = nil,
    ) : Nil
      return if expr_id.invalid?
      member = unwrap_visibility_member(@arena[expr_id])
      if !member.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode) &&
         !member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
        clear_pending_effect_annotations
      end
      case member
      when CrystalV2::Compiler::Frontend::BlockNode
        member.body.each do |child_id|
          register_class_members_from_expansion(
            class_name,
            child_id,
            defined_class_method_full_names,
            visited_extends,
            ivars,
            offset_ref
          )
        end
      when CrystalV2::Compiler::Frontend::ExtendNode
        register_module_class_methods_for(class_name, member.target, defined_class_method_full_names, visited_extends)
      when CrystalV2::Compiler::Frontend::DefNode
        register_type_method_from_def(member, class_name)
      when CrystalV2::Compiler::Frontend::GetterNode
        register_accessors_in_class(member, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::SetterNode
        register_accessors_in_class(member, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::PropertyNode
        register_accessors_in_class(member, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::ClassNode
        nested_name = String.new(member.name)
        register_class_with_name(member, "#{class_name}::#{nested_name}")
      when CrystalV2::Compiler::Frontend::EnumNode
        nested_name = String.new(member.name)
        register_enum_with_name(member, "#{class_name}::#{nested_name}")
      when CrystalV2::Compiler::Frontend::ModuleNode
        nested_name = String.new(member.name)
        register_nested_module(member, "#{class_name}::#{nested_name}")
      when CrystalV2::Compiler::Frontend::MacroDefNode
        register_macro(member, class_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        result = try_evaluate_macro_condition(member.condition)
        if result == true
          register_class_members_from_expansion(
            class_name,
            member.then_body,
            defined_class_method_full_names,
            visited_extends,
            ivars,
            offset_ref
          )
        elsif result == false
          if else_body = member.else_body
            else_node = @arena[else_body]
            if else_node.is_a?(CrystalV2::Compiler::Frontend::MacroIfNode)
              register_class_members_from_expansion(
                class_name,
                else_body,
                defined_class_method_full_names,
                visited_extends,
                ivars,
                offset_ref
              )
            else
              register_class_members_from_expansion(
                class_name,
                else_body,
                defined_class_method_full_names,
                visited_extends,
                ivars,
                offset_ref
              )
            end
          end
        else
          register_class_members_from_expansion(
            class_name,
            member.then_body,
            defined_class_method_full_names,
            visited_extends,
            ivars,
            offset_ref
          )
          if else_body = member.else_body
            register_class_members_from_expansion(
              class_name,
              else_body,
              defined_class_method_full_names,
              visited_extends,
              ivars,
              offset_ref
            )
          end
        end
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_class(member, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        if raw_text = macro_literal_raw_text(member)
          expanded = expand_flag_macro_text(raw_text) || raw_text
          if parsed = parse_macro_literal_class_body(expanded)
            program, body_ids = parsed
            with_arena(program.arena) do
              body_ids.each do |child_id|
                register_class_members_from_expansion(
                  class_name,
                  child_id,
                  defined_class_method_full_names,
                  visited_extends,
                  ivars,
                  offset_ref
                )
              end
            end
            return
          end
          if program = parse_macro_literal_program(expanded)
            with_arena(program.arena) do
              program.roots.each do |child_id|
                register_class_members_from_expansion(
                  class_name,
                  child_id,
                  defined_class_method_full_names,
                  visited_extends,
                  ivars,
                  offset_ref
                )
              end
            end
          end
        end
      when CrystalV2::Compiler::Frontend::CallNode
        callee = @arena[member.callee]
        if callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          method_name = String.new(callee.name)
          macro_lookup = lookup_macro_entry_with_inheritance(method_name, class_name)
          if macro_lookup.nil? && class_name != "Object"
            macro_lookup = lookup_macro_entry(method_name, "Object")
          end
          if macro_lookup
            macro_entry, macro_key = macro_lookup
            macro_def, macro_arena = macro_entry
            macro_args, macro_block = extract_macro_block_from_args(member.args, member.block)
            expanded_id = expand_macro_expr(macro_def, macro_arena, macro_args, member.named_args, macro_block, macro_key)
            unless expanded_id.invalid?
              old_arena = @arena
              @arena = macro_arena
              begin
                register_class_members_from_expansion(
                  class_name,
                  expanded_id,
                  defined_class_method_full_names,
                  visited_extends,
                  ivars,
                  offset_ref
                )
              ensure
                @arena = old_arena
              end
            end
          end
        end
      end
    end

    private def record_nested_type_names(class_name : String, body : Array(ExprId)?) : Nil
      return unless body
      set = @nested_type_names[class_name]? || Set(String).new
      body.each do |expr_id|
        collect_nested_type_names(expr_id, set)
      end
      if debug_env_filter_match?("DEBUG_NESTED_TYPES", class_name)
        STDERR.puts "[NESTED_TYPES] class=#{class_name} names=#{set.to_a.sort.join(",")}"
      end
      @nested_type_names[class_name] = set unless set.empty?
    end

    private def collect_nested_type_names(expr_id : ExprId, set : Set(String)) : Nil
      return if expr_id.invalid?
      node = unwrap_visibility_member(@arena[expr_id])
      case node
      when CrystalV2::Compiler::Frontend::BlockNode
        node.body.each { |child_id| collect_nested_type_names(child_id, set) }
      when CrystalV2::Compiler::Frontend::MacroIfNode
        collect_nested_type_names(node.then_body, set)
        if else_body = node.else_body
          collect_nested_type_names(else_body, set)
        end
      when CrystalV2::Compiler::Frontend::MacroForNode
        collect_nested_type_names(node.body, set)
      when CrystalV2::Compiler::Frontend::CallNode
        callee_name = resolve_path_like_name(node.callee)
        if callee_name == "record"
          if first_arg = node.args.first?
            if nested_name = resolve_path_like_name(first_arg)
              short = last_namespace_component(nested_name)
              set << short unless short.empty?
            end
          end
        end
      when CrystalV2::Compiler::Frontend::ClassNode,
           CrystalV2::Compiler::Frontend::ModuleNode,
           CrystalV2::Compiler::Frontend::EnumNode,
           CrystalV2::Compiler::Frontend::AliasNode
        set << String.new(node.name)
      end
    end

    private def extract_macro_params(node : CrystalV2::Compiler::Frontend::MacroDefNode) : Array(MacroParamInfo)
      source = @sources_by_arena[@arena]?
      return [] of MacroParamInfo unless source

      span = node.span
      start = span.start_offset
      length = span.end_offset - span.start_offset
      return [] of MacroParamInfo if length <= 0
      return [] of MacroParamInfo if start < 0 || start >= source.bytesize
      if start + length > source.bytesize
        length = source.bytesize - start
      end

      snippet = source.byte_slice(start, length)
      lexer = CrystalV2::Compiler::Frontend::Lexer.new(snippet)

      params = [] of MacroParamInfo
      seen_macro = false
      seen_name = false
      depth = 0
      current_tokens = [] of CrystalV2::Compiler::Frontend::Token

      loop do
        token = lexer.next_token
        break if token.kind == CrystalV2::Compiler::Frontend::Token::Kind::EOF
        next if token.kind == CrystalV2::Compiler::Frontend::Token::Kind::Whitespace ||
                token.kind == CrystalV2::Compiler::Frontend::Token::Kind::Comment

        case token.kind
        when CrystalV2::Compiler::Frontend::Token::Kind::Macro
          seen_macro = true
        when CrystalV2::Compiler::Frontend::Token::Kind::Identifier
          name = String.new(token.slice)
          if seen_macro && !seen_name
            seen_name = true
          elsif depth == 1
            current_tokens << token
          end
        when CrystalV2::Compiler::Frontend::Token::Kind::LParen
          if seen_name && depth == 0
            depth = 1
          elsif depth > 0
            depth += 1
          end
        when CrystalV2::Compiler::Frontend::Token::Kind::RParen
          if depth == 1
            if info = parse_macro_param_tokens(current_tokens)
              params << info
            end
            current_tokens.clear
            depth = 0
            break
          elsif depth > 1
            depth -= 1
          end
        when CrystalV2::Compiler::Frontend::Token::Kind::Comma
          if depth == 1
            if info = parse_macro_param_tokens(current_tokens)
              params << info
            end
            current_tokens.clear
          end
        when CrystalV2::Compiler::Frontend::Token::Kind::StarStar
          current_tokens << token if depth == 1
        when CrystalV2::Compiler::Frontend::Token::Kind::Star
          current_tokens << token if depth == 1
        else
          current_tokens << token if depth == 1
        end
      end

      params
    end

    private def parse_macro_param_tokens(tokens : Array(CrystalV2::Compiler::Frontend::Token)) : MacroParamInfo?
      return nil if tokens.empty?

      prefix = ""
      names = [] of String

      tokens.each do |token|
        case token.kind
        when CrystalV2::Compiler::Frontend::Token::Kind::StarStar
          prefix = "**"
        when CrystalV2::Compiler::Frontend::Token::Kind::Star
          prefix = "*"
        when CrystalV2::Compiler::Frontend::Token::Kind::Identifier
          names << String.new(token.slice)
        end
      end

      return nil if names.empty?
      if names.first? == "__name"
        names.shift
      end
      return nil if names.empty?

      internal = names.last
      external = names.size > 1 ? names.first : nil
      MacroParamInfo.new(internal, external, prefix)
    end

    # Register a type alias (pass 1)
    # e.g., alias HIR = Crystal::HIR
    def register_alias(node : CrystalV2::Compiler::Frontend::AliasNode)
      alias_name = String.new(node.name)
      full_alias_name = alias_full_name_from_span(node) || alias_name
      if !full_alias_name.includes?("::")
        if current = @current_class
          full_alias_name = "#{current}::#{full_alias_name}"
        end
      end
      context = if full_alias_name.includes?("::")
                  parts = full_alias_name.split("::")
                  parts.size > 1 ? parts[0...-1].join("::") : nil
                else
                  nil
                end
      old_class = @current_class
      @current_class = context if context
      target_name = resolve_alias_target(String.new(node.value), context)
      @current_class = old_class if context
      previous = @type_aliases[full_alias_name]?
      register_type_alias(full_alias_name, target_name)
      if env_has?("DEBUG_ALIAS") && @type_aliases[full_alias_name]? == target_name && previous != target_name
        STDERR.puts "[ALIAS] Registered (top): #{full_alias_name} => #{target_name}"
      end
    end

    private def alias_full_name_from_span(node : CrystalV2::Compiler::Frontend::AliasNode) : String?
      source = @sources_by_arena[@arena]?
      return nil unless source

      span = node.span
      start = span.start_offset
      finish = span.end_offset
      return nil if start < 0 || finish <= start || finish > source.bytesize

      snippet = source.byte_slice(start, finish - start)
      if match = snippet.match(/alias\s+([A-Za-z0-9_:]+)\s*=/)
        return match[1]
      end

      nil
    end

    private def register_type_alias(alias_name : String, target_name : String)
      if existing = @type_aliases[alias_name]?
        if existing != target_name
          if env_has?("DEBUG_ALIAS")
            STDERR.puts "[ALIAS] Skipping redefinition: #{alias_name} already #{existing}, new #{target_name}"
          end
          return
        end
      end
      @type_aliases[alias_name] = target_name
      @type_cache.delete(alias_name)
      invalidate_type_cache_for_namespace(alias_name)
    end

    # Register a C library binding (pass 1)
    # e.g., lib LibC ... end
    def register_lib(
      node : CrystalV2::Compiler::Frontend::LibNode,
      annotations : Array(Tuple(CrystalV2::Compiler::Frontend::AnnotationNode, CrystalV2::Compiler::Frontend::ArenaLike))? = nil,
    )
      if annotations
        old_arena = @arena
        annotations.each do |annotation_node, annotation_arena|
          @arena = annotation_arena
          register_link_libraries_from_annotation(annotation_node)
        end
        @arena = old_arena
      end

      lib_name = String.new(node.name)
      @module.register_lib_name(lib_name)

      if body = node.body
        # First pass: register lib-local types so extern param/return types resolve correctly.
        body.each do |expr_id|
          body_node = @arena[expr_id]
          register_lib_member(body_node, lib_name, :types)
        end

        # Second pass: register extern functions after types are available.
        body.each do |expr_id|
          body_node = @arena[expr_id]
          register_lib_member(body_node, lib_name, :externs)
        end
      end
    end

    private def register_lib_member(node : AstNode, lib_name : String, pass : Symbol)
      case node
      when CrystalV2::Compiler::Frontend::AliasNode
        return unless pass == :types
        alias_name = String.new(node.name)
        old_class = @current_class
        @current_class = lib_name
        target_name = resolve_alias_target(String.new(node.value), lib_name)
        @current_class = old_class
        full_alias_name = "#{lib_name}::#{alias_name}"
        register_type_alias(full_alias_name, target_name)
      when CrystalV2::Compiler::Frontend::ConstantNode
        return unless pass == :types
        record_constant_definition(lib_name, String.new(node.name), node.value, @arena)
      when CrystalV2::Compiler::Frontend::EnumNode
        return unless pass == :types
        enum_name = String.new(node.name)
        full_enum_name = "#{lib_name}::#{enum_name}"
        register_enum_with_name(node, full_enum_name)
      when CrystalV2::Compiler::Frontend::ClassNode
        return unless pass == :types
        struct_name = String.new(node.name)
        full_struct_name = "#{lib_name}::#{struct_name}"
        @lib_structs.add(full_struct_name)
        register_class_with_name(node, full_struct_name)
      when CrystalV2::Compiler::Frontend::FunNode
        return unless pass == :externs
        register_extern_fun(lib_name, node)
      when CrystalV2::Compiler::Frontend::GlobalVarDeclNode
        return unless pass == :externs
        raw_name = String.new(node.name)
        var_name = raw_name.lstrip('$')
        type_name = String.new(node.type)
        register_extern_global(lib_name, var_name, type_name)
      when CrystalV2::Compiler::Frontend::AssignNode
        target_node = @arena[node.target]
        value_node = @arena[node.value]
        if target_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
          return unless pass == :types
          record_constant_definition(lib_name, String.new(target_node.name), node.value, @arena)
        else
          return unless pass == :externs
          if target_node.is_a?(CrystalV2::Compiler::Frontend::GlobalNode) &&
             value_node.is_a?(CrystalV2::Compiler::Frontend::TypeDeclarationNode)
            raw_name = String.new(target_node.name)
            var_name = raw_name.lstrip('$')
            real_name = String.new(value_node.name)
            type_name = String.new(value_node.declared_type)
            register_extern_global(lib_name, var_name, type_name, real_name)
          end
        end
      when CrystalV2::Compiler::Frontend::MacroIfNode
        process_macro_if_in_lib(node, lib_name, pass)
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_lib(node, lib_name, pass)
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_lib(node, lib_name, pass)
      end
    end

    private def process_macro_if_in_lib(node : CrystalV2::Compiler::Frontend::MacroIfNode, lib_name : String, pass : Symbol)
      if raw_text = macro_if_raw_text(node)
        nested_macro_end = raw_text.scan(/\{%\s*end\s*%\}/).size > 1
        unless nested_macro_end
          if expanded = expand_flag_macro_text(raw_text)
            if parsed = parse_macro_literal_lib_body(expanded)
              program, body = parsed
              with_arena(program.arena) do
                body.each do |expr_id|
                  register_lib_member(@arena[expr_id], lib_name, pass)
                end
              end
              return
            end
          end
        end
      end

      result = try_evaluate_macro_condition(node.condition)
      if result == true
        process_macro_body_in_lib(node.then_body, lib_name, pass)
      elsif result == false
        if else_node = node.else_body
          else_ast = @arena[else_node]
          case else_ast
          when CrystalV2::Compiler::Frontend::MacroIfNode
            process_macro_if_in_lib(else_ast, lib_name, pass)
          else
            process_macro_body_in_lib(else_node, lib_name, pass)
          end
        end
      else
        process_macro_body_in_lib(node.then_body, lib_name, pass)
        if else_node = node.else_body
          process_macro_body_in_lib(else_node, lib_name, pass)
        end
      end
    end

    private def process_macro_body_in_lib(body_id : ExprId, lib_name : String, pass : Symbol)
      body_node = @arena[body_id]
      case body_node
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_lib(body_node, lib_name, pass)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        process_macro_if_in_lib(body_node, lib_name, pass)
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_lib(body_node, lib_name, pass)
      else
        register_lib_member(body_node, lib_name, pass)
      end
    end

    private def process_macro_for_in_lib(node : CrystalV2::Compiler::Frontend::MacroForNode, lib_name : String, pass : Symbol)
      iter_vars = node.iter_vars.map { |name| String.new(name) }
      return if iter_vars.empty?

      values = macro_for_iterable_values(node.iterable)
      return unless values

      source = @sources_by_arena[@arena]?
      program = CrystalV2::Compiler::Frontend::Program.new(@arena, [] of ExprId)
      expander = CrystalV2::Compiler::Semantic::MacroExpander.new(
        program,
        @arena,
        CrystalV2::Runtime.target_flags,
        recovery_mode: true,
        macro_source: source
      )
      owner_type = macro_owner_type_for(lib_name)

      expanded = String.build do |io|
        values.each_with_index do |value, idx|
          vars = {} of String => CrystalV2::Compiler::Semantic::MacroValue
          assign_macro_iter_vars(vars, iter_vars, value, idx)
          if body_output = expander.expand_literal(node.body, variables: vars, owner_type: owner_type)
            io << body_output
            io << "\n"
          end
        end
      end

      sanitized = strip_macro_lines(expanded)
      if parsed = parse_macro_literal_lib_body(sanitized)
        program, body = parsed
        with_arena(program.arena) do
          body.each do |expr_id|
            register_lib_member(@arena[expr_id], lib_name, pass)
          end
        end
      end
    end

    private def process_macro_literal_in_lib(node : CrystalV2::Compiler::Frontend::MacroLiteralNode, lib_name : String, pass : Symbol)
      if raw_text = macro_literal_raw_text(node)
        expanded = expand_flag_macro_text(raw_text) || raw_text
        sanitized = strip_macro_lines(expanded)
        parsed = parse_macro_literal_lib_body(expanded)
        if parsed.nil? && sanitized != expanded
          parsed = parse_macro_literal_lib_body(sanitized)
        end
        if parsed
          program, body = parsed
          with_arena(program.arena) do
            body.each do |expr_id|
              register_lib_member(@arena[expr_id], lib_name, pass)
            end
          end
          return
        end
      end

      texts = macro_literal_active_texts(node)
      combined = texts.join("\n")
      sanitized = strip_macro_lines(combined)
      parsed = parse_macro_literal_lib_body(combined)
      if parsed.nil? && sanitized != combined
        parsed = parse_macro_literal_lib_body(sanitized)
      end
      if parsed
        program, body = parsed
        with_arena(program.arena) do
          body.each do |expr_id|
            register_lib_member(@arena[expr_id], lib_name, pass)
          end
        end
        return
      end

      texts.each do |text|
        next if text.strip.empty?
        sanitized = strip_macro_lines(text)
        parsed = parse_macro_literal_lib_body(text)
        if parsed.nil? && sanitized != text
          parsed = parse_macro_literal_lib_body(sanitized)
        end
        if parsed
          program, body = parsed
          with_arena(program.arena) do
            body.each do |expr_id|
              register_lib_member(@arena[expr_id], lib_name, pass)
            end
          end
        end
      end
    end

    private def expand_macro_expr(
      macro_def : CrystalV2::Compiler::Frontend::MacroDefNode,
      macro_arena : CrystalV2::Compiler::Frontend::ArenaLike,
      args : Array(ExprId),
      named_args : Array(CrystalV2::Compiler::Frontend::NamedArgument)?,
      block_id : ExprId?,
      macro_key : String,
    ) : ExprId
      macro_name = String.new(macro_def.name)
      params = @macro_params[macro_key]? || @macro_params[macro_name]? || [] of MacroParamInfo
      if env_get("DEBUG_MACRO_EXPAND")
        STDERR.puts "[MACRO_EXPAND] name=#{macro_name} key=#{macro_key} args=#{args.size} named=#{named_args.try(&.size) || 0}"
      end
      if env_get("DEBUG_MACRO_PIECES") && macro_name == "record"
        body_node = macro_arena[macro_def.body]
        if body_node.is_a?(CrystalV2::Compiler::Frontend::MacroLiteralNode)
          body_node.pieces.each_with_index do |piece, idx|
            next unless piece.kind.text?
            next unless text = piece.text
            if text.includes?("struct")
              STDERR.puts "[MACRO_PIECES] idx=#{idx} text=#{text.inspect}"
            end
          end
          body_node.pieces.each_with_index do |piece, idx|
            next unless piece.kind.expression?
            expr_id = piece.expr
            expr_class = expr_id ? macro_arena[expr_id].class : Nil
            detail = nil
            if expr_id
              expr_node = macro_arena[expr_id]
              if expr_node.is_a?(CrystalV2::Compiler::Frontend::MacroExpressionNode)
                inner = macro_arena[expr_node.expression]
                detail = "inner=#{inner.class}"
                if literal = CrystalV2::Compiler::Frontend.node_literal_string(inner)
                  detail += " literal=#{literal.inspect}"
                end
                if inner.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                  obj = macro_arena[inner.object]
                  detail += " member=#{String.new(inner.member)} obj=#{obj.class}"
                  if obj_lit = CrystalV2::Compiler::Frontend.node_literal_string(obj)
                    detail += " obj_lit=#{obj_lit.inspect}"
                  end
                elsif inner.is_a?(CrystalV2::Compiler::Frontend::CallNode)
                  callee = macro_arena[inner.callee]
                  detail += " callee=#{callee.class}"
                  if callee_lit = CrystalV2::Compiler::Frontend.node_literal_string(callee)
                    detail += " callee_lit=#{callee_lit.inspect}"
                  end
                end
              end
            end
            STDERR.puts "[MACRO_PIECES] expr idx=#{idx} trim_left=#{piece.trim_left} trim_right=#{piece.trim_right} class=#{expr_class} #{detail}".rstrip
          end
          body_node.pieces.each_with_index do |piece, idx|
            next unless piece.kind.control_start?
            next unless keyword = piece.control_keyword
            expr_id = piece.expr
            expr_class = expr_id ? macro_arena[expr_id].class : Nil
            STDERR.puts "[MACRO_PIECES] control idx=#{idx} keyword=#{keyword} expr=#{expr_class}"
          end
        end
      end
      if env_get("DEBUG_MACRO_ARGS") && macro_name == "record"
        param_desc = params.map { |param| "#{param.prefix}#{param.name}" }
        STDERR.puts "[MACRO_ARGS] params=#{param_desc.join(",")}"
      end
      if env_get("DEBUG_MACRO_BLOCK") && macro_name == "record"
        if block_id
          arena = arena_for_expr?(block_id) || @arena
          node = (block_id.index >= 0 && block_id.index < arena.size) ? arena[block_id] : nil
          STDERR.puts "[MACRO_BLOCK] record block_id=#{block_id.index} node=#{node ? node.class.name : "nil"} arena=#{arena.class.name}"
        else
          STDERR.puts "[MACRO_BLOCK] record block_id=nil"
        end
      end

      normalized_args, normalized_named = normalize_macro_call_args(params, args, named_args)
      if macro_arena != @arena
        if env_get("DEBUG_MACRO_ARGS") && macro_name == "record"
          if source = @sources_by_arena[@arena]?
            args.each_with_index do |expr_id, idx|
              snippet = slice_source_for_expr_in_arena(expr_id, @arena, source)
              STDERR.puts "[MACRO_ARGS] raw#{idx}=#{snippet.inspect}"
            end
          end
        end
        normalized_args = normalized_args.map do |expr_id|
          reparse_expr_for_macro(expr_id, @arena, macro_arena)
        end
        normalized_named = normalized_named.try do |list|
          list.map { |named_arg| reparse_named_arg_for_macro(named_arg, @arena, macro_arena) }
        end
      end
      return ExprId.new(-1) if normalized_args.any?(&.invalid?) || normalized_named.try(&.any? { |arg| arg.value.invalid? })
      if env_get("DEBUG_MACRO_ARGS") && macro_name == "record"
        normalized_args.each_with_index do |expr_id, idx|
          node = macro_arena[expr_id]
          STDERR.puts "[MACRO_ARGS] #{macro_name} arg#{idx}=#{node.class}"
        end
      end

      macro_params = params.map { |param| "#{param.prefix}#{param.name}" }
      macro_symbol = CrystalV2::Compiler::Semantic::MacroSymbol.new(
        macro_name,
        macro_def.body,
        macro_def.body,
        macro_params
      )

      program = CrystalV2::Compiler::Frontend::Program.new(macro_arena, [] of ExprId)
      expander = CrystalV2::Compiler::Semantic::MacroExpander.new(
        program,
        macro_arena,
        CrystalV2::Runtime.target_flags,
        recovery_mode: true,
        source_provider: ->(expr_id : ExprId) : String? { macro_block_body_text(expr_id) },
        macro_source: @sources_by_arena[macro_arena]?,
        source_sink: ->(code : String) { store_extra_source(macro_arena, code) }
      )

      owner_type = @current_class ? macro_owner_type_for(@current_class.not_nil!) : nil
      expanded_id = expander.expand(
        macro_symbol,
        normalized_args,
        owner_type,
        named_args: normalized_named,
        block_id: block_id
      )
      if output = expander.last_output
        invalidate_type_cache_for_macro_output(output)
      end
      if env_get("DEBUG_MACRO_OUTPUT") && macro_name == "record"
        if output = expander.last_output
          snippet = output.size > 400 ? "#{output[0, 400]}..." : output
          STDERR.puts "[MACRO_OUTPUT] name=#{macro_name} len=#{output.bytesize} snippet=#{snippet.inspect}"
        end
      end
      expanded_id
    end

    private def extract_macro_block_from_args(
      args : Array(ExprId),
      block_id : ExprId?,
    ) : Tuple(Array(ExprId), ExprId?)
      return {args, block_id} unless block_id.nil?
      return {args, nil} if args.empty?

      last_id = args.last
      last_node = @arena[last_id]
      case last_node
      when CrystalV2::Compiler::Frontend::BlockNode
        return {args[0...-1], last_id}
      when CrystalV2::Compiler::Frontend::UnaryNode
        if String.new(last_node.operator) == "&"
          operand = last_node.operand
          operand_node = @arena[operand]
          if operand_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
            return {args[0...-1], operand}
          end
        end
      end

      {args, nil}
    end

    # Expand a macro call inline using the full macro expander.
    private def expand_macro(
      ctx : LoweringContext,
      macro_def : CrystalV2::Compiler::Frontend::MacroDefNode,
      macro_arena : CrystalV2::Compiler::Frontend::ArenaLike,
      args : Array(ExprId),
      named_args : Array(CrystalV2::Compiler::Frontend::NamedArgument)?,
      block_id : ExprId?,
      macro_key : String,
    ) : ValueId
      expanded_id = expand_macro_expr(macro_def, macro_arena, args, named_args, block_id, macro_key)
      if expanded_id.invalid?
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      old_arena = @arena
      @arena = macro_arena
      begin
        last_id = lower_expanded_macro_expr(ctx, expanded_id)
        last_id || begin
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(nil_lit)
          nil_lit.id
        end
      ensure
        @arena = old_arena
      end
    end

    private def normalize_macro_call_args(
      params : Array(MacroParamInfo),
      args : Array(ExprId),
      named_args : Array(CrystalV2::Compiler::Frontend::NamedArgument)?,
    ) : {Array(ExprId), Array(CrystalV2::Compiler::Frontend::NamedArgument)?}
      external_to_internal = {} of String => String
      params.each do |param|
        if ext = param.external_name
          external_to_internal[ext] = param.name
        end
      end

      normalized_named = [] of CrystalV2::Compiler::Frontend::NamedArgument
      named_args.try do |list|
        list.each do |named_arg|
          external = String.new(named_arg.name)
          internal = external_to_internal[external]? || external
          normalized_named << CrystalV2::Compiler::Frontend::NamedArgument.new(
            internal.to_slice,
            named_arg.value,
            named_arg.name_span,
            named_arg.value_span
          )
        end
      end

      {args, normalized_named.empty? ? nil : normalized_named}
    end

    private def reparse_expr_for_macro(
      expr_id : ExprId,
      source_arena : CrystalV2::Compiler::Frontend::ArenaLike,
      target_arena : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : ExprId
      return expr_id if source_arena == target_arena
      source = @sources_by_arena[source_arena]?
      return ExprId.new(-1) unless source

      text = slice_source_for_expr_in_arena(expr_id, source_arena, source)
      return ExprId.new(-1) unless text
      store_extra_source(target_arena, text)

      lexer = CrystalV2::Compiler::Frontend::Lexer.new(text)
      parser = CrystalV2::Compiler::Frontend::Parser.new(lexer, target_arena, recovery_mode: true)
      program = parser.parse_program
      root = program.roots.first?
      if root
        node = target_arena[root]
        return root unless node.is_a?(CrystalV2::Compiler::Frontend::NilNode)
      end

      # Fallback for typed macro args using keyword identifiers (e.g., `when : Int64` in `record`).
      # Reparse through a wrapper call to reuse the typed macro arg parsing path.
      if text.includes?(':')
        wrapper = "record __macro_tmp__, #{text}"
        store_extra_source(target_arena, wrapper)
        wrapper_lexer = CrystalV2::Compiler::Frontend::Lexer.new(wrapper)
        wrapper_parser = CrystalV2::Compiler::Frontend::Parser.new(wrapper_lexer, target_arena, recovery_mode: true)
        wrapper_program = wrapper_parser.parse_program
        if call_root = wrapper_program.roots.first?
          call_node = target_arena[call_root]
          if call_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
            if arg = call_node.args[1]?
              return arg
            elsif arg0 = call_node.args.first?
              return arg0
            end
          end
        end
      end

      ExprId.new(-1)
    end

    private def reparse_named_arg_for_macro(
      named_arg : CrystalV2::Compiler::Frontend::NamedArgument,
      source_arena : CrystalV2::Compiler::Frontend::ArenaLike,
      target_arena : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : CrystalV2::Compiler::Frontend::NamedArgument
      value_id = reparse_expr_for_macro(named_arg.value, source_arena, target_arena)
      CrystalV2::Compiler::Frontend::NamedArgument.new(
        named_arg.name,
        value_id,
        named_arg.name_span,
        named_arg.value_span
      )
    end

    private def macro_block_body_text(block_id : ExprId) : String
      return "" if block_id.invalid?
      arena = nil
      if block_id.index >= 0
        if block_id.index < @arena.size
          node = @arena[block_id]
          arena = @arena if node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
        end
        if arena.nil? && (inline = @inline_arenas)
          inline.each do |candidate|
            next unless block_id.index < candidate.size
            node = candidate[block_id]
            if node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              arena = candidate
              break
            end
          end
        end
        if arena.nil? && @sources_by_arena && !@sources_by_arena.empty?
          best = nil
          best_size = Int32::MAX
          @sources_by_arena.each_key do |candidate|
            next unless block_id.index < candidate.size
            node = candidate[block_id]
            next unless node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
            size = candidate.size
            if size < best_size
              best = candidate
              best_size = size
            end
          end
          arena = best if best
        end
      end
      return "" unless arena
      block_node = arena[block_id]
      return "" unless block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
      return "" if block_node.body.empty?

      source = @sources_by_arena[arena]?
      if source.nil? || source.empty?
        source = arena.extra_sources.last?
      end
      return "" unless source

      texts = [] of String
      block_node.body.each do |expr_id|
        snippet = slice_source_for_expr_in_arena(expr_id, arena, source)
        texts << snippet if snippet
      end
      output = texts.join("\n")
      if env_get("DEBUG_MACRO_BLOCK_TEXT")
        snippet = output.lines.first?.to_s.strip
        STDERR.puts "[MACRO_BLOCK_TEXT] block_id=#{block_id.index} len=#{output.bytesize} snippet=#{snippet.inspect}"
      end
      output
    end

    private def slice_source_for_expr_in_arena(
      expr_id : ExprId,
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      source : String,
    ) : String?
      return nil if expr_id.invalid?
      return nil if expr_id.index < 0 || expr_id.index >= arena.size
      node = arena[expr_id]

      span = node.span
      start = span.start_offset
      length = span.end_offset - span.start_offset
      return nil if length <= 0
      return nil if start < 0 || start >= source.bytesize
      if start + length > source.bytesize
        length = source.bytesize - start
      end
      source.byte_slice(start, length)
    end

    private def macro_owner_type_for(class_name : String) : CrystalV2::Compiler::Semantic::ClassSymbol?
      info = @class_info[class_name]?
      return nil unless info

      scope = CrystalV2::Compiler::Semantic::SymbolTable.new
      class_scope = CrystalV2::Compiler::Semantic::SymbolTable.new

      symbol = CrystalV2::Compiler::Semantic::ClassSymbol.new(
        class_name,
        ExprId.new(-1),
        scope: scope,
        class_scope: class_scope,
        superclass_name: info.parent_name,
        type_parameters: nil,
        is_struct: info.is_struct,
        is_abstract: false
      )

      info.ivars.each do |ivar|
        type_name = type_name_for_macro(ivar.type)
        ivar_name = ivar.name
        ivar_name = ivar_name[1..-1] if ivar_name.starts_with?('@')
        symbol.add_instance_var(ivar_name, type_name, nil, false)
      end

      instance_method_names_for_class(class_name).each do |method_name|
        method_scope = CrystalV2::Compiler::Semantic::SymbolTable.new(scope)
        method_symbol = CrystalV2::Compiler::Semantic::MethodSymbol.new(
          method_name,
          ExprId.new(-1),
          scope: method_scope
        )
        scope.redefine(method_name, method_symbol)
      end

      symbol
    end

    private def instance_method_names_for_class(class_name : String) : Array(String)
      ensure_instance_method_names_cache
      if cached = @instance_method_names_cache[class_name]?
        return cached
      end
      names = @instance_method_names_by_owner[class_name]?
      result = names ? names.to_a : [] of String
      @instance_method_names_cache[class_name] = result
      result
    end

    private def type_name_for_macro(type_ref : TypeRef) : String?
      if name = concrete_type_name_for(type_ref)
        return name
      end
      if desc = @module.get_type_descriptor(type_ref)
        return desc.name
      end
      nil
    end

    private def lower_expanded_macro_expr(ctx : LoweringContext, expr_id : ExprId) : ValueId
      if expr_id.invalid?
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::ClassNode
        name = String.new(node.name)
        full_name = resolve_class_name_for_definition(name)
        register_class_with_name(node, full_name)
        lower_class_with_name(node, full_name)
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::ModuleNode
        name = String.new(node.name)
        full_name = resolve_class_name_for_definition(name)
        register_module_with_name(node, full_name)
        lower_module_with_name(node, full_name)
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::EnumNode
        name = String.new(node.name)
        full_name = resolve_class_name_for_definition(name)
        register_enum_with_name(node, full_name)
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::BlockNode
        last_id : ValueId? = nil
        node.body.each do |child_id|
          last_id = lower_expanded_macro_expr(ctx, child_id)
        end
        last_id || begin
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(nil_lit)
          nil_lit.id
        end
      else
        lower_expr(ctx, expr_id)
      end
    end

    private def resolve_path_like_name(expr_id : ExprId) : String?
      return nil if expr_id.invalid?

      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        String.new(node.name)
      when CrystalV2::Compiler::Frontend::ConstantNode
        String.new(node.name)
      when CrystalV2::Compiler::Frontend::PathNode
        left = node.left
        left_name = left ? resolve_path_like_name(left.not_nil!) : nil
        right_name = resolve_path_like_name(node.right)
        return nil unless right_name
        left_name ? "#{left_name}::#{right_name}" : right_name
      when CrystalV2::Compiler::Frontend::GenericNode
        resolve_path_like_name(node.base_type)
      else
        nil
      end
    end

    private def stringify_type_expr(expr_id : ExprId) : String?
      return nil if expr_id.invalid?

      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::TypeofNode
        inner = node.args.first?
        inner ? resolve_typeof_expr(inner) : "Pointer(Void)"
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(node.name)
        if name == "self" || name == "Self"
          if self_name = @current_class || @current_namespace_override
            return self_name
          end
        end
        if local_name = @current_typeof_local_names.try(&.[name]?)
          return local_name unless local_name.empty?
        elsif local_ref = @current_typeof_locals.try(&.[name]?)
          local_type_name = get_type_name_from_ref(local_ref)
          return local_type_name unless local_type_name.empty? || local_type_name == "Void" || local_type_name == "Unknown"
        end
        @type_param_map[name]? || name
      when CrystalV2::Compiler::Frontend::ConstantNode
        name = String.new(node.name)
        if name == "self" || name == "Self"
          if self_name = @current_class || @current_namespace_override
            return self_name
          end
        end
        if local_name = @current_typeof_local_names.try(&.[name]?)
          return local_name unless local_name.empty?
        elsif local_ref = @current_typeof_locals.try(&.[name]?)
          local_type_name = get_type_name_from_ref(local_ref)
          return local_type_name unless local_type_name.empty? || local_type_name == "Void" || local_type_name == "Unknown"
        end
        @type_param_map[name]? || name
      when CrystalV2::Compiler::Frontend::NumberNode
        String.new(node.value)
      when CrystalV2::Compiler::Frontend::PathNode
        raw_path = collect_path_string(node)
        # Substitute type params in path prefix (e.g., D::CACHE -> ImplInfo_Float32::CACHE)
        substituted = substitute_type_params_in_type_name(raw_path)
        return substituted if substituted.starts_with?("::")
        resolve_path_string_in_context(substituted)
      when CrystalV2::Compiler::Frontend::CallNode
        base = resolve_path_like_name(node.callee) || stringify_type_expr(node.callee)
        return nil unless base
        # typeof(expr) parsed as CallNode — resolve the inner expression type
        if base == "typeof"
          if first_arg = node.args.first?
            inner_node = @arena[first_arg]
            resolved = resolve_typeof_expr(first_arg)
            return normalize_typeof_type_name(resolved)
          end
          return "Pointer(Void)"
        end
        args = [] of String
        node.args.each do |arg|
          if str = stringify_type_expr(arg)
            args << str
          end
        end
        "#{base}(#{args.join(", ")})"
      when CrystalV2::Compiler::Frontend::GenericNode
        base = stringify_type_expr(node.base_type)
        return nil unless base
        args = [] of String
        node.type_args.each do |arg|
          if str = stringify_type_expr(arg)
            args << str
          end
        end
        if base == "Union" && args.size == 1
          return args.first
        end
        "#{base}(#{args.join(", ")})"
      when CrystalV2::Compiler::Frontend::SplatNode
        stringify_type_expr(node.expr)
      when CrystalV2::Compiler::Frontend::TupleLiteralNode
        args = [] of String
        node.elements.each do |elem|
          args << (stringify_type_expr(elem) || "Unknown")
        end
        "Tuple(#{args.join(", ")})"
      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        entries = node.entries.map do |entry|
          key = String.new(entry.key)
          value = stringify_type_expr(entry.value) || "Unknown"
          "#{key}: #{value}"
        end
        "NamedTuple(#{entries.join(", ")})"
      when CrystalV2::Compiler::Frontend::IndexNode
        base = stringify_type_expr(node.object)
        return nil unless base
        if node.indexes.size == 1
          idx_node = @arena[node.indexes.first]
          if idx_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
            idx_str = String.new(idx_node.value)
            return "StaticArray(#{base}, #{idx_str})"
          elsif idx_str = stringify_type_expr(node.indexes.first)
            return "StaticArray(#{base}, #{idx_str})"
          end
        end
        nil
      when CrystalV2::Compiler::Frontend::UnaryNode
        base = stringify_type_expr(node.operand)
        return nil unless base
        op = String.new(node.operator)
        case op
        when "?"
          "#{base}?"
        when "*", "**"
          "#{base}#{op}"
        else
          nil
        end
      when CrystalV2::Compiler::Frontend::BinaryNode
        op = String.new(node.operator)
        return nil unless op == "|"
        left = stringify_type_expr(node.left)
        right = stringify_type_expr(node.right)
        return nil unless left && right
        "#{left} | #{right}"
      when CrystalV2::Compiler::Frontend::SelfNode
        # For extend SomeModule(self), return the current class/module name
        @current_class || @current_namespace_override
      else
        nil
      end
    end

    private def type_like_expr_id?(expr_id : ExprId) : Bool
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(node.name)
        return true if name[0]?.try(&.uppercase?) || @type_param_map.has_key?(name)
        false
      when CrystalV2::Compiler::Frontend::ConstantNode,
           CrystalV2::Compiler::Frontend::PathNode,
           CrystalV2::Compiler::Frontend::GenericNode,
           CrystalV2::Compiler::Frontend::TypeofNode,
           CrystalV2::Compiler::Frontend::NumberNode,
           CrystalV2::Compiler::Frontend::SelfNode
        true
      when CrystalV2::Compiler::Frontend::IndexNode
        return false unless type_like_expr_id?(node.object)
        node.indexes.all? { |idx| type_like_expr_id?(idx) }
      when CrystalV2::Compiler::Frontend::CallNode
        type_like_call_expr?(node)
      else
        false
      end
    end

    private def type_like_call_expr?(node : CrystalV2::Compiler::Frontend::CallNode) : Bool
      base = resolve_path_like_name(node.callee) || stringify_type_expr(node.callee)
      return false unless base
      base = resolve_type_alias_chain(base)
      return false unless base[0]?.try(&.uppercase?) || base.includes?("::") || base == "typeof"
      # typeof's arguments are expressions, not types — always type-like
      return true if base == "typeof"
      node.args.all? { |arg_id| type_like_expr_id?(arg_id) }
    end

    private def normalize_typeof_type_name(type_name : String) : String
      return "Pointer(Void)" if type_name.empty? || type_name == "Void" || type_name == "Unknown" || type_name.includes?('|')
      type_name
    end

    private def resolve_typeof_expr(expr_id : ExprId) : String
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(node.name)
        # Parser stores typeof(...) as identifier name in generic type args
        if name.starts_with?("typeof(") && name.ends_with?(')')
          inner_expr = name[7..-2] # Extract content between typeof( and )
          resolve_typeof_string_expr(inner_expr)
        else
          resolve_typeof_inner(name)
        end
      when CrystalV2::Compiler::Frontend::InstanceVarNode
        resolve_typeof_inner(String.new(node.name))
      when CrystalV2::Compiler::Frontend::ClassVarNode
        resolve_typeof_inner(String.new(node.name))
      when CrystalV2::Compiler::Frontend::SelfNode
        resolve_typeof_inner("self")
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # Handle expressions like str.to_unsafe.value
        resolve_typeof_member_chain(node)
      when CrystalV2::Compiler::Frontend::CallNode
        # Handle expressions like str.to_unsafe()
        resolve_typeof_call_chain(node)
      when CrystalV2::Compiler::Frontend::YieldNode
        # typeof(yield expr) — determine the block return type.
        # Delegate to infer_type_from_expr which already tracks inline
        # block return types via @inline_yield_block_return_stack.
        if inferred = infer_type_from_expr(expr_id, @current_class)
          type_name = get_type_name_from_ref(inferred)
          unless type_name.empty? || type_name == "Void" || type_name == "Unknown"
            return normalize_typeof_type_name(type_name)
          end
        end
        # Fallback: use __block_return__ from pending type param map
        # (set when the caller provides a block with known return type)
        if br = @type_param_map["__block_return__"]?
          return normalize_typeof_type_name(br) unless br.empty? || br == "Void" || br == "Unknown"
        end
        "Pointer(Void)"
      else
        "Pointer(Void)"
      end
    end

    # Resolve typeof from a string expression like "str.to_unsafe.value"
    # This handles the case where parser stores typeof(...) as an identifier name
    private def resolve_typeof_string_expr(expr : String) : String
      expr = expr.strip
      if resolved = resolve_element_type_expression(expr)
        return normalize_typeof_type_name(resolved)
      end

      # Split on dots to get the call chain
      # Handle patterns like: str.to_unsafe.value, str.to_slice, @buffer.to_unsafe
      parts = split_method_chain(expr)
      return resolve_typeof_inner(expr) if parts.size <= 1

      # Start with the base variable's type
      base = parts[0].strip
      current_type = resolve_typeof_inner(base)
      return "Pointer(Void)" if current_type == "Pointer(Void)"

      # Walk through each method call
      parts[1..].each do |method_part|
        method_name = method_part.gsub(/\(\)$/, "").strip # Remove trailing ()

        case method_name
        when "to_unsafe"
          if current_type == "String"
            current_type = "Pointer(UInt8)"
          elsif current_type.starts_with?("Array(") && current_type.ends_with?(')')
            inner = current_type[6..-2]
            current_type = "Pointer(#{inner})"
          elsif current_type.starts_with?("Slice(") && current_type.ends_with?(')')
            inner = current_type[6..-2]
            current_type = "Pointer(#{inner})"
          elsif current_type.starts_with?("Pointer(")
            # Already a pointer, to_unsafe is identity
          else
            # Default to Pointer(current_type)
            current_type = "Pointer(#{current_type})"
          end
        when "to_slice"
          if current_type == "String"
            current_type = "Slice(UInt8)"
          elsif current_type.starts_with?("Array(") && current_type.ends_with?(')')
            inner = current_type[6..-2]
            current_type = "Slice(#{inner})"
          end
        when "value"
          # Dereference pointer: Pointer(T).value -> T
          if current_type.starts_with?("Pointer(") && current_type.ends_with?(')')
            current_type = current_type[8..-2]
          end
        when "size", "bytesize"
          current_type = "Int32"
        else
          # Try to look up return type
          method_full_name = "#{current_type}##{method_name}"
          if ret_type = @function_types[method_full_name]?
            current_type = get_type_name_from_ref(ret_type)
          else
            return "Pointer(Void)" # Unknown method
          end
        end
      end

      current_type
    end

    # Split a method chain string, handling nested parentheses
    private def split_method_chain(expr : String) : Array(String)
      parts = [] of String
      current = String::Builder.new
      depth = 0

      expr.each_char do |c|
        case c
        when '(', '[', '{'
          depth += 1
          current << c
        when ')', ']', '}'
          depth -= 1
          current << c
        when '.'
          if depth == 0
            parts << current.to_s
            current = String::Builder.new
          else
            current << c
          end
        else
          current << c
        end
      end

      parts << current.to_s unless current.empty?
      parts
    end

    # Resolve typeof for member access chains like str.to_unsafe.value
    private def resolve_typeof_member_chain(node : CrystalV2::Compiler::Frontend::MemberAccessNode) : String
      member_name = String.new(node.member)

      # Special case: x.to_unsafe.value pattern - common for getting element type
      # This handles typeof(str.to_unsafe.value) where str is String
      if member_name == "value"
        obj = @arena[node.object]
        if obj.is_a?(CrystalV2::Compiler::Frontend::CallNode)
          callee = @arena[obj.callee]
          if callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
            call_method = String.new(callee.member)
            if call_method == "to_unsafe"
              # x.to_unsafe.value - infer x's element type
              base_obj = @arena[callee.object]
              # Check if base is String parameter (common pattern)
              if base_obj.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
                # For String.to_unsafe.value, returns UInt8
                # This is a conservative assumption but handles the common case
                return "UInt8"
              end
            end
          end
        end
      end

      # Get the base type
      base_type = resolve_typeof_expr(node.object)
      return "Pointer(Void)" if base_type == "Pointer(Void)"

      # Handle common patterns
      case member_name
      when "value"
        # Pointer(T).value returns T
        if base_type.starts_with?("Pointer(") && base_type.ends_with?(')')
          inner = base_type[8..-2] # Extract T from Pointer(T)
          return inner
        end
        # For other types, return element type if available
        if element_type = extract_element_type(base_type)
          return element_type
        end
      end

      # Try to look up the return type of the method
      method_full_name = "#{base_type}##{member_name}"
      if ret_type = @function_types[method_full_name]?
        return get_type_name_from_ref(ret_type)
      end

      # Try to look up struct/class field type (for typeof(struct_var.field))
      if info = @class_info[base_type]?
        if field = info.ivars.find { |iv| iv.name == "@#{member_name}" || iv.name == member_name }
          return get_type_name_from_ref(field.type)
        end
      end

      "Pointer(Void)"
    end

    # Resolve typeof for call chains like str.to_unsafe()
    private def resolve_typeof_call_chain(node : CrystalV2::Compiler::Frontend::CallNode) : String
      callee = @arena[node.callee]
      case callee
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        method_name = String.new(callee.member)
        if method_name == "element_type"
          if arg_id = node.args.first?
            arg_node = @arena[arg_id]
            chained = false
            if arg_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
              inner_callee = @arena[arg_node.callee]
              chained = inner_callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
                        String.new(inner_callee.member) == "element_type"
            end
            inner_type = resolve_typeof_expr(arg_id)
            if inner_type == "Pointer(Void)" && arg_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
              if type_name = lookup_typeof_local_name(String.new(arg_node.name))
                inner_type = type_name
              elsif locals = @current_typeof_locals
                if ref = locals[String.new(arg_node.name)]?
                  inner_type = get_type_name_from_ref(ref)
                end
              end
            end
            element_type = element_type_for_type_name(inner_type)
            return inner_type if element_type.nil? && chained
            return element_type if element_type
          end
        end

        base_type = resolve_typeof_expr(callee.object)
        return "Pointer(Void)" if base_type == "Pointer(Void)"

        # Handle common stdlib methods
        case method_name
        when "to_unsafe"
          # String.to_unsafe returns Pointer(UInt8)
          if base_type == "String"
            return "Pointer(UInt8)"
          end
          # Array(T).to_unsafe returns Pointer(T)
          if base_type.starts_with?("Array(") && base_type.ends_with?(')')
            inner = base_type[6..-2]
            return "Pointer(#{inner})"
          end
          # Slice(T).to_unsafe returns Pointer(T)
          if base_type.starts_with?("Slice(") && base_type.ends_with?(')')
            inner = base_type[6..-2]
            return "Pointer(#{inner})"
          end
        when "to_slice"
          # String.to_slice returns Slice(UInt8)
          if base_type == "String"
            return "Slice(UInt8)"
          end
        end

        # Try to look up the return type of the method
        method_full_name = "#{base_type}##{method_name}"
        if ret_type = @function_types[method_full_name]?
          return get_type_name_from_ref(ret_type)
        end
      when CrystalV2::Compiler::Frontend::IdentifierNode
        # Simple identifier call like some_func()
        method_name = String.new(callee.name)
        # Look up return type
        if ret_type = @function_types[method_name]?
          return get_type_name_from_ref(ret_type)
        end
      end

      "Pointer(Void)"
    end

    # Extract element type from container types
    private def extract_element_type(type_name : String) : String?
      if type_name.starts_with?("Array(") && type_name.ends_with?(')')
        return type_name[6..-2]
      elsif type_name.starts_with?("Slice(") && type_name.ends_with?(')')
        return type_name[6..-2]
      elsif type_name.starts_with?("Pointer(") && type_name.ends_with?(')')
        return type_name[8..-2]
      elsif type_name.starts_with?("StaticArray(") && type_name.ends_with?(')')
        # StaticArray(T, N) - extract T
        inner = type_name[12..-2]
        if comma_idx = inner.index(',')
          return inner[0, comma_idx].strip
        end
      end
      nil
    end

    private def resolve_typeof_inner(expr : String) : String
      expr = expr.strip
      if expr == "self"
        return normalize_typeof_type_name(@current_class || "Pointer(Void)")
      end

      if locals = @current_typeof_locals
        if type_ref = locals[expr]?
          resolved = get_type_name_from_ref(type_ref)
          return normalize_typeof_type_name(resolved) unless resolved == "Void"
        end
      end
      if type_name = lookup_typeof_local_name(expr)
        return normalize_typeof_type_name(type_name)
      end

      if class_name = @current_class
        if info = @class_info[class_name]?
          if expr.starts_with?("@@")
            cvar_name = expr.lstrip('@')
            if cvar = info.class_vars.find { |cv| cv.name == cvar_name }
              return normalize_typeof_type_name(get_type_name_from_ref(cvar.type))
            end
          elsif expr.starts_with?('@')
            if ivar = info.ivars.find { |iv| iv.name == expr }
              return normalize_typeof_type_name(get_type_name_from_ref(ivar.type))
            end
          end
        end
      end

      drop_nil = false
      if expr.ends_with?(".not_nil!")
        drop_nil = true
        expr = expr[0, expr.size - 9].strip
      end

      index_suffix = nil
      if expr.ends_with?(']')
        if match = expr.match(/^(.*)\[(\d+)\]\s*$/)
          expr = match[1].strip
          index_suffix = match[2].to_i
        end
      end

      if resolved = resolve_element_type_expression(expr)
        resolved = apply_index_to_type_name(resolved, index_suffix) if index_suffix
        resolved = drop_nil_from_union(resolved) if drop_nil
        return normalize_typeof_type_name(resolved)
      end

      # Allow simple constant/path typeof usage in type contexts (no local scope needed).
      if expr.includes?("::") || (expr.size > 0 && expr[0].uppercase?)
        resolved = resolve_type_alias_chain(expr)
        if !resolved.includes?("::")
          resolved = resolve_class_name_in_context(resolved)
        end
        if @class_info.has_key?(resolved) || @module_defs.has_key?(resolved)
          return normalize_typeof_type_name(resolved)
        end
      end

      "Pointer(Void)"
    end

    ELEMENT_TYPE_PREFIXES = ["Enumerable.element_type", "::Enumerable.element_type", "Indexable.element_type",
                             "::Indexable.element_type", "Iterator.element_type", "::Iterator.element_type",
                             "Iterable.element_type", "::Iterable.element_type"] of String

    private def resolve_element_type_expression(expr : String) : String?
      prefix = ELEMENT_TYPE_PREFIXES.find { |p| expr.starts_with?(p) }
      return nil unless prefix

      rest = expr[prefix.size, expr.size - prefix.size].strip
      arg_str = if rest.starts_with?('(')
                  extract_balanced_paren_content(rest)
                else
                  rest
                end
      return nil if arg_str.nil? || arg_str.empty?

      arg_expr = arg_str.not_nil!.strip
      chained = ELEMENT_TYPE_PREFIXES.any? { |p| arg_expr.starts_with?(p) }
      inner_type = resolve_typeof_inner(arg_expr)
      if !chained && inner_type == "Pointer(Void)" && arg_expr.size > 0 && arg_expr[0].uppercase?
        inner_type = arg_expr
      end

      element_type = element_type_for_type_name(inner_type)
      return inner_type if element_type.nil? && chained
      element_type
    end

    private def extract_balanced_paren_content(expr : String) : String?
      return nil unless expr.starts_with?('(')
      depth = 0
      i = 0
      while i < expr.bytesize
        ch = expr.byte_at(i).unsafe_chr
        case ch
        when '('
          depth += 1
        when ')'
          depth -= 1
          if depth == 0
            return expr[1, i - 1].strip
          end
        end
        i += 1
      end
      nil
    end

    # Return type for stdlib numeric conversion methods
    # These are defined in Crystal's primitive types with well-known signatures:
    #   def to_u8! : UInt8  (etc.)
    # This enables type inference without requiring full method body lowering.
    private def conversion_method_return_type(method_name : String) : TypeRef?
      case method_name
      when "to_u8", "to_u8!", "to_u8?"       then TypeRef::UINT8
      when "to_i8", "to_i8!", "to_i8?"       then TypeRef::INT8
      when "to_u16", "to_u16!", "to_u16?"    then TypeRef::UINT16
      when "to_i16", "to_i16!", "to_i16?"    then TypeRef::INT16
      when "to_u32", "to_u32!", "to_u32?"    then TypeRef::UINT32
      when "to_i32", "to_i32!", "to_i32?"    then TypeRef::INT32
      when "to_u64", "to_u64!", "to_u64?"    then TypeRef::UINT64
      when "to_i64", "to_i64!", "to_i64?"    then TypeRef::INT64
      when "to_u128", "to_u128!", "to_u128?" then type_ref_for_name("UInt128")
      when "to_i128", "to_i128!", "to_i128?" then type_ref_for_name("Int128")
      when "to_u", "to_u!"                   then TypeRef::UINT64 # alias for to_u64
      when "to_i", "to_i!"                   then TypeRef::INT32  # alias for to_i32
      when "to_f32", "to_f32!", "to_f32?"    then TypeRef::FLOAT32
      when "to_f64", "to_f64!", "to_f64?"    then TypeRef::FLOAT64
      when "to_f", "to_f!"                   then TypeRef::FLOAT64          # alias for to_f64
      when "ord"                             then TypeRef::INT32            # Char#ord
      when "chr"                             then type_ref_for_name("Char") # Int#chr
      when "unsafe_chr"                      then type_ref_for_name("Char")
      else                                        nil
      end
    end

    private def element_type_for_type_name(type_name : String) : String?
      name = type_name.strip
      if name.includes?('|')
        variants = split_union_type_name(name).map(&.strip)
        return nil unless variants.size > 1
        element_variants = variants.compact_map { |v| element_type_for_type_name(v) }
        uniq = element_variants.uniq
        return uniq.join(" | ") unless uniq.empty?
      end

      if name.ends_with?('?')
        base = name[0, name.size - 1]
        return element_type_for_type_name(base)
      end

      paren = name.index('(')
      if paren && name.ends_with?(')')
        base = name[0, paren]
        params_str = name[paren + 1, name.size - paren - 2]
        args = split_generic_type_args(params_str)
        case base
        when "Array", "StaticArray", "Slice", "Deque", "Set", "Indexable", "Enumerable", "Iterator", "Iterable", "Range", "Pointer"
          return args.first?
        when "Tuple"
          return args.join(" | ") unless args.empty?
        when "Hash"
          return "Tuple(#{args[0]}, #{args[1]})" if args.size >= 2
        end
      end

      return "Char" if name == "String"

      nil
    end

    private def hash_value_type_for_type_name(type_name : String) : String?
      name = type_name.strip
      return nil unless name.starts_with?("Hash(") && name.ends_with?(')')
      paren = name.index('(')
      return nil unless paren
      params_str = name[paren + 1, name.size - paren - 2]
      args = split_generic_type_args(params_str)
      return nil unless args.size >= 2
      args[1]
    end

    private def array_element_type_for_value(
      ctx : LoweringContext,
      array_id : ValueId,
      default_type : TypeRef,
    ) : TypeRef
      element_type = ctx.type_of(array_id)
      if type_desc = @module.get_type_descriptor(element_type)
        if elem_name = element_type_for_type_name(type_desc.name)
          return type_ref_for_name(elem_name)
        end
      end
      return default_type if element_type == TypeRef::VOID
      element_type
    end

    private def apply_index_to_type_name(type_name : String, index : Int32?) : String
      return type_name unless index
      name = type_name.strip
      if name.includes?('|')
        variants = split_union_type_name(name).map(&.strip)
        return type_name unless variants.size > 1
        indexed = variants.compact_map { |v| apply_index_to_type_name(v, index) }
        uniq = indexed.uniq
        return uniq.join(" | ") unless uniq.empty?
      end

      if name.starts_with?("Tuple(") && name.ends_with?(')')
        params_str = name[6, name.size - 7]
        args = split_generic_type_args(params_str)
        return args[index]? || type_name
      end

      if name.starts_with?("Array(") && name.ends_with?(')')
        params_str = name[6, name.size - 7]
        args = split_generic_type_args(params_str)
        return args.first? || type_name
      end

      type_name
    end

    private def drop_nil_from_union(type_name : String) : String
      return type_name unless type_name.includes?('|')
      parts = split_union_type_name(type_name).map(&.strip)
      return type_name if parts.size <= 1
      filtered = parts.reject { |p| p == "Nil" }
      return "Nil" if filtered.empty?
      filtered.uniq.join(" | ")
    end

    private def resolve_typeof_in_type_string(type_name : String) : String
      return type_name unless type_name.includes?("typeof(")

      output = String.build do |io|
        i = 0
        while i < type_name.bytesize
          if i + 7 <= type_name.bytesize && type_name.byte_slice(i, 7) == "typeof("
            start = i + 7
            depth = 1
            j = start
            while j < type_name.bytesize && depth > 0
              ch = type_name[j]
              if ch == '('
                depth += 1
              elsif ch == ')'
                depth -= 1
              end
              j += 1
            end
            if depth != 0
              io << type_name[i]
              i += 1
              next
            end
            inner = type_name.byte_slice(start, j - start - 1)
            io << resolve_typeof_string_expr(inner)
            i = j
          else
            io << type_name[i]
            i += 1
          end
        end
      end

      output
    end

    private def resolve_alias_target(target_name : String, context : String? = nil) : String
      raw = target_name
      # IMPORTANT: When `context` is provided we intentionally avoid pre/post qualification here.
      # `normalize_declared_type_name(..., context)` already resolves names under `@current_class=context`
      # (including `typeof(self)`), and qualifying first can mis-classify `typeof(...)` as a generic
      # type and produce invalid names like `Box::typeof(Box::self)`.
      resolved = normalize_declared_type_name(raw, context)
      return target_name if resolved.includes?("Pointer(Void)") || resolved.includes?("Unknown")

      if !context || context.empty?
        # If the alias target is an unqualified constant and nothing is registered yet,
        # keep it relative to the current namespace so later lookup resolves correctly.
        if current = @current_class
          if resolved.matches?(/\A[A-Za-z_][A-Za-z0-9_]*\z/) && !type_name_exists?(resolved) && !builtin_alias_target?(resolved)
            return "#{current}::#{resolved}"
          end
        end
      elsif !resolved.includes?("::")
        # When context is provided but normalize_declared_type_name returned a bare name,
        # try qualifying under the context namespace (e.g., PCRE2 → Regex::PCRE2).
        qualified = "#{context}::#{resolved}"
        if type_name_exists?(qualified) || @module_defs.has_key?(qualified)
          resolved = qualified
        end
      end

      resolved
    end

    private def qualify_alias_target_in_context(target_name : String, context : String) : String
      return target_name if context.empty?
      name = target_name.strip
      return name if name.empty?
      return name if name.starts_with?("::")
      return name if value_literal_name?(name)
      if name.includes?('|')
        parts = split_union_type_name(name)
        if parts.size > 1
          return parts.map { |part| qualify_alias_target_in_context(part.strip, context) }.join(" | ")
        end
      end
      if info = split_generic_base_and_args(name)
        base = info[:base]
        resolved_base = if BUILTIN_GENERIC_BASES.includes?(base)
                          base
                        else
                          qualify_alias_target_in_context(base, context)
                        end
        resolved_args = split_generic_type_args(info[:args]).map do |arg|
          qualify_alias_target_in_context(arg.strip, context)
        end.join(", ")
        return "#{resolved_base}(#{resolved_args})"
      end
      return name if name.includes?("::")
      return name if builtin_alias_target?(name) || LIBC_TYPE_ALIASES.has_key?(name) || BUILTIN_TYPE_NAMES.includes?(name)
      return name if type_param_like?(name) && short_type_param_name?(name) && !@type_param_map.has_key?(name)
      "#{context}::#{name}"
    end

    private def normalize_declared_type_name(type_name : String, context : String? = nil) : String
      # Fast cache keyed on (type_name, effective_context, subst_cache_gen).
      # Avoids redundant type_param substitution + context resolution calls.
      effective_context = context || @current_class
      cache_key = {type_name, effective_context, @subst_cache_gen}
      if cached = @normalize_decl_cache[cache_key]?
        return cached
      end

      resolved = resolve_typeof_in_type_string(type_name)
      resolved = normalize_tuple_literal_type_name(resolved)
      @type_param_map.each do |param, actual|
        resolved = substitute_type_param(resolved, param, actual)
      end

      old_class = @current_class
      @current_class = context if context
      result = begin
        if resolved.includes?('|')
          split_union_type_name(resolved).map do |part|
            normalized = normalize_tuple_literal_type_name(part.strip)
            resolve_type_name_in_context(normalized)
          end.join(" | ")
        else
          resolve_type_name_in_context(resolved)
        end
      ensure
        @current_class = old_class if context
      end
      @normalize_decl_cache[cache_key] = result
      result
    end

    private def bare_generic_annotation?(type_name : String) : Bool
      return false if type_name.includes?('(')
      resolved = resolve_type_name_in_context(type_name)
      base = strip_generic_args(resolved)
      @generic_templates.has_key?(base)
    end

    private def update_typeof_local(name : String, type_ref : TypeRef) : Nil
      return unless locals = @current_typeof_locals
      locals[name] = type_ref
      @infer_type_cache_version += 1
    end

    private def update_typeof_local_name(name : String, type_name : String) : Nil
      return unless locals = @current_typeof_local_names
      normalized = normalize_declared_type_name(type_name)
      if env_get("DEBUG_TYPE_CLASS") && normalized.ends_with?(".class")
        STDERR.puts "[DEBUG_TYPE_CLASS] local=#{name} type_name=#{normalized}"
      end
      locals[name] = normalized
      @infer_type_cache_version += 1
    end

    private def concrete_type_name_for(type_ref : TypeRef) : String?
      return nil if type_ref == TypeRef::VOID

      # Prefer direct primitive names to avoid missing descriptors.
      primitive_name = case type_ref
                       when TypeRef::NIL     then "Nil"
                       when TypeRef::BOOL    then "Bool"
                       when TypeRef::INT8    then "Int8"
                       when TypeRef::INT16   then "Int16"
                       when TypeRef::INT32   then "Int32"
                       when TypeRef::INT64   then "Int64"
                       when TypeRef::INT128  then "Int128"
                       when TypeRef::UINT8   then "UInt8"
                       when TypeRef::UINT16  then "UInt16"
                       when TypeRef::UINT32  then "UInt32"
                       when TypeRef::UINT64  then "UInt64"
                       when TypeRef::UINT128 then "UInt128"
                       when TypeRef::FLOAT32 then "Float32"
                       when TypeRef::FLOAT64 then "Float64"
                       when TypeRef::CHAR    then "Char"
                       when TypeRef::STRING  then "String"
                       when TypeRef::SYMBOL  then "Symbol"
                       when TypeRef::POINTER then "Pointer"
                       else                       nil
                       end
      return primitive_name if primitive_name

      if desc = @module.get_type_descriptor(type_ref)
        return nil if desc.kind == TypeKind::Module
        return normalize_union_type_name(desc.name) if desc.kind == TypeKind::Union
        return desc.name
      end

      nil
    end

    private def lookup_typeof_local_name(name : String) : String?
      @current_typeof_local_names.try(&.[name]?)
    end

    private def with_arena(arena : CrystalV2::Compiler::Frontend::ArenaLike, &)
      old_arena = @arena
      @arena = arena
      begin
        yield
      ensure
        @arena = old_arena
      end
    end

    private def arena_for_expr?(expr_id : ExprId) : CrystalV2::Compiler::Frontend::ArenaLike?
      return nil if expr_id.index < 0
      return @arena if expr_id.index < @arena.size
      if arenas = @inline_arenas
        arenas.each do |candidate|
          return candidate if expr_id.index < candidate.size
        end
      end
      # Fallback: scan known arenas (macros/expansions) for an index match.
      if @sources_by_arena && !@sources_by_arena.empty?
        best = nil
        best_size = Int32::MAX
        @sources_by_arena.each_key do |candidate|
          next unless expr_id.index < candidate.size
          size = candidate.size
          if size < best_size
            best = candidate
            best_size = size
          end
        end
        return best if best
      end
      nil
    end

    private def arena_for_expr(expr_id : ExprId) : CrystalV2::Compiler::Frontend::ArenaLike
      arena_for_expr?(expr_id) || @arena
    end

    private def node_for_expr(expr_id : ExprId) : CrystalV2::Compiler::Frontend::Node?
      arena = arena_for_expr?(expr_id)
      unless arena
        if env_get("DEBUG_INFER_CRASH")
          STDERR.puts "[INFER_NODE] missing_arena expr=#{expr_id.index} current=#{@arena.class}:#{@arena.size}"
        end
        return nil
      end
      if expr_id.index >= arena.size
        if env_get("DEBUG_INFER_CRASH")
          STDERR.puts "[INFER_NODE] oob expr=#{expr_id.index} arena=#{arena.class}:#{arena.size}"
        end
        return nil
      end
      arena[expr_id]
    end

    private def span_fits_source?(arena : CrystalV2::Compiler::Frontend::ArenaLike, span : CrystalV2::Compiler::Frontend::Span) : Bool
      if source = @sources_by_arena[arena]?
        return false if span.end_offset > source.bytesize
        if span.end_line > 0
          line_count = @line_counts_by_arena[arena]?
          unless line_count
            line_count = source.count('\n') + 1
            @line_counts_by_arena[arena] = line_count
          end
          return false if span.end_line > line_count
        end
        true
      else
        true
      end
    end

    private def source_path_for(arena : CrystalV2::Compiler::Frontend::ArenaLike) : String?
      @paths_by_arena[arena]?
    end

    private def callsite_snippet_for(
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      span : CrystalV2::Compiler::Frontend::Span,
      max_bytes : Int32 = 160,
    ) : String?
      source = @sources_by_arena[arena]?
      return nil unless source
      start = span.start_offset
      finish = span.end_offset
      return nil if start < 0 || finish <= start || start >= source.bytesize
      length = finish - start
      length = max_bytes if length > max_bytes
      slice = source.byte_slice(start, length)
      slice.gsub(/\s+/, " ").strip
    end

    private def slice_source_for_span(
      span : CrystalV2::Compiler::Frontend::Span,
      source : String,
    ) : String?
      start = span.start_offset
      finish = span.end_offset
      return nil if start < 0 || finish <= start || start >= source.bytesize
      length = finish - start
      source.byte_slice(start, length)
    end

    private def trace_missing_symbol(
      ctx : LoweringContext,
      node : CrystalV2::Compiler::Frontend::CallNode,
      mangled_name : String,
      base_name : String,
      method_name : String,
      receiver_id : ValueId?,
      arg_types : Array(TypeRef),
      reason : String,
      call_virtual : Bool,
      abstract_target : Bool,
    ) : Nil
      return unless DebugHooks::ENABLED && env_get("CRYSTAL_V2_MISSING_TRACE")

      span = node.span
      path = source_path_for(@arena) || "(unknown)"
      recv_name = receiver_id ? type_name_for_mangling(ctx.type_of(receiver_id)) : "nil"
      arg_names = arg_types.map { |t| type_name_for_mangling(t) }.join(",")
      snippet = callsite_snippet_for(@arena, span)
      data = "symbol=#{mangled_name} base=#{base_name} method=#{method_name} recv=#{recv_name} args=#{arg_names} path=#{path} span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column} reason=#{reason} virtual=#{call_virtual} abstract=#{abstract_target}"
      if snippet && !snippet.empty?
        data += " snippet=\"#{snippet}\""
      end
      if debug_callsite = @debug_callsite
        data += " callsite=#{debug_callsite}"
      end
      debug_hook("missing.symbol", data)
    end

    private def record_allocation_location(
      ctx : LoweringContext,
      value_id : ValueId,
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      node : CrystalV2::Compiler::Frontend::Node,
    ) : Nil
      path = source_path_for(arena)
      return unless path
      span = node.span
      ctx.function.record_value_location(value_id, SourceLocation.new(path, span.start_line, span.start_column))
    end

    private def store_extra_source(arena : CrystalV2::Compiler::Frontend::ArenaLike, text : String) : Nil
      return if text.empty?
      arena.retain_source(text)
      list = @extra_sources_by_arena[arena]?
      unless list
        list = [] of String
        @extra_sources_by_arena[arena] = list
      end
      list << text
    end

    private def resolve_arena_for_def(
      func_def : CrystalV2::Compiler::Frontend::DefNode,
      fallback : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : CrystalV2::Compiler::Frontend::ArenaLike
      cache_key = func_def.object_id
      if cached = @arena_for_def_cache[cache_key]?
        return cached
      end
      result = resolve_arena_for_def_uncached(func_def, fallback)
      @arena_for_def_cache[cache_key] = result
      result
    end

    private def body_max_index_for_def(func_def : CrystalV2::Compiler::Frontend::DefNode) : Int32
      key = func_def.object_id
      if cached = @def_body_max_index_cache[key]?
        return cached
      end
      max_index = if body = func_def.body
                    body.empty? ? -1 : body.max_of(&.index)
                  else
                    -1
                  end
      @def_body_max_index_cache[key] = max_index
      max_index
    end

    @function_def_arenas_last_refresh_size : Int32 = 0

    private def refresh_unique_def_arenas! : Nil
      return if @function_def_arenas.size == @function_def_arenas_last_refresh_size
      @function_def_arenas.each_value do |arena|
        oid = arena.object_id
        next if @unique_def_arenas.has_key?(oid)
        @unique_def_arenas[oid] = arena
        @unique_def_arenas_list << arena
        if path = source_path_for(arena)
          (@unique_def_arenas_by_path[path] ||= [] of CrystalV2::Compiler::Frontend::ArenaLike) << arena
        end
      end
      @function_def_arenas_last_refresh_size = @function_def_arenas.size
      @unique_def_arenas_list_size = @unique_def_arenas_list.size
    end

    private def each_def_arena_candidate(
      fallback : CrystalV2::Compiler::Frontend::ArenaLike,
      &block : CrystalV2::Compiler::Frontend::ArenaLike -> Nil
    ) : Nil
      refresh_unique_def_arenas!
      @unique_def_arenas_list.each { |arena| yield arena }
      if arenas = @inline_arenas
        arenas.each { |arena| yield arena }
      end
      unless @unique_def_arenas.has_key?(fallback.object_id)
        yield fallback
      end
    end

    private def resolve_arena_for_def_uncached(
      func_def : CrystalV2::Compiler::Frontend::DefNode,
      fallback : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : CrystalV2::Compiler::Frontend::ArenaLike
      max_index = body_max_index_for_def(func_def)
      fallback_path = source_path_for(fallback)

      best = nil
      best_size = Int32::MAX
      if fallback_path
        refresh_unique_def_arenas!
        if arenas = @unique_def_arenas_by_path[fallback_path]?
          arenas.each do |arena|
            next if max_index >= 0 && max_index >= arena.size
            next unless span_fits_source?(arena, func_def.span)
            size = arena.size
            if size < best_size
              best = arena
              best_size = size
            end
          end
        end
        if arenas = @inline_arenas
          arenas.each do |arena|
            next unless source_path_for(arena) == fallback_path
            next if max_index >= 0 && max_index >= arena.size
            next unless span_fits_source?(arena, func_def.span)
            size = arena.size
            if size < best_size
              best = arena
              best_size = size
            end
          end
        end
        unless best
          each_def_arena_candidate(fallback) do |arena|
            next if max_index >= 0 && max_index >= arena.size
            next unless span_fits_source?(arena, func_def.span)
            path = source_path_for(arena)
            next unless path == fallback_path
            size = arena.size
            if size < best_size
              best = arena
              best_size = size
            end
          end
        end
      end

      unless best
        each_def_arena_candidate(fallback) do |arena|
          next if max_index >= 0 && max_index >= arena.size
          next unless span_fits_source?(arena, func_def.span)
          size = arena.size
          if size < best_size
            best = arena
            best_size = size
          end
        end
      end

      best || fallback
    end

    private def arena_fits_def?(
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      func_def : CrystalV2::Compiler::Frontend::DefNode,
    ) : Bool
      max_index = body_max_index_for_def(func_def)
      return false if max_index >= 0 && max_index >= arena.size
      span_fits_source?(arena, func_def.span)
    end

    private def resolve_arena_for_block(
      block : CrystalV2::Compiler::Frontend::BlockNode,
      fallback : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : CrystalV2::Compiler::Frontend::ArenaLike?
      block_id = block.object_id
      if cached = cached_block_arena(block_id)
        return cached
      end

      max_index = block.body.empty? ? -1 : block.body.max_of(&.index)
      each_def_arena_candidate(fallback) do |arena|
        next if max_index >= 0 && max_index >= arena.size
        next unless span_fits_source?(arena, block.span)
        store_block_arena(block_id, arena)
        return arena
      end

      nil
    end

    private def cached_block_arena(block_id : UInt64) : CrystalV2::Compiler::Frontend::ArenaLike?
      if @last_block_arena_id == block_id
        return @last_block_arena
      end
      if cached = @block_node_arenas[block_id]?
        @last_block_arena_id = block_id
        @last_block_arena = cached
        return cached
      end
      nil
    end

    private def store_block_arena(block_id : UInt64, arena : CrystalV2::Compiler::Frontend::ArenaLike) : Nil
      @block_node_arenas[block_id] = arena
      @last_block_arena_id = block_id
      @last_block_arena = arena
    end

    private def with_type_param_map(extra : Hash(String, String), &)
      old_map = @type_param_map
      @type_param_map = old_map.merge(extra)
      @subst_cache_gen &+= 1
      begin
        yield
      ensure
        @type_param_map = old_map
        @subst_cache_gen &+= 1
      end
    end

    private def with_namespace_override(namespace : String, &)
      old_namespace = @current_namespace_override
      @current_namespace_override = namespace
      begin
        yield
      ensure
        @current_namespace_override = old_namespace
      end
    end

    private def with_namespace_override_or_clear(namespace : String?, &)
      old_namespace = @current_namespace_override
      @current_namespace_override = namespace
      begin
        yield
      ensure
        @current_namespace_override = old_namespace
      end
    end

    private def record_pending_type_param_map(name : String, params : Hash(String, String)) : Nil
      return if name.empty? || params.empty?
      if env_get("DEBUG_TUPLE_MAP") && name.starts_with?("Tuple#")
        params_str = params.map { |k, v| "#{k}=#{v}" }.join(",")
        STDERR.puts "[TUPLE_MAP_STORE] name=#{name} params=#{params_str}"
      end
      if existing = @pending_type_param_maps[name]?
        @pending_type_param_maps[name] = existing.merge(params)
      else
        @pending_type_param_maps[name] = params.dup
      end
    end

    private def consume_pending_type_param_map(name : String) : Hash(String, String)?
      return nil if name.empty?
      map = @pending_type_param_maps[name]?
      @pending_type_param_maps.delete(name) if map
      map
    end

    # Register type params from a deferred module context (lazy module method registration).
    # Called when the deferred module lookup finds a method, to provide the module's
    # type param mapping (e.g., Enumerable's T → Tuple(K, V) for Hash includes).
    private def register_deferred_module_type_params(owner : String, module_name : String, full_name : String, base_name : String) : Nil
      contexts = @deferred_module_contexts[owner]?
      return unless contexts
      contexts.each do |ctx|
        base_ctx_module = strip_generic_args(ctx.module_full_name)
        next unless base_ctx_module == module_name || ctx.module_full_name == module_name
        # Store the deferred type param snapshot so lower_method can set up correct context
        store_function_type_param_map(full_name, base_name, ctx.type_param_snapshot)
        # Also store the namespace override if present
        if ns = ctx.namespace_override
          store_function_namespace_override(full_name, base_name, ns)
        end
        # Store the arena so the method body can be found
        @function_def_arenas[full_name] ||= ctx.mod_arena
        @function_def_arenas[base_name] ||= ctx.mod_arena
        break
      end
    end

    private def store_function_type_param_map(full_name : String, base_name : String, params : Hash(String, String)) : Nil
      return if params.empty?
      stored = params.dup
      @function_type_param_maps[full_name] = stored
      @function_type_param_maps[base_name] = stored unless @function_type_param_maps.has_key?(base_name)
    end

    private def function_type_param_map_for(*names : String) : Hash(String, String)?
      names.each do |name|
        next if name.empty?
        if map = @function_type_param_maps[name]?
          if env_get("DEBUG_TYPE_PARAM_RETRIEVE") && (name.includes?("Slice") && name.includes?("hash"))
            STDERR.puts "[TYPE_PARAM_RETRIEVE] found name=#{name} map=#{map}"
          end
          return map
        end
      end
      if env_get("DEBUG_TYPE_PARAM_RETRIEVE") && names.any? { |n| n.includes?("Slice") && n.includes?("hash") }
        STDERR.puts "[TYPE_PARAM_RETRIEVE] NOT_FOUND names=#{names.to_a.join(", ")}"
      end
      nil
    end

    private def store_function_namespace_override(full_name : String, base_name : String, namespace : String) : Nil
      return if namespace.empty?
      @function_namespace_overrides[full_name] = namespace
      @function_namespace_overrides[base_name] = namespace unless @function_namespace_overrides.has_key?(base_name)
    end

    private def function_namespace_override_for(*names : String) : String?
      names.each do |name|
        next if name.empty?
        if ns = @function_namespace_overrides[name]?
          return ns
        end
      end
      nil
    end

    private def include_type_param_map(
      module_node : CrystalV2::Compiler::Frontend::ModuleNode,
      include_target : ExprId,
      include_arena : CrystalV2::Compiler::Frontend::ArenaLike = @arena,
      self_type : String? = nil,
    ) : Hash(String, String)
      extra = {} of String => String
      type_params = module_node.type_params
      return extra unless type_params

      arg_strings = [] of String
      target_node = include_arena[include_target]
      base_node = nil
      type_args = nil
      case target_node
      when CrystalV2::Compiler::Frontend::GenericNode
        base_node = target_node.base_type
        type_args = target_node.type_args
      when CrystalV2::Compiler::Frontend::CallNode
        if type_like_call_expr?(target_node)
          base_node = target_node.callee
          type_args = target_node.args
        else
          base_node = nil
        end
      end
      if base_node.nil? || type_args.nil?
        if DebugHooks::ENABLED
          module_name = String.new(module_node.name)
          debug_hook("include.param.missing", "module=#{module_name} target=#{target_node.class.name}")
        end
        return extra
      end
      with_arena(include_arena) do
        type_args.each do |arg|
          arg_node = include_arena[arg]
          # Handle self specially - resolve to the including class/module
          if arg_node.is_a?(CrystalV2::Compiler::Frontend::SelfNode)
            if self_name = self_type || @current_class || @current_namespace_override
              arg_strings << substitute_type_params_in_type_name(self_name)
            end
          elsif str = stringify_type_expr(arg)
            arg_strings << substitute_type_params_in_type_name(str)
          end
        end
      end
      if arg_strings.empty?
        if DebugHooks::ENABLED
          module_name = String.new(module_node.name)
          base_name = base_node ? (resolve_path_like_name(base_node) || "unknown") : "unknown"
          debug_hook("include.param.empty", "module=#{module_name} target=#{base_name}")
        end
        return extra
      end

      type_params.each_with_index do |tp, idx|
        break if idx >= arg_strings.size
        param_name = String.new(tp)
        arg_name = arg_strings[idx]
        if arg_name == param_name && type_param_like?(arg_name)
          mapped = @type_param_map[arg_name]?
          if mapped
            extra[param_name] = mapped
          end
          next
        end
        # Skip mappings that still reference the same type param (e.g., Union(*T), Array(T)).
        # Treat these as unresolved so module methods defer until concrete types are known.
        if type_name_includes_param?(arg_name, param_name)
          next
        end
        extra[param_name] = arg_name
      end
      extra
    end

    private def defer_untyped_params_for_module?(
      module_node : CrystalV2::Compiler::Frontend::ModuleNode,
      extra_map : Hash(String, String),
    ) : Bool
      type_params = module_node.type_params
      return false unless type_params

      type_params.any? do |tp|
        param_name = String.new(tp)
        arg_name = extra_map[param_name]?
        arg_name.nil? || (arg_name == param_name && type_param_like?(param_name))
      end
    end

    private def unwrap_visibility_member(member)
      while member.is_a?(CrystalV2::Compiler::Frontend::VisibilityModifierNode)
        member = @arena[member.expression]
      end
      member
    end

    private def collect_defined_instance_method_full_names(class_name : String, body : Array(ExprId)) : Set(String)
      defined = Set(String).new
      type_cache = {} of String => TypeRef
      resolved_type_cache = {} of String => String
      old_type_name_cache = @type_name_exists_cache
      old_typeof_locals = @current_typeof_local_names
      old_signature_scan = @signature_scan_mode
      @type_name_exists_cache = {} of String => Bool
      @current_typeof_local_names = nil
      @signature_scan_mode = true
      begin
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          case member
          when CrystalV2::Compiler::Frontend::DefNode
            next if member.is_abstract
            next if (recv = member.receiver) && String.new(recv) == "self"

            method_name = String.new(member.name)
            base_name = "#{class_name}##{method_name}"

            param_types = [] of TypeRef
            has_block = false
            if params = member.params
              params.each do |param|
                next if named_only_separator?(param)
                if param.is_block
                  has_block = true
                  next
                end
                if ta = param.type_annotation
                  type_name = String.new(ta)
                  if resolved_name = resolved_type_cache[type_name]?
                    param_types << (type_cache[resolved_name]? || begin
                      resolved_ref = fast_param_type_ref(resolved_name)
                      type_cache[resolved_name] = resolved_ref
                      resolved_ref
                    end)
                  else
                    resolved_name = fast_resolve_type_name_for_signature(type_name)
                    resolved_type_cache[type_name] = resolved_name
                    param_types << (type_cache[resolved_name]? || begin
                      resolved_ref = fast_param_type_ref(resolved_name)
                      type_cache[resolved_name] = resolved_ref
                      resolved_ref
                    end)
                  end
                else
                  param_types << TypeRef::VOID
                end
              end
            end

            full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
            defined << full_name
            if env_get("DEBUG_DEFINED_METHODS") && class_name.starts_with?("Tuple") && method_name == "hash"
              STDERR.puts "[DEFINED_METHOD] class=#{class_name} full=#{full_name}"
            end
            # Untyped params may get an arity suffix later if a base name collision occurs.
            if param_types.any? { |t| t == TypeRef::VOID }
              param_count = 0
              if params = member.params
                params.each do |param|
                  next if named_only_separator?(param) || param.is_block
                  param_count += 1
                end
              end
              defined << "#{base_name}$arity#{param_count}" if param_count > 0
            end
          when CrystalV2::Compiler::Frontend::GetterNode
            member.specs.each do |spec|
              accessor_name = accessor_method_name(spec)
              base_name = "#{class_name}##{accessor_name}"
              full_name = mangle_function_name(base_name, [] of TypeRef)
              defined << full_name
            end
          when CrystalV2::Compiler::Frontend::SetterNode
            member.specs.each do |spec|
              accessor_name = accessor_storage_name(spec)
              base_name = "#{class_name}##{accessor_name}="
              param_type = if ta = spec.type_annotation
                             type_ref_for_name(String.new(ta))
                           else
                             TypeRef::VOID
                           end
              full_name = mangle_function_name(base_name, [param_type])
              defined << full_name
            end
          when CrystalV2::Compiler::Frontend::PropertyNode
            member.specs.each do |spec|
              getter_name = accessor_method_name(spec)
              setter_name = accessor_storage_name(spec)
              getter_base = "#{class_name}##{getter_name}"
              setter_base = "#{class_name}##{setter_name}="
              getter_full = mangle_function_name(getter_base, [] of TypeRef)
              param_type = if ta = spec.type_annotation
                             type_ref_for_name(String.new(ta))
                           else
                             TypeRef::VOID
                           end
              setter_full = mangle_function_name(setter_base, [param_type])
              defined << getter_full
              defined << setter_full
            end
          end
        end
      ensure
        @type_name_exists_cache = old_type_name_cache
        @current_typeof_local_names = old_typeof_locals
        @signature_scan_mode = old_signature_scan
      end
      defined
    end

    private def collect_defined_class_method_full_names(class_name : String, body : Array(ExprId)) : Set(String)
      defined = Set(String).new
      type_cache = {} of String => TypeRef
      resolved_type_cache = {} of String => String
      old_type_name_cache = @type_name_exists_cache
      old_typeof_locals = @current_typeof_local_names
      old_signature_scan = @signature_scan_mode
      @type_name_exists_cache = {} of String => Bool
      @current_typeof_local_names = nil
      @signature_scan_mode = true
      begin
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          case member
          when CrystalV2::Compiler::Frontend::DefNode
            next if member.is_abstract
            next unless (recv = member.receiver) && String.new(recv) == "self"

            method_name = String.new(member.name)
            base_name = "#{class_name}.#{method_name}"

            param_types = [] of TypeRef
            has_block = false
            if params = member.params
              params.each do |param|
                next if named_only_separator?(param)
                if param.is_block
                  has_block = true
                  next
                end
                if ta = param.type_annotation
                  type_name = String.new(ta)
                  if resolved_name = resolved_type_cache[type_name]?
                    param_types << (type_cache[resolved_name]? || begin
                      resolved_ref = fast_param_type_ref(resolved_name)
                      type_cache[resolved_name] = resolved_ref
                      resolved_ref
                    end)
                  else
                    resolved_name = fast_resolve_type_name_for_signature(type_name)
                    resolved_type_cache[type_name] = resolved_name
                    param_types << (type_cache[resolved_name]? || begin
                      resolved_ref = fast_param_type_ref(resolved_name)
                      type_cache[resolved_name] = resolved_ref
                      resolved_ref
                    end)
                  end
                else
                  param_types << TypeRef::VOID
                end
              end
            end

            full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
            defined << full_name
          when CrystalV2::Compiler::Frontend::GetterNode
            next unless member.is_class?
            member.specs.each do |spec|
              accessor_name = accessor_method_name(spec)
              base_name = "#{class_name}.#{accessor_name}"
              full_name = mangle_function_name(base_name, [] of TypeRef)
              defined << full_name
            end
          when CrystalV2::Compiler::Frontend::SetterNode
            next unless member.is_class?
            member.specs.each do |spec|
              accessor_name = accessor_storage_name(spec)
              base_name = "#{class_name}.#{accessor_name}="
              param_type = if ta = spec.type_annotation
                             type_ref_for_name(String.new(ta))
                           else
                             TypeRef::VOID
                           end
              full_name = mangle_function_name(base_name, [param_type])
              defined << full_name
            end
          when CrystalV2::Compiler::Frontend::PropertyNode
            next unless member.is_class?
            member.specs.each do |spec|
              getter_name = accessor_method_name(spec)
              getter_base = "#{class_name}.#{getter_name}"
              defined << mangle_function_name(getter_base, [] of TypeRef)

              setter_name = "#{class_name}.#{accessor_storage_name(spec)}="
              setter_type = if ta = spec.type_annotation
                              type_ref_for_name(String.new(ta))
                            else
                              TypeRef::VOID
                            end
              defined << mangle_function_name(setter_name, [setter_type])
            end
          end
        end
      ensure
        @type_name_exists_cache = old_type_name_cache
        @current_typeof_local_names = old_typeof_locals
        @signature_scan_mode = old_signature_scan
      end
      defined
    end

    private def add_defined_instance_methods_from_expr(
      class_name : String,
      defined_full_names : Set(String),
      expr_id : ExprId,
    )
      return if expr_id.invalid?

      member = unwrap_visibility_member(@arena[expr_id])
      case member
      when CrystalV2::Compiler::Frontend::BlockNode
        member.body.each do |child_id|
          add_defined_instance_methods_from_expr(class_name, defined_full_names, child_id)
        end
      when CrystalV2::Compiler::Frontend::DefNode
        return if member.is_abstract
        if recv = member.receiver
          return if String.new(recv) == "self"
        end

        method_name = String.new(member.name)
        base_name = "#{class_name}##{method_name}"

        param_types = [] of TypeRef
        has_block = false
        if params = member.params
          params.each do |param|
            next if named_only_separator?(param)
            if param.is_block
              has_block = true
              next
            end
            if ta = param.type_annotation
              param_types << type_ref_for_name(String.new(ta))
            else
              param_types << TypeRef::VOID
            end
          end
        end

        full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
        defined_full_names << full_name
      when CrystalV2::Compiler::Frontend::GetterNode
        return if member.is_class?
        member.specs.each do |spec|
          accessor_name = accessor_method_name(spec)
          base_name = "#{class_name}##{accessor_name}"
          full_name = mangle_function_name(base_name, [] of TypeRef)
          defined_full_names << full_name
        end
      when CrystalV2::Compiler::Frontend::SetterNode
        return if member.is_class?
        member.specs.each do |spec|
          accessor_name = accessor_storage_name(spec)
          base_name = "#{class_name}##{accessor_name}="
          param_type = if ta = spec.type_annotation
                         type_ref_for_name(String.new(ta))
                       else
                         TypeRef::VOID
                       end
          full_name = mangle_function_name(base_name, [param_type])
          defined_full_names << full_name
        end
      when CrystalV2::Compiler::Frontend::PropertyNode
        return if member.is_class?
        member.specs.each do |spec|
          getter_name = accessor_method_name(spec)
          setter_name = accessor_storage_name(spec)
          getter_base = "#{class_name}##{getter_name}"
          setter_base = "#{class_name}##{setter_name}="
          getter_full = mangle_function_name(getter_base, [] of TypeRef)
          param_type = if ta = spec.type_annotation
                         type_ref_for_name(String.new(ta))
                       else
                         TypeRef::VOID
                       end
          setter_full = mangle_function_name(setter_base, [param_type])
          defined_full_names << getter_full
          defined_full_names << setter_full
        end
      when CrystalV2::Compiler::Frontend::VisibilityModifierNode
        add_defined_instance_methods_from_expr(class_name, defined_full_names, member.expression)
      end
    end

    private def accessor_method_name(spec : CrystalV2::Compiler::Frontend::AccessorSpec) : String
      name = String.new(spec.name)
      spec.predicate ? "#{name}?" : name
    end

    private def accessor_storage_name(spec : CrystalV2::Compiler::Frontend::AccessorSpec) : String
      String.new(spec.name)
    end

    private def register_accessor_from_module(
      class_name : String,
      spec : CrystalV2::Compiler::Frontend::AccessorSpec,
      ivars : Array(IVarInfo),
      offset : Int32,
      defined_full_names : Set(String),
      is_struct : Bool,
      include_getter : Bool,
      include_setter : Bool,
    ) : Int32
      storage_name = accessor_storage_name(spec)
      getter_name = accessor_method_name(spec)
      ivar_name = "@#{storage_name}"
      ivar_type = if ta = spec.type_annotation
                    type_ref_for_name(String.new(ta))
                  elsif spec.predicate
                    TypeRef::BOOL
                  elsif default_value = spec.default_value
                    infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                  else
                    TypeRef::VOID
                  end

      unless ivars.any? { |iv| iv.name == ivar_name }
        # Store default value expression if present (property x : T = expr)
        default_expr_id : CrystalV2::Compiler::Frontend::ExprId? = nil
        default_arena : CrystalV2::Compiler::Frontend::ArenaLike? = nil
        if val_expr = spec.default_value
          val_node = @arena[val_expr]
          unless is_trivial_default(val_node)
            default_expr_id = val_expr
            default_arena = @arena
          end
        end
        offset = align_offset(offset, type_alignment(ivar_type))
        ivars << IVarInfo.new(ivar_name, ivar_type, offset,
          default_expr_id: default_expr_id,
          default_arena: default_arena)
        offset += type_size(ivar_type)
      end

      if include_getter
        getter_base = "#{class_name}##{getter_name}"
        getter_full = mangle_function_name(getter_base, [] of TypeRef)
        unless defined_full_names.includes?(getter_full)
          register_function_type(getter_full, ivar_type)
        end
      end

      if include_setter
        setter_name = "#{class_name}##{storage_name}="
        setter_full = mangle_function_name(setter_name, [ivar_type])
        unless defined_full_names.includes?(setter_full)
          setter_return = is_struct ? TypeRef::VOID : ivar_type
          register_function_type(setter_full, setter_return)
        end
      end

      offset
    end

    private def capture_initialize_params(
      params : Array(CrystalV2::Compiler::Frontend::Parameter),
      ivars : Array(IVarInfo),
      offset_ptr : Pointer(Int32),
      owner_name : String? = nil,
    ) : Array({String, TypeRef})
      init_params = [] of {String, TypeRef}
      params.each do |param|
        next if named_only_separator?(param)
        param_name = param.name.nil? ? "_" : String.new(param.name.not_nil!)
        is_ivar_param = param.is_instance_var || param_name.starts_with?('@')
        if is_ivar_param
          param_name = param_name.lstrip('@')
        end
        param_type = if ta = param.type_annotation
                       type_ref_for_name(String.new(ta))
                     elsif param.is_double_splat
                       type_ref_for_name("NamedTuple")
                     else
                       TypeRef::VOID
                     end

        if is_ivar_param
          ivar_name = "@#{param_name}"
          if param_type == TypeRef::VOID
            if default_value = param.default_value
              inferred = infer_type_from_expr(default_value, owner_name)
              param_type = inferred if inferred && inferred != TypeRef::VOID
            end
          end
          if idx = ivars.index { |iv| iv.name == ivar_name }
            existing = ivars[idx]
            if existing.type == TypeRef::VOID && param_type != TypeRef::VOID
              ivars[idx] = IVarInfo.new(ivar_name, param_type, existing.offset)
            elsif param_type == TypeRef::VOID && existing.type != TypeRef::VOID
              param_type = existing.type
            elsif param_type == TypeRef::NIL && existing.type != TypeRef::VOID && existing.type != TypeRef::NIL
              # `@ivar = nil` default: use the declared ivar type (e.g., Foo?) not Nil
              param_type = existing.type
            end
          else
            ivars << IVarInfo.new(ivar_name, param_type, offset_ptr.value)
            offset_ptr.value += type_size(param_type)
          end
          if owner_name && (ta = param.type_annotation)
            type_name = String.new(ta)
            resolved = resolve_type_alias_chain(resolve_type_name_in_context(type_name))
            if enum_name = resolve_enum_name(resolved)
              enum_map = @enum_ivar_types ||= {} of String => Hash(String, String)
              class_map = enum_map[owner_name]? || begin
                new_map = {} of String => String
                enum_map[owner_name] = new_map
                new_map
              end
              class_map[ivar_name] = enum_name
            end
          end
          init_params << {param_name, param_type}
        else
          # For non-ivar params without type annotation, try to infer from default value
          if param_type == TypeRef::VOID
            if default_value = param.default_value
              inferred = infer_type_from_expr(default_value, owner_name)
              param_type = inferred if inferred && inferred != TypeRef::VOID
            end
          end
          init_params << {param_name, param_type}
        end
      end
      init_params
    end

    private def register_module_instance_methods_for(
      class_name : String,
      include_node : CrystalV2::Compiler::Frontend::IncludeNode,
      defined_full_names : Set(String),
      defined_class_method_full_names : Set(String),
      visited : Set(String),
      visited_extends : Set(String),
      ivars : Array(IVarInfo),
      offset : Int32,
      is_struct : Bool,
      init_capture : InitParamsCapture?,
    ) : Int32
      # Sanitize class_name (fix malformed types with unbalanced parens)
      class_name = sanitize_type_name(class_name)
      module_full_name = resolve_path_like_name(include_node.target)
      return offset unless module_full_name
      # Prefer nested modules under the including class (e.g., Crystal::EventLoop::FileDescriptor).
      if !module_full_name.includes?("::")
        base_owner = strip_generic_args(class_name)
        nested_name = "#{base_owner}::#{module_full_name}"
        module_full_name = nested_name if @module_defs.has_key?(nested_name)
      end

      # INC_DEBUG disabled

      # If module not found directly, try resolving relative to the including class's namespace
      # e.g., BinaryFormat_Float64 includes BinaryFormat -> Float::FastFloat::BinaryFormat
      unless @module_defs.has_key?(module_full_name)
        # Extract namespace from class_name (e.g., Float::FastFloat from Float::FastFloat::BinaryFormat_Float64)
        if class_name.includes?("::")
          parts = class_name.split("::")
          parts.pop # Remove the class name itself
          # Try progressively shorter namespaces
          while parts.size > 0
            qualified_name = "#{parts.join("::")}::#{module_full_name}"
            if @module_defs.has_key?(qualified_name)
              module_full_name = qualified_name
              break
            end
            parts.pop
          end
        end
        # STDERR.puts "[INC_DEBUG] after resolution: module_full_name=#{module_full_name}"
      end

      module_full_name = resolve_module_alias_for_include(module_full_name)
      record_module_inclusion(module_full_name, class_name)
      return offset if visited.includes?(module_full_name)
      visited << module_full_name

      defs = @module_defs[module_full_name]?
      return offset unless defs
      # INC_DEBUG disabled
      include_arena = @arena
      defs.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          extra_map = include_type_param_map(mod_node, include_node.target, include_arena, class_name)
          with_type_param_map(extra_map) do
            if macro_lookup = lookup_macro_entry("included", module_full_name)
              macro_entry, macro_key = macro_lookup
              macro_def, macro_arena = macro_entry
              expanded_id = expand_macro_expr(macro_def, macro_arena, [] of ExprId, nil, nil, macro_key)
              old_arena = @arena
              @arena = macro_arena
              begin
                # Fallback: parse raw macro literal as class body when it contains no macro controls.
                # This recovers accessors like property?/getter?/setter? for included modules.
                macro_body = macro_arena[macro_def.body]
                if macro_body.is_a?(CrystalV2::Compiler::Frontend::MacroLiteralNode)
                  if raw_text = macro_literal_raw_text(macro_body)
                    expanded = expand_flag_macro_text(raw_text) || raw_text
                    if parsed = parse_macro_literal_class_body(expanded)
                      program, body_ids = parsed
                      with_arena(program.arena) do
                        body_ids.each do |child_id|
                          register_class_members_from_expansion(
                            class_name,
                            child_id,
                            defined_class_method_full_names,
                            visited_extends,
                            ivars,
                            pointerof(offset)
                          )
                        end
                      end
                    end
                  end
                end

                unless expanded_id.invalid?
                  register_class_members_from_expansion(
                    class_name,
                    expanded_id,
                    defined_class_method_full_names,
                    visited_extends,
                    ivars,
                    pointerof(offset)
                  )
                end
              ensure
                @arena = old_arena
              end
            end
            if body = mod_node.body
              body_ids = body.not_nil!
              with_namespace_override(module_full_name) do
                # Two-pass approach: register direct definitions (DefNode, accessors,
                # ivars) FIRST, then process IncludeNodes. This ensures that when a
                # module defines a method that overrides an included sub-module's method
                # (e.g., Indexable#empty? overriding Enumerable#empty?), the defining
                # module's version is registered first and wins.

                # Lazy mode: save context for on-demand method resolution, skip DefNodes
                if @lazy_module_methods
                  ctx = DeferredModuleContext.new(
                    module_full_name: module_full_name,
                    type_param_snapshot: @type_param_map.dup,
                    mod_arena: mod_arena,
                    namespace_override: @current_namespace_override
                  )
                  list = @deferred_module_contexts[class_name]?
                  unless list
                    list = [] of DeferredModuleContext
                    @deferred_module_contexts[class_name] = list
                  end
                  list << ctx
                end

                # Pass 1: Everything except IncludeNode
                body_ids.each do |member_id|
                  member = unwrap_visibility_member(@arena[member_id])
                  case member
                  when CrystalV2::Compiler::Frontend::IncludeNode
                    next # Deferred to Pass 2
                  when CrystalV2::Compiler::Frontend::InstanceVarDeclNode
                    ivar_name = String.new(member.name)
                    ivar_type = type_ref_for_name(String.new(member.type))
                    unless ivars.any? { |iv| iv.name == ivar_name }
                      # Store default value expression if present (e.g., @x : T = expr)
                      default_expr_id : CrystalV2::Compiler::Frontend::ExprId? = nil
                      default_arena : CrystalV2::Compiler::Frontend::ArenaLike? = nil
                      if val_expr = member.value
                        val_node = @arena[val_expr]
                        unless is_trivial_default(val_node)
                          default_expr_id = val_expr
                          default_arena = @arena
                        end
                      end
                      offset = align_offset(offset, type_alignment(ivar_type))
                      ivars << IVarInfo.new(ivar_name, ivar_type, offset,
                        default_expr_id: default_expr_id,
                        default_arena: default_arena)
                      offset += type_size(ivar_type)
                    end
                  when CrystalV2::Compiler::Frontend::AssignNode
                    target_node = @arena[member.target]
                    if target_node.is_a?(CrystalV2::Compiler::Frontend::InstanceVarNode)
                      ivar_name = String.new(target_node.name)
                      value_node = @arena[member.value]
                      inferred = infer_type_from_class_ivar_assign(value_node)
                      if env_has?("DEBUG_IVAR_INFER")
                        inferred_name = inferred == TypeRef::VOID ? "Void" : get_type_name_from_ref(inferred)
                        detail = ""
                        if value_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                          detail = " member=#{String.new(value_node.member)} obj=#{@arena[value_node.object].class}"
                        end
                        STDERR.puts "[IVAR_INFER] include=#{module_full_name} class=#{class_name} ivar=#{ivar_name} value=#{value_node.class} inferred=#{inferred_name}#{detail}"
                      end
                      inferred = TypeRef::POINTER if inferred == TypeRef::VOID
                      unless ivars.any? { |iv| iv.name == ivar_name }
                        # Store the default value expression for later evaluation in the allocator
                        # (same as class body handler at line 12583)
                        default_expr = member.value
                        needs_expr = !is_trivial_default(value_node)
                        offset = align_offset(offset, type_alignment(inferred))
                        ivars << IVarInfo.new(ivar_name, inferred, offset,
                          default_expr_id: needs_expr ? default_expr : nil,
                          default_arena: needs_expr ? @arena : nil)
                        offset += type_size(inferred)
                      end
                    end
                  when CrystalV2::Compiler::Frontend::DefNode
                    next if (recv = member.receiver) && String.new(recv) == "self"
                    next if member.is_abstract

                    method_name = String.new(member.name)
                    base_name = "#{class_name}##{method_name}"

                    # Early skip: if the class already defines this method (base_name), skip
                    # the expensive type resolution below. The class's own def takes priority.
                    next if defined_full_names.includes?(base_name)

                    # Lazy mode: skip DefNode registration entirely (will be resolved on demand)
                    # via the deferred module lookup path. This prevents the monomorphization
                    # cascade caused by type_ref_for_name in param type resolution.
                    next if @lazy_module_methods

                    # NOTE: We intentionally do NOT write @function_def_arenas[base_name] here.
                    # The early arena write was causing bugs when included module methods should
                    # be skipped (e.g., Slice#hash overrides Indexable#hash). The arena is only
                    # written when the method is actually registered at line 4409.

                    type_literal_name = @defer_body_return_inference ? nil : infer_type_literal_return_name_from_body(member, class_name)
                    defer = @defer_body_return_inference
                    return_type = if rt = member.return_type
                                    rt_name = String.new(rt)
                                    inferred = !defer && module_like_type_name?(rt_name) ? infer_concrete_return_type_from_body(member, class_name) : nil
                                    inferred || type_ref_for_name(rt_name)
                                  elsif method_name.ends_with?('?')
                                    inferred = defer ? nil : infer_unannotated_query_return_type(method_name, type_ref_for_name(class_name))
                                    inferred = infer_concrete_return_type_from_body(member, class_name) if inferred.nil? && !defer
                                    inferred || TypeRef::BOOL
                                  else
                                    inferred = defer ? nil : infer_getter_return_type(member, ivars)
                                    inferred = infer_concrete_return_type_from_body(member, class_name) if inferred.nil? && !defer
                                    inferred = infer_unannotated_search_return_type(method_name, type_ref_for_name(class_name)) if inferred.nil? && !defer
                                    inferred || TypeRef::VOID
                                  end
                    if type_literal_name
                      literal_ref = type_ref_for_name(type_literal_name)
                      if return_type == TypeRef::VOID || return_type == TypeRef::NIL
                        return_type = literal_ref if literal_ref != TypeRef::VOID
                      end
                    end

                    param_types = [] of TypeRef
                    has_block = false
                    if params = member.params
                      params.each do |param|
                        next if named_only_separator?(param)
                        if param.is_block
                          has_block = true
                          next
                        end
                        param_type = if ta = param.type_annotation
                                       type_ref_for_name(String.new(ta))
                                     elsif param.is_double_splat
                                       type_ref_for_name("NamedTuple")
                                     else
                                       TypeRef::VOID
                                     end
                        param_types << param_type
                      end
                    end
                    if !has_block
                      has_block = def_contains_yield?(member, @arena)
                    end

                    if method_name == "initialize"
                      if init_capture && init_capture.source != :class
                        if params = member.params
                          new_params = capture_initialize_params(params, ivars, pointerof(offset), class_name)
                          init_capture.params.clear
                          new_params.each { |param| init_capture.params << param }
                          init_capture.source = :include
                        end
                      end
                      if body = member.body
                        infer_ivars_from_body(body, ivars, pointerof(offset))
                      end
                    end

                    full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
                    if env_get("DEBUG_MODULE_OVERRIDE") && class_name.starts_with?("Tuple") && method_name == "hash"
                      has_full = defined_full_names.includes?(full_name)
                      has_base = defined_full_names.includes?(base_name)
                      STDERR.puts "[MODULE_OVERRIDE] full=#{full_name} defined_full=#{has_full} defined_base=#{has_base}"
                    end
                    # If the class defines this method (especially untyped), don't let the include override it.
                    next if defined_full_names.includes?(full_name) || defined_full_names.includes?(base_name)
                    # Avoid overriding an existing definition with an included module method.
                    next if @function_defs.has_key?(full_name)

                    store_function_type_param_map(full_name, base_name, extra_map)
                    store_function_namespace_override(full_name, base_name, module_full_name)
                    if DebugHooks::ENABLED
                      debug_hook(
                        "module.instance_method.register",
                        "class=#{class_name} module=#{module_full_name} method=#{method_name} full=#{full_name}"
                      )
                      if module_full_name.includes?("SelectAction")
                        param_ids = param_types.map(&.id).join(",")
                        debug_hook("module.instance_method.register.body", "method=#{method_name} params=#{param_ids}")
                      end
                    end
                    if env_get("DEBUG_EACH_REGISTER") && method_name == "each" && class_name.includes?("Slice(")
                      STDERR.puts "[EACH_REGISTER] class=#{class_name} full=#{full_name}"
                    end
                    if type_literal_name
                      literal_ref = type_ref_for_name(type_literal_name)
                      if literal_ref != TypeRef::VOID
                        record_type_literal_return(full_name, base_name)
                      end
                    end
                    register_function_type(full_name, return_type)
                    @function_defs[full_name] = member
                    @function_def_arenas[full_name] = @arena
                    if env_get("DEBUG_ARENA_WRITE") && (class_name.includes?("Slice") && method_name == "hash")
                      arena_path = source_path_for(@arena) || "(unknown)"
                      STDERR.puts "[ARENA_WRITE_MOD_INST] full=#{full_name} arena=#{arena_path}:#{@arena.size} module=#{module_full_name}"
                    end
                    if should_register_base_name?(full_name, base_name, member, has_block)
                      @function_defs[base_name] = member
                      @function_def_arenas[base_name] = @arena
                    end

                    if body = member.body
                      contains_yield = def_contains_yield?(member, @arena)
                      if !contains_yield && @yield_functions.includes?(full_name)
                        @yield_functions.delete(full_name)
                        debug_hook("yield.unregister", full_name)
                      elsif contains_yield
                        @yield_functions.add(full_name)
                        if env_get("DEBUG_EACH_REGISTER") && method_name == "each" && class_name.includes?("Slice(")
                          STDERR.puts "[EACH_REGISTER] yield=#{full_name}"
                        end
                        debug_hook("yield.register", full_name)
                        if !has_block && !@function_defs.has_key?(base_name)
                          @function_defs[base_name] = member
                          @function_def_arenas[base_name] = @arena
                        end
                        @function_defs[full_name] = member
                        @function_def_arenas[full_name] = @arena
                      end
                    end
                  when CrystalV2::Compiler::Frontend::GetterNode
                    member.specs.each do |spec|
                      offset = register_accessor_from_module(
                        class_name,
                        spec,
                        ivars,
                        offset,
                        defined_full_names,
                        is_struct,
                        true,
                        false
                      )
                    end
                  when CrystalV2::Compiler::Frontend::SetterNode
                    member.specs.each do |spec|
                      offset = register_accessor_from_module(
                        class_name,
                        spec,
                        ivars,
                        offset,
                        defined_full_names,
                        is_struct,
                        false,
                        true
                      )
                    end
                  when CrystalV2::Compiler::Frontend::PropertyNode
                    member.specs.each do |spec|
                      offset = register_accessor_from_module(
                        class_name,
                        spec,
                        ivars,
                        offset,
                        defined_full_names,
                        is_struct,
                        true,
                        true
                      )
                    end
                  end
                end

                # Pass 2: Process IncludeNodes (included sub-module methods)
                body_ids.each do |member_id|
                  member = unwrap_visibility_member(@arena[member_id])
                  case member
                  when CrystalV2::Compiler::Frontend::IncludeNode
                    offset = register_module_instance_methods_for(
                      class_name,
                      member,
                      defined_full_names,
                      defined_class_method_full_names,
                      visited,
                      visited_extends,
                      ivars,
                      offset,
                      is_struct,
                      init_capture
                    )
                  end
                end
              end
            end
          end
        end
      end
      offset
    end

    private def register_module_class_methods_for(
      class_name : String,
      extend_target : ExprId,
      defined_full_names : Set(String),
      visited : Set(String),
    ) : Nil
      class_name = sanitize_type_name(class_name)

      module_full_name = resolve_path_like_name(extend_target)
      return unless module_full_name
      # Prefer nested modules under the extending class.
      if !module_full_name.includes?("::")
        base_owner = strip_generic_args(class_name)
        nested_name = "#{base_owner}::#{module_full_name}"
        module_full_name = nested_name if @module_defs.has_key?(nested_name)
      end
      module_full_name = resolve_module_alias_for_include(module_full_name)
      record_module_inclusion(module_full_name, class_name)
      return if visited.includes?(module_full_name)
      visited << module_full_name

      defs = @module_defs[module_full_name]? || return
      include_arena = @arena
      defs.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          extra_map = include_type_param_map(mod_node, extend_target, include_arena, class_name)
          with_type_param_map(extra_map) do
            if body = mod_node.body
              body_ids = body.not_nil!
              with_namespace_override(module_full_name) do
                body_ids.each do |member_id|
                  member = unwrap_visibility_member(@arena[member_id])
                  case member
                  when CrystalV2::Compiler::Frontend::IncludeNode
                    register_module_class_methods_for(class_name, member.target, defined_full_names, visited)
                  when CrystalV2::Compiler::Frontend::DefNode
                    next if (recv = member.receiver) && String.new(recv) == "self"
                    next if member.is_abstract

                    method_name = String.new(member.name)
                    base_name = "#{class_name}.#{method_name}"
                    if env_get("DEBUG_EXTEND_REGISTER") && class_name.includes?("ImplInfo")
                      STDERR.puts "[EXTEND_REGISTER] class=#{class_name} method=#{method_name} base=#{base_name}"
                    end

                    type_literal_name = infer_type_literal_return_name_from_body(member, class_name)
                    return_type = if rt = member.return_type
                                    rt_name = String.new(rt)
                                    inferred = module_like_type_name?(rt_name) ? infer_concrete_return_type_from_body(member, class_name) : nil
                                    inferred || type_ref_for_name(rt_name)
                                  elsif method_name.ends_with?('?')
                                    inferred = infer_unannotated_query_return_type(method_name, type_ref_for_name(class_name))
                                    inferred ||= infer_concrete_return_type_from_body(member, class_name)
                                    inferred || TypeRef::BOOL
                                  else
                                    inferred = infer_concrete_return_type_from_body(member, class_name)
                                    inferred ||= infer_unannotated_search_return_type(method_name, type_ref_for_name(class_name))
                                    inferred || TypeRef::VOID
                                  end
                    if type_literal_name
                      literal_ref = type_ref_for_name(type_literal_name)
                      if return_type == TypeRef::VOID || return_type == TypeRef::NIL
                        return_type = literal_ref if literal_ref != TypeRef::VOID
                      end
                    end

                    param_types = [] of TypeRef
                    has_block = false
                    if params = member.params
                      params.each do |param|
                        next if named_only_separator?(param)
                        if param.is_block
                          has_block = true
                          next
                        end
                        param_type = if ta = param.type_annotation
                                       type_ref_for_name(String.new(ta))
                                     elsif param.is_double_splat
                                       type_ref_for_name("NamedTuple")
                                     else
                                       TypeRef::VOID
                                     end
                        param_types << param_type
                      end
                    end

                    full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
                    next if defined_full_names.includes?(full_name)
                    next if @function_types.has_key?(full_name)

                    store_function_type_param_map(full_name, base_name, extra_map)
                    store_function_namespace_override(full_name, base_name, module_full_name)
                    debug_hook("module.class_method.register", "class=#{class_name} module=#{module_full_name} method=#{method_name} full=#{full_name}")
                    if type_literal_name
                      literal_ref = type_ref_for_name(type_literal_name)
                      if literal_ref != TypeRef::VOID
                        record_type_literal_return(full_name, base_name)
                      end
                    end
                    register_function_type(full_name, return_type)
                    @function_defs[full_name] = member
                    @function_def_arenas[full_name] = @arena
                  end
                end
              end
            end
          end
        end
      end
    end

    private def lower_module_instance_methods_for(
      class_name : String,
      class_info : ClassInfo,
      include_node : CrystalV2::Compiler::Frontend::IncludeNode,
      defined_full_names : Set(String),
      visited : Set(String),
    )
      module_full_name = resolve_path_like_name(include_node.target)
      return unless module_full_name
      # Prefer nested modules under the including class.
      if !module_full_name.includes?("::")
        base_owner = strip_generic_args(class_name)
        nested_name = "#{base_owner}::#{module_full_name}"
        module_full_name = nested_name if @module_defs.has_key?(nested_name)
      end
      module_full_name = resolve_module_alias_for_include(module_full_name)
      record_module_inclusion(module_full_name, class_name)
      return if visited.includes?(module_full_name)
      visited << module_full_name

      debug_hook("mixin.lower", "class=#{class_name} module=#{module_full_name}")

      defs = @module_defs[module_full_name]? || return
      include_arena = @arena
      defs.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          extra_map = include_type_param_map(mod_node, include_node.target, include_arena, class_name)
          with_type_param_map(extra_map) do
            if macro_lookup = lookup_macro_entry("included", module_full_name)
              macro_entry, macro_key = macro_lookup
              macro_def, macro_arena = macro_entry
              expanded_id = expand_macro_expr(macro_def, macro_arena, [] of ExprId, nil, nil, macro_key)
              unless expanded_id.invalid?
                old_arena = @arena
                @arena = macro_arena
                begin
                  lower_class_body_expr(class_name, class_info, expanded_id, defined_full_names, visited)
                ensure
                  @arena = old_arena
                end
              end
            end
            if body = mod_node.body
              with_namespace_override(module_full_name) do
                # Two-pass approach: process direct DefNodes FIRST, then IncludeNodes.
                # This ensures module-local overrides (e.g., Indexable#empty? overriding
                # Enumerable#empty?) take priority over methods found through includes.

                # Pass 1: Direct definitions (DefNode, GetterNode, SetterNode, PropertyNode)
                body.each do |member_id|
                  member = unwrap_visibility_member(@arena[member_id])
                  if member.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode)
                    remember_effect_annotation(member, @arena)
                    next
                  elsif !member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
                    clear_pending_effect_annotations
                  end
                  case member
                  when CrystalV2::Compiler::Frontend::DefNode
                    next if (recv = member.receiver) && String.new(recv) == "self"
                    next if member.is_abstract

                    method_name = String.new(member.name)
                    base_name = "#{class_name}##{method_name}"

                    if debug_hook_filter_match?(class_name, method_name)
                      block_type = ""
                      if params = member.params
                        if blk = params.find(&.is_block)
                          block_type = blk.type_annotation ? String.new(blk.type_annotation.not_nil!) : ""
                        end
                      end
                      debug_hook("method.lower.inspect", "class=#{class_name} method=#{method_name} block_type=#{block_type} map=#{type_param_map_debug_string}")
                    end

                    block_unbound = false
                    if params = member.params
                      params.each do |param|
                        next unless param.is_block
                        if ta = param.type_annotation
                          if type_param_name = extract_proc_return_type_name(String.new(ta))
                            if type_param_like?(type_param_name) && !@type_param_map.has_key?(type_param_name)
                              block_unbound = true
                              break
                            end
                          end
                        end
                      end
                    end

                    has_untyped_params = false
                    if params = member.params
                      params.each do |param|
                        next if named_only_separator?(param)
                        next if param.is_block || param.is_splat || param.is_double_splat
                        if param.type_annotation.nil?
                          has_untyped_params = true
                          break
                        end
                      end
                    end
                    if env_get("DEBUG_DEFER_UNTYPED") && method_name == "compare_or_raise"
                      defer_now = defer_untyped_params_for_module?(mod_node, extra_map)
                      STDERR.puts "[DEFER_UNTYPED] module=#{module_full_name} defer=#{defer_now} untyped=#{has_untyped_params}"
                    end

                    if block_unbound || def_has_unbound_type_params?(member) ||
                       (defer_untyped_params_for_module?(mod_node, extra_map) && has_untyped_params)
                      reason = block_unbound ? "block_return_type_param" : "unbound_type_params"
                      if defer_untyped_params_for_module?(mod_node, extra_map) && has_untyped_params && !block_unbound
                        reason = "defer_untyped_params"
                      end
                      debug_hook("method.lower.defer", "class=#{class_name} method=#{method_name} reason=#{reason}")
                      if defer_untyped_params_for_module?(mod_node, extra_map) && has_untyped_params
                        param_types = [] of TypeRef
                        has_block = false
                        if params = member.params
                          params.each do |param|
                            next if named_only_separator?(param)
                            if param.is_block
                              has_block = true
                              next
                            end
                            if ta = param.type_annotation
                              param_types << type_ref_for_name(String.new(ta))
                            else
                              param_types << TypeRef::VOID
                            end
                          end
                        end

                        return_type = if rt = member.return_type
                                        type_ref_for_name(String.new(rt))
                                      elsif method_name.ends_with?('?')
                                        TypeRef::BOOL
                                      else
                                        TypeRef::VOID
                                      end

                        full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
                        unless defined_full_names.includes?(full_name) || @module.has_function?(full_name) || @function_defs.has_key?(full_name)
                          register_function_type(full_name, return_type)
                          register_pending_method_effects(full_name, param_types.size)
                          @function_defs[full_name] = member
                          @function_def_arenas[full_name] = @arena
                        end
                      end
                      next
                    end

                    param_types = [] of TypeRef
                    has_block = false
                    if params = member.params
                      params.each do |param|
                        next if named_only_separator?(param)
                        if param.is_block
                          has_block = true
                          next
                        end
                        if ta = param.type_annotation
                          param_types << type_ref_for_name(String.new(ta))
                        else
                          param_types << TypeRef::VOID
                        end
                      end
                    end

                    full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
                    next if defined_full_names.includes?(full_name)
                    next if @module.has_function?(full_name)

                    lower_method(class_name, class_info, member)
                  when CrystalV2::Compiler::Frontend::GetterNode
                    member.specs.each do |spec|
                      generate_getter_method(class_name, class_info, spec)
                    end
                  when CrystalV2::Compiler::Frontend::SetterNode
                    member.specs.each do |spec|
                      generate_setter_method(class_name, class_info, spec)
                    end
                  when CrystalV2::Compiler::Frontend::PropertyNode
                    member.specs.each do |spec|
                      generate_getter_method(class_name, class_info, spec)
                      generate_setter_method(class_name, class_info, spec)
                    end
                  end
                end

                # Pass 2: Process IncludeNodes (included module methods)
                body.each do |member_id|
                  member = unwrap_visibility_member(@arena[member_id])
                  case member
                  when CrystalV2::Compiler::Frontend::IncludeNode
                    lower_module_instance_methods_for(class_name, class_info, member, defined_full_names, visited)
                  end
                end
              end
            end
          end
        end
      end
    end

    private def lower_module_class_methods_for(
      class_name : String,
      class_info : ClassInfo,
      extend_target : ExprId,
      visited : Set(String),
    )
      module_full_name = resolve_path_like_name(extend_target)
      return unless module_full_name
      if !module_full_name.includes?("::")
        base_owner = strip_generic_args(class_name)
        nested_name = "#{base_owner}::#{module_full_name}"
        module_full_name = nested_name if @module_defs.has_key?(nested_name)
      end
      module_full_name = resolve_module_alias_for_include(module_full_name)
      return if visited.includes?(module_full_name)
      visited << module_full_name

      defs = @module_defs[module_full_name]? || return
      include_arena = @arena
      defs.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          extra_map = include_type_param_map(mod_node, extend_target, include_arena, class_name)
          with_type_param_map(extra_map) do
            if body = mod_node.body
              with_namespace_override(module_full_name) do
                body.each do |member_id|
                  member = unwrap_visibility_member(@arena[member_id])
                  if member.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode)
                    remember_effect_annotation(member, @arena)
                    next
                  elsif !member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
                    clear_pending_effect_annotations
                  end
                  case member
                  when CrystalV2::Compiler::Frontend::IncludeNode
                    lower_module_class_methods_for(class_name, class_info, member.target, visited)
                  when CrystalV2::Compiler::Frontend::DefNode
                    next if (recv = member.receiver) && String.new(recv) == "self"
                    next if member.is_abstract
                    lower_method(class_name, class_info, member, force_class_method: true)
                  end
                end
              end
            end
          end
        end
      end
    end

    private def class_like_namespace?(name : String) : Bool
      return true if @class_info.has_key?(name)
      return true if @generic_templates.has_key?(name)
      return true if @top_level_class_kinds.has_key?(name)
      false
    end

    private def class_method_fallback_from_module(resolved_name : String, method_name : String) : String?
      return nil unless @module_defs.has_key?(resolved_name)
      return nil if is_module_method?(resolved_name, method_name)
      short_name = last_namespace_component(resolved_name)
      return nil if short_name.empty?
      return nil unless @class_info.has_key?(short_name) || @top_level_class_kinds.has_key?(short_name)
      return short_name if resolve_class_method_with_inheritance(short_name, method_name)
      return short_name if @function_types.has_key?("#{short_name}.#{method_name}") || has_function_base?("#{short_name}.#{method_name}")
      nil
    end

    private def upgrade_module_type_for_class(name : String, kind : TypeKind) : TypeRef?
      @module.types.each_with_index do |desc, idx|
        next unless desc.name == name
        next unless desc.kind == TypeKind::Module
        @module.types[idx] = TypeDescriptor.new(kind, name, desc.type_params)
        return TypeRef.new(TypeRef::FIRST_USER_TYPE + idx.to_u32)
      end
      nil
    end

    private def module_like_type_name?(name : String) : Bool
      base = if paren = name.index('(')
               name[0, paren]
             else
               name
             end
      return false if class_like_namespace?(base)
      return true if @module_defs.has_key?(base)
      return true if @module_includers.has_key?(base) || @module_includer_keys_by_suffix.has_key?(base)

      short_name = last_namespace_component(base)
      return true if @module_defs.has_key?(short_name)
      return true if @module_includers.has_key?(short_name) || @module_includer_keys_by_suffix.has_key?(short_name)

      false
    end

    private def module_type_ref?(type_ref : TypeRef) : Bool
      return false if type_ref == TypeRef::VOID
      if desc = @module.get_type_descriptor(type_ref)
        return true if desc.kind == TypeKind::Module
        # Some module-like types can be upgraded to Class in the descriptor,
        # but should still be treated as module values for call resolution.
        return module_like_type_name?(desc.name)
      end
      # Fallback: if the descriptor is missing, try resolving the type name.
      name = get_type_name_from_ref(type_ref)
      return module_like_type_name?(name) unless name.empty?
      false
    end

    private def resolve_included_type_name(name : String) : String?
      return nil if name.empty?
      return nil if name.includes?("::")

      # Nested types of the current class/namespace shadow included module types.
      return nil if current_or_override_has_nested_type?(name)

      namespaces = [] of String
      if override = @current_namespace_override
        if included = @class_included_modules[override]?
          included.each { |entry| namespaces << entry }
        end
      end
      if current = @current_class
        if included = @class_included_modules[current]?
          included.each { |entry| namespaces << entry }
        end
      end

      namespaces.each do |namespace|
        candidate = "#{namespace}::#{name}"
        return candidate if type_name_exists?(candidate)
      end

      nil
    end

    NILABLE_QUERY_METHODS = ["[]?", "at?", "first?", "last?", "pop?", "shift?"] of String

    # Known generic types that require type parameters for proper instantiation.
    # Used to skip lowering functions with bare generic parameter types.
    KNOWN_GENERIC_TYPES = Set{"Range", "Array", "Hash", "Set", "Slice", "Pointer", "Tuple", "NamedTuple", "StaticArray", "Deque", "Iterator", "Enumerable", "Indexable"}

    private def fallback_query_return_type(method_name : String) : TypeRef
      NILABLE_QUERY_METHODS.includes?(method_name) ? TypeRef::VOID : TypeRef::BOOL
    end

    # Some stdlib methods end in `?` but return a value (typically `T?` / `V?`) rather than `Bool`.
    # We need correct return types early (during signature registration) so callers lowered before the
    # callee body still get a stable type (avoids emitting `i1` where `i32`/union is expected).
    private def infer_unannotated_query_return_type(method_name : String, self_type : TypeRef) : TypeRef?
      return nil unless NILABLE_QUERY_METHODS.includes?(method_name)

      desc = @module.get_type_descriptor(self_type)
      return nil unless desc

      case desc.kind
      when TypeKind::Array
        elem = desc.type_params.first?
        return nil unless elem
        create_union_type_for_nullable(elem)
      when TypeKind::Hash
        value = desc.type_params[1]?
        return nil unless value
        create_union_type_for_nullable(value)
      when TypeKind::Class, TypeKind::Struct
        elem = desc.type_params.first?
        return nil unless elem
        base = desc.name
        if paren = base.index('(')
          base = base[0, paren]
        end
        short_base = last_namespace_component(base)
        case short_base
        when "Deque", "Slice", "StaticArray", "Set"
          create_union_type_for_nullable(elem)
        when "PointerLinkedList"
          elem_name = get_type_name_from_ref(elem)
          if elem_name.empty? || elem_name == "Void" || elem_name == "Unknown"
            if info = split_generic_base_and_args(desc.name)
              elem_name = info[:args].strip
            end
          end
          return nil if elem_name.empty? || elem_name == "Void" || elem_name == "Unknown"
          ptr_ref = type_ref_for_name("Pointer(#{elem_name})")
          return nil if ptr_ref == TypeRef::VOID
          create_union_type_for_nullable(ptr_ref)
        else
          nil
        end
      else
        nil
      end
    end

    private def infer_unannotated_search_return_type(method_name : String, self_type : TypeRef) : TypeRef?
      return nil if self_type == TypeRef::VOID
      case method_name
      when "bsearch"
        if desc = @module.get_type_descriptor(self_type)
          if elem_name = element_type_for_type_name(desc.name)
            elem_ref = type_ref_for_name(elem_name)
            return create_union_type_for_nullable(elem_ref) if elem_ref != TypeRef::VOID
          end
        end
      when "bsearch_index"
        return create_union_type_for_nullable(TypeRef::INT32)
      end
      nil
    end

    private def tail_expr_id_for_body(body : Array(ExprId)) : ExprId?
      return nil if body.empty?
      expr_id = body.last
      loop do
        expr_node = @arena[expr_id]
        case expr_node
        when CrystalV2::Compiler::Frontend::GroupingNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::MacroExpressionNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::ReturnNode
          value = expr_node.value
          return nil unless value
          expr_id = value
        else
          break
        end
      end
      expr_id
    end

    private def infer_type_literal_name_from_expr(expr_id : ExprId) : String?
      node = node_for_expr(expr_id)
      return nil unless node

      case node
      when CrystalV2::Compiler::Frontend::PathNode
        raw_path = collect_path_string(node)
        type_name = if path_is_absolute?(node)
                      raw_path.starts_with?("::") ? raw_path[2..] : raw_path
                    else
                      resolve_path_string_in_context(raw_path)
                    end
        type_name = resolve_type_name_in_context(type_name)
        type_name = resolve_type_alias_chain(type_name)
        return type_name if type_name_exists?(type_name) || @module_defs.has_key?(type_name) || @generic_templates.has_key?(type_name)
      when CrystalV2::Compiler::Frontend::GenericNode
        if type_name = stringify_type_expr(expr_id)
          type_name = resolve_type_name_in_context(type_name)
          type_name = resolve_type_alias_chain(type_name)
          return type_name if type_name_exists?(type_name) || @generic_templates.has_key?(type_name)
          if info = split_generic_base_and_args(type_name)
            base = info[:base]
            return type_name if @generic_templates.has_key?(base) || type_name_exists?(base)
          end
        end
      when CrystalV2::Compiler::Frontend::MacroIfNode
        result = try_evaluate_macro_condition(node.condition)
        if result == true
          return infer_type_literal_name_from_expr(node.then_body)
        elsif result == false
          if else_body = node.else_body
            return infer_type_literal_name_from_expr(else_body)
          end
        end
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        if raw_text = macro_literal_raw_text(node)
          text = raw_text.strip
          if text.includes?("{%")
            if expanded = expand_flag_macro_text(text)
              text = expanded.strip
            else
              return nil
            end
          end
          if text.match(/\A[A-Z][A-Za-z0-9_]*(::[A-Z][A-Za-z0-9_]*)*\z/)
            resolved = resolve_path_string_in_context(text)
            resolved = resolve_type_alias_chain(resolved)
            return resolved if type_name_exists?(resolved) || @module_defs.has_key?(resolved) || @generic_templates.has_key?(resolved)
          end
        end
      when CrystalV2::Compiler::Frontend::BlockNode
        if !node.body.empty?
          return infer_type_literal_name_from_expr(node.body.last)
        end
      end

      nil
    end

    private def infer_type_literal_return_name_from_body(
      node : CrystalV2::Compiler::Frontend::DefNode,
      self_type_name : String? = nil,
    ) : String?
      body = node.body
      return nil unless body && !body.empty?
      expr_id = tail_expr_id_for_body(body)
      return nil unless expr_id

      old_class = @current_class
      @current_class = self_type_name if self_type_name
      begin
        infer_type_literal_name_from_expr(expr_id)
      ensure
        @current_class = old_class
      end
    end

    private def infer_concrete_return_type_from_body(
      node : CrystalV2::Compiler::Frontend::DefNode,
      self_type_name : String? = nil,
    ) : TypeRef?
      # Skip expensive body inference when we're inside ensure_monomorphized_type.
      # Return types will be inferred lazily when the method is actually called.
      return nil if @defer_body_return_inference
      body = node.body
      method_name = String.new(node.name)
      debug_name = env_get("DEBUG_INFER_BODY_NAME")
      debug_infer = debug_name ? method_name.includes?(debug_name) : false
      if env_get("DEBUG_INFER_BODY") && method_name.includes?("internal_representation")
        STDERR.puts "[INFER_BODY] method=#{method_name} body_size=#{body.try(&.size) || 0} self=#{self_type_name || "nil"}"
      end
      return nil unless body && !body.empty?
      old_body_context = @infer_body_context
      old_method = @current_method
      old_class = @current_class
      old_def = @current_def_node
      resolved_arena = resolve_arena_for_def(node, @arena)
      if self_type_name
        sep = if recv = node.receiver
                String.new(recv) == "self" ? "." : "#"
              else
                "#"
              end
        full_name = "#{self_type_name}#{sep}#{method_name}"
        if arena = @function_def_arenas[full_name]?
          # Prefer the recorded arena when it matches this def.
          resolved_arena = arena if arena_fits_def?(arena, node)
        end
      end
      extra_type_params = {} of String => String
      if self_type_name
        full_name ||= "#{self_type_name}##{method_name}"
        if map = function_type_param_map_for(full_name, method_name)
          extra_type_params.merge!(map)
        end
        receiver_map = type_param_map_for_receiver_name(full_name)
        extra_type_params.merge!(receiver_map) unless receiver_map.empty?
      end
      @infer_body_context = body
      @current_method = method_name
      @current_class = self_type_name if self_type_name
      @current_def_node = node
      begin
        with_arena(resolved_arena) do
          if extra_type_params.empty?
            return infer_concrete_return_type_from_body_inner(body, self_type_name, method_name, resolved_arena, debug_infer)
          end
          return with_type_param_map(extra_type_params) do
            infer_concrete_return_type_from_body_inner(body, self_type_name, method_name, resolved_arena, debug_infer)
          end
        end
      ensure
        @infer_body_context = old_body_context
        @current_method = old_method
        @current_class = old_class
        @current_def_node = old_def
      end
    end

    private def infer_concrete_return_type_from_body_inner(
      body : Array(CrystalV2::Compiler::Frontend::ExprId),
      self_type_name : String?,
      method_name : String,
      resolved_arena : CrystalV2::Compiler::Frontend::ArenaLike,
      debug_infer : Bool,
    ) : TypeRef?
      return_types = [] of TypeRef
      body.each do |expr_id|
        collect_return_types(expr_id, self_type_name, return_types)
      end
      if return_types.any?
        inferred = merge_return_types(return_types)
        # If we have explicit returns, still consider the final expression
        # as a possible implicit return type.
        expr_id = body.last
        loop do
          expr_node = node_for_expr(expr_id)
          break unless expr_node
          case expr_node
          when CrystalV2::Compiler::Frontend::GroupingNode
            expr_id = expr_node.expression
          when CrystalV2::Compiler::Frontend::MacroExpressionNode
            expr_id = expr_node.expression
          when CrystalV2::Compiler::Frontend::ReturnNode
            value = expr_node.value
            break unless value
            expr_id = value
          else
            break
          end
        end
        if inferred && (tail_type = infer_type_from_expr(expr_id, self_type_name))
          inferred = union_type_for_values(inferred, tail_type) if tail_type != inferred
        end
        return inferred
      end

      # Use the last expression as a heuristic return (handles simple multi-line bodies).
      expr_id = body.last
      loop do
        expr_node = node_for_expr(expr_id)
        break unless expr_node
        case expr_node
        when CrystalV2::Compiler::Frontend::GroupingNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::MacroExpressionNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::ReturnNode
          value = expr_node.value
          return nil unless value
          expr_id = value
        else
          break
        end
      end

      if inferred = infer_type_from_expr(expr_id, self_type_name)
        if debug_infer
          inferred_name = get_type_name_from_ref(inferred)
          expr_node = node_for_expr(expr_id)
          expr_kind = expr_node ? expr_node.class.name.split("::").last : "nil"
          snippet = nil
          if source = @sources_by_arena[resolved_arena]?
            snippet = slice_source_for_expr_in_arena(expr_id, resolved_arena, source)
          end
          snippet_label = snippet ? " snippet=#{snippet}" : ""
          STDERR.puts "[INFER_BODY] method=#{method_name} expr=#{expr_kind} inferred=#{inferred_name}#{snippet_label}"
        end
        return inferred
      elsif debug_infer
        expr_node = node_for_expr(expr_id)
        expr_kind = expr_node ? expr_node.class.name.split("::").last : "nil"
        snippet = nil
        if source = @sources_by_arena[resolved_arena]?
          snippet = slice_source_for_expr_in_arena(expr_id, resolved_arena, source)
        end
        snippet_label = snippet ? " snippet=#{snippet}" : ""
        STDERR.puts "[INFER_BODY] method=#{method_name} expr=#{expr_kind} inferred=nil#{snippet_label}"
      end

      expr_node = node_for_expr(expr_id)
      case expr_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(expr_node.name)
        if inferred = infer_local_type_from_body(body, name, self_type_name)
          return inferred
        end
      when CrystalV2::Compiler::Frontend::AssignNode
        return infer_type_from_expr(expr_node.value, self_type_name)
      when CrystalV2::Compiler::Frontend::TypeDeclarationNode
        return type_ref_for_name(String.new(expr_node.declared_type))
      end

      nil
    end

    private def infer_return_type_from_body_without_callsite(
      node : CrystalV2::Compiler::Frontend::DefNode,
      self_type_name : String? = nil,
    ) : TypeRef?
      old_locals = @current_typeof_locals
      old_names = @current_typeof_local_names
      old_infer_cache = @infer_type_cache
      old_infer_cache_version = @infer_type_cache_version
      old_infer_cache_scope = @infer_type_cache_scope
      old_local_cache = @infer_local_type_cache
      old_local_nil_cache = @infer_local_type_nil_cache
      old_local_cache_scope = @infer_local_type_cache_scope
      @current_typeof_locals = nil
      @current_typeof_local_names = nil
      # Prevent cached inference results from a different callsite
      # from polluting return type inference.
      @infer_type_cache = {} of UInt64 => {Int32, TypeRef}
      @infer_local_type_cache = {} of {UInt64, String, String?} => {Int32, TypeRef}
      @infer_local_type_nil_cache = Set({UInt64, String, String?}).new
      @infer_type_cache_scope = nil
      @infer_local_type_cache_scope = nil
      @infer_type_cache_version += 1
      begin
        infer_concrete_return_type_from_body(node, self_type_name)
      ensure
        @current_typeof_locals = old_locals
        @current_typeof_local_names = old_names
        @infer_type_cache = old_infer_cache
        @infer_local_type_cache = old_local_cache
        @infer_local_type_nil_cache = old_local_nil_cache
        @infer_type_cache_scope = old_infer_cache_scope
        @infer_local_type_cache_scope = old_local_cache_scope
        @infer_type_cache_version = old_infer_cache_version
      end
    end

    private def record_type_literal_return(full_name : String, base_name : String) : Nil
      return if full_name.empty? && base_name.empty?
      @function_return_type_literals.add(full_name) unless full_name.empty?
      @function_return_type_literals.add(base_name) unless base_name.empty?
    end

    private def function_returns_type_literal?(mangled_name : String, base_name : String) : Bool
      return true if @function_return_type_literals.includes?(mangled_name)
      if mangled_base = strip_type_suffix(mangled_name)
        return true if @function_return_type_literals.includes?(mangled_base)
      end
      @function_return_type_literals.includes?(base_name)
    end

    private def collect_return_types(
      expr_id : ExprId,
      self_type_name : String?,
      output : Array(TypeRef),
    ) : Nil
      expr_node = node_for_expr(expr_id)
      return unless expr_node
      case expr_node
      when CrystalV2::Compiler::Frontend::ReturnNode
        if value = expr_node.value
          if inferred = infer_type_from_expr(value, self_type_name)
            output << inferred
          end
        else
          output << TypeRef::NIL
        end
      when CrystalV2::Compiler::Frontend::IfNode
        expr_node.then_body.each { |child| collect_return_types(child, self_type_name, output) }
        if elsifs = expr_node.elsifs
          elsifs.each do |branch|
            branch.body.each { |child| collect_return_types(child, self_type_name, output) }
          end
        end
        if else_body = expr_node.else_body
          else_body.each { |child| collect_return_types(child, self_type_name, output) }
        end
      when CrystalV2::Compiler::Frontend::CaseNode
        expr_node.when_branches.each do |branch|
          branch.body.each { |child| collect_return_types(child, self_type_name, output) }
        end
        if else_branch = expr_node.else_branch
          else_branch.each { |child| collect_return_types(child, self_type_name, output) }
        end
        if in_branches = expr_node.in_branches
          in_branches.each do |branch|
            branch.body.each { |child| collect_return_types(child, self_type_name, output) }
          end
        end
      when CrystalV2::Compiler::Frontend::BeginNode
        expr_node.body.each { |child| collect_return_types(child, self_type_name, output) }
        if clauses = expr_node.rescue_clauses
          clauses.each do |clause|
            clause.body.each { |child| collect_return_types(child, self_type_name, output) }
          end
        end
        if else_body = expr_node.else_body
          else_body.each { |child| collect_return_types(child, self_type_name, output) }
        end
        if ensure_body = expr_node.ensure_body
          ensure_body.each { |child| collect_return_types(child, self_type_name, output) }
        end
      when CrystalV2::Compiler::Frontend::BlockNode
        if body = expr_node.body
          body.each { |child| collect_return_types(child, self_type_name, output) }
        end
      when CrystalV2::Compiler::Frontend::CallNode
        block_expr = expr_node.block
        if block_expr.nil? && !expr_node.args.empty?
          last_id = expr_node.args.last
          last_node = node_for_expr(last_id)
          case last_node
          when CrystalV2::Compiler::Frontend::BlockNode
            block_expr = last_id
          when CrystalV2::Compiler::Frontend::UnaryNode
            if slice_eq?(last_node.operator, "&")
              operand = last_node.operand
              operand_node = node_for_expr(operand)
              block_expr = operand if operand_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
            end
          end
        end
        if block_expr
          if block_node = node_for_expr(block_expr)
            if block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if body = block_node.body
                body.each { |child| collect_return_types(child, self_type_name, output) }
              end
            end
          end
        end
      when CrystalV2::Compiler::Frontend::LoopNode
        expr_node.body.each { |child| collect_return_types(child, self_type_name, output) }
      when CrystalV2::Compiler::Frontend::ForNode
        expr_node.body.each { |child| collect_return_types(child, self_type_name, output) }
      end
    end

    private def merge_return_types(types : Array(TypeRef)) : TypeRef?
      return nil if types.empty?
      merged = types.first
      types[1..].each do |t|
        merged = union_type_for_values(merged, t)
      end
      merged
    end

    private def noreturn_expr?(expr_id : ExprId) : Bool
      node = node_for_expr(expr_id)
      return false unless node
      case node
      when CrystalV2::Compiler::Frontend::RaiseNode,
           CrystalV2::Compiler::Frontend::ReturnNode,
           CrystalV2::Compiler::Frontend::BreakNode,
           CrystalV2::Compiler::Frontend::NextNode
        true
      else
        false
      end
    end

    private def infer_type_from_expr(expr_id : ExprId, self_type_name : String?) : TypeRef?
      stats = env_get("DEBUG_LOWER_METHOD_STATS") ? @lower_method_stats_stack.last? : nil
      stats_start = stats ? Time.instant : nil
      if env_get("DEBUG_INFER_CRASH")
        STDERR.puts "[INFER_CALL] expr=#{expr_id.index} current=#{@arena.class}:#{@arena.size}"
      end
      arena = arena_for_expr?(expr_id)
      return nil unless arena
      return nil if expr_id.index >= arena.size

      if @current_class && @current_method
        scope = "#{@current_class}##{@current_method}"
        if scope != @infer_type_cache_scope
          @infer_type_cache.clear
          @infer_type_cache_version = 0
          @infer_type_guarded.clear
          @infer_type_cache_scope = scope
        end
      elsif @infer_type_cache_scope
        @infer_type_cache.clear
        @infer_type_cache_version = 0
        @infer_type_guarded.clear
        @infer_type_cache_scope = nil
      end

      old_arena = @arena
      @arena = arena
      key = (arena.object_id.to_u64 << 32) ^ expr_id.index.to_u64
      if cached = @infer_type_cache[key]?
        cached_version, cached_type = cached
        if cached_version == @infer_type_cache_version
          if stats && stats_start
            stats.infer_ms += (Time.instant - stats_start).total_milliseconds
            stats.infer_calls += 1
          end
          @arena = old_arena
          return cached_type
        end
      end
      if @infer_expr_stack.includes?(key)
        if @debug_infer_guard_enabled
          record_infer_guard_hit(expr_id)
        end
        @infer_type_guarded[key] = @infer_type_cache_version
        if stats && stats_start
          stats.infer_ms += (Time.instant - stats_start).total_milliseconds
          stats.infer_calls += 1
        end
        @arena = old_arena
        return nil
      end
      if guarded_version = @infer_type_guarded[key]?
        if guarded_version == @infer_type_cache_version
          if stats && stats_start
            stats.infer_ms += (Time.instant - stats_start).total_milliseconds
            stats.infer_calls += 1
          end
          @arena = old_arena
          return nil
        end
      end
      @infer_expr_stack.add(key)
      begin
        result = infer_type_from_expr_inner(expr_id, self_type_name)
        if result
          @infer_type_cache[key] = {@infer_type_cache_version, result}
        end
        if stats && stats_start
          stats.infer_ms += (Time.instant - stats_start).total_milliseconds
          stats.infer_calls += 1
        end
        result
      ensure
        @infer_expr_stack.delete(key)
        @arena = old_arena
      end
    end

    private def record_infer_guard_hit(expr_id : ExprId) : Nil
      @infer_guard_hits += 1
      now = Time.instant
      last = @infer_guard_last_report
      return if last && (now - last).total_seconds < 3.0 && (@infer_guard_hits % 200) != 0
      @infer_guard_last_report = now
      expr_node = expr_id.index < @arena.size ? @arena[expr_id] : nil
      kind = expr_node ? last_namespace_component(expr_node.class.name) : "nil"
      current = @current_class || "nil"
      method = @current_method || "nil"
      path = source_path_for(@arena) || "(unknown)"
      span_info = ""
      if expr_node
        span = expr_node.span
        if span_fits_source?(@arena, span)
          span_info = " span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column}"
        end
      end
      STDERR.puts "[INFER_GUARD] hits=#{@infer_guard_hits} expr=#{expr_id.index} kind=#{kind} current=#{current} method=#{method} file=#{File.basename(path)}#{span_info}"
    end

    private def infer_type_from_expr_inner(expr_id : ExprId, self_type_name : String?) : TypeRef?
      expr_node = @arena[expr_id]
      case expr_node
      when CrystalV2::Compiler::Frontend::NumberNode
        return type_ref_for_number_kind(expr_node.kind)
      when CrystalV2::Compiler::Frontend::BoolNode
        return TypeRef::BOOL
      when CrystalV2::Compiler::Frontend::NilNode
        return TypeRef::NIL
      when CrystalV2::Compiler::Frontend::StringNode, CrystalV2::Compiler::Frontend::StringInterpolationNode
        return TypeRef::STRING
      when CrystalV2::Compiler::Frontend::CharNode
        return TypeRef::CHAR
      when CrystalV2::Compiler::Frontend::SymbolNode
        return TypeRef::SYMBOL
      when CrystalV2::Compiler::Frontend::TupleLiteralNode
        element_names = [] of String
        expr_node.elements.each do |elem|
          elem_type = infer_type_from_expr(elem, self_type_name)
          return nil unless elem_type
          elem_name = get_type_name_from_ref(elem_type)
          return nil if elem_name == "Void" || elem_name == "Unknown"
          element_names << elem_name
        end
        return type_ref_for_name("Tuple(#{element_names.join(", ")})")
      when CrystalV2::Compiler::Frontend::RangeNode
        begin_type = infer_type_from_expr(expr_node.begin_expr, self_type_name)
        end_type = infer_type_from_expr(expr_node.end_expr, self_type_name)
        return nil unless begin_type && end_type
        begin_name = get_type_name_from_ref(begin_type)
        end_name = get_type_name_from_ref(end_type)
        return nil if begin_name == "Void" || begin_name == "Unknown"
        return nil if end_name == "Void" || end_name == "Unknown"
        return type_ref_for_name("Range(#{begin_name}, #{end_name})")
      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        entries = [] of String
        expr_node.entries.each do |entry|
          value_type = infer_type_from_expr(entry.value, self_type_name)
          return nil unless value_type
          value_name = get_type_name_from_ref(value_type)
          return nil if value_name == "Void" || value_name == "Unknown"
          entries << "#{String.new(entry.key)}: #{value_name}"
        end
        return type_ref_for_name("NamedTuple(#{entries.join(", ")})")
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        if of_type = expr_node.of_type
          if type_str = stringify_type_expr(of_type)
            element_name = normalize_declared_type_name(type_str)
            return type_ref_for_name("Array(#{element_name})")
          end
        end
        if first_id = expr_node.elements.first?
          if elem_type = infer_type_from_expr(first_id, self_type_name)
            elem_name = get_type_name_from_ref(elem_type)
            return type_ref_for_name("Array(#{elem_name})") if elem_name != "Void" && elem_name != "Unknown"
          end
        end
        return type_ref_for_name("Array(String)")
      when CrystalV2::Compiler::Frontend::YieldNode
        if @inline_yield_block_return_stack.size > 0
          if inferred = @inline_yield_block_return_stack.last?
            return type_ref_for_name(inferred) if inferred && !inferred.empty?
          elsif @inline_yield_block_return_stack.size >= 2
            if inferred = @inline_yield_block_return_stack[-2]?
              return type_ref_for_name(inferred) if inferred && !inferred.empty?
            end
          end
        end
        if @inline_yield_block_stack.size > 0
          outer_block = @inline_yield_block_stack.last
          outer_param_types = @inline_yield_block_param_types_stack.last?
          if inferred = inline_block_return_type_name(outer_block, outer_param_types, self_type_name)
            return type_ref_for_name(inferred)
          elsif @inline_yield_block_stack.size >= 2
            outer_block = @inline_yield_block_stack[-2]
            outer_param_types = @inline_yield_block_param_types_stack[-2]?
            if inferred = inline_block_return_type_name(outer_block, outer_param_types, self_type_name)
              return type_ref_for_name(inferred)
            end
          end
        end
      when CrystalV2::Compiler::Frontend::PathNode
        raw_path = collect_path_string(expr_node)
        absolute = raw_path.starts_with?("::")
        full_name = absolute ? raw_path[2..] : resolve_path_string_in_context(raw_path)
        if mapped = @type_param_map[full_name]?
          if literal = literal_for_type_param_value(mapped)
            return literal[0]
          end
        end
        if resolved = resolve_constant_name_in_context(full_name)
          if const_type = @constant_types[resolved]?
            return const_type if const_type != TypeRef::VOID
          end
          # Constant exists but type not yet determined — try literal value
          if literal = @constant_literal_values[resolved]?
            literal_type_name = literal.type_name
            inferred = type_ref_for_name(literal_type_name)
            if inferred != TypeRef::VOID
              @constant_types[resolved] = inferred
              return inferred
            end
          end
          # This IS a constant, not a type — don't fall through to type_name_exists
          # which would incorrectly treat the constant name as a type name
          return nil
        end
        parts = full_name.split("::")
        if parts.size >= 2
          member = parts.last
          enum_candidate = parts[0...-1].join("::")
          if enum_name = resolve_enum_name(enum_candidate)
            if enum_info = @enum_info
              if enum_info[enum_name]?.try(&.has_key?(member))
                enum_ref = type_ref_for_name(enum_name)
                return enum_ref == TypeRef::VOID ? enum_base_type(enum_name) : enum_ref
              end
            end
          end
        end
        if type_name_exists?(full_name)
          return type_ref_for_name(absolute ? raw_path : full_name)
        end
      when CrystalV2::Compiler::Frontend::ConstantNode
        name = String.new(expr_node.name)
        resolved = resolve_constant_name_in_context(name)
        if debug_filter = env_get("DEBUG_INFER_CONST")
          if debug_filter == "1" || name.includes?(debug_filter) || (resolved && resolved.includes?(debug_filter))
            type_name = resolved ? @constant_types[resolved]?.try { |t| get_type_name_from_ref(t) } : nil
            STDERR.puts "[INFER_CONST] name=#{name} resolved=#{resolved || "nil"} type=#{type_name || "nil"}"
          end
        end
        if resolved
          if const_type = @constant_types[resolved]?
            return const_type if const_type != TypeRef::VOID
          end
          # Constant exists but type not yet determined — try literal value
          if literal = @constant_literal_values[resolved]?
            literal_type_name = literal.type_name
            inferred = type_ref_for_name(literal_type_name)
            if inferred != TypeRef::VOID
              @constant_types[resolved] = inferred
              return inferred
            end
          end
        end
        # Fallback: if the constant name is a known type, treat as type literal.
        # This handles patterns like read_bytes(UInt32, format) where UInt32 is
        # passed as a type value (metaclass argument).
        # Only do this if the name was NOT resolved as a constant — constants
        # should use their value type, not be treated as type names.
        unless resolved
          qualified = resolve_class_name_in_context(name)
          if type_name_exists?(qualified)
            return type_ref_for_name(qualified)
          end
        end
      when CrystalV2::Compiler::Frontend::GroupingNode
        return infer_type_from_expr(expr_node.expression, self_type_name)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        return infer_type_from_expr(expr_node.expression, self_type_name)
      when CrystalV2::Compiler::Frontend::AsNode
        return type_ref_for_name(String.new(expr_node.target_type))
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        member_name = String.new(expr_node.member)
        if env_get("DEBUG_INFER_MEMBER_ACCESS") && member_name == "value"
          STDERR.puts "[INFER_MEMBER_ACCESS] member=#{member_name} self_type=#{self_type_name || "nil"}"
        end
        object_node = node_for_expr(expr_node.object)
        lib_name = case object_node
                   when CrystalV2::Compiler::Frontend::ConstantNode
                     resolved = resolve_class_name_in_context(String.new(object_node.name))
                     resolved = resolve_type_alias_chain(resolved)
                     @module.is_lib?(resolved) ? resolved : nil
                   when CrystalV2::Compiler::Frontend::IdentifierNode
                     name = String.new(object_node.name)
                     if name[0]?.try(&.uppercase?)
                       resolved = resolve_class_name_in_context(name)
                       resolved = resolve_type_alias_chain(resolved)
                       @module.is_lib?(resolved) ? resolved : nil
                     end
                   when CrystalV2::Compiler::Frontend::PathNode
                     raw_path = collect_path_string(object_node)
                     full_path = path_is_absolute?(object_node) ? raw_path.sub(/^::/, "") : resolve_path_string_in_context(raw_path)
                     @module.is_lib?(full_path) ? full_path : nil
                   else
                     nil
                   end
        if lib_name
          if extern = @module.get_extern_global(lib_name, member_name)
            return extern.type
          end
        end
        if member_name == "new"
          if type_str = stringify_type_expr(expr_node.object)
            if local_name = @current_typeof_local_names.try(&.[type_str]?)
              type_str = local_name unless local_name.empty?
            elsif local_ref = @current_typeof_locals.try(&.[type_str]?)
              local_type_name = get_type_name_from_ref(local_ref)
              type_str = local_type_name unless local_type_name.empty? || local_type_name == "Void" || local_type_name == "Unknown"
            end
            if env_get("DEBUG_INT_CLASS") && type_str == "int_class"
              STDERR.puts "[INT_CLASS_NEW] scope=#{@current_class || "nil"}##{@current_method || "nil"} raw=#{type_str}"
            end
            if type_str[0]?.try(&.uppercase?) || type_str.includes?("::")
              if ref = type_ref_for_name(type_str)
                return ref if ref != TypeRef::VOID
              end
            end
          end
          if obj_type = infer_type_from_expr(expr_node.object, self_type_name)
            return obj_type if obj_type != TypeRef::VOID
          end
        end
        # Numeric conversion methods have well-defined return types based on method name
        # These are stdlib primitives, not arbitrary user methods
        if conv_type = conversion_method_return_type(member_name)
          return conv_type
        end
        if member_name == "size"
          if object_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            object_name = String.new(object_node.name)
            # Macro patterns like {{T.size}} use type params; treat as Int32 for signature inference.
            if object_name == "T" || object_name == "U" || object_name == "V" ||
               object_name == "K" || object_name == "E" || object_name == "B" ||
               object_name == "L" || object_name == "W"
              return TypeRef::INT32
            end
          end
        end
        if obj_type = infer_type_from_expr(expr_node.object, self_type_name)
          if obj_type != TypeRef::VOID
            class_name = get_type_name_from_ref(obj_type)
            # For struct getters, check if there's an ivar matching the member name
            # and return its type directly
            if env_get("DEBUG_STRUCT_GETTER_INFER") && member_name == "hash"
              STDERR.puts "[STRUCT_GETTER_INFER_CHECK] class=#{class_name} has_info=#{@class_info.has_key?(class_name)}"
            end
            if member_name == "first" || member_name == "last" || member_name == "first?" || member_name == "last?"
              type_desc = @module.get_type_descriptor(obj_type)
              type_name = type_desc ? type_desc.name : class_name
              if elem_name = element_type_for_type_name(type_name)
                elem_ref = type_ref_for_name(elem_name)
                if elem_ref != TypeRef::VOID
                  return member_name.ends_with?('?') ? create_union_type_for_nullable(elem_ref) : elem_ref
                end
              end
            end
            if info = @class_info[class_name]?
              if info.is_struct
                if ivar_info = info.ivars.find { |iv| iv.name == "@#{member_name}" }
                  if env_get("DEBUG_STRUCT_GETTER_INFER") && member_name == "hash"
                    STDERR.puts "[STRUCT_GETTER_INFER] #{class_name}##{member_name} -> #{get_type_name_from_ref(ivar_info.type)}"
                  end
                  return ivar_info.type
                end
              end
            elsif member_name == "hash" && class_name.starts_with?("Tuple(")
              # Special case: block parameter might be an Entry struct mistyped as Tuple
              # The Tuple(K, V) might actually be an Entry(K, V) struct from Hash iteration
              # Use the tuple type args to construct the Entry type
              if tuple_args = split_generic_type_args(class_name[6...-1])
                # Entry has (key, value) matching Tuple(K, V)
                entry_params = tuple_args.join(", ")
                entry_name = "Hash::Entry(#{entry_params})"
                if entry_info = @class_info[entry_name]?
                  if entry_info.is_struct
                    if ivar_info = entry_info.ivars.find { |iv| iv.name == "@hash" }
                      if env_get("DEBUG_STRUCT_GETTER_INFER")
                        STDERR.puts "[STRUCT_GETTER_INFER_ENTRY] tuple=#{class_name} -> entry=#{entry_name} type=#{get_type_name_from_ref(ivar_info.type)}"
                      end
                      return ivar_info.type
                    end
                  end
                end
              end
              if env_get("DEBUG_STRUCT_GETTER_INFER")
                STDERR.puts "[STRUCT_GETTER_INFER_MISS] #{class_name}##{member_name} - no class_info"
              end
            elsif env_get("DEBUG_STRUCT_GETTER_INFER") && member_name == "hash" && class_name.includes?("Entry")
              STDERR.puts "[STRUCT_GETTER_INFER_MISS] #{class_name}##{member_name} - no class_info"
            end
            # First try the fully specialized class name for struct getters
            base_name = resolve_method_with_inheritance(class_name, member_name)
            if base_name.nil?
              # Fall back to base name (without generic params) for inherited methods
              owner_name = split_generic_base_and_args(class_name).try(&.[](:base)) || class_name
              base_name = resolve_method_with_inheritance(owner_name, member_name) || "#{owner_name}##{member_name}"
            end
            ret_type = resolve_return_type_from_def(base_name, base_name, obj_type)
            if ret_type && ret_type != TypeRef::VOID
              return ret_type
            end
            ret_type = get_function_return_type(base_name)
            if ret_type != TypeRef::VOID
              return ret_type
            end
            # Fallback for to_unsafe on array-like types when return type isn't registered yet.
            if member_name == "to_unsafe"
              if elem_name = element_type_for_type_name(class_name)
                ptr_ref = type_ref_for_name("Pointer(#{elem_name})")
                return ptr_ref if ptr_ref != TypeRef::VOID
              end
            end
            # Special handling for Pointer#value - return dereferenced type
            if member_name == "value"
              ptr_desc = @module.get_type_descriptor(obj_type)
              if ptr_desc && ptr_desc.name.starts_with?("Pointer(") && ptr_desc.name.ends_with?(')')
                elem_name = ptr_desc.name[8...-1]
                elem_ref = type_ref_for_name(elem_name)
                if env_get("DEBUG_PTR_VALUE_INFER")
                  STDERR.puts "[PTR_VALUE_INFER] desc=#{ptr_desc.name} elem=#{elem_name} elem_ref=#{get_type_name_from_ref(elem_ref)}"
                end
                return elem_ref if elem_ref != TypeRef::VOID
              elsif env_get("DEBUG_PTR_VALUE_INFER")
                STDERR.puts "[PTR_VALUE_INFER] obj_type=#{obj_type.id} no_desc class=#{class_name}"
              end
            end
            # Enum#value — enums are stored as their base integer type, .value is identity
            if member_name == "value" && (signed_integer_type?(obj_type) || unsigned_integer_type?(obj_type))
              return obj_type
            end
            if member_name == "clone" || member_name == "dup"
              return obj_type
            end
            if env_get("DEBUG_INFER_MEMBER") && (member_name == "first" || member_name == "address")
              STDERR.puts "[INFER_MEMBER] member=#{member_name} owner=#{owner_name} type=#{class_name} base=#{base_name} ret=Void"
            end
          end
        end
      when CrystalV2::Compiler::Frontend::ReturnNode
        value = expr_node.value
        return nil unless value
        return infer_type_from_expr(value, self_type_name)
      when CrystalV2::Compiler::Frontend::SelfNode
        return type_ref_for_name(self_type_name) if self_type_name
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(expr_node.name)
        if env_get("DEBUG_INT_CLASS") && name == "int_class"
          local_ref = @current_typeof_locals.try(&.[name]?)
          local_name = @current_typeof_local_names.try(&.[name]?)
          ref_name = local_ref ? get_type_name_from_ref(local_ref) : "nil"
          STDERR.puts "[INT_CLASS] scope=#{@current_class || "nil"}##{@current_method || "nil"} locals_ref=#{ref_name} locals_name=#{local_name || "nil"}"
        end
        if name.starts_with?('@')
          if name.starts_with?("@@")
            cvar_name = name.lstrip('@')
            cvar_type = get_class_var_type(cvar_name)
            return cvar_type if cvar_type != TypeRef::VOID
          elsif self_type_name
            if info = @class_info[self_type_name]?
              ivar = info.ivars.find { |iv| iv.name == name }
              return ivar.type if ivar
            end
          end
        end
        if mapped = @type_param_map[name]?
          if literal = literal_for_type_param_value(mapped)
            return literal[0]
          end
        end
        if self_type_name && String.new(expr_node.name) == "self"
          return type_ref_for_name(self_type_name)
        end
        if name[0]?.try(&.uppercase?)
          resolved = resolve_constant_name_in_context(name)
          if debug_filter = env_get("DEBUG_INFER_CONST")
            if debug_filter == "1" || name.includes?(debug_filter) || (resolved && resolved.includes?(debug_filter))
              type_name = resolved ? @constant_types[resolved]?.try { |t| get_type_name_from_ref(t) } : nil
              STDERR.puts "[INFER_CONST] ident=#{name} resolved=#{resolved || "nil"} type=#{type_name || "nil"}"
            end
          end
          if resolved
            if const_type = @constant_types[resolved]?
              return const_type if const_type != TypeRef::VOID
            end
          end
          # Fallback: if the identifier is a known type name, treat as type literal.
          # Handles patterns like read_bytes(UInt32, format) where UInt32 is
          # a type value (metaclass argument).
          qualified = resolve_class_name_in_context(name)
          if type_name_exists?(qualified)
            return type_ref_for_name(qualified)
          end
        end
        if locals = @current_typeof_locals
          if type_ref = locals[name]?
            return type_ref if type_ref != TypeRef::VOID
          end
        end
        if type_name = lookup_typeof_local_name(String.new(expr_node.name))
          return type_ref_for_name(type_name)
        end
        if @current_method
          owner_name = self_type_name || @current_class
          if owner_name
            def_node = @current_def_node
            if def_node.nil?
              base = "#{owner_name}#{@current_method_is_class ? "." : "#"}#{@current_method}"
              def_node = lookup_function_def_for_return(base, base)
              if def_node.nil?
                alt_base = @current_method_is_class ? "#{owner_name}##{@current_method}" : "#{owner_name}.#{@current_method}"
                def_node = lookup_function_def_for_return(alt_base, alt_base)
              end
            end
            if def_node
              if params = def_node.params
                params.each do |param|
                  next unless param.name && slice_eq?(param.name, name)
                  if type_slice = param.type_annotation
                    type_name = normalize_declared_type_name(String.new(type_slice), owner_name)
                    param_ref = type_ref_for_name(type_name)
                    if filter = env_get("DEBUG_PARAM_INFER")
                      if filter == "1" || name.includes?(filter) || owner_name.includes?(filter)
                        STDERR.puts "[PARAM_INFER] owner=#{owner_name} method=#{@current_method} name=#{name} type=#{type_name}"
                      end
                    end
                    return param_ref if param_ref != TypeRef::VOID
                  end
                end
              end
            end
          end
        end
        if body = @infer_body_context
          if inferred = infer_local_type_from_body(body, name, self_type_name)
            if env_get("DEBUG_LOCAL_INFER") && name == "ptr"
              STDERR.puts "[LOCAL_INFER] name=#{name} inferred=#{get_type_name_from_ref(inferred)}"
            end
            return inferred
          elsif env_get("DEBUG_LOCAL_INFER") && name == "ptr"
            STDERR.puts "[LOCAL_INFER] name=#{name} inferred=nil body_size=#{body.size}"
          end
        elsif env_get("DEBUG_LOCAL_INFER") && name == "ptr"
          STDERR.puts "[LOCAL_INFER] name=#{name} no_body_context"
        end
        if owner_name = (self_type_name || @current_class)
          if class_method_base = resolve_method_with_inheritance(owner_name, name)
            receiver_ref = type_ref_for_name(owner_name)
            if receiver_ref != TypeRef::VOID
              if ret_type = resolve_return_type_from_def(class_method_base, class_method_base, receiver_ref)
                return ret_type if ret_type != TypeRef::VOID
              end
            end
            ret_type = get_function_return_type(class_method_base)
            return ret_type if ret_type != TypeRef::VOID
          end
          module_method_base = "#{owner_name}.#{name}"
          if @function_types.has_key?(module_method_base) ||
             has_function_base?(module_method_base) ||
             @class_accessor_entries.has_key?(module_method_base)
            ret_type = get_function_return_type(module_method_base)
            ret_type = @function_types[module_method_base]? if ret_type == TypeRef::VOID
            return ret_type if ret_type && ret_type != TypeRef::VOID
          end
        end
        if ret_type = @function_types[name]?
          return ret_type if ret_type != TypeRef::VOID
        end
        if cached = @function_base_return_types[name]?
          return cached if cached != TypeRef::VOID
        end
      when CrystalV2::Compiler::Frontend::AssignNode
        value_id = expr_node.value
        value_node = node_for_expr(value_id)
        value_type = nil
        if value_node.is_a?(CrystalV2::Compiler::Frontend::BinaryNode)
          op = value_node.operator_string
          if op == "&&" || op == "||"
            left_type = infer_type_from_expr(value_node.left, self_type_name)
            right_noreturn = (op == "||") && noreturn_expr?(value_node.right)
            if right_noreturn
              if left_type && left_type != TypeRef::VOID
                value_type = non_nil_type_for_union(left_type) || left_type
              end
            else
              right_type = infer_type_from_expr(value_node.right, self_type_name)
              if left_type && right_type
                value_type = union_type_for_values(left_type, right_type)
              end
              value_type ||= left_type if left_type && left_type != TypeRef::VOID
              value_type ||= right_type if right_type && right_type != TypeRef::VOID
            end
            if env_get("DEBUG_INFER_ASSIGN") && value_type.nil?
              left_name = left_type ? get_type_name_from_ref(left_type) : "nil"
              right_name = right_type ? get_type_name_from_ref(right_type) : "nil"
              STDERR.puts "[INFER_ASSIGN] op=#{op} left=#{left_name} right=#{right_name} self=#{self_type_name || "nil"}"
              if self_type_name == "Fiber"
                left_node = node_for_expr(value_node.left)
                right_node = node_for_expr(value_node.right)
                STDERR.puts "[INFER_ASSIGN_NODE] left=#{left_node.class.name.split("::").last} right=#{right_node.class.name.split("::").last}"
              end
            end
          end
        end
        value_type ||= infer_type_from_expr(value_id, self_type_name)
        if value_type && value_type != TypeRef::VOID
          if target = node_for_expr(expr_node.target)
            if target.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
              name = String.new(target.name)
              update_typeof_local(name, value_type)
              if concrete_name = concrete_type_name_for(value_type)
                existing_name = lookup_typeof_local_name(name)
                if existing_name.nil? || module_like_type_name?(existing_name)
                  update_typeof_local_name(name, concrete_name)
                end
              end
            end
          end
        end
        return value_type
      when CrystalV2::Compiler::Frontend::InstanceVarNode
        if self_type_name
          if info = @class_info[self_type_name]?
            ivar_name = String.new(expr_node.name)
            if ivar = info.ivars.find { |iv| iv.name == ivar_name }
              return ivar.type
            end
          end
        end
      when CrystalV2::Compiler::Frontend::ClassVarNode
        raw_name = String.new(expr_node.name)
        name = raw_name.lstrip('@')
        cvar_type = get_class_var_type(name)
        if cvar_type == TypeRef::VOID
          owner_name = self_type_name || @current_class
          if inferred = infer_class_var_type_from_owner(owner_name, name)
            cvar_type = inferred
          end
          if cvar_type == TypeRef::VOID && owner_name && owner_name.includes?("::")
            parts = owner_name.split("::")
            (parts.size - 1).downto(1) do |i|
              parent_name = parts[0, i].join("::")
              if inferred = infer_class_var_type_from_owner(parent_name, name)
                cvar_type = inferred
                break
              end
            end
          end
        end
        return cvar_type if cvar_type != TypeRef::VOID
      when CrystalV2::Compiler::Frontend::CallNode
        block_expr = expr_node.block
        block_pass_expr : ExprId? = nil
        if block_expr.nil? && !expr_node.args.empty?
          last_id = expr_node.args.last
          last_node = node_for_expr(last_id)
          case last_node
          when CrystalV2::Compiler::Frontend::BlockNode
            block_expr = last_id
          when CrystalV2::Compiler::Frontend::UnaryNode
            if String.new(last_node.operator) == "&"
              operand = last_node.operand
              operand_node = node_for_expr(operand)
              if operand_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                block_expr = operand
              else
                block_pass_expr = operand
              end
            end
          end
        end

        callee_node = node_for_expr(expr_node.callee)
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          member_name = String.new(callee_node.member)
          if member_name == "bsearch" || member_name == "bsearch_index"
            if recv_type = infer_type_from_expr(callee_node.object, self_type_name)
              if recv_type != TypeRef::VOID
                recv_name = get_type_name_from_ref(recv_type)
                if member_name == "bsearch"
                  if elem_name = element_type_for_type_name(recv_name)
                    elem_ref = type_ref_for_name(elem_name)
                    if elem_ref != TypeRef::VOID
                      return create_union_type_for_nullable(elem_ref)
                    end
                  end
                else
                  return create_union_type_for_nullable(TypeRef::INT32)
                end
              end
            end
          end
          if member_name == "try"
            receiver_type = infer_type_from_expr(callee_node.object, self_type_name)
            if receiver_type && receiver_type != TypeRef::VOID
              block_id = expr_node.block
              if block_id.nil? && !expr_node.args.empty?
                last_id = expr_node.args.last
                last_node = node_for_expr(last_id)
                case last_node
                when CrystalV2::Compiler::Frontend::BlockNode
                  block_id = last_id
                when CrystalV2::Compiler::Frontend::UnaryNode
                  if String.new(last_node.operator) == "&"
                    operand = last_node.operand
                    operand_node = node_for_expr(operand)
                    if operand_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                      block_id = operand
                    end
                  end
                end
              end
              if env_get("DEBUG_INFER_TRY")
                recv_name = get_type_name_from_ref(receiver_type)
                block_kind = block_id ? (node_for_expr(block_id).class.to_s) : "nil"
                STDERR.puts "[INFER_TRY] recv=#{recv_name} block=#{block_kind}"
              end
              if block_id && !block_id.invalid?
                non_nil_type = non_nil_type_for_union(receiver_type) || receiver_type
                if env_get("DEBUG_INFER_TRY")
                  non_nil_name = get_type_name_from_ref(non_nil_type)
                  STDERR.puts "[INFER_TRY] non_nil=#{non_nil_name}"
                end
                if block_return = infer_try_block_return_type(block_id, [non_nil_type], self_type_name)
                  if env_get("DEBUG_INFER_TRY")
                    ret_name = get_type_name_from_ref(block_return)
                    STDERR.puts "[INFER_TRY] return=#{ret_name}"
                  end
                  return TypeRef::NIL if block_return == TypeRef::VOID || block_return == TypeRef::NIL
                  return block_return if is_union_or_nilable_type?(block_return)
                  return create_union_type_for_nullable(block_return)
                end
              elsif !expr_node.args.empty?
                # Handle block pass shorthand (&.method) for try, which isn't a BlockNode.
                last_id = expr_node.args.last
                last_node = node_for_expr(last_id)
                if last_node.is_a?(CrystalV2::Compiler::Frontend::UnaryNode) &&
                   String.new(last_node.operator) == "&"
                  operand_node = node_for_expr(last_node.operand)
                  if operand_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
                    callee = node_for_expr(operand_node.callee)
                    if callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                      member = String.new(callee.member)
                      non_nil_type = non_nil_type_for_union(receiver_type) || receiver_type
                      owner_name = get_type_name_from_ref(non_nil_type)
                      base_name = resolve_method_with_inheritance(owner_name, member) || "#{owner_name}##{member}"
                      if ret = resolve_return_type_from_def(base_name, base_name, non_nil_type)
                        return ret if is_union_or_nilable_type?(ret)
                        return create_union_type_for_nullable(ret)
                      end
                      if ret = get_function_return_type(base_name)
                        return ret if is_union_or_nilable_type?(ret)
                        return create_union_type_for_nullable(ret) if ret != TypeRef::VOID && ret != TypeRef::NIL
                      end
                    end
                  end
                end
              end
            end
          end
          if member_name == "unsafe_as"
            if arg = expr_node.args.first?
              if type_str = stringify_type_expr(arg)
                return type_ref_for_name(type_str)
              end
            end
          end
          if member_name == "literal"
            if type_str = stringify_type_expr(callee_node.object)
              type_str = resolve_type_name_in_context(type_str)
              return type_ref_for_name(type_str)
            end
          end
          if member_name == "clone" || member_name == "dup"
            if receiver_type = infer_type_from_expr(callee_node.object, self_type_name)
              return receiver_type if receiver_type != TypeRef::VOID
            end
          end
          if member_name == "new"
            if type_str = stringify_type_expr(callee_node.object)
              if type_str == "self" && self_type_name
                return type_ref_for_name(self_type_name)
              end
              if local_name = @current_typeof_local_names.try(&.[type_str]?)
                type_str = local_name unless local_name.empty?
              elsif local_ref = @current_typeof_locals.try(&.[type_str]?)
                local_type_name = get_type_name_from_ref(local_ref)
                type_str = local_type_name unless local_type_name.empty? || local_type_name == "Void" || local_type_name == "Unknown"
              end
              resolved_type_str = resolve_type_alias_chain(resolve_type_name_in_context(type_str))
              type_str = resolved_type_str unless resolved_type_str.empty?
              if env_get("DEBUG_INFER_NEW") && self_type_name == "Fiber"
                STDERR.puts "[INFER_NEW] type_str=#{type_str}"
              end
              if type_str == "Range" && expr_node.args.size >= 2
                begin_type = infer_type_from_expr(expr_node.args[0], self_type_name)
                end_type = infer_type_from_expr(expr_node.args[1], self_type_name)
                if begin_type && end_type
                  range_name = "Range(#{get_type_name_from_ref(begin_type)}, #{get_type_name_from_ref(end_type)})"
                  return type_ref_for_name(range_name)
                end
              end
              # Infer Slice(T) from Slice.new(pointer, size) when generic args are omitted.
              if type_str == "Slice" && expr_node.args.size >= 1
                if arg_type = infer_type_from_expr(expr_node.args[0], self_type_name)
                  if type_desc = @module.get_type_descriptor(arg_type)
                    if type_desc.kind == TypeKind::Pointer
                      elem_type = type_desc.type_params.first? || pointer_element_type(type_desc.name)
                      if elem_type && elem_type != TypeRef::VOID
                        elem_name = get_type_name_from_ref(elem_type)
                        return type_ref_for_name("Slice(#{elem_name})")
                      end
                    elsif arg_type == TypeRef::POINTER && expr_node.args.size >= 2
                      return type_ref_for_name("Slice(UInt8)")
                    end
                  end
                elsif expr_node.args.size >= 2
                  return type_ref_for_name("Slice(UInt8)")
                end
              end
              if template = @generic_templates[type_str]?
                if template.type_params.size == 1
                  inferred_name = nil.as(String?)
                  if type_str == "Array"
                    if expr_node.args.size >= 2
                      if inferred_ref = infer_type_from_expr(expr_node.args[1], self_type_name)
                        inferred_name = get_type_name_from_ref(inferred_ref)
                      end
                    end
                    if (inferred_name.nil? || inferred_name.empty? || inferred_name == "Void" || inferred_name == "Unknown") && block_expr
                      block_node = node_for_expr(block_expr)
                      if block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                        if body = block_node.body
                          if last_id = body.last?
                            if inferred_ref = infer_type_from_expr(last_id, self_type_name)
                              inferred_name = get_type_name_from_ref(inferred_ref)
                            end
                          end
                        end
                      end
                    end
                  end
                  if (inferred_name.nil? || inferred_name.empty? || inferred_name == "Void" || inferred_name == "Unknown") && !expr_node.args.empty?
                    if inferred_ref = infer_type_from_expr(expr_node.args[0], self_type_name)
                      inferred_name = get_type_name_from_ref(inferred_ref)
                    end
                  end
                  if (inferred_name.nil? || inferred_name.empty? || inferred_name == "Void" || inferred_name == "Unknown") &&
                     (named_args = expr_node.named_args)
                    preferred = named_args.find { |named| String.new(named.name) == "value" }
                    selected = preferred || named_args.first?
                    if selected
                      if inferred_ref = infer_type_from_expr(selected.value, self_type_name)
                        inferred_name = get_type_name_from_ref(inferred_ref)
                      end
                      if (inferred_name.nil? || inferred_name.empty? || inferred_name == "Void" || inferred_name == "Unknown")
                        value_node = node_for_expr(selected.value)
                        if value_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
                          value_callee = node_for_expr(value_node.callee)
                          if value_callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                            value_member = String.new(value_callee.member)
                            if value_member == "new"
                              value_obj = node_for_expr(value_callee.object)
                              if value_obj.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
                                obj_name = String.new(value_obj.name)
                                if inferred_ref = @current_typeof_locals.try(&.[obj_name]?)
                                  inferred_name = get_type_name_from_ref(inferred_ref)
                                elsif inferred_local = @current_typeof_local_names.try(&.[obj_name]?)
                                  inferred_name = inferred_local
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                  if inferred_name && !inferred_name.empty? && inferred_name != "Void" && inferred_name != "Unknown"
                    return type_ref_for_name("#{type_str}(#{inferred_name})")
                  end
                end
              end
              return type_ref_for_name(type_str)
            else
              if self_type_name
                obj_node = node_for_expr(callee_node.object)
                if obj_node.is_a?(CrystalV2::Compiler::Frontend::SelfNode) ||
                   (obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && String.new(obj_node.name) == "self")
                  return type_ref_for_name(self_type_name)
                end
              end
              if env_get("DEBUG_INFER_NEW") && self_type_name == "Fiber"
                obj_node = node_for_expr(callee_node.object)
                obj_kind = obj_node.class.name.split("::").last
                detail = nil
                if obj_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                  member = String.new(obj_node.member)
                  inner = node_for_expr(obj_node.object)
                  detail = "#{inner.class.name.split("::").last}.#{member}"
                end
                snippet = nil
                if source = @sources_by_arena[@arena]?
                  snippet = slice_source_for_expr_in_arena(callee_node.object, @arena, source)
                end
                snippet_label = snippet ? " snippet=#{snippet}" : ""
                detail_label = detail ? " detail=#{detail}" : ""
                STDERR.puts "[INFER_NEW] type_str=nil obj=#{obj_kind}#{detail_label}#{snippet_label}"
              end
            end
          elsif member_name.ends_with?('?')
            if obj_type = infer_type_from_expr(callee_node.object, self_type_name)
              if inferred = infer_unannotated_query_return_type(member_name, obj_type)
                return inferred
              end
            end
          end
          # Binary operator return type inference (used for lightweight return-type discovery).
          if binary_op_for_method(member_name)
            # Comparisons and boolean operators always return Bool.
            if member_name == "==" || member_name == "!=" || member_name == "<" || member_name == "<=" ||
               member_name == ">" || member_name == ">=" || member_name == "&&" || member_name == "||"
              return TypeRef::BOOL
            end

            receiver_type = infer_type_from_expr(callee_node.object, self_type_name)
            if receiver_type && receiver_type != TypeRef::VOID
              arg_types = [] of TypeRef
              expr_node.args.each do |arg_id|
                if arg_type = infer_type_from_expr(arg_id, self_type_name)
                  arg_types << arg_type unless arg_type == TypeRef::VOID
                end
              end
              common = common_numeric_type([receiver_type] + arg_types)
              return common if common
              return receiver_type if numeric_primitive?(receiver_type)
            end
          end
          unless block_expr || block_pass_expr
            if obj_name = stringify_type_expr(callee_node.object)
              obj_name = resolve_type_name_in_context(obj_name)
              base_method = "#{obj_name}.#{member_name}"
              # When there are args, try to find the specific overload matching arg types.
              # This avoids returning the wrong type when multiple overloads exist
              # (e.g., Math.sqrt(Float32):Float32 vs Math.sqrt(Float64):Float64).
              if !expr_node.args.empty?
                arg_type_names = [] of String
                expr_node.args.each do |arg_id|
                  if at = infer_type_from_expr(arg_id, self_type_name)
                    arg_type_names << type_name_for_mangling(at) if at != TypeRef::VOID
                  end
                end
                unless arg_type_names.empty?
                  # Check function types with mangled name
                  mangled_method = "#{base_method}$#{arg_type_names.join("_")}"
                  if ret_type = @function_types[mangled_method]?
                    return ret_type if ret_type != TypeRef::VOID
                  end
                  # Check function def for declared return type annotation with matching args
                  if def_node = @function_defs[mangled_method]? || @function_defs["#{base_method}$$#{arg_type_names.join("_")}"]?
                    if rt_bytes = def_node.return_type
                      rt_name = normalize_declared_type_name(String.new(rt_bytes))
                      resolved = type_ref_for_name(rt_name)
                      return resolved if resolved != TypeRef::VOID
                    end
                  end
                end
              end
              if ret_type = @function_base_return_types[base_method]?
                return ret_type if ret_type != TypeRef::VOID
              end
              if ret_type = @function_types[base_method]?
                return ret_type if ret_type != TypeRef::VOID
              end
            end
          end
          # Fallback: infer receiver type and look up instance method
          if recv_type = infer_type_from_expr(callee_node.object, self_type_name)
            if recv_type != TypeRef::VOID
              recv_name = get_type_name_from_ref(recv_type)
              if block_expr || block_pass_expr
                owner_name = split_generic_base_and_args(recv_name).try(&.[](:base)) || recv_name
                base_name = resolve_method_with_inheritance(owner_name, member_name) || "#{owner_name}##{member_name}"
                block_param_types = block_param_types_for_call(base_name, base_name, recv_type)
                if block_return_name = infer_call_block_return_name(block_expr, block_pass_expr, expr_node.span, block_param_types, self_type_name)
                  if inferred = resolve_block_dependent_return_type(base_name, base_name, block_return_name)
                    return inferred
                  end
                  if member_name == "map" || member_name == "map_with_index"
                    if tuple_return = tuple_map_return_type(recv_type, block_return_name)
                      return tuple_return
                    end
                  end
                end
              end
              # Strip generic args for base lookup: Array(UInt64) -> Array
              base_recv = strip_generic_args(recv_name)
              # Try exact type first, then base type
              [recv_name, base_recv].each do |owner|
                next if owner.empty?
                instance_method = "#{owner}##{member_name}"
                if ret_type = @function_base_return_types[instance_method]?
                  def_base = strip_type_suffix(instance_method)
                  needs_callsite = unresolved_generic_return_type?(ret_type)
                  if !needs_callsite && ret_type == TypeRef::POINTER
                    if map = function_type_param_map_for(instance_method, def_base)
                      needs_callsite = !map.empty?
                    end
                  end
                  if needs_callsite
                    def_node = @function_defs[instance_method]? || @function_defs[def_base]?
                    if def_node
                      inferred = infer_return_type_from_callsite(def_node, owner, expr_node.args, expr_node.named_args, self_type_name)
                      if inferred && inferred != TypeRef::VOID && inferred != TypeRef::NIL
                        @function_types[instance_method] = inferred
                        @function_base_return_types[def_base] = inferred
                        return inferred
                      end
                    end
                  end
                  return ret_type if ret_type != TypeRef::VOID
                end
                if ret_type = @function_types[instance_method]?
                  def_name = instance_method
                  def_base = strip_type_suffix(instance_method)
                  needs_callsite = unresolved_generic_return_type?(ret_type)
                  if !needs_callsite && ret_type == TypeRef::POINTER
                    if map = function_type_param_map_for(def_name, def_base)
                      needs_callsite = !map.empty?
                    end
                  end
                  if needs_callsite
                    def_node = @function_defs[def_name]? || @function_defs[def_base]?
                    if def_node
                      inferred = infer_return_type_from_callsite(def_node, owner, expr_node.args, expr_node.named_args, self_type_name)
                      if inferred && inferred != TypeRef::VOID && inferred != TypeRef::NIL
                        @function_types[def_name] = inferred
                        @function_base_return_types[def_base] = inferred
                        return inferred
                      end
                    end
                  end
                  return ret_type if ret_type != TypeRef::VOID
                end
              end
              # For collection methods, infer element type
              if member_name == "unsafe_fetch" || member_name == "[]" || member_name == "first" || member_name == "last"
                if env_get("DEBUG_UNSAFE_FETCH")
                  STDERR.puts "[UNSAFE_FETCH_INFER] method=#{@current_method} recv_name=#{recv_name} self_type=#{self_type_name}"
                end
                if elem_name = element_type_for_type_name(recv_name)
                  elem_ref = type_ref_for_name(elem_name)
                  if env_get("DEBUG_UNSAFE_FETCH")
                    STDERR.puts "[UNSAFE_FETCH_INFER] elem_name=#{elem_name} elem_ref=#{elem_ref.id}"
                  end
                  return elem_ref if elem_ref != TypeRef::VOID
                end
              end
            end
          end
        elsif callee_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          method_name = String.new(callee_node.name)
          if self_type_name
            base = resolve_method_with_inheritance(self_type_name, method_name) || "#{self_type_name}##{method_name}"
            if ret_type = @function_base_return_types[base]?
              def_base = strip_type_suffix(base)
              needs_callsite = unresolved_generic_return_type?(ret_type)
              if !needs_callsite && ret_type == TypeRef::POINTER
                if map = function_type_param_map_for(base, def_base)
                  needs_callsite = !map.empty?
                end
              end
              if needs_callsite
                def_node = @function_defs[base]? || @function_defs[def_base]?
                if def_node
                  inferred = infer_return_type_from_callsite(def_node, self_type_name, expr_node.args, expr_node.named_args, self_type_name)
                  if inferred && inferred != TypeRef::VOID && inferred != TypeRef::NIL
                    @function_types[base] = inferred
                    @function_base_return_types[def_base] = inferred
                    return inferred
                  end
                end
              end
              return ret_type if ret_type != TypeRef::VOID
            end
            if ret_type = @function_types[base]?
              def_base = strip_type_suffix(base)
              needs_callsite = unresolved_generic_return_type?(ret_type)
              if !needs_callsite && ret_type == TypeRef::POINTER
                if map = function_type_param_map_for(base, def_base)
                  needs_callsite = !map.empty?
                end
              end
              if needs_callsite
                def_node = @function_defs[base]? || @function_defs[def_base]?
                if def_node
                  inferred = infer_return_type_from_callsite(def_node, self_type_name, expr_node.args, expr_node.named_args, self_type_name)
                  if inferred && inferred != TypeRef::VOID && inferred != TypeRef::NIL
                    @function_types[base] = inferred
                    @function_base_return_types[def_base] = inferred
                    return inferred
                  end
                end
              end
              return ret_type if ret_type != TypeRef::VOID
            end
          end
          if ret_type = @function_types[method_name]?
            return ret_type if ret_type != TypeRef::VOID
          end
          if cached = @function_base_return_types[method_name]?
            return cached if cached != TypeRef::VOID
          end
        end
      when CrystalV2::Compiler::Frontend::IndexNode
        debug_filter = env_get("DEBUG_INFER_INDEX")
        debug_enabled = debug_filter && (debug_filter == "1" || (@current_method && @current_method.not_nil!.includes?(debug_filter)))
        obj_type = infer_type_from_expr(expr_node.object, self_type_name)
        if obj_type
          if obj_type == TypeRef::VOID
            if debug_enabled
              STDERR.puts "[INFER_INDEX] method=#{@current_method || ""} self=#{self_type_name || "nil"} obj=Void idxs=#{expr_node.indexes.size}"
            end
            return nil
          end
          desc = @module.get_type_descriptor(obj_type)
          type_name = desc.try(&.name) || get_type_name_from_ref(obj_type)
          if debug_enabled
            STDERR.puts "[INFER_INDEX] method=#{@current_method || ""} self=#{self_type_name || "nil"} obj=#{type_name} idxs=#{expr_node.indexes.size}"
          end
          if type_name == "String"
            if expr_node.indexes.size >= 2 ||
               expr_node.indexes.any? { |idx| node_for_expr(idx).is_a?(CrystalV2::Compiler::Frontend::RangeNode) }
              return TypeRef::STRING
            end
            return TypeRef::CHAR
          end
          if type_name.starts_with?("Hash(")
            if type_desc = desc
              if type_desc.type_params.size >= 2
                value_ref = type_desc.type_params[1]
                return value_ref if value_ref != TypeRef::VOID
              end
            end
            if value_name = hash_value_type_for_type_name(type_name)
              value_ref = type_ref_for_name(value_name)
              return value_ref if value_ref != TypeRef::VOID
            end
          end
          if elem_name = element_type_for_type_name(type_name)
            elem_ref = type_ref_for_name(elem_name)
            return elem_ref if elem_ref != TypeRef::VOID
          end
        elsif debug_enabled
          obj_node = node_for_expr(expr_node.object)
          obj_kind = obj_node ? obj_node.class.name.split("::").last : "nil"
          STDERR.puts "[INFER_INDEX] method=#{@current_method || ""} self=#{self_type_name || "nil"} obj=nil obj_kind=#{obj_kind} idxs=#{expr_node.indexes.size}"
        end
      when CrystalV2::Compiler::Frontend::UnaryNode
        op = String.new(expr_node.operator)
        if op == "!"
          return TypeRef::BOOL
        end
        return infer_type_from_expr(expr_node.operand, self_type_name)
      when CrystalV2::Compiler::Frontend::UninitializedNode
        if type_str = stringify_type_expr(expr_node.type)
          return type_ref_for_name(type_str)
        end
      when CrystalV2::Compiler::Frontend::BinaryNode
        op = expr_node.operator_string
        if op == "&&" || op == "||"
          left_type = infer_type_from_expr(expr_node.left, self_type_name)
          right_noreturn = (op == "||") && noreturn_expr?(expr_node.right)
          if right_noreturn
            return non_nil_type_for_union(left_type) || left_type if left_type && left_type != TypeRef::VOID
          end
          right_type = infer_type_from_expr(expr_node.right, self_type_name)
          if left_type && right_type
            return union_type_for_values(left_type, right_type)
          end
          return left_type if left_type && left_type != TypeRef::VOID
          return right_type if right_type && right_type != TypeRef::VOID
        end
        if op == "==" || op == "!=" || op == "<" || op == "<=" || op == ">" || op == ">="
          return TypeRef::BOOL
        end
        left_type = infer_type_from_expr(expr_node.left, self_type_name)
        right_type = infer_type_from_expr(expr_node.right, self_type_name)
        if left_type && right_type
          integer_op = op == "+" || op == "-" || op == "*" || op == "&" || op == "|" ||
                       op == "^" || op == "<<" || op == ">>"
          if integer_op
            left_node = node_for_expr(expr_node.left)
            right_node = node_for_expr(expr_node.right)
            if left_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode) &&
               unsigned_integer_type?(right_type) && signed_integer_type?(left_type)
              return right_type
            end
            if right_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode) &&
               unsigned_integer_type?(left_type) && signed_integer_type?(right_type)
              return left_type
            end
          end
        end
        if left_type && right_type
          pointer_like = ->(t : TypeRef) do
            return false if t == TypeRef::VOID
            return true if @module.get_type_descriptor(t).try(&.kind) == TypeKind::Pointer
            name = get_type_name_from_ref(t)
            name.starts_with?("Pointer(")
          end
          integer_like = ->(t : TypeRef) do
            return false if t == TypeRef::VOID
            name = get_type_name_from_ref(t)
            name.starts_with?("Int") || name.starts_with?("UInt")
          end
          numeric_like = ->(t : TypeRef) do
            return false if t == TypeRef::VOID
            name = get_type_name_from_ref(t)
            name.starts_with?("Int") || name.starts_with?("UInt") || name.starts_with?("Float")
          end
          if op == "+" || op == "-"
            if pointer_like.call(left_type) && integer_like.call(right_type)
              return left_type
            elsif pointer_like.call(right_type) && integer_like.call(left_type)
              return right_type
            elsif pointer_like.call(left_type) && pointer_like.call(right_type)
              return TypeRef::INT64
            elsif op == "+" && (left_type == TypeRef::STRING || right_type == TypeRef::STRING)
              return TypeRef::STRING
            elsif numeric_like.call(left_type) && numeric_like.call(right_type)
              if common = common_numeric_type([left_type, right_type])
                return common
              end
            end
          end
        end
        types = [] of TypeRef
        types << left_type if left_type && left_type != TypeRef::VOID
        types << right_type if right_type && right_type != TypeRef::VOID
        if types.any?
          if common = common_numeric_type(types)
            return common
          end
          if op == "+" || op == "-"
            if left_type && left_type != TypeRef::VOID
              name = get_type_name_from_ref(left_type)
              return left_type if name.starts_with?("Int") || name.starts_with?("UInt") || name.starts_with?("Float")
            end
            if right_type && right_type != TypeRef::VOID
              name = get_type_name_from_ref(right_type)
              return right_type if name.starts_with?("Int") || name.starts_with?("UInt") || name.starts_with?("Float")
            end
            return TypeRef::STRING if op == "+" && (left_type == TypeRef::STRING || right_type == TypeRef::STRING)
            return nil
          end
          return left_type if left_type && left_type != TypeRef::VOID
          return right_type if right_type && right_type != TypeRef::VOID
        end
      when CrystalV2::Compiler::Frontend::IfNode
        types = [] of TypeRef
        if inferred = infer_type_from_branch(expr_node.then_body, self_type_name)
          types << inferred
        end
        if elsifs = expr_node.elsifs
          elsifs.each do |branch|
            if inferred = infer_type_from_branch(branch.body, self_type_name)
              types << inferred
            end
          end
        end
        if else_body = expr_node.else_body
          if inferred = infer_type_from_branch(else_body, self_type_name)
            types << inferred
          end
        else
          types << TypeRef::NIL
        end
        if types.any?
          return merge_return_types(types)
        end
      when CrystalV2::Compiler::Frontend::TernaryNode
        true_type = infer_type_from_expr(expr_node.true_branch, self_type_name)
        false_type = infer_type_from_expr(expr_node.false_branch, self_type_name)
        if debug_name = env_get("DEBUG_INFER_TERNARY")
          if method_name = @current_method
            if method_name.includes?(debug_name)
              true_name = true_type ? get_type_name_from_ref(true_type) : "nil"
              false_name = false_type ? get_type_name_from_ref(false_type) : "nil"
              STDERR.puts "[INFER_TERNARY] method=#{method_name} true=#{true_name} false=#{false_name}"
            end
          end
        end
        if true_type && true_type != TypeRef::VOID && false_type && false_type != TypeRef::VOID
          return union_type_for_values(true_type, false_type)
        end
        return true_type if true_type && true_type != TypeRef::VOID
        return false_type if false_type && false_type != TypeRef::VOID
      when CrystalV2::Compiler::Frontend::BeginNode
        types = [] of TypeRef
        old_body_context = @infer_body_context
        begin
          if else_body = expr_node.else_body
            @infer_body_context = else_body
            if inferred = infer_type_from_branch(else_body, self_type_name)
              types << inferred
            end
          elsif body = expr_node.body
            @infer_body_context = body
            if inferred = infer_type_from_branch(body, self_type_name)
              types << inferred
            end
          end
          if clauses = expr_node.rescue_clauses
            clauses.each do |clause|
              @infer_body_context = clause.body
              if inferred = infer_type_from_branch(clause.body, self_type_name)
                types << inferred
              end
            end
          end
        ensure
          @infer_body_context = old_body_context
        end
        if types.any?
          return merge_return_types(types)
        end
      end

      nil
    end

    private def infer_type_from_branch(
      body : Array(ExprId),
      self_type_name : String?,
    ) : TypeRef?
      return nil if body.empty?
      old_body_context = @infer_body_context
      debug_name = env_get("DEBUG_INFER_BRANCH")
      method_name = @current_method
      debug_infer = debug_name ? (method_name ? method_name.includes?(debug_name) : false) : false
      @infer_body_context = body
      begin
        expr_id = body.last
        loop do
          expr_node = @arena[expr_id]
          case expr_node
          when CrystalV2::Compiler::Frontend::GroupingNode
            expr_id = expr_node.expression
          when CrystalV2::Compiler::Frontend::MacroExpressionNode
            expr_id = expr_node.expression
          when CrystalV2::Compiler::Frontend::ReturnNode
            if debug_infer
              expr_kind = expr_node.class.name.split("::").last
              STDERR.puts "[INFER_BRANCH] method=#{@current_method || ""} expr=#{expr_kind} inferred=nil (return)"
            end
            return nil
          else
            break
          end
        end
        inferred = infer_type_from_expr(expr_id, self_type_name)
        if debug_infer
          expr_node = @arena[expr_id]
          expr_kind = expr_node.class.name.split("::").last
          inferred_name = inferred ? get_type_name_from_ref(inferred) : "nil"
          STDERR.puts "[INFER_BRANCH] method=#{@current_method || ""} expr=#{expr_kind} inferred=#{inferred_name}"
        end
        inferred
      ensure
        @infer_body_context = old_body_context
      end
    end

    private def type_ref_for_number_kind(kind : CrystalV2::Compiler::Frontend::NumberKind) : TypeRef
      case kind
      when CrystalV2::Compiler::Frontend::NumberKind::I8   then TypeRef::INT8
      when CrystalV2::Compiler::Frontend::NumberKind::I16  then TypeRef::INT16
      when CrystalV2::Compiler::Frontend::NumberKind::I32  then TypeRef::INT32
      when CrystalV2::Compiler::Frontend::NumberKind::I64  then TypeRef::INT64
      when CrystalV2::Compiler::Frontend::NumberKind::I128 then TypeRef::INT128
      when CrystalV2::Compiler::Frontend::NumberKind::U8   then TypeRef::UINT8
      when CrystalV2::Compiler::Frontend::NumberKind::U16  then TypeRef::UINT16
      when CrystalV2::Compiler::Frontend::NumberKind::U32  then TypeRef::UINT32
      when CrystalV2::Compiler::Frontend::NumberKind::U64  then TypeRef::UINT64
      when CrystalV2::Compiler::Frontend::NumberKind::U128 then TypeRef::UINT128
      when CrystalV2::Compiler::Frontend::NumberKind::F32  then TypeRef::FLOAT32
      when CrystalV2::Compiler::Frontend::NumberKind::F64  then TypeRef::FLOAT64
      else
        TypeRef::INT32
      end
    end

    private def literal_for_type_param_value(value : String) : {TypeRef, LiteralValue}?
      raw = value.strip
      return {TypeRef::BOOL, true} if raw == "true"
      return {TypeRef::BOOL, false} if raw == "false"

      suffix = raw.match(/_(i|u)(8|16|32|64|128)\z/)
      signed = true
      bits = 0
      if suffix
        signed = suffix[1] == "i"
        bits = suffix[2].to_i
        raw = raw[0, raw.size - suffix[0].size]
      end

      negative = raw.starts_with?('-')
      raw = raw[1..] if negative

      base = 10
      if raw.starts_with?("0x")
        base = 16
        raw = raw[2..]
      elsif raw.starts_with?("0b")
        base = 2
        raw = raw[2..]
      elsif raw.starts_with?("0o")
        base = 8
        raw = raw[2..]
      end

      raw = raw.gsub('_', "")
      return nil if raw.empty?

      if signed
        int_value = raw.to_i64(base)
        int_value = -int_value if negative
        type = case bits
               when   8 then TypeRef::INT8
               when  16 then TypeRef::INT16
               when  32 then TypeRef::INT32
               when  64 then TypeRef::INT64
               when 128 then TypeRef::INT128
               else
                 if int_value >= Int32::MIN && int_value <= Int32::MAX
                   TypeRef::INT32
                 else
                   TypeRef::INT64
                 end
               end
        return {type, int_value}
      end

      return nil if negative
      uint_value = raw.to_u64(base)
      type = case bits
             when   8 then TypeRef::UINT8
             when  16 then TypeRef::UINT16
             when  32 then TypeRef::UINT32
             when  64 then TypeRef::UINT64
             when 128 then TypeRef::UINT128
             else
               TypeRef::UINT64
             end
      {type, uint_value}
    rescue
      nil
    end

    private def infer_arg_types_for_call(args : Array(ExprId), self_type_name : String?) : Array(TypeRef)
      args.map { |arg| infer_type_from_expr(arg, self_type_name) || TypeRef::VOID }
    end

    private def infer_local_type_from_body(
      body : Array(ExprId),
      name : String,
      self_type_name : String?,
      visited : Set(String)? = nil,
    ) : TypeRef?
      if @current_class && @current_method
        scope = "#{@current_class}##{@current_method}"
        if scope != @infer_local_type_cache_scope
          @infer_local_type_cache.clear
          @infer_local_type_nil_cache.clear
          @infer_local_type_cache_scope = scope
        end
      elsif @infer_local_type_cache_scope
        @infer_local_type_cache.clear
        @infer_local_type_nil_cache.clear
        @infer_local_type_cache_scope = nil
      end

      cache_key = {body.object_id.to_u64, name, self_type_name}
      if cached = @infer_local_type_cache[cache_key]?
        cached_version, cached_type = cached
        return cached_type if cached_version == @infer_type_cache_version
      end
      return nil if @infer_local_type_nil_cache.includes?(cache_key)

      visited ||= Set(String).new
      return nil if visited.includes?(name)
      visited.add(name)
      types = [] of TypeRef
      body.each do |expr_id|
        collect_local_assignment_types(expr_id, name, self_type_name, types, body, visited)
      end
      visited.delete(name)
      inferred = merge_return_types(types)
      if inferred
        @infer_local_type_cache[cache_key] = {@infer_type_cache_version, inferred}
      else
        @infer_local_type_nil_cache.add(cache_key)
      end
      inferred
    end

    private def collect_local_assignment_types(
      expr_id : ExprId,
      name : String,
      self_type_name : String?,
      output : Array(TypeRef),
      body : Array(ExprId),
      visited : Set(String),
    ) : Nil
      expr_node = node_for_expr(expr_id)
      return unless expr_node
      case expr_node
      when CrystalV2::Compiler::Frontend::AssignNode
        target = node_for_expr(expr_node.target)
        if target.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
           slice_eq?(target.name, name)
          if expr_mentions_identifier?(expr_node.value, name)
            # Avoid recursive inference from self-referential assignments (e.g. a = a + 1).
          elsif inferred = infer_type_from_expr(expr_node.value, self_type_name)
            if env_get("DEBUG_INFER_LOCAL") && name == String.new(target.name)
              scope = "#{@current_class || ""}##{@current_method || ""}"
              expr_kind = node_for_expr(expr_node.value).class.name.split("::").last
              STDERR.puts "[INFER_LOCAL] scope=#{scope} name=#{name} expr=#{expr_kind} type=#{get_type_name_from_ref(inferred)}"
            end
            output << inferred if inferred != TypeRef::VOID
          elsif value_node = node_for_expr(expr_node.value)
            if value_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
              value_name = String.new(value_node.name)
              if inferred = infer_local_type_from_body(body, value_name, self_type_name, visited)
                output << inferred if inferred != TypeRef::VOID
              end
            end
          end
        end
        collect_local_assignment_types(expr_node.value, name, self_type_name, output, body, visited)
      when CrystalV2::Compiler::Frontend::TypeDeclarationNode
        if slice_eq?(expr_node.name, name)
          type_ref = type_ref_for_name(String.new(expr_node.declared_type))
          output << type_ref if type_ref != TypeRef::VOID
        end
        if value_id = expr_node.value
          collect_local_assignment_types(value_id, name, self_type_name, output, body, visited)
        end
      when CrystalV2::Compiler::Frontend::MultipleAssignNode
        value_node = node_for_expr(expr_node.value)
        if value_node.is_a?(CrystalV2::Compiler::Frontend::TupleLiteralNode)
          value_node.elements.each_with_index do |val_id, idx|
            target_id = expr_node.targets[idx]?
            next unless target_id
            target_node = node_for_expr(target_id)
            if target_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
               slice_eq?(target_node.name, name)
              if inferred = infer_type_from_expr(val_id, self_type_name)
                output << inferred if inferred != TypeRef::VOID
              end
            end
          end
        end
        collect_local_assignment_types(expr_node.value, name, self_type_name, output, body, visited)
      when CrystalV2::Compiler::Frontend::CallNode
        block_expr = expr_node.block
        if block_expr.nil? && !expr_node.args.empty?
          last_id = expr_node.args.last
          last_node = node_for_expr(last_id)
          case last_node
          when CrystalV2::Compiler::Frontend::BlockNode
            block_expr = last_id
          when CrystalV2::Compiler::Frontend::UnaryNode
            if slice_eq?(last_node.operator, "&")
              operand = last_node.operand
              operand_node = node_for_expr(operand)
              block_expr = operand if operand_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
            end
          end
        end

        if block_expr
          block_node = node_for_expr(block_expr)
          if block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
            if params = block_node.params
              param_index = nil
              params.each_with_index do |param, idx|
                next unless param.name
                if slice_eq?(param.name, name)
                  param_index = idx
                  break
                end
              end
              if param_index
                if param_types = infer_block_param_types_for_call(expr_node, self_type_name)
                  if inferred = param_types[param_index]?
                    output << inferred if inferred != TypeRef::VOID
                  end
                end
              end
            end
            if body = block_node.body
              body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
            end
          end
        end
        expr_node.args.each { |arg| collect_local_assignment_types(arg, name, self_type_name, output, body, visited) }
      when CrystalV2::Compiler::Frontend::DefNode
        if body = expr_node.body
          body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
        end
      when CrystalV2::Compiler::Frontend::BlockNode
        if body = expr_node.body
          body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
        end
      when CrystalV2::Compiler::Frontend::IfNode
        expr_node.then_body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
        if elsifs = expr_node.elsifs
          elsifs.each { |branch| branch.body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) } }
        end
        if else_body = expr_node.else_body
          else_body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
        end
      when CrystalV2::Compiler::Frontend::CaseNode
        expr_node.when_branches.each { |branch| branch.body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) } }
        if else_branch = expr_node.else_branch
          else_branch.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
        end
        if in_branches = expr_node.in_branches
          in_branches.each { |branch| branch.body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) } }
        end
      when CrystalV2::Compiler::Frontend::BeginNode
        expr_node.body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
        if clauses = expr_node.rescue_clauses
          clauses.each { |clause| clause.body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) } }
        end
        if else_body = expr_node.else_body
          else_body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
        end
        if ensure_body = expr_node.ensure_body
          ensure_body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
        end
      when CrystalV2::Compiler::Frontend::WhileNode
        expr_node.body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
      when CrystalV2::Compiler::Frontend::UntilNode
        expr_node.body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
      when CrystalV2::Compiler::Frontend::LoopNode
        expr_node.body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
      when CrystalV2::Compiler::Frontend::ForNode
        expr_node.body.each { |child| collect_local_assignment_types(child, name, self_type_name, output, body, visited) }
      when CrystalV2::Compiler::Frontend::BinaryNode
        # Infer variable type from the other operand of a binary expression.
        # Skip << (push/append) — it doesn't relate the types of its operands.
        op_str = String.new(expr_node.operator)
        unless op_str == "<<"
          left = node_for_expr(expr_node.left)
          right = node_for_expr(expr_node.right)
          if left.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && String.new(left.name) == name
            if inferred = infer_type_from_expr(expr_node.right, self_type_name)
              output << inferred if inferred != TypeRef::VOID
            end
          end
          if right.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && String.new(right.name) == name
            if inferred = infer_type_from_expr(expr_node.left, self_type_name)
              output << inferred if inferred != TypeRef::VOID
            end
          end
        end
      when CrystalV2::Compiler::Frontend::ReturnNode
        if value = expr_node.value
          collect_local_assignment_types(value, name, self_type_name, output, body, visited)
        end
      when CrystalV2::Compiler::Frontend::GroupingNode
        collect_local_assignment_types(expr_node.expression, name, self_type_name, output, body, visited)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        collect_local_assignment_types(expr_node.expression, name, self_type_name, output, body, visited)
      end
    end

    private def infer_block_param_types_for_call(
      expr_node : CrystalV2::Compiler::Frontend::CallNode,
      self_type_name : String?,
    ) : Array(TypeRef)?
      callee_node = node_for_expr(expr_node.callee)
      if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
        member_name = String.new(callee_node.member)
        receiver_type = infer_type_from_expr(callee_node.object, self_type_name)
        return nil if receiver_type.nil? || receiver_type == TypeRef::VOID
        receiver_name = get_type_name_from_ref(receiver_type)
        resolved = resolve_method_with_inheritance(receiver_name, member_name) || "#{receiver_name}##{member_name}"
        return block_param_types_for_call(resolved, resolved, receiver_type)
      elsif callee_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
        method_name = String.new(callee_node.name)
        owner_name = self_type_name || @current_class
        return nil unless owner_name
        base = resolve_method_with_inheritance(owner_name, method_name) || "#{owner_name}##{method_name}"
        receiver_ref = type_ref_for_name(owner_name)
        return nil if receiver_ref == TypeRef::VOID
        return block_param_types_for_call(base, base, receiver_ref)
      end
      nil
    end

    private def expr_mentions_identifier?(expr_id : ExprId, name : String, depth : Int32 = 0) : Bool
      return false if depth > 4
      expr_node = node_for_expr(expr_id)
      return false unless expr_node
      case expr_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        slice_eq?(expr_node.name, name)
      when CrystalV2::Compiler::Frontend::BinaryNode
        expr_mentions_identifier?(expr_node.left, name, depth + 1) ||
          expr_mentions_identifier?(expr_node.right, name, depth + 1)
      when CrystalV2::Compiler::Frontend::UnaryNode
        expr_mentions_identifier?(expr_node.operand, name, depth + 1)
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        expr_mentions_identifier?(expr_node.object, name, depth + 1)
      when CrystalV2::Compiler::Frontend::CallNode
        return true if expr_mentions_identifier?(expr_node.callee, name, depth + 1)
        expr_node.args.any? { |arg| expr_mentions_identifier?(arg, name, depth + 1) }
      when CrystalV2::Compiler::Frontend::AssignNode
        expr_mentions_identifier?(expr_node.value, name, depth + 1)
      when CrystalV2::Compiler::Frontend::GroupingNode
        expr_mentions_identifier?(expr_node.expression, name, depth + 1)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        expr_mentions_identifier?(expr_node.expression, name, depth + 1)
      when CrystalV2::Compiler::Frontend::IndexNode
        return true if expr_mentions_identifier?(expr_node.object, name, depth + 1)
        expr_node.indexes.any? { |idx| expr_mentions_identifier?(idx, name, depth + 1) }
      else
        false
      end
    end

    # Register a module and its methods (pass 1)
    # Modules are like classes but with only class methods (self.method)
    # Also handles nested classes: module Foo; class Bar; end; end -> Foo::Bar
    def register_module(node : CrystalV2::Compiler::Frontend::ModuleNode)
      old_class = @current_class
      old_override = @current_namespace_override
      @current_class = nil
      @current_namespace_override = nil
      begin
        register_module_with_name(node, String.new(node.name))
      ensure
        @current_class = old_class
        @current_namespace_override = old_override
      end
    end

    private def register_module_with_name(node : CrystalV2::Compiler::Frontend::ModuleNode, module_name : String)
      module_name = resolve_class_name_for_definition(module_name)
      if env_get("DEBUG_TYPE_PATH") && module_name.includes?('/')
        current_path = @paths_by_arena[@arena]? || "(unknown)"
        STDERR.puts "[TYPE_PATH_MODULE] name=#{module_name} file=#{File.basename(current_path)} span=#{node.span.start_line}:#{node.span.start_column}"
      end
      if debug_env_filter_match?("DEBUG_NESTED_CLASS", module_name)
        STDERR.puts "[DEBUG_MODULE] Processing module: #{module_name}, body_size=#{node.body.try(&.size) || 0}"
      end

      record_nested_type_names(module_name, node.body)

      if class_like_namespace?(module_name)
        if @module_defs.delete(module_name)
          @module_defs_cache_version += 1
          invalidate_type_cache_for_namespace(module_name)
        end
        if body = node.body
          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            case member
            when CrystalV2::Compiler::Frontend::ModuleNode
              nested_name = String.new(member.name)
              full_nested_name = "#{module_name}::#{nested_name}"
              register_nested_module(member, full_nested_name)
            when CrystalV2::Compiler::Frontend::ClassNode
              nested_name = String.new(member.name)
              full_nested_name = "#{module_name}::#{nested_name}"
              register_class_with_name(member, full_nested_name)
            when CrystalV2::Compiler::Frontend::EnumNode
              nested_name = String.new(member.name)
              full_nested_name = "#{module_name}::#{nested_name}"
              register_enum_with_name(member, full_nested_name)
            when CrystalV2::Compiler::Frontend::AliasNode
              alias_name = String.new(member.name)
              old_class = @current_class
              @current_class = module_name
              target_name = resolve_alias_target(String.new(member.value), module_name)
              @current_class = old_class
              full_alias_name = "#{module_name}::#{alias_name}"
              register_type_alias(full_alias_name, target_name)
            end
          end
        end
        return
      end

      # Keep module AST around for mixin expansion (`include Foo` in classes/structs).
      existing_defs = @module_defs.has_key?(module_name)
      (@module_defs[module_name] ||= [] of {CrystalV2::Compiler::Frontend::ModuleNode, CrystalV2::Compiler::Frontend::ArenaLike}) << {node, @arena}
      @module_defs_cache_version += 1
      invalidate_type_cache_for_namespace(module_name) if existing_defs

      # Always register nested types (classes, enums, modules) from module bodies.
      # Namespace modules like Crystal, Crystal::MachO etc. are not "class-like"
      # but still contain class definitions that must be registered.
      if body = node.body
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          case member
          when CrystalV2::Compiler::Frontend::ClassNode
            nested_name = String.new(member.name)
            full_nested_name = "#{module_name}::#{nested_name}"
            register_class_with_name(member, full_nested_name)
          when CrystalV2::Compiler::Frontend::EnumNode
            nested_name = String.new(member.name)
            full_nested_name = "#{module_name}::#{nested_name}"
            register_enum_with_name(member, full_nested_name)
          when CrystalV2::Compiler::Frontend::ModuleNode
            nested_name = String.new(member.name)
            full_nested_name = "#{module_name}::#{nested_name}"
            register_nested_module(member, full_nested_name)
          when CrystalV2::Compiler::Frontend::AliasNode
            alias_name = String.new(member.name)
            old_class = @current_class
            @current_class = module_name
            target_name = resolve_alias_target(String.new(member.value), module_name)
            @current_class = old_class
            full_alias_name = "#{module_name}::#{alias_name}"
            register_type_alias(full_alias_name, target_name)
          end
        end
      end

      if module_name == "Enum"
        if body = node.body
          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            next unless member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
            if recv = member.receiver
              next if String.new(recv) == "self"
            end
            register_type_method_from_def(member, "Enum")
          end
        end
        if enum_info = @enum_info
          enum_info.each_key do |enum_name|
            attach_enum_instance_methods(enum_name)
          end
        end
      end
      # Add module to short_type_index so Printer can resolve to Float::Printer
      short_name = last_namespace_component(module_name)
      if short_name != module_name
        (@short_type_index[short_name] ||= Set(String).new) << module_name
      end
      if env_has?("DEBUG_MODULE_BINARY_FORMAT") && module_name.includes?("BinaryFormat")
        STDERR.puts "[REG_MODULE_TOP] #{module_name}, now has #{@module_defs[module_name].size} defs"
      end
      if env_has?("DEBUG_MODULE_THREAD") && module_name.includes?("Thread")
        STDERR.puts "[REG_MODULE_TOP] #{module_name}, body_size=#{node.body.try(&.size) || 0}"
        if body = node.body
          body.each do |expr_id|
            member = @arena[expr_id]
            STDERR.puts "[REG_MODULE_MEMBER] type=#{member.class}"
          end
        end
      end
      if env_get("DEBUG_CLASSVAR_INFER") && module_name == "Crystal::AtExitHandlers"
        if body = node.body
          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            next unless member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
            next unless String.new(member.name) == "add"
            if def_body = member.body
              def_body.each do |child|
                child_node = @arena[child]
                next unless child_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
                if block_id = child_node.block
                  block_node = @arena[block_id]
                  block_size = block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode) ? block_node.body.try(&.size) || 0 : 0
                  STDERR.puts "[REG_MODULE_TOP] AtExitHandlers.add block_body=#{block_size}"
                  if block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                    if block_body = block_node.body
                      block_body.each do |bid|
                        expr = @arena[bid]
                        STDERR.puts "[REG_MODULE_TOP] AtExitHandlers.add block_expr=#{expr.class.name.split("::").last} span=#{expr.span.start_line}"
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end

      # Register module methods (def self.foo) and nested classes
      if body = node.body
        extend_self = false
        extend_nodes = [] of CrystalV2::Compiler::Frontend::ExtendNode
        if env_get("DEBUG_EXTEND_REGISTER") && module_name.includes?("ImplInfo")
          STDERR.puts "[EXTEND_SCAN] module=#{module_name} body_size=#{body.size}"
        end
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          if env_get("DEBUG_EXTEND_REGISTER") && module_name.includes?("ImplInfo")
            STDERR.puts "[EXTEND_SCAN_MEMBER] module=#{module_name} member=#{member.class.name}"
          end
          next unless member.is_a?(CrystalV2::Compiler::Frontend::ExtendNode)
          extend_nodes << member
          target_node = @arena[member.target]
          case target_node
          when CrystalV2::Compiler::Frontend::SelfNode
            extend_self = true
          when CrystalV2::Compiler::Frontend::IdentifierNode
            extend_self = String.new(target_node.name) == "self"
          end
        end
        @module_extend_self.add(module_name) if extend_self
        defined_class_method_full_names = collect_defined_class_method_full_names(module_name, body)

        # PASS 1: Register aliases and nested modules first (so they're available for function type resolution)
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          if member.is_a?(CrystalV2::Compiler::Frontend::AliasNode)
            alias_name = String.new(member.name)
            old_class = @current_class
            @current_class = module_name
            target_name = resolve_alias_target(String.new(member.value), module_name)
            @current_class = old_class
            full_alias_name = "#{module_name}::#{alias_name}"
            register_type_alias(full_alias_name, target_name)
            if env_has?("DEBUG_ALIAS")
              STDERR.puts "[ALIAS] Registered (module): #{full_alias_name} => #{target_name}"
            end
          elsif member.is_a?(CrystalV2::Compiler::Frontend::ModuleNode)
            # Nested module: Foo::Bar (as module)
            nested_name = String.new(member.name)
            full_nested_name = "#{module_name}::#{nested_name}"
            register_module_with_name(member, full_nested_name)
          elsif member.is_a?(CrystalV2::Compiler::Frontend::ClassNode)
            # Register class/struct type alias and any aliases inside the class
            class_name = String.new(member.name)
            full_class_name = "#{module_name}::#{class_name}"
            register_type_alias(full_class_name, full_class_name)
            register_class_aliases(member, full_class_name)
          end
        end
        # PASS 1.5: Register enums BEFORE classes/structs so type resolution works
        # (e.g., IO::Seek must exist before IO::FileDescriptor methods reference "Seek")
        old_class = @current_class
        @current_class = module_name
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          if member.is_a?(CrystalV2::Compiler::Frontend::EnumNode)
            enum_name = String.new(member.name)
            full_enum_name = "#{module_name}::#{enum_name}"
            register_enum_with_name(member, full_enum_name)
          end
        end
        @current_class = old_class
        # PASS 1.7: Register macros BEFORE macro expansion.
        # Macro calls inside a module body must see macros defined earlier in the same module.
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          next unless member.is_a?(CrystalV2::Compiler::Frontend::MacroDefNode)
          register_macro(member, module_name)
        end
        # PASS 1.75: Expand macros before method registration.
        # This ensures nested types (e.g., record structs) and macro‑generated defs
        # (e.g., class_getter) are available for type resolution when registering methods.
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          case member
          when CrystalV2::Compiler::Frontend::CallNode
            callee = @arena[member.callee]
            next unless callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            method_name = String.new(callee.name)
            macro_lookup = lookup_macro_entry_with_inheritance(method_name, module_name)
            if macro_lookup.nil? && module_name != "Object"
              macro_lookup = lookup_macro_entry(method_name, "Object")
            end
            next unless macro_lookup
            macro_entry, macro_key = macro_lookup
            macro_def, macro_arena = macro_entry
            macro_args, macro_block = extract_macro_block_from_args(member.args, member.block)
            expanded_id = expand_macro_expr(macro_def, macro_arena, macro_args, member.named_args, macro_block, macro_key)
            unless expanded_id.invalid?
              old_arena = @arena
              @arena = macro_arena
              begin
                register_module_members_from_macro_expansion(module_name, expanded_id)
              ensure
                @arena = old_arena
              end
            end
          when CrystalV2::Compiler::Frontend::IdentifierNode
            method_name = String.new(member.name)
            macro_lookup = lookup_macro_entry_with_inheritance(method_name, module_name)
            if macro_lookup.nil? && module_name != "Object"
              macro_lookup = lookup_macro_entry(method_name, "Object")
            end
            next unless macro_lookup
            macro_entry, macro_key = macro_lookup
            macro_def, macro_arena = macro_entry
            expanded_id = expand_macro_expr(macro_def, macro_arena, [] of ExprId, nil, nil, macro_key)
            unless expanded_id.invalid?
              old_arena = @arena
              @arena = macro_arena
              begin
                register_module_members_from_macro_expansion(module_name, expanded_id)
              ensure
                @arena = old_arena
              end
            end
          end
        end
        # PASS 2: Register functions and classes (now that aliases and enums are available)
        old_class = @current_class
        @current_class = module_name
        begin
          record_constants_in_body(module_name, body)
          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            case member
            when CrystalV2::Compiler::Frontend::ClassVarDeclNode
              raw_name = String.new(member.name)
              cvar_name = raw_name.lstrip('@')
              cvar_type = type_ref_for_name(String.new(member.type))
              initial_value : Int64? = nil
              if val_id = member.value
                val_node = @arena[val_id]
                if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
                  num_str = String.new(val_node.value)
                  initial_value = num_str.to_i64?
                end
              end
              record_class_var_type(module_name, cvar_name, cvar_type, initial_value)
            when CrystalV2::Compiler::Frontend::MacroDefNode
              register_macro(member, module_name)
            when CrystalV2::Compiler::Frontend::AssignNode
              target_node = @arena[member.target]
              if target_node.is_a?(CrystalV2::Compiler::Frontend::ClassVarNode)
                raw_name = String.new(target_node.name)
                cvar_name = raw_name.lstrip('@')
                value_node = @arena[member.value]
                cvar_type = infer_type_from_class_ivar_assign(value_node)
                record_class_var_type(module_name, cvar_name, cvar_type)
              end
            when CrystalV2::Compiler::Frontend::DefNode
              method_name = String.new(member.name)
              # In Crystal, `def self.foo` defines a module (class) method,
              # while `def foo` defines an instance method meant to be mixed in via `include`.
              is_class_method = if recv = member.receiver
                                  String.new(recv) == "self"
                                else
                                  extend_self
                                end
              if is_class_method
                base_name = "#{module_name}.#{method_name}"
                return_type = nil.as(TypeRef?)
                param_types = [] of TypeRef
                has_block = false
                with_namespace_override(module_name) do
                  return_type = if rt = member.return_type
                                  rt_name = String.new(rt)
                                  inferred = module_like_type_name?(rt_name) ? infer_concrete_return_type_from_body(member) : nil
                                  inferred || type_ref_for_name(rt_name)
                                elsif method_name.ends_with?('?')
                                  TypeRef::BOOL
                                else
                                  infer_concrete_return_type_from_body(member) || TypeRef::VOID
                                end
                  if params = member.params
                    params.each do |param|
                      next if named_only_separator?(param)
                      if param.is_block
                        has_block = true
                        next
                      end
                      param_type = if ta = param.type_annotation
                                     type_ref_for_name(String.new(ta))
                                   elsif param.is_double_splat
                                     type_ref_for_name("NamedTuple")
                                   else
                                     TypeRef::VOID
                                   end
                      if env_get("DEBUG_WUINT128") && module_name.includes?("Dragonbox::WUInt")
                        if ta = param.type_annotation
                          ta_name = String.new(ta)
                          resolved_name = get_type_name_from_ref(param_type)
                          STDERR.puts "[DEBUG_WUINT128] module=#{module_name} param=#{ta_name} resolved=#{resolved_name}"
                        end
                      end
                      param_types << param_type
                    end
                  end
                end
                return_type ||= TypeRef::VOID
                if !has_block
                  has_block = def_contains_yield?(member, @arena)
                end
                full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
                register_function_type(full_name, return_type)
                @function_defs[full_name] = member
                @function_def_arenas[full_name] = @arena
                if should_register_base_name?(full_name, base_name, member, has_block)
                  @function_defs[base_name] = member
                  @function_def_arenas[base_name] = @arena
                end

                # Track yield-functions for inline expansion (module methods).
                if def_contains_yield?(member, @arena)
                  @yield_functions.add(full_name)
                  debug_hook("yield.register", full_name)
                  if !has_block && !@function_defs.has_key?(base_name)
                    @function_defs[base_name] = member
                    @function_def_arenas[base_name] = @arena
                  end
                  @function_defs[full_name] = member
                  @function_def_arenas[full_name] = @arena
                end
              else
                register_type_method_from_def(member, module_name)
              end
            when CrystalV2::Compiler::Frontend::GetterNode
              next unless member.is_class?
              member.specs.each do |spec|
                register_class_accessor_entry(module_name, spec, :getter)
              end
            when CrystalV2::Compiler::Frontend::SetterNode
              next unless member.is_class?
              member.specs.each do |spec|
                register_class_accessor_entry(module_name, spec, :setter)
              end
            when CrystalV2::Compiler::Frontend::PropertyNode
              next unless member.is_class?
              member.specs.each do |spec|
                register_class_accessor_entry(module_name, spec, :getter)
                register_class_accessor_entry(module_name, spec, :setter)
              end
            when CrystalV2::Compiler::Frontend::ClassNode
              class_name = String.new(member.name)
              full_class_name = "#{module_name}::#{class_name}"
              if debug_env_filter_match?("DEBUG_NESTED_CLASS", full_class_name)
                STDERR.puts "[DEBUG_NESTED_CLASS] Registering nested class: #{full_class_name}"
              end
              register_class_with_name(member, full_class_name)
            when CrystalV2::Compiler::Frontend::EnumNode
              # Already registered in PASS 1.5 - skip
            when CrystalV2::Compiler::Frontend::AliasNode
              old_class = @current_class
              @current_class = module_name
              register_alias(member)
              @current_class = old_class
            when CrystalV2::Compiler::Frontend::MacroIfNode
              # Handle macro conditionals inside module body
              process_macro_if_in_module(member, module_name)
            when CrystalV2::Compiler::Frontend::MacroForNode
              # Handle macro for-loops inside module body (e.g., ByteFormat)
              process_macro_for_in_module(member, module_name)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              # Handle macro literal (may contain def/class inside)
              process_macro_literal_in_module(member, module_name)
            when CrystalV2::Compiler::Frontend::CallNode
              callee = @arena[member.callee]
              if callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
                method_name = String.new(callee.name)
                macro_lookup = lookup_macro_entry_with_inheritance(method_name, module_name)
                if macro_lookup.nil? && module_name != "Object"
                  macro_lookup = lookup_macro_entry(method_name, "Object")
                end
                if macro_lookup
                  macro_entry, macro_key = macro_lookup
                  macro_def, macro_arena = macro_entry
                  if macro_def_maybe_defines_type?(macro_def, macro_arena)
                    # Already handled in PASS 1.75 to ensure type availability.
                    next
                  end
                  macro_args, macro_block = extract_macro_block_from_args(member.args, member.block)
                  expanded_id = expand_macro_expr(macro_def, macro_arena, macro_args, member.named_args, macro_block, macro_key)
                  unless expanded_id.invalid?
                    old_arena = @arena
                    @arena = macro_arena
                    begin
                      register_module_members_from_macro_expansion(module_name, expanded_id)
                    ensure
                      @arena = old_arena
                    end
                  end
                end
              end
            when CrystalV2::Compiler::Frontend::IdentifierNode
              method_name = String.new(member.name)
              macro_lookup = lookup_macro_entry_with_inheritance(method_name, module_name)
              if macro_lookup.nil? && module_name != "Object"
                macro_lookup = lookup_macro_entry(method_name, "Object")
              end
              if macro_lookup
                macro_entry, macro_key = macro_lookup
                macro_def, macro_arena = macro_entry
                if macro_def_maybe_defines_type?(macro_def, macro_arena)
                  # Already handled in PASS 1.75 to ensure type availability.
                  next
                end
                expanded_id = expand_macro_expr(macro_def, macro_arena, [] of ExprId, nil, nil, macro_key)
                unless expanded_id.invalid?
                  old_arena = @arena
                  @arena = macro_arena
                  begin
                    register_module_members_from_macro_expansion(module_name, expanded_id)
                  ensure
                    @arena = old_arena
                  end
                end
              end
            end
          end
          visited_extends = Set(String).new
          extend_nodes.each do |ext|
            if env_get("DEBUG_EXTEND_REGISTER") && module_name.includes?("ImplInfo")
              target_str = resolve_path_like_name(ext.target) || "?"
              STDERR.puts "[EXTEND_REGISTER_CALL] module=#{module_name} target=#{target_str}"
            end
            register_module_class_methods_for(
              module_name,
              ext.target,
              defined_class_method_full_names,
              visited_extends
            )
          end
          if module_name == "Enum"
            if enum_info = @enum_info
              enum_info.each_key do |enum_name|
                attach_enum_instance_methods(enum_name)
              end
            end
          end
        ensure
          @current_class = old_class
        end
      end
    end

    # Process MacroIfNode inside a module body to extract methods
    private def process_macro_if_in_module(node : CrystalV2::Compiler::Frontend::MacroIfNode, module_name : String)
      if raw_text = macro_if_raw_text(node)
        nested_macro_end = raw_text.scan(/\{%\s*end\s*%\}/).size > 1
        unless nested_macro_end
          if expanded = expand_flag_macro_text(raw_text)
            if program = parse_macro_literal_program(expanded)
              with_arena(program.arena) do
                scan_module_extend_self_in_program(program, module_name)
                roots = program.roots
                skip_next = false
                roots.each_with_index do |expr_id, idx|
                  if skip_next
                    skip_next = false
                    next
                  end
                  expr_node = @arena[expr_id]
                  case expr_node
                  when CrystalV2::Compiler::Frontend::DefNode
                    register_module_method_from_def(expr_node, module_name)
                  when CrystalV2::Compiler::Frontend::AliasNode
                    old_class = @current_class
                    @current_class = module_name
                    register_alias(expr_node)
                    @current_class = old_class
                  when CrystalV2::Compiler::Frontend::ClassNode
                    class_name = String.new(expr_node.name)
                    full_class_name = "#{module_name}::#{class_name}"
                    register_class_with_name(expr_node, full_class_name)
                  when CrystalV2::Compiler::Frontend::ModuleNode
                    nested_name = String.new(expr_node.name)
                    full_nested_name = "#{module_name}::#{nested_name}"
                    register_nested_module(expr_node, full_nested_name)
                  when CrystalV2::Compiler::Frontend::ExtendNode
                    mark_module_extend_self(expr_node, module_name)
                  when CrystalV2::Compiler::Frontend::MacroIfNode
                    process_macro_if_in_module(expr_node, module_name)
                  when CrystalV2::Compiler::Frontend::MacroForNode
                    process_macro_for_in_module(expr_node, module_name)
                  when CrystalV2::Compiler::Frontend::MacroLiteralNode
                    process_macro_literal_in_module(expr_node, module_name)
                  when CrystalV2::Compiler::Frontend::ConstantNode
                    record_constant_definition(module_name, String.new(expr_node.name), expr_node.value, @arena)
                  when CrystalV2::Compiler::Frontend::AssignNode
                    target = @arena[expr_node.target]
                    if target.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
                      record_constant_definition(module_name, String.new(target.name), expr_node.value, @arena)
                    end
                  when CrystalV2::Compiler::Frontend::ClassVarDeclNode
                    # Handle class variable declarations from macro-expanded content
                    raw_name = String.new(expr_node.name)
                    cvar_name = raw_name.lstrip('@')
                    cvar_type = type_ref_for_name(String.new(expr_node.type))
                    initial_value : Int64? = nil
                    if val_id = expr_node.value
                      val_node = @arena[val_id]
                      if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
                        num_str = String.new(val_node.value)
                        initial_value = num_str.to_i64?
                      end
                    end
                    STDERR.puts "[DEBUG_CVAR_MACRO_IF] Registering #{module_name}::@@#{cvar_name} : #{String.new(expr_node.type)}" if env_get("DEBUG_CVAR")
                    record_class_var_type(module_name, cvar_name, cvar_type, initial_value)
                  when CrystalV2::Compiler::Frontend::ClassVarNode
                    # Handle class var node followed by PathNode (type) - parser quirk for @@var : Type at top level
                    raw_name = String.new(expr_node.name)
                    cvar_name = raw_name.lstrip('@')
                    # Check if next root is a PathNode (the type)
                    if idx + 1 < roots.size
                      next_id = roots[idx + 1]
                      next_node = @arena[next_id]
                      if next_node.is_a?(CrystalV2::Compiler::Frontend::PathNode)
                        type_name = collect_path_string(next_node)
                        cvar_type = type_ref_for_name(type_name)
                        STDERR.puts "[DEBUG_CVAR_MACRO_IF] Registering (ClassVarNode+PathNode) #{module_name}::@@#{cvar_name} : #{type_name}" if env_get("DEBUG_CVAR")
                        record_class_var_type(module_name, cvar_name, cvar_type, nil)
                        skip_next = true
                      end
                    end
                  end
                end
              end
              return
            end
          end
        end
      end

      result = try_evaluate_macro_condition(node.condition)
      if result == true
        process_macro_body_in_module(node.then_body, module_name)
      elsif result == false
        if else_node = node.else_body
          else_ast = @arena[else_node]
          case else_ast
          when CrystalV2::Compiler::Frontend::MacroIfNode
            process_macro_if_in_module(else_ast, module_name)
          else
            process_macro_body_in_module(else_node, module_name)
          end
        end
      else
        # Can't evaluate - try both branches
        process_macro_body_in_module(node.then_body, module_name)
        if else_node = node.else_body
          process_macro_body_in_module(else_node, module_name)
        end
      end
    end

    # Process macro body (MacroLiteralNode or expression) to extract module methods
    private def process_macro_body_in_module(body_id : ExprId, module_name : String)
      body_node = @arena[body_id]
      case body_node
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_module(body_node, module_name)
      when CrystalV2::Compiler::Frontend::DefNode
        register_module_method_from_def(body_node, module_name)
      when CrystalV2::Compiler::Frontend::ClassNode
        class_name = String.new(body_node.name)
        full_class_name = "#{module_name}::#{class_name}"
        register_class_with_name(body_node, full_class_name)
      when CrystalV2::Compiler::Frontend::ExtendNode
        mark_module_extend_self(body_node, module_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        process_macro_if_in_module(body_node, module_name)
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_module(body_node, module_name)
      when CrystalV2::Compiler::Frontend::ClassVarDeclNode
        # Handle class variable declarations from macro-expanded content
        raw_name = String.new(body_node.name)
        cvar_name = raw_name.lstrip('@')
        cvar_type = type_ref_for_name(String.new(body_node.type))
        initial_value : Int64? = nil
        if val_id = body_node.value
          val_node = @arena[val_id]
          if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
            num_str = String.new(val_node.value)
            initial_value = num_str.to_i64?
          end
        end
        record_class_var_type(module_name, cvar_name, cvar_type, initial_value)
      when CrystalV2::Compiler::Frontend::ConstantNode
        record_constant_definition(module_name, String.new(body_node.name), body_node.value, @arena)
      when CrystalV2::Compiler::Frontend::AssignNode
        target = @arena[body_node.target]
        if target.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
          record_constant_definition(module_name, String.new(target.name), body_node.value, @arena)
        end
      end
    end

    private def process_macro_for_in_module(node : CrystalV2::Compiler::Frontend::MacroForNode, module_name : String)
      iter_vars = node.iter_vars.map { |name| String.new(name) }
      return if iter_vars.empty?
      values = macro_for_iterable_values(node.iterable)
      return unless values

      source = @sources_by_arena[@arena]?
      program = CrystalV2::Compiler::Frontend::Program.new(@arena, [] of ExprId)
      expander = CrystalV2::Compiler::Semantic::MacroExpander.new(
        program,
        @arena,
        CrystalV2::Runtime.target_flags,
        recovery_mode: true,
        macro_source: source
      )
      owner_type = macro_owner_type_for(module_name)

      expanded = String.build do |io|
        values.each_with_index do |value, idx|
          vars = {} of String => CrystalV2::Compiler::Semantic::MacroValue
          assign_macro_iter_vars(vars, iter_vars, value, idx)
          if body_output = expander.expand_literal(node.body, variables: vars, owner_type: owner_type)
            io << body_output
            io << "\n"
          end
        end
      end
      sanitized = strip_macro_lines(expanded)
      if program = parse_macro_literal_program(sanitized)
        with_arena(program.arena) do
          scan_module_extend_self_in_program(program, module_name)
          program.roots.each do |expr_id|
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::DefNode
              register_module_method_from_def(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::AliasNode
              old_class = @current_class
              @current_class = module_name
              register_alias(expr_node)
              @current_class = old_class
            when CrystalV2::Compiler::Frontend::ClassNode
              class_name = String.new(expr_node.name)
              full_class_name = "#{module_name}::#{class_name}"
              register_class_with_name(expr_node, full_class_name)
            when CrystalV2::Compiler::Frontend::ModuleNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{module_name}::#{nested_name}"
              register_nested_module(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::ExtendNode
              mark_module_extend_self(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_module(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroForNode
              process_macro_for_in_module(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_module(expr_node, module_name)
            end
          end
        end
      end
    end

    # Process MacroLiteralNode to extract module methods
    private def process_macro_literal_in_module(node : CrystalV2::Compiler::Frontend::MacroLiteralNode, module_name : String)
      if raw_text = macro_literal_raw_text(node)
        expanded = expand_flag_macro_text(raw_text) || raw_text
        sanitized = strip_macro_lines(expanded)
        program = parse_macro_literal_program(expanded)
        if program.nil? && sanitized != expanded
          program = parse_macro_literal_program(sanitized)
        end
        if program
          with_arena(program.arena) do
            scan_module_extend_self_in_program(program, module_name)
            program.roots.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::DefNode
                register_module_method_from_def(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::AliasNode
                old_class = @current_class
                @current_class = module_name
                register_alias(expr_node)
                @current_class = old_class
              when CrystalV2::Compiler::Frontend::ClassNode
                class_name = String.new(expr_node.name)
                full_class_name = "#{module_name}::#{class_name}"
                register_class_with_name(expr_node, full_class_name)
              when CrystalV2::Compiler::Frontend::ModuleNode
                nested_name = String.new(expr_node.name)
                full_nested_name = "#{module_name}::#{nested_name}"
                register_nested_module(expr_node, full_nested_name)
              when CrystalV2::Compiler::Frontend::ExtendNode
                mark_module_extend_self(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                process_macro_if_in_module(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::MacroForNode
                process_macro_for_in_module(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                process_macro_literal_in_module(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::ConstantNode
                record_constant_definition(module_name, String.new(expr_node.name), expr_node.value, @arena)
              when CrystalV2::Compiler::Frontend::AssignNode
                target = @arena[expr_node.target]
                if target.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
                  record_constant_definition(module_name, String.new(target.name), expr_node.value, @arena)
                end
              when CrystalV2::Compiler::Frontend::ClassVarDeclNode
                # Handle class variable declarations from macro-expanded content
                raw_name = String.new(expr_node.name)
                cvar_name = raw_name.lstrip('@')
                cvar_type = type_ref_for_name(String.new(expr_node.type))
                initial_value : Int64? = nil
                if val_id = expr_node.value
                  val_node = @arena[val_id]
                  if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
                    num_str = String.new(val_node.value)
                    initial_value = num_str.to_i64?
                  end
                end
                record_class_var_type(module_name, cvar_name, cvar_type, initial_value)
              end
            end
          end
          return
        end
      end

      # Fallback: evaluate active text pieces (handles nested macro controls).
      texts = macro_literal_active_texts(node)
      combined = texts.join("\n")
      sanitized = strip_macro_lines(combined)
      program = parse_macro_literal_program(combined)
      if program.nil? && sanitized != combined
        program = parse_macro_literal_program(sanitized)
      end
      if program
        with_arena(program.arena) do
          scan_module_extend_self_in_program(program, module_name)
          program.roots.each do |expr_id|
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::DefNode
              register_module_method_from_def(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::AliasNode
              old_class = @current_class
              @current_class = module_name
              register_alias(expr_node)
              @current_class = old_class
            when CrystalV2::Compiler::Frontend::ClassNode
              class_name = String.new(expr_node.name)
              full_class_name = "#{module_name}::#{class_name}"
              register_class_with_name(expr_node, full_class_name)
            when CrystalV2::Compiler::Frontend::ModuleNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{module_name}::#{nested_name}"
              register_nested_module(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::ExtendNode
              mark_module_extend_self(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_module(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_module(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::ConstantNode
              record_constant_definition(module_name, String.new(expr_node.name), expr_node.value, @arena)
            when CrystalV2::Compiler::Frontend::AssignNode
              target = @arena[expr_node.target]
              if target.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
                record_constant_definition(module_name, String.new(target.name), expr_node.value, @arena)
              end
            when CrystalV2::Compiler::Frontend::ClassVarDeclNode
              # Handle class variable declarations from macro-expanded content
              raw_name = String.new(expr_node.name)
              cvar_name = raw_name.lstrip('@')
              cvar_type = type_ref_for_name(String.new(expr_node.type))
              initial_value : Int64? = nil
              if val_id = expr_node.value
                val_node = @arena[val_id]
                if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
                  num_str = String.new(val_node.value)
                  initial_value = num_str.to_i64?
                end
              end
              record_class_var_type(module_name, cvar_name, cvar_type, initial_value)
            end
          end
        end
        return
      end

      parsed_any = false
      texts.each do |text|
        next if text.strip.empty?
        sanitized = strip_macro_lines(text)
        program = parse_macro_literal_program(text)
        if program.nil? && sanitized != text
          program = parse_macro_literal_program(sanitized)
        end
        if program
          parsed_any = true
          with_arena(program.arena) do
            program.roots.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::DefNode
                register_module_method_from_def(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::AliasNode
                old_class = @current_class
                @current_class = module_name
                register_alias(expr_node)
                @current_class = old_class
              when CrystalV2::Compiler::Frontend::ClassNode
                class_name = String.new(expr_node.name)
                full_class_name = "#{module_name}::#{class_name}"
                register_class_with_name(expr_node, full_class_name)
              when CrystalV2::Compiler::Frontend::ModuleNode
                nested_name = String.new(expr_node.name)
                full_nested_name = "#{module_name}::#{nested_name}"
                register_nested_module(expr_node, full_nested_name)
              when CrystalV2::Compiler::Frontend::ExtendNode
                mark_module_extend_self(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                process_macro_if_in_module(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::MacroForNode
                process_macro_for_in_module(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                process_macro_literal_in_module(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::ConstantNode
                record_constant_definition(module_name, String.new(expr_node.name), expr_node.value, @arena)
              when CrystalV2::Compiler::Frontend::AssignNode
                target = @arena[expr_node.target]
                if target.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
                  record_constant_definition(module_name, String.new(target.name), expr_node.value, @arena)
                end
              when CrystalV2::Compiler::Frontend::ClassVarDeclNode
                # Handle class variable declarations from macro-expanded content
                raw_name = String.new(expr_node.name)
                cvar_name = raw_name.lstrip('@')
                cvar_type = type_ref_for_name(String.new(expr_node.type))
                initial_value : Int64? = nil
                if val_id = expr_node.value
                  val_node = @arena[val_id]
                  if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
                    num_str = String.new(val_node.value)
                    initial_value = num_str.to_i64?
                  end
                end
                record_class_var_type(module_name, cvar_name, cvar_type, initial_value)
              end
            end
          end
        end
      end
      return if parsed_any

      node.pieces.each do |piece|
        case piece.kind
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::Expression
          if expr_id = piece.expr
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::DefNode
              register_module_method_from_def(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::ClassNode
              class_name = String.new(expr_node.name)
              full_class_name = "#{module_name}::#{class_name}"
              register_class_with_name(expr_node, full_class_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_module(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroForNode
              process_macro_for_in_module(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_module(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::ClassVarDeclNode
              # Handle class variable declarations from macro-expanded content
              raw_name = String.new(expr_node.name)
              cvar_name = raw_name.lstrip('@')
              cvar_type = type_ref_for_name(String.new(expr_node.type))
              initial_value : Int64? = nil
              if val_id = expr_node.value
                val_node = @arena[val_id]
                if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
                  num_str = String.new(val_node.value)
                  initial_value = num_str.to_i64?
                end
              end
              record_class_var_type(module_name, cvar_name, cvar_type, initial_value)
            end
          end
        end
      end
    end

    private def scan_module_extend_self_in_program(
      program : CrystalV2::Compiler::Frontend::Program,
      module_name : String,
    ) : Nil
      program.roots.each do |expr_id|
        expr_node = @arena[expr_id]
        next unless expr_node.is_a?(CrystalV2::Compiler::Frontend::ExtendNode)
        mark_module_extend_self(expr_node, module_name)
      end
    end

    private def macro_literal_active_texts(node : CrystalV2::Compiler::Frontend::MacroLiteralNode) : Array(String)
      texts = [] of String
      control_stack = [] of {Bool, Bool, Bool} # {parent_active, branch_taken, active}
      active = true
      source = @sources_by_arena[@arena]?
      bytesize = source ? source.bytesize : 0

      node.pieces.each do |piece|
        case piece.kind
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::Text
          next unless active
          if source && (span = piece.span)
            start = span.start_offset
            length = span.end_offset - span.start_offset
            next if length <= 0
            next if start < 0 || start >= bytesize
            if start + length > bytesize
              length = bytesize - start
            end
            texts << source.byte_slice(start, length)
          elsif text = piece.text
            texts << text
          end
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::ControlStart
          keyword = piece.control_keyword || ""
          cond_expr = piece.expr
          cond = cond_expr ? try_evaluate_macro_condition(cond_expr) : nil
          if keyword == "unless"
            cond = cond.nil? ? nil : !cond
          end

          parent_active = active
          branch_active = if cond == true
                            parent_active
                          elsif cond == false
                            false
                          else
                            parent_active
                          end
          branch_taken = cond == true
          control_stack << {parent_active, branch_taken, branch_active}
          active = branch_active
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::ControlElseIf
          next if control_stack.empty?
          parent_active, branch_taken, _ = control_stack[-1]
          cond_expr = piece.expr
          cond = cond_expr ? try_evaluate_macro_condition(cond_expr) : nil
          take = !branch_taken && cond == true
          branch_active = if cond == false
                            false
                          elsif cond == true
                            parent_active && take
                          else
                            parent_active
                          end
          branch_taken = true if cond == true
          control_stack[-1] = {parent_active, branch_taken, branch_active}
          active = branch_active
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::ControlElse
          next if control_stack.empty?
          parent_active, branch_taken, _ = control_stack[-1]
          branch_active = parent_active && !branch_taken
          control_stack[-1] = {parent_active, true, branch_active}
          active = branch_active
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::ControlEnd
          if control_stack.empty?
            active = true
          else
            parent_active, _, _ = control_stack.pop
            active = parent_active
          end
        else
          # Ignore expression/macro var pieces for module registration.
        end
      end

      texts
    end

    private def strip_macro_lines(code : String) : String
      String.build do |io|
        code.each_line(chomp: false) do |line|
          if line.includes?("{{") || line.includes?("{%")
            # Remove inline macro tags but keep surrounding code when possible.
            sanitized = line.gsub(/\{\{.*?\}\}/, "")
            sanitized = sanitized.gsub(/\{%.+?%\}/, "")
            next if sanitized.strip.empty?
            io << sanitized
          else
            io << line
          end
        end
      end
    end

    # Register a class method from a DefNode inside a module
    private def register_module_method_from_def(member : CrystalV2::Compiler::Frontend::DefNode, module_name : String)
      old_class = @current_class
      @current_class = module_name
      begin
        if env_get("DEBUG_WUINT128") && module_name.includes?("Dragonbox::WUInt")
          STDERR.puts "[DEBUG_WUINT128] register_module_method_from_def module=#{module_name} current=#{@current_class || "(nil)"}"
        end
        method_name = String.new(member.name)
        if env_get("DEBUG_DRAGONBOX_REGISTER") && module_name.includes?("Dragonbox")
          recv_name = member.receiver ? String.new(member.receiver.not_nil!) : "(none)"
          STDERR.puts "[DRAGONBOX_MACRO_DEF] owner=#{module_name} method=#{method_name} receiver=#{recv_name}"
        end
        is_class_method = if recv = member.receiver
                            String.new(recv) == "self"
                          else
                            @module_extend_self.includes?(module_name)
                          end
        unless is_class_method
          register_type_method_from_def(member, module_name)
          return
        end
        base_name = "#{module_name}.#{method_name}"
        return_type = nil.as(TypeRef?)
        param_types = [] of TypeRef
        has_block = false
        with_namespace_override(module_name) do
          return_type = if rt = member.return_type
                          rt_name = qualify_unqualified_type_in_namespace(String.new(rt), module_name)
                          inferred = module_like_type_name?(rt_name) ? infer_concrete_return_type_from_body(member) : nil
                          inferred || type_ref_for_name(rt_name)
                        elsif method_name.ends_with?('?')
                          TypeRef::BOOL
                        else
                          infer_concrete_return_type_from_body(member) || TypeRef::VOID
                        end
          if params = member.params
            params.each do |param|
              next if named_only_separator?(param)
              if param.is_block
                has_block = true
                next
              end
              param_type = if ta = param.type_annotation
                             type_ref_for_name(qualify_unqualified_type_in_namespace(String.new(ta), module_name))
                           elsif param.is_double_splat
                             type_ref_for_name("NamedTuple")
                           else
                             TypeRef::VOID
                           end
              param_types << param_type
            end
          end
        end
        return_type ||= TypeRef::VOID
        contains_yield = false
        if !has_block
          contains_yield = def_contains_yield?(member, @arena)
          has_block = contains_yield
        end
        if env_get("DEBUG_TRACE_REGISTER") && module_name == "Crystal" && method_name == "trace"
          params_str = (member.params || [] of CrystalV2::Compiler::Frontend::Parameter).map do |param|
            name = param.name ? String.new(param.name.not_nil!) : "(nil)"
            "#{name}:block=#{param.is_block ? 1 : 0},splat=#{param.is_splat ? 1 : 0},dsplat=#{param.is_double_splat ? 1 : 0}"
          end.join(",")
          STDERR.puts "[TRACE_REGISTER] module=#{module_name} name=#{method_name} has_block=#{has_block ? 1 : 0} yield=#{contains_yield ? 1 : 0} params=[#{params_str}]"
        end
        full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
        # Prefer class-defined methods over included module methods when the base name
        # is already occupied by an untyped overload. This prevents module defs from
        # shadowing the class's own implementation (e.g., Tuple#hash).
        if full_name.starts_with?("#{base_name}$arity") && @function_defs.has_key?(base_name)
          full_name = base_name
        end
        if env_has?("DEBUG_MODULE_THREAD") && module_name.includes?("System::Thread")
          STDERR.puts "[REG_MODULE_METHOD_MACRO] #{module_name}.#{method_name} -> #{full_name}"
        end
        if @function_defs.has_key?(full_name)
          if def_contains_yield?(member, @arena)
            @yield_functions.add(full_name)
            debug_hook("yield.register", full_name)
          end
          if env_has?("DEBUG_DUP_FUNCTION")
            STDERR.puts "[DEBUG_DUP_FUNCTION] Skipping duplicate module method: #{full_name}"
          end
          return
        end
        register_function_type(full_name, return_type)
        @function_defs[full_name] = member
        @function_def_arenas[full_name] = @arena
        if env_get("DEBUG_ARENA_WRITE") && (module_name.includes?("Slice") || full_name.includes?("Slice")) && method_name == "hash"
          arena_path = source_path_for(@arena) || "(unknown)"
          STDERR.puts "[ARENA_WRITE_MOD_METHOD] full=#{full_name} base=#{base_name} module=#{module_name} arena=#{arena_path}:#{@arena.size}"
        end
        if should_register_base_name?(full_name, base_name, member, has_block)
          @function_defs[base_name] = member
          @function_def_arenas[base_name] = @arena
        elsif !has_block
          prefer_non_yield_base_name(base_name, member, @arena)
          prefer_lower_arity_base_name(base_name, member, @arena)
        end

        # Track yield-functions for inline expansion
        if def_contains_yield?(member, @arena)
          @yield_functions.add(full_name)
          debug_hook("yield.register", full_name)
          if !has_block && !@function_defs.has_key?(base_name)
            @function_defs[base_name] = member
            @function_def_arenas[base_name] = @arena
          end
          @function_defs[full_name] = member
          @function_def_arenas[full_name] = @arena
        end
      ensure
        @current_class = old_class
      end
    end

    private def register_module_members_from_macro_expansion(module_name : String, expr_id : ExprId)
      return if expr_id.invalid?
      member = unwrap_visibility_member(@arena[expr_id])
      case member
      when CrystalV2::Compiler::Frontend::BlockNode
        member.body.each do |child_id|
          child = unwrap_visibility_member(@arena[child_id])
          next unless child.is_a?(CrystalV2::Compiler::Frontend::ExtendNode)
          mark_module_extend_self(child, module_name)
        end
        member.body.each do |child_id|
          register_module_members_from_macro_expansion(module_name, child_id)
        end
      when CrystalV2::Compiler::Frontend::DefNode
        register_module_method_from_def(member, module_name)
      when CrystalV2::Compiler::Frontend::AliasNode
        old_class = @current_class
        @current_class = module_name
        register_alias(member)
        @current_class = old_class
      when CrystalV2::Compiler::Frontend::ClassNode
        class_name = String.new(member.name)
        full_class_name = "#{module_name}::#{class_name}"
        register_class_with_name(member, full_class_name)
      when CrystalV2::Compiler::Frontend::ModuleNode
        nested_name = String.new(member.name)
        full_nested_name = "#{module_name}::#{nested_name}"
        register_nested_module(member, full_nested_name)
      when CrystalV2::Compiler::Frontend::EnumNode
        enum_name = String.new(member.name)
        full_enum_name = "#{module_name}::#{enum_name}"
        register_enum_with_name(member, full_enum_name)
      when CrystalV2::Compiler::Frontend::ExtendNode
        mark_module_extend_self(member, module_name)
      when CrystalV2::Compiler::Frontend::MacroDefNode
        register_macro(member, module_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        process_macro_if_in_module(member, module_name)
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_module(member, module_name)
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_module(member, module_name)
      end
    end

    private def mark_module_extend_self(node : CrystalV2::Compiler::Frontend::ExtendNode, module_name : String) : Nil
      target_node = @arena[node.target]
      case target_node
      when CrystalV2::Compiler::Frontend::SelfNode
        @module_extend_self.add(module_name)
      when CrystalV2::Compiler::Frontend::IdentifierNode
        if String.new(target_node.name) == "self"
          @module_extend_self.add(module_name)
        elsif module_target = resolve_path_like_name(node.target)
          if !module_target.includes?("::") && module_name.includes?("::")
            parent = module_name.rpartition("::")[0]
            candidate = "#{parent}::#{module_target}"
            module_target = candidate if @module_defs.has_key?(candidate)
          end
          record_module_inclusion(module_target, module_name)
        end
      else
        if module_target = resolve_path_like_name(node.target)
          if !module_target.includes?("::") && module_name.includes?("::")
            parent = module_name.rpartition("::")[0]
            candidate = "#{parent}::#{module_target}"
            module_target = candidate if @module_defs.has_key?(candidate)
          end
          record_module_inclusion(module_target, module_name)
        end
      end
    end

    private def register_enum_methods(node : CrystalV2::Compiler::Frontend::EnumNode, enum_name : String)
      return unless body = node.body

      body.each do |expr_id|
        member = unwrap_visibility_member(@arena[expr_id])
        case member
        when CrystalV2::Compiler::Frontend::DefNode
          register_type_method_from_def(member, enum_name)
        when CrystalV2::Compiler::Frontend::MacroDefNode
          register_macro(member, enum_name)
        when CrystalV2::Compiler::Frontend::MacroIfNode
          process_macro_if_in_enum(member, enum_name)
        when CrystalV2::Compiler::Frontend::MacroLiteralNode
          process_macro_literal_in_enum(member, enum_name)
        end
      end
    end

    # Attach Enum module instance methods (e.g., Enum#hash) to a concrete enum type.
    private def attach_enum_instance_methods(enum_name : String) : Nil
      enum_prefix = "Enum#"
      has_enum_methods = false
      @function_defs.each do |full_name, def_node|
        next unless full_name.starts_with?(enum_prefix)
        has_enum_methods = true
        method_suffix = full_name[enum_prefix.size..]
        next if method_suffix.empty?
        enum_full_name = "#{enum_name}##{method_suffix}"
        next if @function_defs.has_key?(enum_full_name)
        arena = @function_def_arenas[full_name]? || @arena
        register_function_def(enum_full_name, def_node, arena)
        if return_type = @function_types[full_name]?
          register_function_type(enum_full_name, return_type) unless @function_types.has_key?(enum_full_name)
        end
      end
      return if has_enum_methods
      # If Enum instance methods weren't registered yet, pull them from the Enum module body.
      if defs = @module_defs["Enum"]?
        defs.each do |mod_node, mod_arena|
          with_arena(mod_arena) do
            body = mod_node.body
            next unless body
            body.each do |expr_id|
              member = unwrap_visibility_member(@arena[expr_id])
              next unless member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
              next if member.receiver # skip class methods
              register_type_method_from_def(member, enum_name)
            end
          end
        end
      end
    end

    # Extract enum members from macro conditionals in enum body
    private def extract_enum_members_from_body(node : CrystalV2::Compiler::Frontend::EnumNode, members : Hash(String, Int64))
      return unless body = node.body
      body.each do |expr_id|
        body_node = @arena[expr_id]
        case body_node
        when CrystalV2::Compiler::Frontend::MacroIfNode
          extract_enum_members_from_macro_if(body_node, members)
        when CrystalV2::Compiler::Frontend::MacroLiteralNode
          extract_enum_members_from_macro_literal(body_node, members)
        end
      end
    end

    private def extract_enum_members_from_macro_if(node : CrystalV2::Compiler::Frontend::MacroIfNode, members : Hash(String, Int64))
      # Try to parse raw text first for simple flag conditionals
      if raw_text = macro_if_raw_text(node)
        nested_macro_end = raw_text.scan(/\{%\s*end\s*%\}/).size > 1
        unless nested_macro_end
          if expanded = expand_flag_macro_text(raw_text)
            if program = parse_macro_literal_program(expanded)
              with_arena(program.arena) do
                program.roots.each do |expr_id|
                  expr_node = @arena[expr_id]
                  case expr_node
                  when CrystalV2::Compiler::Frontend::ConstantNode
                    extract_member_from_constant(expr_node, members)
                  when CrystalV2::Compiler::Frontend::MacroIfNode
                    extract_enum_members_from_macro_if(expr_node, members)
                  when CrystalV2::Compiler::Frontend::MacroLiteralNode
                    extract_enum_members_from_macro_literal(expr_node, members)
                  end
                end
              end
              return
            end
          end
        end
      end

      # Evaluate condition and process appropriate branch
      result = try_evaluate_macro_condition(node.condition)
      if result == true
        extract_enum_members_from_body_id(node.then_body, members)
      elsif result == false
        if else_node = node.else_body
          else_ast = @arena[else_node]
          case else_ast
          when CrystalV2::Compiler::Frontend::MacroIfNode
            extract_enum_members_from_macro_if(else_ast, members)
          else
            extract_enum_members_from_body_id(else_node, members)
          end
        end
      else
        # Unknown - process both branches
        extract_enum_members_from_body_id(node.then_body, members)
        if else_node = node.else_body
          extract_enum_members_from_body_id(else_node, members)
        end
      end
    end

    private def extract_enum_members_from_body_id(body_id : ExprId, members : Hash(String, Int64))
      body_node = @arena[body_id]
      case body_node
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        extract_enum_members_from_macro_literal(body_node, members)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        extract_enum_members_from_macro_if(body_node, members)
      when CrystalV2::Compiler::Frontend::ConstantNode
        extract_member_from_constant(body_node, members)
      end
    end

    private def extract_enum_members_from_macro_literal(node : CrystalV2::Compiler::Frontend::MacroLiteralNode, members : Hash(String, Int64))
      if raw_text = macro_literal_raw_text(node)
        expanded = expand_flag_macro_text(raw_text) || raw_text
        if program = parse_macro_literal_program(expanded)
          with_arena(program.arena) do
            program.roots.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::ConstantNode
                extract_member_from_constant(expr_node, members)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                extract_enum_members_from_macro_if(expr_node, members)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                extract_enum_members_from_macro_literal(expr_node, members)
              end
            end
          end
          return
        end
      end

      texts = macro_literal_active_texts(node)
      combined = texts.join("\n")
      if program = parse_macro_literal_program(combined)
        with_arena(program.arena) do
          program.roots.each do |expr_id|
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::ConstantNode
              extract_member_from_constant(expr_node, members)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              extract_enum_members_from_macro_if(expr_node, members)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              extract_enum_members_from_macro_literal(expr_node, members)
            end
          end
        end
      end
    end

    private def extract_member_from_constant(node : CrystalV2::Compiler::Frontend::ConstantNode, members : Hash(String, Int64))
      member_name = String.new(node.name)
      # Try to extract value if it's a number
      value = members.values.max? || -1_i64
      value += 1
      begin
        val_node = @arena[node.value]
        case val_node
        when CrystalV2::Compiler::Frontend::NumberNode
          value = String.new(val_node.value).to_i64? || value
        end
      rescue
        # Value not accessible, use default
      end
      members[member_name] = value unless members.has_key?(member_name)
    end

    private def register_type_method_from_def(member : CrystalV2::Compiler::Frontend::DefNode, type_name : String)
      method_name = String.new(member.name)
      unless @arena_for_def_cache.has_key?(member.object_id)
        @arena_for_def_cache[member.object_id] = @arena
      end
      is_class_method = if recv = member.receiver
                          String.new(recv) == "self"
                        else
                          false
                        end
      base_name = if is_class_method
                    "#{type_name}.#{method_name}"
                  else
                    "#{type_name}##{method_name}"
                  end
      enum_return_name : String? = nil
      if rt = member.return_type
        resolved_return = resolve_type_name_in_context(String.new(rt))
        if enum_name = resolve_enum_name(resolved_return)
          enum_return_name = enum_name
        end
      end
      return_type = if rt = member.return_type
                      type_ref_for_name(String.new(rt))
                    elsif method_name.ends_with?('?')
                      inferred = infer_concrete_return_type_from_body(member, type_name)
                      inferred ||= infer_unannotated_query_return_type(method_name, type_ref_for_name(type_name))
                      inferred || TypeRef::BOOL
                    else
                      infer_concrete_return_type_from_body(member, type_name) || TypeRef::VOID
                    end
      if is_class_method && return_type == TypeRef::VOID
        if enum_name = resolve_enum_name(type_name)
          return_type = enum_base_type(enum_name)
        end
      end
      param_types = [] of TypeRef
      has_block = false
      if params = member.params
        params.each do |param|
          next if named_only_separator?(param)
          if param.is_block
            has_block = true
            next
          end
          param_type = if ta = param.type_annotation
                         type_ref_for_name(String.new(ta))
                       elsif param.is_double_splat
                         type_ref_for_name("NamedTuple")
                       else
                         TypeRef::VOID
                       end
          param_types << param_type
        end
      end
      if !has_block
        has_block = def_contains_yield?(member, @arena)
      end
      full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
      if filter = env_get("DEBUG_METHOD_REGISTER_FILTER")
        if filter == "1" || type_name.includes?(filter) || method_name.includes?(filter)
          STDERR.puts "[DEBUG_METHOD_REGISTER] class=#{type_name} method=#{method_name} full=#{full_name} (macro_literal)"
        end
      end
      alias_full_name = nil
      if is_class_method
        base_owner = strip_generic_args(type_name)
        if base_owner != type_name
          alias_base = "#{base_owner}.#{method_name}"
          alias_full_name = function_full_name_for_def(alias_base, param_types, member.params, has_block)
        end
      end
      if enum_return_name
        @function_enum_return_names[full_name] = enum_return_name
        @function_enum_return_names[base_name] = enum_return_name
        if alias_full_name
          alias_base = strip_type_suffix(alias_full_name)
          @function_enum_return_names[alias_full_name] = enum_return_name
          @function_enum_return_names[alias_base] = enum_return_name
        end
      end
      if existing_def = @function_defs[full_name]?
        previous_base = "#{base_name}_previous"
        previous_full = function_full_name_for_def(previous_base, param_types, member.params, has_block)
        if prev_return = @function_types[full_name]?
          register_function_type(previous_full, prev_return)
        end
        @function_defs[previous_full] = existing_def
        if prev_arena = @function_def_arenas[full_name]?
          @function_def_arenas[previous_full] = prev_arena
        else
          @function_def_arenas[previous_full] = @arena
        end
        if prev_enum = @function_enum_return_names[full_name]? || @function_enum_return_names[base_name]?
          @function_enum_return_names[previous_full] = prev_enum
          @function_enum_return_names[previous_base] = prev_enum
        end
      end
      register_function_type(full_name, return_type)
      @function_defs[full_name] = member
      @function_def_arenas[full_name] = @arena
      if env_get("DEBUG_ARENA_WRITE_TYPE") && (type_name.includes?("Slice") || full_name.includes?("Slice")) && method_name == "hash"
        arena_path = source_path_for(@arena) || "(unknown)"
        STDERR.puts "[ARENA_WRITE_TYPE] full=#{full_name} base=#{base_name} type=#{type_name} arena=#{arena_path}:#{@arena.size}"
      end
      # Store type param map for lazy lowering of generic class methods.
      # When a monomorphized class registers its methods, the @type_param_map
      # contains substitutions (e.g., T => UInt8) needed for macro evaluation.
      unless @type_param_map.empty?
        if env_get("DEBUG_TYPE_PARAM_STORE") && (type_name.includes?("Slice") || method_name == "hash")
          STDERR.puts "[TYPE_PARAM_STORE] full=#{full_name} base=#{base_name} map=#{@type_param_map}"
        end
        store_function_type_param_map(full_name, base_name, @type_param_map)
      end
      if alias_full_name
        register_function_type(alias_full_name, return_type) unless @function_types.has_key?(alias_full_name)
        @function_defs[alias_full_name] = member
        @function_def_arenas[alias_full_name] = @arena
        unless @type_param_map.empty?
          store_function_type_param_map(alias_full_name, strip_type_suffix(alias_full_name), @type_param_map)
        end
      end
      if should_register_base_name?(full_name, base_name, member, has_block)
        @function_defs[base_name] = member
        @function_def_arenas[base_name] = @arena
      elsif !has_block
        prefer_non_yield_base_name(base_name, member, @arena)
        prefer_lower_arity_base_name(base_name, member, @arena)
      end

      if body = member.body
        if def_contains_yield?(member, @arena)
          @yield_functions.add(full_name)
          debug_hook("yield.register", full_name)
          # Don't let yield-based block overloads claim the bare base name.
          # This avoids routing no-block calls to block-only defs.
          if !has_block && !@function_defs.has_key?(base_name)
            @function_defs[base_name] = member
            @function_def_arenas[base_name] = @arena
          end
          @function_defs[full_name] = member
          @function_def_arenas[full_name] = @arena
        end
      end
    end

    private def process_macro_if_in_enum(node : CrystalV2::Compiler::Frontend::MacroIfNode, enum_name : String)
      if raw_text = macro_if_raw_text(node)
        nested_macro_end = raw_text.scan(/\{%\s*end\s*%\}/).size > 1
        unless nested_macro_end
          if expanded = expand_flag_macro_text(raw_text)
            if program = parse_macro_literal_program(expanded)
              with_arena(program.arena) do
                program.roots.each do |expr_id|
                  expr_node = @arena[expr_id]
                  case expr_node
                  when CrystalV2::Compiler::Frontend::DefNode
                    register_type_method_from_def(expr_node, enum_name)
                  when CrystalV2::Compiler::Frontend::MacroIfNode
                    process_macro_if_in_enum(expr_node, enum_name)
                  when CrystalV2::Compiler::Frontend::MacroLiteralNode
                    process_macro_literal_in_enum(expr_node, enum_name)
                  end
                end
              end
              return
            end
          end
        end
      end

      result = try_evaluate_macro_condition(node.condition)
      if result == true
        process_macro_body_in_enum(node.then_body, enum_name)
      elsif result == false
        if else_node = node.else_body
          else_ast = @arena[else_node]
          case else_ast
          when CrystalV2::Compiler::Frontend::MacroIfNode
            process_macro_if_in_enum(else_ast, enum_name)
          else
            process_macro_body_in_enum(else_node, enum_name)
          end
        end
      else
        process_macro_body_in_enum(node.then_body, enum_name)
        if else_node = node.else_body
          process_macro_body_in_enum(else_node, enum_name)
        end
      end
    end

    private def process_macro_body_in_enum(body_id : ExprId, enum_name : String)
      body_node = @arena[body_id]
      case body_node
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_enum(body_node, enum_name)
      when CrystalV2::Compiler::Frontend::DefNode
        register_type_method_from_def(body_node, enum_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        process_macro_if_in_enum(body_node, enum_name)
      end
    end

    private def process_macro_literal_in_enum(node : CrystalV2::Compiler::Frontend::MacroLiteralNode, enum_name : String)
      if raw_text = macro_literal_raw_text(node)
        expanded = expand_flag_macro_text(raw_text) || raw_text
        if program = parse_macro_literal_program(expanded)
          with_arena(program.arena) do
            program.roots.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::DefNode
                register_type_method_from_def(expr_node, enum_name)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                process_macro_if_in_enum(expr_node, enum_name)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                process_macro_literal_in_enum(expr_node, enum_name)
              end
            end
          end
          return
        end
      end

      texts = macro_literal_active_texts(node)
      combined = texts.join("\n")
      if program = parse_macro_literal_program(combined)
        with_arena(program.arena) do
          program.roots.each do |expr_id|
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::DefNode
              register_type_method_from_def(expr_node, enum_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_enum(expr_node, enum_name)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_enum(expr_node, enum_name)
            end
          end
        end
        return
      end

      parsed_any = false
      texts.each do |text|
        next if text.strip.empty?
        if program = parse_macro_literal_program(text)
          parsed_any = true
          with_arena(program.arena) do
            program.roots.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::DefNode
                register_type_method_from_def(expr_node, enum_name)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                process_macro_if_in_enum(expr_node, enum_name)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                process_macro_literal_in_enum(expr_node, enum_name)
              end
            end
          end
        end
      end
      return if parsed_any
    end

    private def process_macro_if_in_class(
      node : CrystalV2::Compiler::Frontend::MacroIfNode,
      class_name : String,
      ivars : Array(IVarInfo)? = nil,
      offset_ref : Pointer(Int32)? = nil,
    )
      if raw_text = macro_if_raw_text(node)
        if filter = env_get("DEBUG_MACRO_LITERAL_CLASS")
          if filter == "1" || class_name.includes?(filter)
            if raw_text.includes?("def self.open") || raw_text.includes?("def open")
              STDERR.puts "[MACRO_IF_CLASS] class=#{class_name} raw_contains_open=true"
            end
          end
        end
        nested_macro_end = raw_text.scan(/\{%\s*end\s*%\}/).size > 1
        unless nested_macro_end
          if expanded = expand_flag_macro_text(raw_text)
            if parsed = parse_macro_literal_class_body(expanded)
              program, body_ids = parsed
              with_arena(program.arena) do
                body_ids.each do |expr_id|
                  expr_node = @arena[expr_id]
                  case expr_node
                  when CrystalV2::Compiler::Frontend::DefNode
                    register_type_method_from_def(expr_node, class_name)
                  when CrystalV2::Compiler::Frontend::MacroIfNode
                    process_macro_if_in_class(expr_node, class_name, ivars, offset_ref)
                  when CrystalV2::Compiler::Frontend::MacroLiteralNode
                    process_macro_literal_in_class(expr_node, class_name, ivars, offset_ref)
                  when CrystalV2::Compiler::Frontend::ClassNode
                    nested_name = String.new(expr_node.name)
                    full_nested_name = "#{class_name}::#{nested_name}"
                    register_class_with_name(expr_node, full_nested_name)
                  when CrystalV2::Compiler::Frontend::EnumNode
                    nested_name = String.new(expr_node.name)
                    full_nested_name = "#{class_name}::#{nested_name}"
                    register_enum_with_name(expr_node, full_nested_name)
                  when CrystalV2::Compiler::Frontend::ModuleNode
                    nested_name = String.new(expr_node.name)
                    full_nested_name = "#{class_name}::#{nested_name}"
                    register_nested_module(expr_node, full_nested_name)
                  when CrystalV2::Compiler::Frontend::GetterNode
                    register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
                  when CrystalV2::Compiler::Frontend::SetterNode
                    register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
                  when CrystalV2::Compiler::Frontend::PropertyNode
                    register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
                  when CrystalV2::Compiler::Frontend::ConstantNode
                    record_constant_definition(class_name, String.new(expr_node.name), expr_node.value, @arena)
                  when CrystalV2::Compiler::Frontend::AssignNode
                    target = @arena[expr_node.target]
                    if target.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
                      record_constant_definition(class_name, String.new(target.name), expr_node.value, @arena)
                    end
                  end
                end
              end
              return
            end
          end
        end
      end

      result = try_evaluate_macro_condition(node.condition)
      if result == true
        process_macro_body_in_class(node.then_body, class_name, ivars, offset_ref)
      elsif result == false
        if else_node = node.else_body
          else_ast = @arena[else_node]
          case else_ast
          when CrystalV2::Compiler::Frontend::MacroIfNode
            process_macro_if_in_class(else_ast, class_name, ivars, offset_ref)
          else
            process_macro_body_in_class(else_node, class_name, ivars, offset_ref)
          end
        end
      else
        process_macro_body_in_class(node.then_body, class_name, ivars, offset_ref)
        if else_node = node.else_body
          process_macro_body_in_class(else_node, class_name, ivars, offset_ref)
        end
      end
    end

    private def process_macro_body_in_class(
      body_id : ExprId,
      class_name : String,
      ivars : Array(IVarInfo)? = nil,
      offset_ref : Pointer(Int32)? = nil,
    )
      body_node = @arena[body_id]
      if filter = env_get("DEBUG_MACRO_LITERAL_CLASS")
        if filter == "1" || class_name.includes?(filter)
          STDERR.puts "[MACRO_BODY_CLASS] class=#{class_name} body_kind=#{body_node.class}"
        end
      end
      case body_node
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_class(body_node, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::DefNode
        register_type_method_from_def(body_node, class_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        process_macro_if_in_class(body_node, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_class(body_node, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::GetterNode
        register_accessors_in_class(body_node, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::SetterNode
        register_accessors_in_class(body_node, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::PropertyNode
        register_accessors_in_class(body_node, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::ConstantNode
        record_constant_definition(class_name, String.new(body_node.name), body_node.value, @arena)
      when CrystalV2::Compiler::Frontend::AssignNode
        target = @arena[body_node.target]
        if target.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
          record_constant_definition(class_name, String.new(target.name), body_node.value, @arena)
        end
      end
    end

    private def process_macro_literal_in_class(
      node : CrystalV2::Compiler::Frontend::MacroLiteralNode,
      class_name : String,
      ivars : Array(IVarInfo)? = nil,
      offset_ref : Pointer(Int32)? = nil,
    )
      if raw_text = macro_literal_raw_text(node)
        if filter = env_get("DEBUG_MACRO_LITERAL_CLASS")
          if filter == "1" || class_name.includes?(filter)
            if raw_text.includes?("def self.open") || raw_text.includes?("def open")
              STDERR.puts "[MACRO_LITERAL_CLASS] class=#{class_name} raw_contains_open=true"
            end
          end
        end
        expanded = expand_flag_macro_text(raw_text) || raw_text
        sanitized = strip_macro_lines(expanded)
        if filter = env_get("DEBUG_MACRO_LITERAL_CLASS")
          if filter == "1" || class_name.includes?(filter)
            if sanitized.includes?("def self.open") || sanitized.includes?("def open")
              STDERR.puts "[MACRO_LITERAL_CLASS] class=#{class_name} sanitized_contains_open=true"
            end
          end
        end
        program = parse_macro_literal_program(expanded)
        if program.nil? && sanitized != expanded
          program = parse_macro_literal_program(sanitized)
        end
        if program
          with_arena(program.arena) do
            program.roots.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::DefNode
                register_type_method_from_def(expr_node, class_name)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                process_macro_if_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::MacroForNode
                process_macro_for_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                process_macro_literal_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::GetterNode
                register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::SetterNode
                register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::PropertyNode
                register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::ConstantNode
                record_constant_definition(class_name, String.new(expr_node.name), expr_node.value, @arena)
              when CrystalV2::Compiler::Frontend::AssignNode
                target = @arena[expr_node.target]
                if target.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
                  record_constant_definition(class_name, String.new(target.name), expr_node.value, @arena)
                end
              end
            end
          end
          return
        end
      end

      texts = macro_literal_active_texts(node)
      combined = texts.join("\n")
      sanitized = strip_macro_lines(combined)
      parsed = parse_macro_literal_class_body(combined)
      if parsed.nil? && sanitized != combined
        parsed = parse_macro_literal_class_body(sanitized)
      end
      if parsed
        program, body_ids = parsed
        with_arena(program.arena) do
          body_ids.each do |expr_id|
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::DefNode
              register_type_method_from_def(expr_node, class_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::MacroForNode
              process_macro_for_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::ClassNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{class_name}::#{nested_name}"
              register_class_with_name(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::EnumNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{class_name}::#{nested_name}"
              register_enum_with_name(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::ModuleNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{class_name}::#{nested_name}"
              register_nested_module(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::GetterNode
              register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::SetterNode
              register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::PropertyNode
              register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::ConstantNode
              record_constant_definition(class_name, String.new(expr_node.name), expr_node.value, @arena)
            when CrystalV2::Compiler::Frontend::AssignNode
              target = @arena[expr_node.target]
              if target.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
                record_constant_definition(class_name, String.new(target.name), expr_node.value, @arena)
              end
            end
          end
        end
        return
      end

      parsed_any = false
      texts.each do |text|
        next if text.strip.empty?
        sanitized = strip_macro_lines(text)
        parsed = parse_macro_literal_class_body(text)
        if parsed.nil? && sanitized != text
          parsed = parse_macro_literal_class_body(sanitized)
        end
        if parsed
          parsed_any = true
          program, body_ids = parsed
          with_arena(program.arena) do
            body_ids.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::DefNode
                register_type_method_from_def(expr_node, class_name)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                process_macro_if_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::MacroForNode
                process_macro_for_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                process_macro_literal_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::ClassNode
                nested_name = String.new(expr_node.name)
                full_nested_name = "#{class_name}::#{nested_name}"
                register_class_with_name(expr_node, full_nested_name)
              when CrystalV2::Compiler::Frontend::EnumNode
                nested_name = String.new(expr_node.name)
                full_nested_name = "#{class_name}::#{nested_name}"
                register_enum_with_name(expr_node, full_nested_name)
              when CrystalV2::Compiler::Frontend::ModuleNode
                nested_name = String.new(expr_node.name)
                full_nested_name = "#{class_name}::#{nested_name}"
                register_nested_module(expr_node, full_nested_name)
              when CrystalV2::Compiler::Frontend::GetterNode
                register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::SetterNode
                register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::PropertyNode
                register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
              end
            end
          end
        end
      end
      return if parsed_any
    end

    private def process_macro_for_in_class(
      node : CrystalV2::Compiler::Frontend::MacroForNode,
      class_name : String,
      ivars : Array(IVarInfo)? = nil,
      offset_ref : Pointer(Int32)? = nil,
    )
      iter_vars = node.iter_vars.map { |name| String.new(name) }
      return if iter_vars.empty?

      values = macro_for_iterable_values(node.iterable)
      return unless values

      source = @sources_by_arena[@arena]?
      program = CrystalV2::Compiler::Frontend::Program.new(@arena, [] of ExprId)
      expander = CrystalV2::Compiler::Semantic::MacroExpander.new(
        program,
        @arena,
        CrystalV2::Runtime.target_flags,
        recovery_mode: true,
        macro_source: source
      )
      owner_type = macro_owner_type_for(class_name)

      expanded = String.build do |io|
        values.each_with_index do |value, idx|
          vars = {} of String => CrystalV2::Compiler::Semantic::MacroValue
          assign_macro_iter_vars(vars, iter_vars, value, idx)
          if body_output = expander.expand_literal(node.body, variables: vars, owner_type: owner_type)
            io << body_output
            io << "\n"
          end
        end
      end

      sanitized = strip_macro_lines(expanded)
      if parsed = parse_macro_literal_class_body(sanitized)
        program, body_ids = parsed
        with_arena(program.arena) do
          body_ids.each do |expr_id|
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::DefNode
              register_type_method_from_def(expr_node, class_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::MacroForNode
              process_macro_for_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::ClassNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{class_name}::#{nested_name}"
              register_class_with_name(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::EnumNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{class_name}::#{nested_name}"
              register_enum_with_name(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::ModuleNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{class_name}::#{nested_name}"
              register_nested_module(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::GetterNode
              register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::SetterNode
              register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::PropertyNode
              register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
            end
          end
        end
      end
    end

    private def register_accessors_in_class(
      member : CrystalV2::Compiler::Frontend::GetterNode | CrystalV2::Compiler::Frontend::SetterNode | CrystalV2::Compiler::Frontend::PropertyNode,
      class_name : String,
      ivars : Array(IVarInfo)?,
      offset_ref : Pointer(Int32)?,
    )
      return unless ivars && offset_ref

      # Set @current_class so type_ref_for_name resolves types relative to the
      # class's module context (e.g. "Span" → "CrystalV2::Compiler::Frontend::Span"
      # instead of falling through to "Time::Span" from stdlib).
      old_class = @current_class
      @current_class = class_name
      begin

      if member.is_class?
        case member
        when CrystalV2::Compiler::Frontend::GetterNode
          member.specs.each { |spec| register_class_accessor_entry(class_name, spec, :getter) }
        when CrystalV2::Compiler::Frontend::SetterNode
          member.specs.each { |spec| register_class_accessor_entry(class_name, spec, :setter) }
        when CrystalV2::Compiler::Frontend::PropertyNode
          member.specs.each do |spec|
            register_class_accessor_entry(class_name, spec, :getter)
            register_class_accessor_entry(class_name, spec, :setter)
          end
        end
        return
      end

      case member
      when CrystalV2::Compiler::Frontend::GetterNode
        member.specs.each do |spec|
          storage_name = accessor_storage_name(spec)
          getter_name = accessor_method_name(spec)
          ivar_name = "@#{storage_name}"
          ivar_type = if ta = spec.type_annotation
                        type_ref_for_name(String.new(ta))
                      elsif spec.predicate
                        TypeRef::BOOL
                      elsif default_value = spec.default_value
                        infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                      else
                        TypeRef::VOID
                      end
          unless ivars.any? { |iv| iv.name == ivar_name }
            ivars << IVarInfo.new(ivar_name, ivar_type, offset_ref.value,
              default_expr_id: spec.default_value,
              default_arena: spec.default_value ? @arena : nil)
            offset_ref.value += type_size(ivar_type)
          end
          getter_base = "#{class_name}##{getter_name}"
          full_name = mangle_function_name(getter_base, [] of TypeRef)
          register_function_type(full_name, ivar_type)
        end
      when CrystalV2::Compiler::Frontend::SetterNode
        member.specs.each do |spec|
          storage_name = accessor_storage_name(spec)
          ivar_name = "@#{storage_name}"
          ivar_type = if ta = spec.type_annotation
                        type_ref_for_name(String.new(ta))
                      elsif spec.predicate
                        TypeRef::BOOL
                      elsif default_value = spec.default_value
                        infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                      else
                        TypeRef::VOID
                      end
          unless ivars.any? { |iv| iv.name == ivar_name }
            ivars << IVarInfo.new(ivar_name, ivar_type, offset_ref.value)
            offset_ref.value += type_size(ivar_type)
          end
          setter_name = "#{class_name}##{storage_name}="
          full_name = mangle_function_name(setter_name, [ivar_type])
          register_function_type(full_name, ivar_type)
        end
      when CrystalV2::Compiler::Frontend::PropertyNode
        member.specs.each do |spec|
          storage_name = accessor_storage_name(spec)
          getter_name = accessor_method_name(spec)
          ivar_name = "@#{storage_name}"
          ivar_type = if ta = spec.type_annotation
                        type_ref_for_name(String.new(ta))
                      elsif spec.predicate
                        TypeRef::BOOL
                      elsif default_value = spec.default_value
                        infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                      else
                        TypeRef::VOID
                      end
          unless ivars.any? { |iv| iv.name == ivar_name }
            ivars << IVarInfo.new(ivar_name, ivar_type, offset_ref.value)
            offset_ref.value += type_size(ivar_type)
          end
          getter_base = "#{class_name}##{getter_name}"
          getter_full = mangle_function_name(getter_base, [] of TypeRef)
          register_function_type(getter_full, ivar_type)
          setter_name = "#{class_name}##{storage_name}="
          setter_full = mangle_function_name(setter_name, [ivar_type])
          register_function_type(setter_full, ivar_type)
        end
      end

      ensure
        @current_class = old_class
      end
    end

    # Register a nested module with full path
    private def register_nested_module(node : CrystalV2::Compiler::Frontend::ModuleNode, full_name : String)
      record_nested_type_names(full_name, node.body)
      # Keep nested module AST around for mixin expansion.
      existing_defs = @module_defs.has_key?(full_name)
      (@module_defs[full_name] ||= [] of {CrystalV2::Compiler::Frontend::ModuleNode, CrystalV2::Compiler::Frontend::ArenaLike}) << {node, @arena}
      invalidate_type_cache_for_namespace(full_name) if existing_defs
      # Add module to short_type_index so Printer can resolve to Float::Printer
      short_name = last_namespace_component(full_name)
      if short_name != full_name
        (@short_type_index[short_name] ||= Set(String).new) << full_name
      end
      if env_has?("DEBUG_MODULE_LOOKUP") && full_name == "Crystal::System::Signal"
        body_size = node.body.try(&.size) || 0
        STDERR.puts "[DEBUG_MODULE_LOOKUP] register_nested_module #{full_name} body_size=#{body_size}"
      end
      if full_name.includes?("BinaryFormat") && full_name == "Float::FastFloat::BinaryFormat"
        body_methods = [] of String
        body_size = node.body.try(&.size) || 0
        start_line = node.span.start_line rescue 0
        end_line = node.span.end_line rescue 0
        if b = node.body
          b.each do |id|
            mem = @arena[id]
            while mem.is_a?(CrystalV2::Compiler::Frontend::VisibilityModifierNode)
              mem = @arena[mem.expression]
            end
            if mem.is_a?(CrystalV2::Compiler::Frontend::DefNode)
              param_count = mem.params.try(&.size) || 0
              body_methods << "#{String.new(mem.name)}(#{param_count})"
            end
          end
        end
        # STDERR.puts "[REG_MODULE] #{full_name} (lines #{start_line}-#{end_line}), now has #{@module_defs[full_name].size} defs, body_size=#{body_size}, methods=#{body_methods}"
      end

      if body = node.body
        # PASS 1: Register aliases first (so they're available for function type resolution)
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          if member.is_a?(CrystalV2::Compiler::Frontend::AliasNode)
            alias_name = String.new(member.name)
            old_class = @current_class
            @current_class = full_name
            target_name = resolve_alias_target(String.new(member.value), full_name)
            @current_class = old_class
            full_alias_name = "#{full_name}::#{alias_name}"
            register_type_alias(full_alias_name, target_name)
            if env_has?("DEBUG_ALIAS")
              STDERR.puts "[ALIAS] Registered: #{full_alias_name} => #{target_name}"
            end
          elsif member.is_a?(CrystalV2::Compiler::Frontend::ModuleNode)
            # Recursively register nested module aliases first
            nested_name = String.new(member.name)
            full_nested_name = "#{full_name}::#{nested_name}"
            register_nested_module(member, full_nested_name)
          elsif member.is_a?(CrystalV2::Compiler::Frontend::ClassNode)
            # Register class/struct type alias and any aliases inside the class
            class_name = String.new(member.name)
            full_class_name = "#{full_name}::#{class_name}"
            register_type_alias(full_class_name, full_class_name)
            register_class_aliases(member, full_class_name)
          end
        end
        # Scan for extend self before PASS 2
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          if member.is_a?(CrystalV2::Compiler::Frontend::ExtendNode)
            target_node = @arena[member.target]
            is_self = case target_node
                      when CrystalV2::Compiler::Frontend::SelfNode
                        true
                      when CrystalV2::Compiler::Frontend::IdentifierNode
                        String.new(target_node.name) == "self"
                      else
                        false
                      end
            if is_self
              @module_extend_self.add(full_name)
            end
          end
        end
        # Process extend SomeModule(...) patterns (not extend self)
        extend_nodes = body.compact_map do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          next unless member.is_a?(CrystalV2::Compiler::Frontend::ExtendNode)
          target_node = @arena[member.target]
          is_self = case target_node
                    when CrystalV2::Compiler::Frontend::SelfNode
                      true
                    when CrystalV2::Compiler::Frontend::IdentifierNode
                      String.new(target_node.name) == "self"
                    else
                      false
                    end
          next if is_self
          member
        end
        unless extend_nodes.empty?
          visited_extends = Set(String).new
          defined_class_method_full_names = Set(String).new
          # Pre-populate with already defined methods
          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            if member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
              recv = member.receiver
              if recv && String.new(recv) == "self"
                method_name = String.new(member.name)
                defined_class_method_full_names << "#{full_name}.#{method_name}"
              end
            end
          end
          old_class = @current_class
          @current_class = full_name
          begin
            extend_nodes.each do |ext|
              if env_get("DEBUG_EXTEND_REGISTER") && full_name.includes?("ImplInfo")
                target_str = resolve_path_like_name(ext.target) || "?"
                STDERR.puts "[EXTEND_REGISTER_NESTED] module=#{full_name} target=#{target_str}"
              end
              register_module_class_methods_for(
                full_name,
                ext.target,
                defined_class_method_full_names,
                visited_extends
              )
            end
          ensure
            @current_class = old_class
          end
        end
        # PASS 1.75: Expand macros that define types before method registration.
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          case member
          when CrystalV2::Compiler::Frontend::CallNode
            callee = @arena[member.callee]
            next unless callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            method_name = String.new(callee.name)
            macro_lookup = lookup_macro_entry_with_inheritance(method_name, full_name)
            if macro_lookup.nil? && full_name != "Object"
              macro_lookup = lookup_macro_entry(method_name, "Object")
            end
            next unless macro_lookup
            macro_entry, macro_key = macro_lookup
            macro_def, macro_arena = macro_entry
            next unless macro_def_maybe_defines_type?(macro_def, macro_arena)
            macro_args, macro_block = extract_macro_block_from_args(member.args, member.block)
            expanded_id = expand_macro_expr(macro_def, macro_arena, macro_args, member.named_args, macro_block, macro_key)
            unless expanded_id.invalid?
              old_arena = @arena
              @arena = macro_arena
              begin
                register_module_members_from_macro_expansion(full_name, expanded_id)
              ensure
                @arena = old_arena
              end
            end
          when CrystalV2::Compiler::Frontend::IdentifierNode
            method_name = String.new(member.name)
            macro_lookup = lookup_macro_entry_with_inheritance(method_name, full_name)
            if macro_lookup.nil? && full_name != "Object"
              macro_lookup = lookup_macro_entry(method_name, "Object")
            end
            next unless macro_lookup
            macro_entry, macro_key = macro_lookup
            macro_def, macro_arena = macro_entry
            next unless macro_def_maybe_defines_type?(macro_def, macro_arena)
            expanded_id = expand_macro_expr(macro_def, macro_arena, [] of ExprId, nil, nil, macro_key)
            unless expanded_id.invalid?
              old_arena = @arena
              @arena = macro_arena
              begin
                register_module_members_from_macro_expansion(full_name, expanded_id)
              ensure
                @arena = old_arena
              end
            end
          end
        end
        # PASS 2: Register functions and other members (now that aliases are available)
        old_class = @current_class
        @current_class = full_name
        begin
          # Register constants before functions (e.g., CACHE constant in ImplInfo_Float32)
          record_constants_in_body(full_name, body)
          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            case member
            when CrystalV2::Compiler::Frontend::DefNode
              method_name = String.new(member.name)
              recv = member.receiver
              if env_get("DEBUG_DRAGONBOX_REGISTER") && full_name.includes?("Dragonbox")
                recv_name = recv ? String.new(recv) : "(none)"
                STDERR.puts "[DRAGONBOX_DEF] owner=#{full_name} method=#{method_name} receiver=#{recv_name}"
              end
              # Check extend self for nested modules - methods without receiver are class methods if extend self
              is_class_method = if recv
                                  String.new(recv) == "self"
                                else
                                  @module_extend_self.includes?(full_name)
                                end
              next unless is_class_method
              if env_has?("DEBUG_MODULE_LOOKUP") && full_name == "Crystal::System::Signal"
                STDERR.puts "[DEBUG_MODULE_LOOKUP] register #{full_name}.#{method_name}"
              end
              base_name = "#{full_name}.#{method_name}"
              return_type = nil.as(TypeRef?)
              param_types = [] of TypeRef
              has_block = false
              old_class = @current_class
              @current_class = full_name
              with_namespace_override(full_name) do
                return_type = if rt = member.return_type
                                rt_name = qualify_unqualified_type_in_namespace(String.new(rt), full_name)
                                inferred = module_like_type_name?(rt_name) ? infer_concrete_return_type_from_body(member) : nil
                                inferred || type_ref_for_name(rt_name)
                              elsif method_name.ends_with?('?')
                                TypeRef::BOOL
                              else
                                infer_concrete_return_type_from_body(member) || TypeRef::VOID
                              end
                if params = member.params
                  params.each do |param|
                    next if named_only_separator?(param)
                    if param.is_block
                      has_block = true
                      next
                    end
                    param_type = if ta = param.type_annotation
                                   type_ref_for_name(qualify_unqualified_type_in_namespace(String.new(ta), full_name))
                                 elsif param.is_double_splat
                                   type_ref_for_name("NamedTuple")
                                 else
                                   TypeRef::VOID
                                 end
                    param_types << param_type
                  end
                end
              end
              @current_class = old_class
              return_type ||= TypeRef::VOID
              if env_get("DEBUG_WUINT128") && full_name.includes?("Dragonbox::WUInt")
                ret_name = get_type_name_from_ref(return_type)
                STDERR.puts "[DEBUG_WUINT128] register return method=#{method_name} return=#{ret_name}"
                if params = member.params
                  param_index = 0
                  params.each do |param|
                    next if named_only_separator?(param)
                    if param.is_block
                      next
                    end
                    if ta = param.type_annotation
                      ta_name = String.new(ta)
                      resolved_name = get_type_name_from_ref(param_types[param_index]? || TypeRef::VOID)
                      STDERR.puts "[DEBUG_WUINT128] register param #{ta_name} resolved=#{resolved_name}"
                    end
                    param_index += 1
                  end
                end
              end
              if !has_block
                has_block = def_contains_yield?(member, @arena)
              end
              full_method_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
              register_function_type(full_method_name, return_type)
              @function_defs[full_method_name] = member
              @function_def_arenas[full_method_name] = @arena
              if should_register_base_name?(full_method_name, base_name, member, has_block)
                @function_defs[base_name] = member
                @function_def_arenas[base_name] = @arena
              end

              # Track yield-functions for inline expansion (nested module methods).
              if def_contains_yield?(member, @arena)
                @yield_functions.add(full_method_name)
                debug_hook("yield.register", full_method_name)
                unless @function_defs.has_key?(base_name)
                  @function_defs[base_name] = member
                  @function_def_arenas[base_name] = @arena
                end
                @function_defs[full_method_name] = member
                @function_def_arenas[full_method_name] = @arena
              end
            when CrystalV2::Compiler::Frontend::ClassNode
              class_name = String.new(member.name)
              full_class_name = "#{full_name}::#{class_name}"
              register_class_with_name(member, full_class_name)
            when CrystalV2::Compiler::Frontend::EnumNode
              enum_name = String.new(member.name)
              full_enum_name = "#{full_name}::#{enum_name}"
              register_enum_with_name(member, full_enum_name)
            when CrystalV2::Compiler::Frontend::MacroDefNode
              register_macro(member, full_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_module(member, full_name)
            when CrystalV2::Compiler::Frontend::MacroForNode
              process_macro_for_in_module(member, full_name)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_module(member, full_name)
            when CrystalV2::Compiler::Frontend::CallNode
              # Handle macro calls like `record UInt128, ...` inside nested modules
              callee = @arena[member.callee]
              if callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
                method_name = String.new(callee.name)
                macro_lookup = lookup_macro_entry_with_inheritance(method_name, full_name)
                if macro_lookup.nil? && full_name != "Object"
                  macro_lookup = lookup_macro_entry(method_name, "Object")
                end
                if macro_lookup
                  macro_entry, macro_key = macro_lookup
                  macro_def, macro_arena = macro_entry
                  if macro_def_maybe_defines_type?(macro_def, macro_arena)
                    # Already handled in PASS 1.75 to ensure type availability.
                    next
                  end
                  macro_args, macro_block = extract_macro_block_from_args(member.args, member.block)
                  expanded_id = expand_macro_expr(macro_def, macro_arena, macro_args, member.named_args, macro_block, macro_key)
                  unless expanded_id.invalid?
                    old_arena = @arena
                    @arena = macro_arena
                    begin
                      register_module_members_from_macro_expansion(full_name, expanded_id)
                    ensure
                      @arena = old_arena
                    end
                  end
                end
              end
            when CrystalV2::Compiler::Frontend::IdentifierNode
              method_name = String.new(member.name)
              macro_lookup = lookup_macro_entry_with_inheritance(method_name, full_name)
              if macro_lookup.nil? && full_name != "Object"
                macro_lookup = lookup_macro_entry(method_name, "Object")
              end
              if macro_lookup
                macro_entry, macro_key = macro_lookup
                macro_def, macro_arena = macro_entry
                if macro_def_maybe_defines_type?(macro_def, macro_arena)
                  # Already handled in PASS 1.75 to ensure type availability.
                  next
                end
                expanded_id = expand_macro_expr(macro_def, macro_arena, [] of ExprId, nil, nil, macro_key)
                unless expanded_id.invalid?
                  old_arena = @arena
                  @arena = macro_arena
                  begin
                    register_module_members_from_macro_expansion(full_name, expanded_id)
                  ensure
                    @arena = old_arena
                  end
                end
              end
            end
          ensure
            @current_class = old_class
          end
        end
      end
    end

    # Register aliases inside a class (for nested alias-first processing)
    private def register_class_aliases(node : CrystalV2::Compiler::Frontend::ClassNode, class_name : String)
      if body = node.body
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          if member.is_a?(CrystalV2::Compiler::Frontend::AliasNode)
            alias_name = String.new(member.name)
            old_class = @current_class
            @current_class = class_name
            target_name = resolve_alias_target(String.new(member.value), class_name)
            @current_class = old_class
            full_alias_name = "#{class_name}::#{alias_name}"
            register_type_alias(full_alias_name, target_name)
            register_type_alias(alias_name, target_name)
            if env_has?("DEBUG_ALIAS")
              STDERR.puts "[ALIAS] Registered (class): #{full_alias_name} => #{target_name}, also: #{alias_name} => #{target_name}"
            end
          end
        end
      end
    end

    private def record_constants_in_body(owner_name : String, body : Array(ExprId))
      body.each do |expr_id|
        # Unwrap visibility modifier and track inner ExprId for deferred init
        raw_node = @arena[expr_id]
        inner_expr_id = expr_id
        while raw_node.is_a?(CrystalV2::Compiler::Frontend::VisibilityModifierNode)
          inner_expr_id = raw_node.expression
          raw_node = @arena[inner_expr_id]
        end
        member = raw_node
        case member
        when CrystalV2::Compiler::Frontend::BlockNode
          record_constants_in_body(owner_name, member.body)
        when CrystalV2::Compiler::Frontend::MacroIfNode
          if class_like_namespace?(owner_name)
            process_macro_if_in_class(member, owner_name)
          else
            process_macro_if_in_module(member, owner_name)
          end
        when CrystalV2::Compiler::Frontend::MacroForNode
          if class_like_namespace?(owner_name)
            process_macro_for_in_class(member, owner_name)
          else
            process_macro_for_in_module(member, owner_name)
          end
        when CrystalV2::Compiler::Frontend::MacroLiteralNode
          if class_like_namespace?(owner_name)
            process_macro_literal_in_class(member, owner_name)
          else
            process_macro_literal_in_module(member, owner_name)
          end
        when CrystalV2::Compiler::Frontend::ConstantNode
          const_name = String.new(member.name)
          record_constant_definition(owner_name, const_name, member.value, @arena)
          # Defer runtime initialization for non-numeric constants (strings, complex exprs).
          # The CLI demand-driven path doesn't call lower_class_with_name, so constants
          # must be deferred during registration. Integer constants are already initialized
          # as globals in the CLI pipeline; float/number constants cause LLVM IR issues
          # when lowered at runtime. Only defer string literals and unknown expressions.
          full_name = constant_full_name(owner_name, const_name)
          literal = @constant_literal_values[full_name]?
          if literal.is_a?(CrystalV2::Compiler::Semantic::MacroStringValue)
            @deferred_classvar_inits << {inner_expr_id, @arena, owner_name}
          end
        when CrystalV2::Compiler::Frontend::AssignNode
          target = @arena[member.target]
          if target.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
            record_constant_definition(owner_name, String.new(target.name), member.value, @arena)
          end
        end
      end
    end

    # Lower a module's methods and nested classes (pass 3)
    def lower_module(node : CrystalV2::Compiler::Frontend::ModuleNode)
      module_name = String.new(node.name)
      lower_module_with_name(node, module_name)
    end

    # Lower a module with a specific name prefix
    private def lower_module_with_name(node : CrystalV2::Compiler::Frontend::ModuleNode, module_name : String)
      # Skip generic module templates; they are lowered via monomorphization.
      if node.type_params && !module_name.includes?('(')
        return
      end
      if debug_env_filter_match?("DEBUG_NESTED_CLASS", module_name)
        STDERR.puts "[DEBUG_LOWER_MOD] lower_module_with_name: #{module_name}, body_size=#{node.body.try(&.size) || 0}"
      end
      # DEBUG_MODULE_THREAD disabled
      if body = node.body
        old_class = @current_class
        old_pending = @pending_def_annotations
        @current_class = module_name
        begin
          @pending_def_annotations = [] of Tuple(CrystalV2::Compiler::Frontend::AnnotationNode, CrystalV2::Compiler::Frontend::ArenaLike)
          body.each_with_index do |expr_id, idx|
            member = unwrap_visibility_member(@arena[expr_id])
            if member.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode)
              remember_effect_annotation(member, @arena)
              next
            elsif !member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
              clear_pending_effect_annotations
            end
            if debug_env_filter_match?("DEBUG_NESTED_CLASS", module_name)
              STDERR.puts "[DEBUG_LOWER_MOD] #{module_name} member #{idx}: #{member.class}"
            end
            case member
            when CrystalV2::Compiler::Frontend::DefNode
              method_name = String.new(member.name)
              is_class_method = if recv = member.receiver
                                  String.new(recv) == "self"
                                else
                                  @module_extend_self.includes?(module_name)
                                end
              next unless is_class_method
              STDERR.puts "      [#{module_name}] Method #{idx}: #{method_name}" if env_get("HIR_DEBUG")
              STDERR.flush if env_get("HIR_DEBUG")
              base_name = "#{module_name}.#{method_name}"
              param_types = [] of TypeRef
              has_block = false
              if params = member.params
                params.each do |param|
                  next if named_only_separator?(param)
                  if param.is_block
                    has_block = true
                    next
                  end
                  param_type = if ta = param.type_annotation
                                 type_ref_for_name(String.new(ta))
                               elsif param.is_double_splat
                                 type_ref_for_name("NamedTuple")
                               else
                                 TypeRef::VOID
                               end
                  param_types << param_type
                end
              end
              full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
              next if @module.has_function?(full_name)
              callsite_args = pending_callsite_args_for_def(member, base_name, full_name)
              call_arg_types = callsite_args ? callsite_args.types : nil
              call_arg_literals = callsite_args ? callsite_args.literals : nil
              call_arg_enum_names = callsite_args ? callsite_args.enum_names : nil
              lower_module_method(module_name, member, call_arg_types, call_arg_literals, call_arg_enum_names)
            when CrystalV2::Compiler::Frontend::GetterNode
              next unless member.is_class?
              member.specs.each do |spec|
                generate_class_getter_method(module_name, spec, @arena)
              end
            when CrystalV2::Compiler::Frontend::SetterNode
              next unless member.is_class?
              member.specs.each do |spec|
                generate_class_setter_method(module_name, spec)
              end
            when CrystalV2::Compiler::Frontend::PropertyNode
              next unless member.is_class?
              member.specs.each do |spec|
                generate_class_getter_method(module_name, spec, @arena)
                generate_class_setter_method(module_name, spec)
              end
            when CrystalV2::Compiler::Frontend::ClassNode
              # Lower nested class with full name
              class_name = String.new(member.name)
              full_class_name = "#{module_name}::#{class_name}"
              if debug_env_filter_match?("DEBUG_NESTED_CLASS", module_name, class_name, full_class_name)
                STDERR.puts "[DEBUG_LOWER_MOD] lowering nested class: #{full_class_name}"
              end
              lower_class_with_name(member, full_class_name)
            when CrystalV2::Compiler::Frontend::ModuleNode
              # Recursively lower nested module
              nested_name = String.new(member.name)
              full_nested_name = "#{module_name}::#{nested_name}"
              lower_module_with_name(member, full_nested_name)
            when CrystalV2::Compiler::Frontend::CallNode
              lower_macro_call_in_module_body(module_name, member)
            when CrystalV2::Compiler::Frontend::IdentifierNode
              lower_macro_identifier_in_module_body(module_name, member)
            end
          end
        ensure
          @current_class = old_class
          @pending_def_annotations = old_pending
        end
      end
    end

    private def lower_module_body_expr(module_name : String, expr_id : ExprId)
      return if expr_id.invalid?

      member = unwrap_visibility_member(@arena[expr_id])
      if !member.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode) &&
         !member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
        clear_pending_effect_annotations
      end
      case member
      when CrystalV2::Compiler::Frontend::BlockNode
        member.body.each do |child_id|
          lower_module_body_expr(module_name, child_id)
        end
      when CrystalV2::Compiler::Frontend::AnnotationNode
        remember_effect_annotation(member, @arena)
      when CrystalV2::Compiler::Frontend::ExtendNode
        mark_module_extend_self(member, module_name)
      when CrystalV2::Compiler::Frontend::DefNode
        is_class_method = if recv = member.receiver
                            String.new(recv) == "self"
                          else
                            @module_extend_self.includes?(module_name)
                          end
        if is_class_method
          method_name = String.new(member.name)
          base_name = "#{module_name}.#{method_name}"
          param_types = [] of TypeRef
          has_block = false
          if params = member.params
            params.each do |param|
              next if named_only_separator?(param)
              if param.is_block
                has_block = true
                next
              end
              param_type = if ta = param.type_annotation
                             type_ref_for_name(String.new(ta))
                           elsif param.is_double_splat
                             type_ref_for_name("NamedTuple")
                           else
                             TypeRef::VOID
                           end
              param_types << param_type
            end
          end
          full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
          callsite_args = pending_callsite_args_for_def(member, base_name, full_name)
          call_arg_types = callsite_args ? callsite_args.types : nil
          call_arg_literals = callsite_args ? callsite_args.literals : nil
          call_arg_enum_names = callsite_args ? callsite_args.enum_names : nil
          lower_module_method(module_name, member, call_arg_types, call_arg_literals, call_arg_enum_names)
        end
      when CrystalV2::Compiler::Frontend::GetterNode
        return unless member.is_class?
        member.specs.each do |spec|
          generate_class_getter_method(module_name, spec, @arena)
        end
      when CrystalV2::Compiler::Frontend::SetterNode
        return unless member.is_class?
        member.specs.each do |spec|
          generate_class_setter_method(module_name, spec)
        end
      when CrystalV2::Compiler::Frontend::PropertyNode
        return unless member.is_class?
        member.specs.each do |spec|
          generate_class_getter_method(module_name, spec, @arena)
          generate_class_setter_method(module_name, spec)
        end
      when CrystalV2::Compiler::Frontend::ClassNode
        class_name = String.new(member.name)
        full_class_name = "#{module_name}::#{class_name}"
        register_class_with_name(member, full_class_name)
        lower_class_with_name(member, full_class_name)
      when CrystalV2::Compiler::Frontend::ModuleNode
        nested_name = String.new(member.name)
        full_nested_name = "#{module_name}::#{nested_name}"
        register_module_with_name(member, full_nested_name)
        lower_module_with_name(member, full_nested_name)
      when CrystalV2::Compiler::Frontend::EnumNode
        enum_name = String.new(member.name)
        full_enum_name = "#{module_name}::#{enum_name}"
        register_enum_with_name(member, full_enum_name)
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        # Parse macro literal output and lower its contents (defs/classes/modules).
        if raw_text = macro_literal_raw_text(member)
          expanded = expand_flag_macro_text(raw_text) || raw_text
          sanitized = strip_macro_lines(expanded)
          program = parse_macro_literal_program(expanded)
          if program.nil? && sanitized != expanded
            program = parse_macro_literal_program(sanitized)
          end
          if program
            with_arena(program.arena) do
              program.roots.each do |child_id|
                lower_module_body_expr(module_name, child_id)
              end
            end
            return
          end
        end

        texts = macro_literal_active_texts(member)
        combined = texts.join("\n")
        sanitized = strip_macro_lines(combined)
        program = parse_macro_literal_program(combined)
        if program.nil? && sanitized != combined
          program = parse_macro_literal_program(sanitized)
        end
        if program
          with_arena(program.arena) do
            program.roots.each do |child_id|
              lower_module_body_expr(module_name, child_id)
            end
          end
        end
      when CrystalV2::Compiler::Frontend::CallNode
        lower_macro_call_in_module_body(module_name, member)
      when CrystalV2::Compiler::Frontend::IdentifierNode
        lower_macro_identifier_in_module_body(module_name, member)
      end
    end

    private def lower_macro_call_in_module_body(
      module_name : String,
      node : CrystalV2::Compiler::Frontend::CallNode,
    )
      callee_node = @arena[node.callee]
      # (debug hook intentionally not used here)
      return unless callee_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)

      method_name = String.new(callee_node.name)
      macro_lookup = lookup_macro_entry_with_inheritance(method_name, module_name)
      if macro_lookup.nil? && module_name != "Object"
        macro_lookup = lookup_macro_entry(method_name, "Object")
      end
      return unless macro_lookup

      macro_entry, macro_key = macro_lookup
      macro_def, macro_arena = macro_entry
      macro_args, macro_block = extract_macro_block_from_args(node.args, node.block)
      expanded_id = expand_macro_expr(macro_def, macro_arena, macro_args, node.named_args, macro_block, macro_key)
      return if expanded_id.invalid?

      old_arena = @arena
      @arena = macro_arena
      begin
        lower_module_body_expr(module_name, expanded_id)
      ensure
        @arena = old_arena
      end
    end

    private def lower_macro_identifier_in_module_body(
      module_name : String,
      node : CrystalV2::Compiler::Frontend::IdentifierNode,
    )
      method_name = String.new(node.name)
      macro_lookup = lookup_macro_entry_with_inheritance(method_name, module_name)
      if macro_lookup.nil? && module_name != "Object"
        macro_lookup = lookup_macro_entry(method_name, "Object")
      end
      return unless macro_lookup

      macro_entry, macro_key = macro_lookup
      macro_def, macro_arena = macro_entry
      expanded_id = expand_macro_expr(macro_def, macro_arena, [] of ExprId, nil, nil, macro_key)
      return if expanded_id.invalid?

      old_arena = @arena
      @arena = macro_arena
      begin
        lower_module_body_expr(module_name, expanded_id)
      ensure
        @arena = old_arena
      end
    end

    # Lower a module method (static function)
    private def lower_module_method(
      module_name : String,
      node : CrystalV2::Compiler::Frontend::DefNode,
      call_arg_types : Array(TypeRef)? = nil,
      call_arg_literals : Array(Bool)? = nil,
      call_arg_enum_names : Array(String?)? = nil,
      full_name_override : String? = nil,
    )
      method_name = String.new(node.name)
      is_class_method = if recv = node.receiver
                          String.new(recv) == "self"
                        else
                          @module_extend_self.includes?(module_name)
                        end
      base_name = if is_class_method
                    "#{module_name}.#{method_name}"
                  else
                    "#{module_name}##{method_name}"
                  end

      if env_get("DEBUG_MATH_MIN") && module_name == "Math" && (method_name == "min" || method_name == "max")
        call_types = call_arg_types || [] of TypeRef
        call_type_names = call_types.map { |t| get_type_name_from_ref(t) }
        # Get param type annotations from node
        param_annotations = if params = node.params
                              params.map do |p|
                                if ta = p.type_annotation
                                  String.new(ta)
                                else
                                  "(untyped)"
                                end
                              end
                            else
                              [] of String
                            end
        STDERR.puts "[MATH_MIN_MODULE] module=#{module_name} method=#{method_name} override=#{full_name_override || "nil"} call_arg_types=#{call_type_names.join(",")} param_annotations=#{param_annotations.join(",")}"
      end

      # Defer lowering for untyped params until call-site types are available.
      # Allow typed overrides to seed call_arg_types from the mangled suffix.
      # Enum value tracking is per-function; preserve outer context.
      old_enum_value_types = @enum_value_types
      @enum_value_types = nil

      old_class = @current_class
      old_method = @current_method
      old_method_is_class = @current_method_is_class
      @current_class = module_name
      @current_method = method_name
      @current_method_is_class = is_class_method

      return_type = TypeRef::VOID

      # Collect parameter types for name mangling
      param_infos = [] of Tuple(String, TypeRef)
      param_default_literals = [] of String?
      param_type_names = [] of String? # Track type annotation names for enum detection
      param_literal_flags = [] of Bool
      param_types = [] of TypeRef
      has_block = false
      param_type_map = {} of String => TypeRef
      extra_type_params = {} of String => String
      old_typeof_locals = @current_typeof_locals
      old_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = param_type_map
      @current_typeof_local_names = {} of String => String
      call_types = call_arg_types || [] of TypeRef
      if env_has?("DEBUG_RANGE_LOWER") && base_name.includes?('[')
        call_type_names = call_types.map { |t| desc = @module.get_type_descriptor(t); desc ? "#{desc.name}(id=#{t.id})" : "T#{t.id}" }
        STDERR.puts "[RANGE_LOWER] module_name=#{module_name} method=#{method_name} call_types=#{call_type_names.join(", ")}"
      end
      call_literal_flags = call_arg_literals || [] of Bool
      call_enum_names = call_arg_enum_names || [] of String?
      if debug_hook_filter_match?(base_name)
        debug_hook(
          "method.callsite_literals",
          "name=#{base_name} types=#{call_types.map(&.id).join(",")} literals=#{call_literal_flags.join(",")}"
        )
      end
      call_index = 0
      splat_param_info_index : Int32? = nil
      splat_param_types_index : Int32? = nil
      splat_param_name : String? = nil

      if params = node.params
        params.each do |param|
          next if named_only_separator?(param)
          param_name = param.name.nil? ? "_" : String.new(param.name.not_nil!)
          is_ivar_param = param.is_instance_var || param_name.starts_with?('@')
          if is_ivar_param
            param_name = param_name.lstrip('@')
          end
          type_ann_str : String? = nil
          param_type = if ta = param.type_annotation
                         type_ann_str = String.new(ta)
                         type_ref_for_name(type_ann_str)
                       elsif param.is_double_splat
                         type_ref_for_name("NamedTuple")
                       else
                         TypeRef::VOID
                       end
          if type_ann_str && bare_generic_annotation?(type_ann_str)
            # Keep the generic base type for dispatch; allow callsite refinement.
            param_type = type_ref_for_name(strip_generic_args(type_ann_str))
          end
          call_type_for_param = if !param.is_block && !param.is_splat && !param.is_double_splat && call_index < call_types.size
                                  call_types[call_index]
                                else
                                  TypeRef::VOID
                                end
          if param_type == TypeRef::VOID && method_name == "hash" && param_name == "hasher"
            inferred = type_ref_for_name("Crystal::Hasher")
            param_type = inferred if inferred != TypeRef::VOID
          end
          if param_type == TypeRef::VOID && !param.is_block && !param.is_splat && !param.is_double_splat
            if call_index < call_types.size
              inferred = call_types[call_index]
              param_type = inferred if inferred != TypeRef::VOID
            end
          end
          if !param.is_block && !param.is_splat && !param.is_double_splat && call_index < call_types.size
            param_type = refine_param_type_from_call(param_type, call_types[call_index])
          end
          if type_ann_str && module_like_type_name?(type_ann_str)
            if call_index < call_types.size
              inferred = call_types[call_index]
              param_type = inferred if inferred != TypeRef::VOID
            end
          end
          if param_type == TypeRef::VOID && !param.is_block && !param.is_splat && !param.is_double_splat
            if default_value = param.default_value
              default_node = @arena[default_value]
              if debug_env_filter_match?("DEBUG_PARAM_DEFAULT", base_name, param_name)
                default_kind = default_node.class.name.split("::").last
                default_extra = default_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode) ? " kind=#{default_node.kind}" : ""
                STDERR.puts "[PARAM_DEFAULT] func=#{base_name} param=#{param_name} node=#{default_kind}#{default_extra}"
              end
              if default_node.is_a?(CrystalV2::Compiler::Frontend::NilNode)
                object_ref = type_ref_for_name("Object")
                param_type = create_union_type_for_nullable(object_ref) if object_ref != TypeRef::VOID
              else
                if inferred_default = infer_type_from_expr(default_value, module_name)
                  if debug_env_filter_match?("DEBUG_PARAM_DEFAULT", base_name, param_name)
                    inferred_name = get_type_name_from_ref(inferred_default)
                    STDERR.puts "[PARAM_DEFAULT] func=#{base_name} param=#{param_name} inferred=#{inferred_name}"
                  end
                  param_type = inferred_default if inferred_default != TypeRef::VOID
                end
              end
            end
          end
          if param_type == TypeRef::VOID && !param.is_block && !param.is_splat && !param.is_double_splat
            if default_value = param.default_value
              inferred = infer_type_from_expr(default_value, module_name)
              param_type = inferred if inferred && inferred != TypeRef::VOID
            end
          end
          if param_name.ends_with?("_class") && call_type_for_param != TypeRef::VOID
            param_type = call_type_for_param
          end
          param_type_map[param_name] = param_type
          param_infos << {param_name, param_type}
          param_default_literals << extract_param_default_literal(param)
          enum_name = call_index < call_enum_names.size ? call_enum_names[call_index] : nil
          param_type_names << (type_ann_str || enum_name)
          if ta = param.type_annotation
            update_typeof_local_name(param_name, String.new(ta))
          end
          param_literal = !param.is_block && !param.is_splat && !param.is_double_splat &&
                          call_index < call_literal_flags.size && call_literal_flags[call_index]
          if param_name.ends_with?("_class")
            chosen_type = call_type_for_param == TypeRef::VOID ? param_type : call_type_for_param
            type_name = get_type_name_from_ref(chosen_type)
            if !type_name.empty? && type_name != "Void" && type_name != "Unknown"
              param_literal = true
            end
          end
          if param_literal
            chosen_type = call_type_for_param == TypeRef::VOID ? param_type : call_type_for_param
            type_name = get_type_name_from_ref(chosen_type)
            if !type_name.empty? && type_name != "Void" && type_name != "Unknown"
              update_typeof_local_name(param_name, type_name)
              extra_type_params[param_name] = type_name
            end
          end
          if param.is_block
            has_block = true
          else
            if param.is_splat
              splat_param_info_index = param_infos.size - 1
              splat_param_types_index = param_types.size
              splat_param_name = param_name
            elsif !param.is_double_splat
              call_index += 1
            end
            param_types << param_type
          end
          param_literal_flags << param_literal
          if debug_hook_filter_match?(base_name)
            debug_hook(
              "param.literal",
              "name=#{base_name} param=#{param_name} literal=#{param_literal}"
            )
          end
        end
      end

      if registered_params = function_type_param_map_for(full_name_override || base_name, base_name)
        extra_type_params.merge!(registered_params)
        if debug_env_filter_match?("DEBUG_LOWER_METHOD_TPM", full_name_override || base_name, base_name)
          STDERR.puts "[LOWER_MODULE_TPM] base=#{base_name} override=#{full_name_override || "nil"} merged=#{registered_params}"
        end
      end

      if splat_param_name
        splat_type = TypeRef::VOID
        if !call_types.empty?
          remaining = call_types[call_index..-1]? || [] of TypeRef
          # Avoid re-wrapping: if single remaining arg is already a Tuple, use it directly
          if remaining.size == 1
            rname = get_type_name_from_ref(remaining[0])
            if rname.starts_with?("Tuple")
              splat_type = remaining[0]
            else
              splat_type = tuple_type_from_arg_types(remaining, allow_void: true)
            end
          else
            splat_type = tuple_type_from_arg_types(remaining, allow_void: true)
          end
        end
        if splat_type == TypeRef::VOID
          if elem_type = param_type_map[splat_param_name.not_nil!]?
            if elem_type != TypeRef::VOID
              # Avoid re-wrapping: if elem_type is already a Tuple, use it directly
              elem_name = get_type_name_from_ref(elem_type)
              if elem_name.starts_with?("Tuple")
                splat_type = elem_type
              else
                splat_type = tuple_type_from_arg_types([elem_type], allow_void: true)
              end
            end
          end
        end
        if splat_type == TypeRef::VOID
          fallback = type_ref_for_name("Tuple")
          splat_type = fallback if fallback != TypeRef::VOID
        end
        if splat_type != TypeRef::VOID
          param_type_map[splat_param_name.not_nil!] = splat_type
          if idx = splat_param_info_index
            param_infos[idx] = {splat_param_name.not_nil!, splat_type}
          end
          if idx = splat_param_types_index
            param_types[idx] = splat_type
          end
        end
        if env_get("DEBUG_IN_ANY_CATEGORY") && base_name == "Unicode.in_any_category?"
          splat_name = splat_param_name.not_nil!
          splat_type_name = get_type_name_from_ref(splat_type)
          call_names = call_types.map { |t| get_type_name_from_ref(t) }
          param_names = param_types.map { |t| get_type_name_from_ref(t) }
          STDERR.puts "[IN_ANY_CATEGORY] base=#{base_name} splat=#{splat_name} splat_type=#{splat_type_name} call_types=#{call_names.join(",")} param_types=#{param_names.join(",")}"
        end
      end

      if rt = node.return_type
        if extra_type_params.empty?
          return_type = type_ref_for_name(String.new(rt))
        else
          with_type_param_map(extra_type_params) do
            return_type = type_ref_for_name(String.new(rt))
          end
        end
      end

      # Mangle function name with parameter types
      full_name = full_name_override || function_full_name_for_def(base_name, param_types, node.params, has_block)

      register_pending_method_effects(full_name, param_types.size)

      func = @module.create_function(full_name, return_type)
      ctx = LoweringContext.new(func, @module, @arena)
      if ctx.lookup_local("self").nil? && func.name.includes?('#')
        if receiver_param = func.params.first?
          ctx.register_local("self", receiver_param.id)
          ctx.register_type(receiver_param.id, receiver_param.type)
        end
      end

      # Bind implicit self for module methods.
      if is_class_method
        self_type = type_ref_for_name(module_name)
        if self_type == TypeRef::VOID
          module_base = strip_generic_args(module_name)
          if module_base != module_name
            self_type = type_ref_for_name(module_base)
          end
        end
        if self_type == TypeRef::VOID
          self_type = TypeRef::POINTER
        end
        self_literal = Literal.new(ctx.next_id, self_type, nil)
        ctx.emit(self_literal)
        ctx.register_local("self", self_literal.id)
        ctx.register_type(self_literal.id, self_type)
        ctx.mark_type_literal(self_literal.id)
        @type_literal_values.add(self_literal.id)
      else
        self_type = type_ref_for_name(module_name)
        if self_type == TypeRef::VOID
          module_base = strip_generic_args(module_name)
          if module_base != module_name
            self_type = type_ref_for_name(module_base)
          end
        end
        if self_type == TypeRef::VOID
          self_type = TypeRef::POINTER
        end
        self_param = func.add_param("self", self_type)
        ctx.register_local("self", self_param.id)
        ctx.register_type(self_param.id, self_type)
      end

      # Lower explicit parameters.
      param_infos.each_with_index do |(param_name, param_type), idx|
        hir_param = func.add_param(param_name, param_type)
        if default_lit = param_default_literals[idx]?
          hir_param.default_literal = default_lit
        end
        ctx.register_local(param_name, hir_param.id)
        ctx.register_type(hir_param.id, param_type)
        if debug_env_filter_match?("DEBUG_PARAM_TYPES", full_name, param_name)
          type_name = get_type_name_from_ref(param_type)
          STDERR.puts "[PARAM_TYPES] func=#{full_name} param=#{param_name} id=#{hir_param.id} type=#{type_name}(id=#{param_type.id})"
        end
        if env_get("DEBUG_SPLAT_PARAM") && param_name == "args"
          STDERR.puts "[SPLAT_PARAM] func=#{full_name} param=#{param_name} type=#{get_type_name_from_ref(param_type)}"
        end
        if (param_literal_flags[idx]? || param_name.ends_with?("_class")) && param_type != TypeRef::VOID
          call_type_for_param = idx < call_types.size ? call_types[idx] : TypeRef::VOID
          module_param = module_type_ref?(param_type)
          if !module_param && call_type_for_param != TypeRef::VOID
            module_param = module_type_ref?(call_type_for_param)
          end
          ctx.mark_type_literal(hir_param.id) unless module_param
        end
        # Track enum types for predicate method resolution
        if type_name = param_type_names[idx]?
          track_enum_value(hir_param.id, type_name)
        end
      end

      # Lower body
      # IMPORTANT: Save and clear inline yield stacks to prevent cross-context contamination.
      # When lowering a standalone function, yield should emit a Yield instruction,
      # NOT substitute an inline block from an unrelated call context.
      saved_yield_block_stack = @inline_yield_block_stack
      saved_yield_arena_stack = @inline_yield_block_arena_stack
      saved_yield_param_stack = @inline_yield_block_param_types_stack
      saved_yield_return_stack = @inline_yield_block_return_stack
      saved_yield_name_stack = @inline_yield_name_stack
      saved_inline_arenas = @inline_arenas
      @inline_yield_block_stack = [] of CrystalV2::Compiler::Frontend::BlockNode
      @inline_yield_block_arena_stack = [] of CrystalV2::Compiler::Frontend::ArenaLike
      @inline_yield_block_param_types_stack = [] of Array(TypeRef)?
      @inline_yield_block_return_stack = [] of String?
      @inline_yield_name_stack = [] of String
      @inline_arenas = nil
      last_value : ValueId? = nil
      begin
        body_exprs = node.body
        if body_exprs
          assigned_vars = collect_assigned_vars(body_exprs).to_set
          @assigned_vars_stack << assigned_vars
          method_arena = @arena
          if extra_type_params.empty?
            i = 0
            while i < body_exprs.size
              expr_id = body_exprs[i]
              with_arena(method_arena) do
                last_value = lower_expr(ctx, expr_id)
              end
              break if should_stop_sequential_lowering?(ctx)

              i += 1
            end
          else
            with_type_param_map(extra_type_params) do
              i = 0
              while i < body_exprs.size
                expr_id = body_exprs[i]
                with_arena(method_arena) do
                  last_value = lower_expr(ctx, expr_id)
                end
                break if should_stop_sequential_lowering?(ctx)

                i += 1
              end
            end
          end
        end
      ensure
        @assigned_vars_stack.pop? if body_exprs
        @inline_yield_block_stack = saved_yield_block_stack
        @inline_yield_block_arena_stack = saved_yield_arena_stack
        @inline_yield_block_param_types_stack = saved_yield_param_stack
        @inline_yield_block_return_stack = saved_yield_return_stack
        @inline_yield_name_stack = saved_yield_name_stack
        @inline_arenas = saved_inline_arenas
      end

      # Infer return type from all Return terminators + last expression.
      # Functions with explicit `return` inside conditionals may return different
      # types from different paths. We must merge all of them.
      if node.return_type.nil?
        inferred_types = [] of TypeRef

        # Collect types from all Return terminators
        func.blocks.each do |block|
          term = block.terminator
          next unless term.is_a?(Return)
          if value = term.value
            t = ctx.type_of(value)
            inferred_types << t unless t == TypeRef::VOID
          else
            inferred_types << TypeRef::NIL
          end
        end

        # Also consider the last expression
        if (last_id = last_value)
          t = ctx.type_of(last_id)
          inferred_types << t unless t == TypeRef::VOID
        end

        if inferred_types.any?
          inferred_type = merge_return_types(inferred_types)
          if inferred_type && inferred_type != TypeRef::VOID && inferred_type != return_type
            return_type = inferred_type
            func.return_type = inferred_type
          end
        end
      end

      register_function_type(full_name, return_type)

      @current_typeof_locals = old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names

      # Restore current class
      @current_class = old_class
      @current_method = old_method
      @current_method_is_class = old_method_is_class || false

      # Add implicit return if not already terminated
      # BUT don't add return after raise (which sets Unreachable terminator)
      block = ctx.get_block(ctx.current_block)
      block_has_raise = block.instructions.any? { |inst| inst.is_a?(Raise) }
      if block.terminator.is_a?(Unreachable) && !block_has_raise
        block.terminator = Return.new(last_value)
      end

      @enum_value_types = old_enum_value_types
    end

    # Register a class type and its methods (pass 1)
    def register_class(node : CrystalV2::Compiler::Frontend::ClassNode)
      class_name = String.new(node.name)
      if debug_env_filter_match?("DEBUG_NESTED_CLASS", class_name)
        STDERR.puts "[DEBUG_CLASS_REG] register_class called: #{class_name}"
      end
      old_class = @current_class
      old_override = @current_namespace_override
      @current_class = nil
      @current_namespace_override = nil
      begin
        register_class_with_name(node, class_name)
      ensure
        @current_class = old_class
        @current_namespace_override = old_override
      end
    end

    # Register a class with a specific name (for nested classes like Foo::Bar)
    def register_class_with_name(node : CrystalV2::Compiler::Frontend::ClassNode, class_name : String)
      class_name = resolve_class_name_for_definition(class_name)
      old_class = @current_class
      old_override = @current_namespace_override
      @current_class = class_name
      begin
        if env_get("DEBUG_TYPE_PATH") && class_name.includes?('/')
          current_path = @paths_by_arena[@arena]? || "(unknown)"
          STDERR.puts "[TYPE_PATH_CLASS] name=#{class_name} file=#{File.basename(current_path)} span=#{node.span.start_line}:#{node.span.start_column}"
        end
        if env_get("DEBUG_WUINT128") && class_name.includes?("UInt128")
          STDERR.puts "[DEBUG_WUINT128] register_class_with_name class_name=#{class_name} is_struct=#{node.is_struct}"
        end
        if env_get("DEBUG_WUINT128") && class_name.includes?("WUInt::UInt128")
          STDERR.puts "[DEBUG_WUINT128] --> Adding to @class_info: #{class_name}"
        end
        if env_get("DEBUG_STRING_CLASS") && class_name == "String"
          STDERR.puts "[STRING_CLASS_REG] class=#{class_name} span=#{node.span.start_line}-#{node.span.end_line}"
        end
        if env_get("DEBUG_LIBC_EXTERN") && class_name.ends_with?("DlInfo")
          STDERR.puts "[DEBUG_LIBC_EXTERN] register_class #{class_name}"
        end
        if env_get("DEBUG_RECORD_CLASS") && class_name.ends_with?("FileEntry")
          STDERR.puts "[DEBUG_RECORD_CLASS] class_name=#{class_name} current=#{@current_class || "(none)"}"
        end
        is_struct = node.is_struct == true
        record_nested_type_names(class_name, node.body)

        # Check if this is a generic class (has type parameters)
        if type_params = node.type_params
          if type_params.size > 0
            # Store as generic template - don't create ClassInfo yet.
            # Keep the template with the LARGEST body as primary, but preserve reopenings
            # so additional methods (e.g., Range#bsearch) are not lost.
            new_body_size = node.body.try(&.size) || 0
            if env_has?("DEBUG_GENERIC_TEMPLATE")
              current_path = @paths_by_arena[@arena]? || "(unknown)"
              STDERR.puts "[GENERIC_TEMPLATE] #{class_name}: body_size=#{new_body_size} file=#{File.basename(current_path)}"
            end
            param_names = type_params.map { |p| String.new(p) }
            new_template = GenericClassTemplate.new(class_name, param_names, node, @arena, is_struct)

            if existing = @generic_templates[class_name]?
              existing_body_size = existing.node.body.try(&.size) || 0
              if new_body_size > existing_body_size
                (@generic_reopenings[class_name] ||= [] of GenericClassTemplate) << existing
                @generic_templates[class_name] = new_template
              else
                (@generic_reopenings[class_name] ||= [] of GenericClassTemplate) << new_template
              end
              invalidate_type_cache_for_namespace(class_name)
            else
              @generic_templates[class_name] = new_template
            end

            # Register nested types inside generic templates under the base namespace.
            if body = node.body
              body.each do |expr_id|
                member = unwrap_visibility_member(@arena[expr_id])
                case member
                when CrystalV2::Compiler::Frontend::ClassNode
                  nested_name = String.new(member.name)
                  full_nested_name = "#{class_name}::#{nested_name}"
                  register_class_with_name(member, full_nested_name)
                when CrystalV2::Compiler::Frontend::EnumNode
                  enum_name = String.new(member.name)
                  full_enum_name = "#{class_name}::#{enum_name}"
                  register_enum_with_name(member, full_enum_name)
                when CrystalV2::Compiler::Frontend::ModuleNode
                  nested_name = String.new(member.name)
                  full_nested_name = "#{class_name}::#{nested_name}"
                  register_nested_module(member, full_nested_name)
                when CrystalV2::Compiler::Frontend::MacroDefNode
                  register_macro(member, class_name)
                end
              end
              record_constants_in_body(class_name, body)
            end
            return # Don't register as concrete class
          end
        end

        # Non-generic class - proceed with normal registration
        register_concrete_class(node, class_name, is_struct)
      ensure
        @current_class = old_class
        @current_namespace_override = old_override
      end
    end

    # Register a concrete (non-generic or specialized) class
    private def register_concrete_class(node : CrystalV2::Compiler::Frontend::ClassNode, class_name : String, is_struct : Bool)
      # Check if class already exists (class reopening)
      existing_info = @class_info[class_name]?
      mono_debug = env_has?("DEBUG_MONO") && (class_name.starts_with?("Hash(") || class_name.starts_with?("Set("))
      mono_start = Time.instant if mono_debug
      had_module_defs = @module_defs.has_key?(class_name)
      if had_module_defs
        @module_defs.delete(class_name)
        @module_defs_cache_version += 1
      end
      if existing_info || had_module_defs
        invalidate_type_cache_for_namespace(class_name)
      else
        # Ensure short-name caches are invalidated when introducing nested types
        # that can shadow builtins or top-level types (e.g., WUInt::UInt128).
        if short = last_namespace_component_if_nested(class_name)
          if BUILTIN_TYPE_NAMES.includes?(short) || @top_level_class_kinds.has_key?(short) || @top_level_type_names.includes?(short)
            invalidate_type_cache_for_namespace(class_name)
          end
        end
      end

      # Collect instance variables and their types
      ivars = [] of IVarInfo
      class_vars = [] of ClassVarInfo
      # C lib structs use C type sizes (Char=1 byte instead of 4)
      is_c_struct = @lib_structs.includes?(class_name)
      # Struct has no type_id header (value type), class starts at 4 for i32 type_id header
      offset = is_struct ? 0 : 4

      # If class already exists, preserve existing ivars and class_vars
      if existing_info
        existing_info.ivars.each { |iv| ivars << iv.dup }
        existing_info.class_vars.each { |cv| class_vars << cv.dup }
        offset = existing_info.size
      end

      # Inheritance: copy parent ivars first (to preserve layout)
      # Only do this for new class definitions, not reopened classes
      parent_name : String? = nil
      if !existing_info && (super_name_slice = node.super_name)
        raw_parent = String.new(super_name_slice)
        old_class = @current_class
        @current_class = class_name
        parent_name = resolve_type_name_in_context(raw_parent)
        @current_class = old_class
        if parent_info = @class_info[parent_name]?
          # Copy all ivars from parent, preserving their offsets
          parent_info.ivars.each do |parent_ivar|
            ivars << parent_ivar.dup
          end
          # Start child ivars after parent ivars
          offset = parent_info.size
        end
      elsif existing_info
        parent_name = existing_info.parent_name
      end
      if parent_name.nil?
        parent_name = builtin_parent_for(class_name, is_struct)
      end

      type_kind = is_struct ? TypeKind::Struct : TypeKind::Class
      type_ref = if existing_info
                   existing_info.type_ref
                 else
                   # Check for primitive types - use well-known TypeRefs
                   case class_name
                   when "Bool"    then TypeRef::BOOL
                   when "Int8"    then TypeRef::INT8
                   when "Int16"   then TypeRef::INT16
                   when "Int32"   then TypeRef::INT32
                   when "Int64"   then TypeRef::INT64
                   when "Int128"  then TypeRef::INT128
                   when "UInt8"   then TypeRef::UINT8
                   when "UInt16"  then TypeRef::UINT16
                   when "UInt32"  then TypeRef::UINT32
                   when "UInt64"  then TypeRef::UINT64
                   when "UInt128" then TypeRef::UINT128
                   when "Float32" then TypeRef::FLOAT32
                   when "Float64" then TypeRef::FLOAT64
                   when "Char"    then TypeRef::CHAR
                   when "String"  then TypeRef::STRING
                   when "Symbol"  then TypeRef::SYMBOL
                   when "Nil"     then TypeRef::NIL
                   else
                     # For generic instantiations, reuse type_ref_for_name so the TypeRef id
                     # matches annotations and preserves Hash/Array kinds.
                     if class_name.includes?('(')
                       type_ref_for_name(class_name)
                     else
                       if upgraded = upgrade_module_type_for_class(class_name, type_kind)
                         store_type_cache(type_cache_key(class_name), upgraded)
                         upgraded
                       else
                         @module.intern_type(TypeDescriptor.new(type_kind, class_name))
                       end
                     end
                   end
                 end

      # Also find initialize to get constructor parameters
      init_capture = InitParamsCapture.new
      init_params = init_capture.params

      class_body = node.body || [] of CrystalV2::Compiler::Frontend::ExprId
      if !class_body.empty?
        specialized_class = class_name.includes?('(')
        if mono_debug
          STDERR.puts "[MONO] register_concrete_class #{class_name} body_size=#{class_body.size}"
        end
        old_suppress = @suppress_monomorphization
        @suppress_monomorphization = @suppress_monomorphization || specialized_class
        # PASS 0: Register nested types first so method signatures and bodies can resolve them
        # (e.g., Dir::EntryIterator used as `EntryIterator` inside Dir).
        pass0_start = Time.instant if mono_debug
        nested_prefix = if info = split_generic_base_and_args(class_name)
                          info[:base]
                        else
                          class_name
                        end
        class_body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          case member
          when CrystalV2::Compiler::Frontend::ClassNode
            nested_name = String.new(member.name)
            full_nested_name = "#{nested_prefix}::#{nested_name}"
            register_class_with_name(member, full_nested_name)
            # When parent has active type substitutions and nested type is generic,
            # also monomorphize the nested type with the substituted type args.
            # E.g., Hash(String, Int32)::Entry(K, V) → Hash::Entry(String, Int32)
            if !@type_param_map.empty? && (nested_type_params = member.type_params) && nested_type_params.size > 0
              type_args = nested_type_params.map { |p| @type_param_map[String.new(p)]? || String.new(p) }
              if concrete_type_args?(type_args)
                specialized_nested = "#{full_nested_name}(#{type_args.join(", ")})"
                unless @monomorphized.includes?(specialized_nested)
                  if @defer_monomorphization
                    @pending_monomorphizations << {full_nested_name, type_args, specialized_nested}
                  else
                    monomorphize_generic_class(full_nested_name, type_args, specialized_nested)
                  end
                end
              end
            end
          when CrystalV2::Compiler::Frontend::EnumNode
            enum_name = String.new(member.name)
            full_enum_name = "#{nested_prefix}::#{enum_name}"
            register_enum_with_name(member, full_enum_name)
          when CrystalV2::Compiler::Frontend::ModuleNode
            nested_name = String.new(member.name)
            full_nested_name = "#{nested_prefix}::#{nested_name}"
            register_nested_module(member, full_nested_name)
          when CrystalV2::Compiler::Frontend::MacroDefNode
            register_macro(member, nested_prefix)
          end
        end
        if mono_debug && pass0_start
          elapsed = (Time.instant - pass0_start).total_milliseconds
          STDERR.puts "[MONO] #{class_name} pass0 nested types #{elapsed.round(1)}ms"
        end

        # Set current class context BEFORE collecting method signatures
        # so type lookups resolve in the correct namespace
        old_class = @current_class
        @current_class = class_name
        include_nodes = [] of CrystalV2::Compiler::Frontend::IncludeNode
        extend_nodes = [] of CrystalV2::Compiler::Frontend::ExtendNode
        class_body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          case member
          when CrystalV2::Compiler::Frontend::IncludeNode
            include_nodes << member
            if module_name = resolve_path_like_name(member.target)
              record_module_inclusion(module_name, class_name)
            end
          when CrystalV2::Compiler::Frontend::ExtendNode
            extend_nodes << member
            if module_name = resolve_path_like_name(member.target)
              record_module_inclusion(module_name, class_name)
            end
          end
        end
        record_constants_in_body(class_name, class_body)
        # Seed provisional class info so return-type inference can see ivars
        # collected during registration (initialize assignments, ivar decls, etc.).
        provisional_info = ClassInfo.new(
          class_name,
          type_ref,
          ivars,
          class_vars,
          offset,
          is_struct,
          parent_name
        )
        @class_info[class_name] = provisional_info
        @class_info_by_type_id[type_ref.id] = provisional_info
        @class_info_version += 1

        defined_start = Time.instant if mono_debug
        if env_has?("DEBUG_TYPE_RESOLVE") && class_name == "IO"
          STDERR.puts "[DEBUG_IO] About to collect_defined_instance_method_full_names for IO"
          STDERR.puts "[DEBUG_IO]   enum_info Seek keys: #{@enum_info.try(&.keys.select { |k| k.includes?("Seek") }) || "nil"}"
        end
        defined_instance_method_full_names = collect_defined_instance_method_full_names(class_name, class_body)
        defined_class_method_full_names = collect_defined_class_method_full_names(class_name, class_body)
        if mono_debug && defined_start
          elapsed = (Time.instant - defined_start).total_milliseconds
          STDERR.puts "[MONO] #{class_name} collect_defined_instance_methods #{elapsed.round(1)}ms"
        end

        begin
          body_start = Time.instant if mono_debug
          skip_next = false
          class_body.each_with_index do |expr_id, idx|
            if skip_next
              skip_next = false
              next
            end
            member = unwrap_visibility_member(@arena[expr_id])
            if env_get("DEBUG_CLASS_BODY_CALLS") && class_name.includes?("WUInt::UInt128")
              STDERR.puts "[DEBUG_BODY_MEMBER] #{class_name} idx=#{idx} type=#{member.class.name.split("::").last}"
            end
            member_start = mono_debug ? Time.instant : nil
            return_elapsed = nil
            param_elapsed = nil
            yield_elapsed = nil
            case member
            when CrystalV2::Compiler::Frontend::IncludeNode
              next
            when CrystalV2::Compiler::Frontend::ExtendNode
              next
            when CrystalV2::Compiler::Frontend::InstanceVarDeclNode
              # Instance variable declaration: @value : Int32 = expr
              ivar_name = String.new(member.name)
              ivar_type = type_ref_for_name(String.new(member.type))
              # Store default value expression if present
              default_expr_id : CrystalV2::Compiler::Frontend::ExprId? = nil
              default_arena : CrystalV2::Compiler::Frontend::ArenaLike? = nil
              if val_expr = member.value
                val_node = @arena[val_expr]
                unless is_trivial_default(val_node)
                  default_expr_id = val_expr
                  default_arena = @arena
                end
              end
              offset = align_offset(offset, type_alignment(ivar_type, is_c_struct))
              ivars << IVarInfo.new(ivar_name, ivar_type, offset,
                default_expr_id: default_expr_id,
                default_arena: default_arena)
              offset += type_size(ivar_type, is_c_struct)
            when CrystalV2::Compiler::Frontend::TypeDeclarationNode
              # Lib struct field declaration: value : Type
              if is_struct
                field_name = String.new(member.name)
                ivar_name = field_name.starts_with?('@') ? field_name : "@#{field_name}"
                ivar_type = type_ref_for_name(String.new(member.declared_type))
                unless ivars.any? { |iv| iv.name == ivar_name }
                  offset = align_offset(offset, type_alignment(ivar_type, is_c_struct))
                  ivars << IVarInfo.new(ivar_name, ivar_type, offset)
                  offset += type_size(ivar_type, is_c_struct)
                end
              end
            when CrystalV2::Compiler::Frontend::ClassVarDeclNode
              # Class variable declaration: @@total : Int32 = 0
              # Name includes @@ prefix, strip it
              raw_name = String.new(member.name)
              cvar_name = raw_name.lstrip('@')
              cvar_type = type_ref_for_name(String.new(member.type))
              if env_has?("DEBUG_DEFERRED_CLASSVAR")
                STDERR.puts "[DEFERRED_CLASSVAR] Found ClassVarDeclNode: class=#{class_name} cvar=#{cvar_name} has_value=#{!member.value.nil?}"
              end
              # Get initial value if present (only supporting literal integers for now)
              initial_value : Int64? = nil
              needs_runtime_init = false
              if val_id = member.value
                val_node = @arena[val_id]
                if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
                  # Parse the number from its text representation
                  num_str = String.new(val_node.value)
                  initial_value = num_str.to_i64?
                else
                  # Non-numeric initializer (e.g., [] of String) - defer to runtime
                  needs_runtime_init = true
                end
              end
              class_vars << ClassVarInfo.new(cvar_name, cvar_type, initial_value)
              # Defer complex classvar initializers to run at start of __crystal_main
              if needs_runtime_init
                @deferred_classvar_inits << {expr_id, @arena, class_name}
                if env_has?("DEBUG_DEFERRED_CLASSVAR")
                  STDERR.puts "[DEFERRED_CLASSVAR] Added: class=#{class_name} cvar=#{cvar_name}"
                end
              end
            when CrystalV2::Compiler::Frontend::ClassVarNode
              # Parser quirk: @@var : Type appears as ClassVarNode + PathNode.
              raw_name = String.new(member.name)
              cvar_name = raw_name.lstrip('@')
              if idx + 1 < class_body.size
                next_id = class_body[idx + 1]
                next_node = @arena[next_id]
                if next_node.is_a?(CrystalV2::Compiler::Frontend::PathNode)
                  type_name = collect_path_string(next_node)
                  cvar_type = type_ref_for_name(type_name)
                  class_vars << ClassVarInfo.new(cvar_name, cvar_type, nil)
                  skip_next = true
                end
              end
            when CrystalV2::Compiler::Frontend::AnnotationNode
              # Scan for @[Primitive(:name)] during registration so demand-driven
              # lowering knows which methods are primitives (skip body compilation).
              remember_effect_annotation(member, @arena)
            when CrystalV2::Compiler::Frontend::DefNode
              # Register method signature
              method_name = String.new(member.name)
              if env_get("DEBUG_PROC_METHOD") && method_name == "internal_representation"
                STDERR.puts "[PROC_METHOD] class=#{class_name} method=#{method_name} rt=#{member.return_type ? String.new(member.return_type.not_nil!) : "(nil)"}"
              end
              # Check if this is a class method (def self.method) or instance method (def method)
              is_class_method = if recv = member.receiver
                                  String.new(recv) == "self"
                                else
                                  false
                                end
              # Use . for class methods, # for instance methods
              base_name = if is_class_method
                            "#{class_name}.#{method_name}"
                          else
                            "#{class_name}##{method_name}"
                          end
              # Register primitive from preceding @[Primitive(:name)] annotation
              if prim = @pending_primitive_kind
                @pending_primitive_kind = nil
                @module.register_primitive(base_name, prim)
                if env_get("DEBUG_PRIMITIVES")
                  STDERR.puts "[PRIMITIVE_REG] #{base_name} → :#{prim}"
                end
              end
              return_start = mono_debug ? Time.instant : nil
              type_literal_name = infer_type_literal_return_name_from_body(member, class_name)
              enum_return_name : String? = nil
              return_type = if rt = member.return_type
                              rt_name = String.new(rt)
                              resolved_rt_name = resolve_type_name_in_context(rt_name)
                              enum_return_name = resolve_enum_name(resolved_rt_name)
                              if env_get("DEBUG_ENUM_RETURN") && class_name == "File::Info" && method_name == "type"
                                STDERR.puts "[DEBUG_ENUM_RETURN] class=#{class_name} rt=#{rt_name} resolved=#{resolved_rt_name} enum=#{enum_return_name || "(nil)"}"
                              end
                              inferred = module_like_type_name?(rt_name) ? infer_concrete_return_type_from_body(member, class_name) : nil
                              resolved = inferred || type_ref_for_name(rt_name)
                              if resolved == TypeRef::VOID && method_name.ends_with?('?')
                                self_type = type_ref_for_name(class_name)
                                resolved = infer_unannotated_query_return_type(method_name, self_type) || resolved
                              end
                              resolved
                            elsif method_name.ends_with?('?')
                              self_type = type_ref_for_name(class_name)
                              inferred = infer_unannotated_query_return_type(method_name, self_type)
                              inferred ||= infer_concrete_return_type_from_body(member, class_name)
                              inferred || fallback_query_return_type(method_name)
                            else
                              # Try to infer return type from getter-style methods (single ivar access).
                              inferred = infer_getter_return_type(member, ivars)
                              inferred = infer_concrete_return_type_from_body(member, class_name) if inferred.nil?
                              inferred ||= infer_unannotated_search_return_type(method_name, type_ref_for_name(class_name))
                              inferred || TypeRef::VOID
                            end
              if type_literal_name
                literal_ref = type_ref_for_name(type_literal_name)
                if return_type == TypeRef::VOID || return_type == TypeRef::NIL
                  return_type = literal_ref if literal_ref != TypeRef::VOID
                end
              end
              return_elapsed = return_start ? (Time.instant - return_start).total_milliseconds : nil
              # Collect parameter types for mangling
              method_param_types = [] of TypeRef
              has_block = false
              param_start = mono_debug ? Time.instant : nil
              if params = member.params
                params.each do |param|
                  next if named_only_separator?(param)
                  if param.is_block
                    has_block = true
                    next
                  end
                  param_type = if ta = param.type_annotation
                                 type_ref_for_name(String.new(ta))
                               elsif param.is_double_splat
                                 type_ref_for_name("NamedTuple")
                               else
                                 TypeRef::VOID
                               end
                  method_param_types << param_type
                end
              end
              param_elapsed = param_start ? (Time.instant - param_start).total_milliseconds : nil
              # Resolve arena once to avoid repeated resolution in def_contains_yield?
              member_arena = if arena_fits_def?(@arena, member)
                               @arena
                             else
                               resolve_arena_for_def(member, @arena)
                             end
              if !has_block
                has_block = def_contains_yield?(member, member_arena)
              end
              full_name = function_full_name_for_def(base_name, method_param_types, member.params, has_block)
              alias_full_name = nil
              alias_base = nil
              if is_class_method
                base_owner = if info = split_generic_base_and_args(class_name)
                               info[:base]
                             else
                               class_name
                             end
                if base_owner != class_name
                  alias_base = "#{base_owner}.#{method_name}"
                  alias_full_name = function_full_name_for_def(alias_base, method_param_types, member.params, has_block)
                end
              end
              if filter = env_get("DEBUG_METHOD_REGISTER_FILTER")
                if filter == "1" || class_name.includes?(filter) || method_name.includes?(filter)
                  STDERR.puts "[DEBUG_METHOD_REGISTER] class=#{class_name} method=#{method_name} full=#{full_name}"
                end
              end
              if type_literal_name
                literal_ref = type_ref_for_name(type_literal_name)
                if literal_ref != TypeRef::VOID
                  record_type_literal_return(full_name, base_name)
                end
              end
              if enum_return_name
                @function_enum_return_names[full_name] = enum_return_name
                @function_enum_return_names[base_name] = enum_return_name
                if alias_full_name && alias_base
                  @function_enum_return_names[alias_full_name] = enum_return_name
                  @function_enum_return_names[alias_base] = enum_return_name
                end
              end
              if debug_env_filter_match?("DEBUG_NESTED_CLASS", class_name, method_name)
                STDERR.puts "[DEBUG_METHOD_REG] #{class_name}: #{method_name} -> #{full_name} (class_method=#{is_class_method})"
              end
              register_function_type(full_name, return_type)
              @function_defs[full_name] = member
              # Resolve correct arena for the def node to avoid cross-file contamination.
              # When registering methods from a monomorphized generic class, @arena may point
              # to a different file than where the method was actually defined.
              if debug_env_filter_match?("DEBUG_ARENA_RESOLVE", class_name, method_name, full_name)
                current_path = source_path_for(@arena) || "(unknown)"
                resolved_path = source_path_for(member_arena) || "(unknown)"
                STDERR.puts "[ARENA_RESOLVE] full=#{full_name} current=#{current_path}:#{@arena.size} resolved=#{resolved_path}:#{member_arena.size} member.span=#{member.span.start_offset}..#{member.span.end_offset}"
              end
              @function_def_arenas[full_name] = member_arena
              # Store type param map for lazy lowering of generic class methods.
              # When a monomorphized class registers its methods, the @type_param_map
              # contains substitutions (e.g., T => UInt8) needed for macro evaluation.
              unless @type_param_map.empty?
                if env_get("DEBUG_TYPE_PARAM_STORE") && (class_name.includes?("Slice") || method_name == "hash")
                  STDERR.puts "[TYPE_PARAM_STORE_CONCRETE] full=#{full_name} base=#{base_name} map=#{@type_param_map}"
                end
                store_function_type_param_map(full_name, base_name, @type_param_map)
              end
              if alias_full_name
                register_function_type(alias_full_name, return_type) unless @function_types.has_key?(alias_full_name)
                @function_defs[alias_full_name] = member
                @function_def_arenas[alias_full_name] = member_arena
                unless @type_param_map.empty?
                  alias_base_name = strip_type_suffix(alias_full_name)
                  store_function_type_param_map(alias_full_name, alias_base_name, @type_param_map)
                end
              end
              if should_register_base_name?(full_name, base_name, member, has_block)
                @function_defs[base_name] = member
                @function_def_arenas[base_name] = member_arena
              elsif !has_block
                prefer_non_yield_base_name(base_name, member, member_arena)
                prefer_lower_arity_base_name(base_name, member, member_arena)
              end

              # Track yield-functions for inline expansion.
              # Note: MIR lowering removes yield-containing functions (inline-only), so we must inline
              # them at call sites. We key by both base and mangled names so resolution can find them.
              yield_start = mono_debug ? Time.instant : nil
              if def_contains_yield?(member, member_arena)
                @yield_functions.add(full_name)
                debug_hook("yield.register", full_name)
                if !has_block && !@function_defs.has_key?(base_name)
                  @function_defs[base_name] = member
                  @function_def_arenas[base_name] = member_arena
                end
                @function_defs[full_name] = member
                @function_def_arenas[full_name] = member_arena
                if alias_full_name
                  @yield_functions.add(alias_full_name)
                  debug_hook("yield.register", alias_full_name)
                  if alias_base && !has_block && !@function_defs.has_key?(alias_base)
                    @function_defs[alias_base] = member
                    @function_def_arenas[alias_base] = member_arena
                  end
                  @function_defs[alias_full_name] = member
                  @function_def_arenas[alias_full_name] = member_arena
                end
              end
              yield_elapsed = yield_start ? (Time.instant - yield_start).total_milliseconds : nil

              # Capture initialize parameters for new()
              # Also extract ivars from shorthand: def initialize(@value : T)
              # Note: Only capture from FIRST initialize (for multiple overloads, each gets its own mangled name)
              if method_name == "initialize" && init_params.empty?
                if params = member.params
                  new_params = capture_initialize_params(params, ivars, pointerof(offset), class_name)
                  init_params.clear
                  new_params.each { |param| init_params << param }
                  init_capture.source = :class
                end
              end
              if method_name == "initialize"
                if body = member.body
                  infer_ivars_from_body(body, ivars, pointerof(offset))
                end
              end
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_class(member, class_name, ivars, pointerof(offset))
            when CrystalV2::Compiler::Frontend::MacroForNode
              process_macro_for_in_class(member, class_name, ivars, pointerof(offset))
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_class(member, class_name, ivars, pointerof(offset))
            when CrystalV2::Compiler::Frontend::CallNode
              callee = @arena[member.callee]
              if callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
                method_name = String.new(callee.name)
                if env_get("DEBUG_CLASS_BODY_CALLS") && (class_name.includes?("LineNumbers") || class_name.includes?("WUInt::UInt128"))
                  STDERR.puts "[DEBUG_CLASS_BODY_CALLS] #{class_name} call=#{method_name}"
                end
                macro_lookup = lookup_macro_entry_with_inheritance(method_name, class_name)
                if macro_lookup.nil? && class_name != "Object"
                  macro_lookup = lookup_macro_entry(method_name, "Object")
                end
                if macro_lookup
                  macro_entry, macro_key = macro_lookup
                  macro_def, macro_arena = macro_entry
                  if env_get("DEBUG_MACRO_TYPE_REG") && macro_def_maybe_defines_type?(macro_def, macro_arena)
                    STDERR.puts "[DEBUG_MACRO_TYPE_REG] expand name=#{method_name} in #{class_name}"
                  end
                  macro_args, macro_block = extract_macro_block_from_args(member.args, member.block)
                  expanded_id = expand_macro_expr(macro_def, macro_arena, macro_args, member.named_args, macro_block, macro_key)
                  unless expanded_id.invalid?
                    old_arena = @arena
                    @arena = macro_arena
                    begin
                      register_class_members_from_expansion(
                        class_name,
                        expanded_id,
                        defined_class_method_full_names,
                        Set(String).new,
                        ivars,
                        pointerof(offset)
                      )
                    ensure
                      @arena = old_arena
                    end
                  end
                end
              end
            when CrystalV2::Compiler::Frontend::GetterNode
              # Getter declarations: getter name : Type
              # Creates @name ivar and def name; @name; end method
              if member.is_class?
                member.specs.each do |spec|
                  register_class_accessor_entry(class_name, spec, :getter)
                end
              else
                specs = member.specs
                specs.each do |spec|
                  storage_name = accessor_storage_name(spec)
                  getter_name = accessor_method_name(spec)
                  ivar_name = "@#{storage_name}"
                  ivar_type = if ta = spec.type_annotation
                                type_ref_for_name(String.new(ta))
                              elsif spec.predicate
                                TypeRef::BOOL
                              elsif default_value = spec.default_value
                                infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                              else
                                TypeRef::VOID
                              end
                  # Register ivar if not already declared
                  unless ivars.any? { |iv| iv.name == ivar_name }
                    offset = align_offset(offset, type_alignment(ivar_type, is_c_struct))
                    ivars << IVarInfo.new(ivar_name, ivar_type, offset,
                      default_expr_id: spec.default_value,
                      default_arena: spec.default_value ? @arena : nil)
                    offset += type_size(ivar_type, is_c_struct)
                  end
                  # Register getter method: def name : Type
                  getter_base = "#{class_name}##{getter_name}"
                  full_name = mangle_function_name(getter_base, [] of TypeRef)
                  register_function_type(full_name, ivar_type)
                end
              end
            when CrystalV2::Compiler::Frontend::SetterNode
              # Setter declarations: setter name : Type
              # Creates @name ivar and def name=(value : Type); @name = value; end
              if member.is_class?
                member.specs.each do |spec|
                  register_class_accessor_entry(class_name, spec, :setter)
                end
              else
                specs = member.specs
                specs.each do |spec|
                  storage_name = accessor_storage_name(spec)
                  ivar_name = "@#{storage_name}"
                  ivar_type = if ta = spec.type_annotation
                                type_ref_for_name(String.new(ta))
                              elsif spec.predicate
                                TypeRef::BOOL
                              elsif default_value = spec.default_value
                                infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                              else
                                TypeRef::VOID
                              end
                  # Register ivar if not already declared
                  unless ivars.any? { |iv| iv.name == ivar_name }
                    offset = align_offset(offset, type_alignment(ivar_type, is_c_struct))
                    ivars << IVarInfo.new(ivar_name, ivar_type, offset)
                    offset += type_size(ivar_type, is_c_struct)
                  end
                  # Register setter method: def name=(value : Type) : Type
                  setter_name = "#{class_name}##{storage_name}="
                  full_name = mangle_function_name(setter_name, [ivar_type])
                  register_function_type(full_name, ivar_type)
                end
              end
            when CrystalV2::Compiler::Frontend::PropertyNode
              # Property declarations: property name : Type
              # Creates both getter and setter
              if member.is_class?
                member.specs.each do |spec|
                  register_class_accessor_entry(class_name, spec, :getter)
                  register_class_accessor_entry(class_name, spec, :setter)
                end
              else
                specs = member.specs
                specs.each do |spec|
                  storage_name = accessor_storage_name(spec)
                  getter_name = accessor_method_name(spec)
                  ivar_name = "@#{storage_name}"
                  ivar_type = if ta = spec.type_annotation
                                type_ref_for_name(String.new(ta))
                              elsif spec.predicate
                                TypeRef::BOOL
                              elsif default_value = spec.default_value
                                infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                              else
                                TypeRef::VOID
                              end
                  # Register ivar if not already declared
                  unless ivars.any? { |iv| iv.name == ivar_name }
                    offset = align_offset(offset, type_alignment(ivar_type, is_c_struct))
                    ivars << IVarInfo.new(ivar_name, ivar_type, offset)
                    offset += type_size(ivar_type, is_c_struct)
                  end
                  # Register getter method
                  getter_base = "#{class_name}##{getter_name}"
                  getter_full = mangle_function_name(getter_base, [] of TypeRef)
                  register_function_type(getter_full, ivar_type)
                  # Register setter method
                  setter_name = "#{class_name}##{storage_name}="
                  setter_full = mangle_function_name(setter_name, [ivar_type])
                  register_function_type(setter_full, ivar_type)
                end
              end
            when CrystalV2::Compiler::Frontend::AssignNode
              # Handle ivar assignments at class body level: @vec = SomeType.new
              target_node = @arena[member.target]
              if target_node.is_a?(CrystalV2::Compiler::Frontend::InstanceVarNode)
                ivar_name = String.new(target_node.name)
                # Infer type from the assigned value
                value_node = @arena[member.value]
                if env_has?("DEBUG_IVAR_REG")
                  STDERR.puts "[IVAR_REG] #{class_name}##{ivar_name} value_node=#{value_node.class}"
                end
                ivar_type = infer_type_from_class_ivar_assign(value_node)
                if env_has?("DEBUG_IVAR_REG")
                  STDERR.puts "[IVAR_REG] #{class_name}##{ivar_name} inferred type=#{ivar_type.id}"
                end
                unless ivars.any? { |iv| iv.name == ivar_name }
                  # Store the default value expression for later evaluation in the allocator
                  default_expr = member.value
                  # Skip trivial defaults that generate_allocator already handles (literal 0, nil)
                  needs_expr = !is_trivial_default(value_node)
                  offset = align_offset(offset, type_alignment(ivar_type, is_c_struct))
                  ivars << IVarInfo.new(ivar_name, ivar_type, offset,
                    default_expr_id: needs_expr ? default_expr : nil,
                    default_arena: needs_expr ? @arena : nil)
                  offset += type_size(ivar_type, is_c_struct)
                end
              elsif target_node.is_a?(CrystalV2::Compiler::Frontend::ClassVarNode)
                raw_name = String.new(target_node.name)
                cvar_name = raw_name.lstrip('@')
                value_node = @arena[member.value]
                cvar_type = infer_type_from_class_ivar_assign(value_node)
                if idx = class_vars.index { |cv| cv.name == cvar_name }
                  if class_vars[idx].type == TypeRef::VOID && cvar_type != TypeRef::VOID
                    class_vars[idx] = ClassVarInfo.new(cvar_name, cvar_type, class_vars[idx].initial_value)
                  end
                else
                  class_vars << ClassVarInfo.new(cvar_name, cvar_type, nil)
                end
                # Defer classvar initialization to run at start of __crystal_main
                @deferred_classvar_inits << {expr_id, @arena, class_name}
                if env_has?("DEBUG_DEFERRED_CLASSVAR")
                  STDERR.puts "[DEFERRED_CLASSVAR] Added AssignNode from register: class=#{class_name} cvar=#{cvar_name}"
                end
              end
            when CrystalV2::Compiler::Frontend::AliasNode
              # Type alias within class: alias Handle = Int32
              alias_name = String.new(member.name)
              target_name = resolve_alias_target(String.new(member.value), class_name)
              full_alias_name = "#{class_name}::#{alias_name}"
              register_type_alias(full_alias_name, target_name)
            end
            if mono_debug && member_start
              elapsed = (Time.instant - member_start).total_milliseconds
              if elapsed > 50.0
                detail = case member
                         when CrystalV2::Compiler::Frontend::DefNode
                           return_ms = return_elapsed ? return_elapsed.round(1) : 0.0
                           param_ms = param_elapsed ? param_elapsed.round(1) : 0.0
                           yield_ms = yield_elapsed ? yield_elapsed.round(1) : 0.0
                           "def #{String.new(member.name)} (return=#{return_ms}ms params=#{param_ms}ms yield=#{yield_ms}ms)"
                         when CrystalV2::Compiler::Frontend::IncludeNode
                           "include"
                         when CrystalV2::Compiler::Frontend::InstanceVarDeclNode
                           "ivar #{String.new(member.name)}"
                         when CrystalV2::Compiler::Frontend::ClassVarDeclNode
                           "cvar #{String.new(member.name)}"
                         else
                           member.class.to_s
                         end
                STDERR.puts "[MONO] #{class_name} slow member #{detail} #{elapsed.round(1)}ms"
              end
            end
          end
          if mono_debug && body_start
            elapsed = (Time.instant - body_start).total_milliseconds
            STDERR.puts "[MONO] #{class_name} body scan #{elapsed.round(1)}ms"
          end

          # Expand module mixins: register included module instance method signatures.
          include_start = Time.instant if mono_debug
          visited_modules = Set(String).new
          visited_extends = Set(String).new
          include_nodes.each do |inc|
            offset = register_module_instance_methods_for(
              class_name,
              inc,
              defined_instance_method_full_names,
              defined_class_method_full_names,
              visited_modules,
              visited_extends,
              ivars,
              offset,
              is_struct,
              init_capture
            )
          end
          extend_nodes.each do |ext|
            register_module_class_methods_for(
              class_name,
              ext.target,
              defined_class_method_full_names,
              visited_extends
            )
          end
          # Re-assert class-defined untyped base methods after mixins so they
          # don't get shadowed by included module defs (e.g., Tuple#hash).
          if !class_body.empty?
            class_body.each do |expr_id|
              member = unwrap_visibility_member(@arena[expr_id])
              next unless member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
              next if member.is_abstract
              if recv = member.receiver
                next if String.new(recv) == "self"
              end
              next unless def_params_untyped?(member)
              method_name = String.new(member.name)
              base_name = "#{class_name}##{method_name}"
              overloads = function_def_overloads(base_name)
              has_typed = overloads.any? do |name|
                if def_node = @function_defs[name]?
                  !def_params_untyped?(def_node)
                else
                  false
                end
              end
              next if has_typed
              @function_defs[base_name] = member
              @function_def_arenas[base_name] = @arena
            end
          end
          if mono_debug && include_start
            elapsed = (Time.instant - include_start).total_milliseconds
            STDERR.puts "[MONO] #{class_name} include expansion #{elapsed.round(1)}ms"
          end

          # Discover implicit ivars from method parameters (e.g. `def initialize(@bytesize : Int32)`)
          # and method bodies (e.g. `out @mutex` in initialize).
          # This runs AFTER module mixin expansion so that ivars from included modules
          # are already registered, preventing duplicate registrations.
          class_body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            next unless member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
            # Scan parameters for ivar shortcuts: def foo(@field : Type)
            if params = member.params
              params.each do |param|
                next unless param.is_instance_var
                next unless (pname = param.name)
                ivar_name = "@#{String.new(pname)}"
                next if ivars.any? { |iv| iv.name == ivar_name }
                if ta = param.type_annotation
                  ivar_type = type_ref_for_name(String.new(ta))
                  if ivar_type != TypeRef::VOID
                    offset = align_offset(offset, type_alignment(ivar_type, is_c_struct))
                    ivars << IVarInfo.new(ivar_name, ivar_type, offset)
                    offset += type_size(ivar_type, is_c_struct)
                  end
                end
              end
            end
            next unless (body = member.body)
            discovered = discover_implicit_ivars_in_body(body, @arena, class_name)
            discovered.each do |ivar_name, ivar_type|
              unless ivars.any? { |iv| iv.name == ivar_name }
                if env_get("DEBUG_IVAR_REG")
                  STDERR.puts "[IVAR_REG] #{class_name}##{ivar_name} discovered from method body type=#{ivar_type.id}"
                end
                offset = align_offset(offset, type_alignment(ivar_type, is_c_struct))
                ivars << IVarInfo.new(ivar_name, ivar_type, offset)
                offset += type_size(ivar_type, is_c_struct)
              end
            end
          end
        ensure
          @current_class = old_class
          @suppress_monomorphization = old_suppress
        end
        if mono_debug && mono_start
          elapsed = (Time.instant - mono_start).total_milliseconds
          STDERR.puts "[MONO] register_concrete_class #{class_name} total #{elapsed.round(1)}ms"
        end
      end

      # Align total size to max field alignment (matches LLVM struct padding)
      if !ivars.empty?
        max_align = ivars.max_of { |iv| type_alignment(iv.type, is_c_struct) }
        offset = align_offset(offset, max_align)
      end
      final_info = ClassInfo.new(class_name, type_ref, ivars, class_vars, offset, is_struct, parent_name)
      @class_info[class_name] = final_info
      @class_info_by_type_id[type_ref.id] = final_info
      @class_info_version += 1
      record_class_parent(class_name, parent_name)
      if env_has?("DEBUG_CLASS_PARENTS") && (class_name == "Base" || class_name == "Child" || class_name == "IO::Memory")
        STDERR.puts "[CLASS_PARENT] class=#{class_name} parent=#{parent_name || "nil"}"
      end
      @module.register_class_parent(class_name, parent_name)
      if env_has?("DEBUG_CLASS_INFO") &&
         (class_name == "Crystal::MachO" || class_name == "IO" || class_name.includes?("FileDescriptor") || class_name == "Thread" || class_name == "Crystal::Scheduler" || class_name == "String")
        ivar_dump = ivars.map { |iv| "#{iv.name}:#{get_type_name_from_ref(iv.type)}@#{iv.offset}" }.join(", ")
        STDERR.puts "[CLASS_INFO] #{class_name} ivars=[#{ivar_dump}] size=#{offset}"
      end
      short_name = last_namespace_component(class_name)
      if short_name != class_name
        (@short_type_index[short_name] ||= Set(String).new) << class_name
      end
      # DEBUG: track type_ref.id for problematic types
      if env_has?("DEBUG_TYPE_ID") &&
         (class_name.includes?("Sequence") || class_name.includes?("LoadCommand") ||
         class_name.includes?("Section") || class_name.includes?("Seek"))
        STDERR.puts "[TYPE_ID] class_info[#{class_name}] type_ref.id=#{type_ref.id}"
      end
      debug_hook_class_register(class_name, parent_name)

      # Store initialize params for allocator generation
      # Preserve existing init params on class reopening; otherwise inherit from parent.
      @init_params ||= {} of String => Array({String, TypeRef})
      if init_params.empty?
        if existing_params = @init_params.not_nil![class_name]?
          init_params = existing_params
        elsif parent_name
          if parent_init_params = @init_params.not_nil![parent_name]?
            init_params = parent_init_params
          end
        end
      end
      @init_params.not_nil![class_name] = init_params

      # Register "new" allocator function
      register_function_type("#{class_name}.new", type_ref)
    end

    # Flush all pending monomorphizations (call after all templates are registered)
    def flush_pending_monomorphizations
      @defer_monomorphization = false
      pending = @pending_monomorphizations.dup
      @pending_monomorphizations.clear
      return unless @eager_monomorphization

      if env_has?("DEBUG_MONO")
        STDERR.puts "[MONO] Flush pending monomorphizations: #{pending.size}"
      end

      pending.each_with_index do |(base_name, type_args, specialized_name), idx|
        if env_has?("DEBUG_MONO") && (idx % 100 == 0 || idx == pending.size - 1)
          STDERR.puts "[MONO] #{idx + 1}/#{pending.size}: #{specialized_name}"
        end
        next if @monomorphized.includes?(specialized_name)
        unless concrete_type_args?(type_args)
          STDERR.puts "[MONO] Skipping unresolved: #{specialized_name}" if env_has?("DEBUG_MONO")
          next
        end
        monomorphize_generic_class(base_name, type_args, specialized_name)
      end
    end

    # Refresh union descriptors that were created before all types were registered.
    # This avoids zero-sized payloads from unresolved variants (e.g., Errno | WinError | WasiError).
    def refresh_union_descriptors : Nil
      return if @union_descriptors.empty?

      to_refresh = [] of Tuple(String, MIR::TypeRef)
      @union_descriptors.each do |mir_ref, descriptor|
        next unless descriptor.variants.any? do |variant|
                      variant.size == 0 && variant.full_name != "Nil" && variant.full_name != "Void"
                    end
        to_refresh << {descriptor.name, mir_ref}
      end
      return if to_refresh.empty?

      # Clear cached entries for these unions regardless of context keying.
      cache_keys = [] of String
      to_refresh.each do |(_, mir_ref)|
        hir_ref = TypeRef.new(mir_ref.id)
        @type_cache.each do |key, value|
          cache_keys << key if value == hir_ref
        end
      end
      cache_keys.uniq.each { |key| @type_cache.delete(key) }

      # Deduplicate names for regeneration.
      names = to_refresh.map(&.[0]).uniq
      old_class = @current_class
      old_override = @current_namespace_override
      @current_class = nil
      @current_namespace_override = nil
      begin
        names.each do |name|
          create_union_type(name)
        end
      ensure
        @current_class = old_class
        @current_namespace_override = old_override
      end
    end

    # Refresh generic type descriptors that captured VOID type params
    # before aliases were registered (e.g., Value alias inside DWARF::Info).
    # This fixes tuple/array element types that would otherwise lower as void.
    def refresh_void_type_params : Nil
      return if @module.types.empty?

      old_class = @current_class
      old_override = @current_namespace_override
      @current_class = nil
      @current_namespace_override = nil
      begin
        @module.types.each_with_index do |desc, idx|
          next if desc.type_params.empty?
          next unless desc.type_params.any? { |t| t == TypeRef::VOID }
          next unless (info = split_generic_base_and_args(desc.name))
          param_names = split_generic_type_args(info[:args]).map(&.strip)
          next unless param_names.size == desc.type_params.size

          updated = false
          new_params = desc.type_params.each_with_index.map do |ref, i|
            next ref unless ref == TypeRef::VOID
            pname = param_names[i]
            next ref if pname.empty? || pname == "_"
            resolved = resolve_type_alias_chain(pname)
            if resolved == pname && !pname.includes?("::")
              if alias_target = resolve_type_alias_by_suffix(pname)
                resolved = alias_target
              end
            end
            resolved = resolve_type_name_in_context(resolved)
            new_ref = if resolved.includes?('|')
                        union_ref = create_union_type(resolved)
                        if union_ref == TypeRef::VOID
                          parts = split_union_type_name(resolved)
                          if parts.empty?
                            TypeRef::VOID
                          else
                            normalized = normalize_union_type_name(resolved)
                            ordered_parts = split_union_type_name(normalized)
                            variant_refs = ordered_parts.map do |part|
                              builtin_type_ref_for(part) || type_ref_for_name(part)
                            end
                            union_ref = @module.intern_type(TypeDescriptor.new(TypeKind::Union, normalized))
                            register_union_descriptor(union_ref, normalized, ordered_parts, variant_refs)
                            union_ref
                          end
                        else
                          union_ref
                        end
                      else
                        type_ref_for_name(resolved)
                      end
            updated = true if new_ref != ref
            new_ref
          end.to_a

          if updated
            @module.types[idx] = TypeDescriptor.new(desc.kind, desc.name, new_params)
          end
        end
      ensure
        @current_class = old_class
        @current_namespace_override = old_override
      end
    end

    # Fix inherited ivars for subclasses.
    # Due to registration order, a child class may be registered before its parent
    # has its ivars populated. This pass ensures all classes include their parent's
    # ivars with correct offsets.
    def fixup_inherited_ivars : Nil
      fixed = Set(String).new
      fixup_count = 0
      @class_info.keys.each do |class_name|
        old_size = @class_info[class_name]?.try(&.ivars.size) || 0
        fixup_class_inherited_ivars(class_name, fixed)
        new_size = @class_info[class_name]?.try(&.ivars.size) || 0
        if new_size != old_size
          info = @class_info[class_name]
          ivar_dump = info.ivars.map { |iv| "#{iv.name}@#{iv.offset}" }.join(", ")
          STDERR.puts "[FIXUP] #{class_name}: #{old_size}→#{new_size} ivars, size=#{info.size} [#{ivar_dump}]" if env_has?("CRYSTAL_V2_DEBUG_FIXUP")
          fixup_count += 1
        end
      end
      STDERR.puts "[FIXUP] Fixed #{fixup_count} classes" if fixup_count > 0 && env_has?("CRYSTAL_V2_DEBUG_FIXUP")
      # Final alignment pass: recompute all ivar offsets with proper alignment
      align_all_class_ivars
      # Re-evaluate offsetof constants now that class info is finalized
      reevaluate_offsetof_constants
      # Generate any allocators that were deferred because class had empty ivars
      flush_deferred_allocators
    end

    # Re-evaluate offsetof constants that couldn't be computed during scanning
    # because class_info wasn't populated yet. Now that inherited ivars are fixed
    # up and aligned, we can compute the correct offsets.
    def reevaluate_offsetof_constants : Nil
      return if @pending_offsetof_constants.empty?
      @pending_offsetof_constants.each do |(full_name, value_id, arena, owner_name)|
        next if @constant_literal_values.has_key?(full_name)
        old_arena = @arena
        old_class = @current_class
        @arena = arena
        @current_class = owner_name
        begin
          if literal = constant_literal_value_from_expr(value_id, arena, owner_name)
            @constant_literal_values[full_name] = literal
            # Also ensure the type is set correctly (Int32 for offsetof)
            if !@constant_types.has_key?(full_name) || @constant_types[full_name] == TypeRef::VOID
              @constant_types[full_name] = TypeRef::INT32
            end
          end
        ensure
          @current_class = old_class
          @arena = old_arena
        end
      end
      @pending_offsetof_constants.clear
    end

    # Generate allocators that were deferred because the class had empty ivars
    # when the allocator was first requested. Now that all classes are registered,
    # we can generate them with the correct ivar info.
    def flush_deferred_allocators : Nil
      return if @deferred_allocators.empty?
      count = 0
      deferred_copy = @deferred_allocators.dup
      @deferred_allocators.clear
      deferred_copy.each do |class_name|
        next if @generated_allocators.includes?(class_name)
        class_info = @class_info[class_name]?
        next unless class_info
        STDERR.puts "[ALLOC_FLUSH] Generating allocator for #{class_name} ivars=#{class_info.ivars.size}"
        generate_allocator(class_name, class_info, force: true)
        count += 1
      end
      STDERR.puts "[ALLOC_FLUSH] Generated #{count} deferred allocators" if count > 0
    end

    # Recompute ivar offsets with proper alignment to match LLVM struct layout.
    # This is called AFTER all ivar registration and inheritance fixup to ensure
    # all classes have correctly aligned field offsets regardless of which code
    # path registered the ivars.
    def align_all_class_ivars : Nil
      realigned = 0
      @class_info.each do |class_name, info|
        next if info.ivars.empty?
        is_c_struct = info.name.starts_with?("LibC::") || info.name.includes?("::Lib")

        needs_fix = false
        # Structs (including C structs) have no type_id header, classes start at 4 (i32 type_id)
        offset = info.is_struct ? 0 : 4
        info.ivars.each do |ivar|
          aligned = align_offset(offset, type_alignment(ivar.type, is_c_struct))
          if aligned != ivar.offset
            needs_fix = true
            break
          end
          offset = aligned + type_size(ivar.type, is_c_struct)
        end

        if needs_fix
          new_ivars = [] of IVarInfo
          offset = info.is_struct ? 0 : 4
          info.ivars.each do |ivar|
            offset = align_offset(offset, type_alignment(ivar.type, is_c_struct))
            new_ivars << IVarInfo.new(ivar.name, ivar.type, offset,
              default_expr_id: ivar.default_expr_id, default_arena: ivar.default_arena)
            offset += type_size(ivar.type, is_c_struct)
          end
          # Align total size to max field alignment
          max_align = new_ivars.max_of { |iv| type_alignment(iv.type, is_c_struct) }
          offset = align_offset(offset, max_align)

          new_info = ClassInfo.new(info.name, info.type_ref, new_ivars, info.class_vars,
            offset, info.is_struct, info.parent_name)
          @class_info[class_name] = new_info
          @class_info_by_type_id[info.type_ref.id] = new_info
          realigned += 1
        end
      end
      STDERR.puts "[ALIGN] Realigned #{realigned} classes" if realigned > 0 && env_has?("CRYSTAL_V2_DEBUG_FIXUP")
    end

    # Align ivars for a single class (used after late monomorphization)
    private def align_class_ivars(class_name : String) : Nil
      info = @class_info[class_name]?
      return unless info
      return if info.ivars.empty?
      is_c_struct = info.name.starts_with?("LibC::") || info.name.includes?("::Lib")
      offset = info.is_struct ? 0 : 4
      new_ivars = [] of IVarInfo
      info.ivars.each do |ivar|
        offset = align_offset(offset, type_alignment(ivar.type, is_c_struct))
        new_ivars << IVarInfo.new(ivar.name, ivar.type, offset,
          default_expr_id: ivar.default_expr_id, default_arena: ivar.default_arena)
        offset += type_size(ivar.type, is_c_struct)
      end
      max_align = new_ivars.max_of { |iv| type_alignment(iv.type, is_c_struct) }
      offset = align_offset(offset, max_align)
      new_info = ClassInfo.new(info.name, info.type_ref, new_ivars, info.class_vars,
        offset, info.is_struct, info.parent_name)
      @class_info[class_name] = new_info
      @class_info_by_type_id[info.type_ref.id] = new_info
    end

    private def fixup_class_inherited_ivars(class_name : String, fixed : Set(String))
      return if fixed.includes?(class_name)
      fixed << class_name # Mark visited BEFORE recursing to break cycles
      info = @class_info[class_name]?
      return unless info
      return if info.is_struct # value types don't share layout with parent

      parent_name = info.parent_name
      if parent_name && @class_info.has_key?(parent_name)
        # Fix parent first (topological order)
        fixup_class_inherited_ivars(parent_name, fixed)

        parent_info = @class_info[parent_name].not_nil!

        if !parent_info.ivars.empty?
          # Check if child already has all parent ivars at correct offsets
          has_all = parent_info.ivars.all? do |piv|
            info.ivars.any? { |iv| iv.name == piv.name && iv.offset == piv.offset }
          end

          unless has_all
            # Identify child's OWN ivars (not from parent)
            parent_ivar_names = parent_info.ivars.map(&.name).to_set
            own_ivars = info.ivars.reject { |iv| parent_ivar_names.includes?(iv.name) }

            # Compute offset adjustment:
            # Parent ivars occupy 8..parent_size-1 (8 = type_id header)
            # Child's own ivars currently start at 8
            # Need to shift to start at parent_size
            own_start = own_ivars.first?.try(&.offset) || 8
            offset_adjust = parent_info.size - own_start

            if offset_adjust > 0
              # Build new ivar list: parent ivars + adjusted child ivars
              new_ivars = [] of IVarInfo
              parent_info.ivars.each { |piv| new_ivars << piv }
              own_ivars.each do |ivar|
                new_ivars << IVarInfo.new(ivar.name, ivar.type, ivar.offset + offset_adjust,
                  default_expr_id: ivar.default_expr_id, default_arena: ivar.default_arena)
              end

              new_size = info.size + offset_adjust

              new_info = ClassInfo.new(
                info.name, info.type_ref, new_ivars, info.class_vars,
                new_size, info.is_struct, info.parent_name
              )
              @class_info[class_name] = new_info
              @class_info_by_type_id[info.type_ref.id] = new_info
            end
          end
        end
      end

    end

    private def concrete_type_args?(type_args : Array(String)) : Bool
      # NOTE: unions like `String | Nil` are concrete and must be allowed here.
      unresolved_token_re = /(?:^|[^A-Za-z0-9_:])(K2|V2|K|V|T|U|L|W|self)(?:$|[^A-Za-z0-9_:])/
      unresolved_param_names = {"K2", "V2", "K", "V", "T", "U", "L", "W", "self"}
      # Bare generic names without type params (like Array, Hash) are not concrete
      bare_generic_names = {"Array", "Hash", "Set", "Slice", "Pointer", "StaticArray", "Iterator", "Enumerable"}
      type_args.none? do |arg|
        arg = arg.strip
        short = last_namespace_component(arg)
        # Namespaced type params like Crystal::HIR::K should still be treated as unresolved.
        short = short.gsub(/[^A-Za-z0-9_]/, "")
        next true if unresolved_param_names.includes?(short)
        # Path-like type args are never concrete (guard against require path leakage).
        next true if arg.includes?('/')
        # typeof(...) in type positions is not fully resolved during bootstrap.
        next true if arg.includes?("typeof(")
        # `self` as a standalone type arg is unresolved
        next true if arg == "self"
        # NoReturn type args are effectively placeholders; skip monomorphization.
        next true if arg == "NoReturn"
        # Bare generic class names without type params are not concrete
        next true if bare_generic_names.includes?(arg)
        # Detect remaining generic placeholders as standalone tokens (avoid false positives like "ValueId").
        arg.matches?(unresolved_token_re)
      end
    end

    # Monomorphize a generic class: create specialized version with concrete types
    private def monomorphize_generic_class(base_name : String, type_args : Array(String), specialized_name : String)
      template = @generic_templates[base_name]?
      return unless template

      if type_args.size == 1 && type_args[0].includes?('|')
        split_union_type_names(type_args[0]).each do |part|
          part = part.strip
          next if part.empty?
          next if part == type_args[0]
          specialized_part = "#{base_name}(#{part})"
          unless @monomorphized.includes?(specialized_part)
            if @defer_monomorphization
              @pending_monomorphizations << {base_name, [part], specialized_part}
            else
              monomorphize_generic_class(base_name, [part], specialized_part)
            end
          end
        end
      end

      # Double-check inside the method (belt and suspenders)
      if @monomorphized.includes?(specialized_name)
        debug_hook("mono.skip", "name=#{specialized_name} reason=already_monomorphized")
        return
      end

      # Skip if type_args contain unresolved type parameters.
      if !concrete_type_args?(type_args)
        if env_has?("DEBUG_MONO")
          STDERR.puts "[MONO] Skipping unresolved: #{specialized_name}"
        end
        debug_hook("mono.skip", "name=#{specialized_name} reason=unresolved_type_args")
        return
      end

      # Mark as monomorphized BEFORE processing to prevent infinite recursion
      # (e.g., Array(String) method calls something that creates Array(String) again)
      @monomorphized.add(specialized_name)
      debug_hook("mono.start", "base=#{base_name} name=#{specialized_name} args=#{type_args}")
      if env_get("DEBUG_MONO_SOURCES")
        @mono_source_counts[base_name] = (@mono_source_counts[base_name]? || 0) + 1
        if env_get("DEBUG_MONO_CALLER")
          callsite = "#{@current_class || ""}##{@current_method || ""}"
          key = "#{base_name}@#{callsite}"
          @mono_caller_counts[key] = (@mono_caller_counts[key]? || 0) + 1
        end
        if env_get("DEBUG_MONO_SOURCES_SAMPLES")
          samples = @mono_source_samples[base_name]? || [] of String
          if samples.size < 3 && !samples.includes?(specialized_name)
            samples << specialized_name
            @mono_source_samples[base_name] = samples
          end
        end
      end
      mono_start = nil
      if env_has?("DEBUG_MONO")
        mono_start = Time.instant
        STDERR.puts "[MONO] start #{specialized_name} args=#{type_args.join(",")}"
      end

      # Check arity matches
      if template.type_params.size != type_args.size
        if env_has?("DEBUG_MONO")
          STDERR.puts "[MONO] arity_mismatch base=#{base_name} name=#{specialized_name} args=#{type_args.join(",")}"
        end
        if env_get("DEBUG_ARITY_MISMATCH")
          STDERR.puts "[ARITY_MISMATCH] base=#{base_name} name=#{specialized_name} expected=#{template.type_params.size} got=#{type_args.size}"
          STDERR.puts "[ARITY_MISMATCH] current_class=#{@current_class || "nil"} current_method=#{@current_method || "nil"} ns=#{@current_namespace_override || "nil"}"
          caller.first(20).each { |frame| STDERR.puts "  #{frame}" }
        end
        raise "Generic #{base_name} expects #{template.type_params.size} type args, got #{type_args.size}"
      end

      # Set up type parameter substitutions: T => Int32, etc.
      old_map = @type_param_map.dup
      template.type_params.each_with_index do |param, i|
        @type_param_map[param] = type_args[i]
      end
      @subst_cache_gen &+= 1

      # Switch to the template's arena for AST node lookup
      old_arena = @arena
      @arena = template.arena

      # CRITICAL: Set @current_class so that 'self' in type annotations resolves
      # to the specialized class name (e.g., Hash(String, Int32)) instead of
      # whatever class was being processed before. This fixes type params like
      # @block : (self, K -> V)? in Hash where 'self' must become the monomorphized type.
      old_class = @current_class
      @current_class = specialized_name

      # Defer expensive body inference during monomorphization — return types
      # will be inferred lazily when the method is actually called.
      old_defer_body = @defer_body_return_inference
      @defer_body_return_inference = true

      # Defer cascading monomorphizations during class registration.
      # This converts recursive depth-first monomorphization into iterative
      # breadth-first, preventing deep stack recursion and reducing redundant work.
      old_defer_mono = @defer_monomorphization
      @defer_monomorphization = true

      # Lazy module method registration: skip registering ALL module DefNodes
      # during monomorphization. Methods will be resolved on demand when actually called.
      # This prevents the 100+ method-per-module explosion that makes the pending queue diverge.
      old_lazy = @lazy_module_methods
      @lazy_module_methods = true

      # Register the specialized class using the template's AST node
      # The type_ref_for_name calls will now substitute T => Int32
      register_concrete_class(template.node, specialized_name, template.is_struct)

      if reopenings = @generic_reopenings[base_name]?
        reopenings.each do |reopen|
          @arena = reopen.arena
          register_concrete_class(reopen.node, specialized_name, reopen.is_struct)
        end
      end

      @defer_monomorphization = old_defer_mono
      @defer_body_return_inference = old_defer_body
      @lazy_module_methods = old_lazy

      # Process deferred monomorphizations iteratively (breadth-first).
      # Only process if we're the outermost monomorphize call (not nested).
      unless old_defer_mono
        while !@pending_monomorphizations.empty?
          batch = @pending_monomorphizations.dup
          @pending_monomorphizations.clear
          batch.each do |(pending_base, pending_args, pending_name)|
            next if @monomorphized.includes?(pending_name)
            next unless concrete_type_args?(pending_args)
            monomorphize_generic_class(pending_base, pending_args, pending_name)
          end
        end
      end

      # Align ivars for this newly monomorphized class (align_all_class_ivars
      # may have already run before this monomorphization happened).
      align_class_ivars(specialized_name)

      if mono_start && env_has?("DEBUG_MONO")
        elapsed_ms = (Time.instant - mono_start).total_milliseconds
        STDERR.puts "[MONO] done #{specialized_name} in #{elapsed_ms.round(1)}ms"
      end

      # Lowering bodies for monomorphized classes is expensive on prelude.
      # Keep it lazy unless explicitly enabled.
      if @eager_monomorphization
        if class_info = @class_info[specialized_name]?
          # Set current class for ivar lookup
          old_class = @current_class
          @current_class = specialized_name

          generate_allocator(specialized_name, class_info)

          # Lower methods with type substitutions across all template bodies.
          templates = [template] of GenericClassTemplate
          if reopenings = @generic_reopenings[base_name]?
            reopenings.each { |entry| templates << entry }
          end
          templates.each do |tmpl|
            @arena = tmpl.arena
            if body = tmpl.node.body
              body.each do |expr_id|
                member = @arena[expr_id]
                case member
                when CrystalV2::Compiler::Frontend::DefNode
                  lower_method(specialized_name, class_info, member)
                when CrystalV2::Compiler::Frontend::GetterNode
                  # Generate synthetic getter methods
                  member.specs.each do |spec|
                    generate_getter_method(specialized_name, class_info, spec)
                  end
                when CrystalV2::Compiler::Frontend::SetterNode
                  member.specs.each do |spec|
                    generate_setter_method(specialized_name, class_info, spec)
                  end
                when CrystalV2::Compiler::Frontend::PropertyNode
                  # Generate both getter and setter methods
                  member.specs.each do |spec|
                    generate_getter_method(specialized_name, class_info, spec)
                    generate_setter_method(specialized_name, class_info, spec)
                  end
                end
              end
            end
          end

          @current_class = old_class
        end
      end

      debug_hook("mono.done", "base=#{base_name} name=#{specialized_name}")

      # Restore arena, type param map, and current class
      @arena = old_arena
      @type_param_map = old_map
      @subst_cache_gen &+= 1
      @current_class = old_class
      @monomorphized.add(specialized_name)
    end

    # Monomorphize a generic module (e.g., Impl(Float32, ImplInfo_Float32))
    private def monomorphize_generic_module(base_name : String, type_args : Array(String), specialized_name : String)
      defs = @module_defs[base_name]?
      return unless defs

      # Find a module definition with type parameters
      template_def : CrystalV2::Compiler::Frontend::ModuleNode? = nil
      template_arena : CrystalV2::Compiler::Frontend::ArenaLike? = nil

      defs.each do |mod_node, mod_arena|
        if type_params = mod_node.type_params
          if type_params.size == type_args.size
            template_def = mod_node
            template_arena = mod_arena
            break
          end
        end
      end

      return unless template_def && template_arena

      # Mark as monomorphized to prevent infinite recursion
      @monomorphized.add(specialized_name)

      # Set up type parameter substitutions
      old_map = @type_param_map.dup
      if type_params = template_def.type_params
        type_params.each_with_index do |param, i|
          @type_param_map[String.new(param)] = type_args[i]
        end
        @subst_cache_gen &+= 1
      end

      old_arena = @arena
      @arena = template_arena

      # Register module methods for the specialized module
      # Module class methods (def self.foo) become <specialized_name>.foo
      if body = template_def.body
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          case member
          when CrystalV2::Compiler::Frontend::DefNode
            recv = member.receiver
            next unless recv && String.new(recv) == "self"
            next if member.is_abstract

            method_name = String.new(member.name)
            base_method = "#{specialized_name}.#{method_name}"

            # Get return type
            return_type = if rt = member.return_type
                            type_ref_for_name(substitute_type_params_in_type_name(String.new(rt)))
                          else
                            inferred = infer_concrete_return_type_from_body(member, specialized_name)
                            inferred || TypeRef::VOID
                          end

            # Get parameter types
            param_types = [] of TypeRef
            has_block = false
            if params = member.params
              params.each do |param|
                next if named_only_separator?(param)
                if param.is_block
                  has_block = true
                  next
                end
                param_type = if ta = param.type_annotation
                               type_ref_for_name(substitute_type_params_in_type_name(String.new(ta)))
                             elsif param.is_double_splat
                               type_ref_for_name("NamedTuple")
                             else
                               TypeRef::VOID
                             end
                param_types << param_type
              end
            end

            full_name = function_full_name_for_def(base_method, param_types, member.params, has_block)

            # Skip if already registered
            next if @function_types.has_key?(full_name)

            register_function_type(full_name, return_type)
            @function_defs[full_name] = member
            @function_def_arenas[full_name] = @arena

            # CRITICAL: Store type param map so lowering can resolve type param calls
            # e.g., ImplInfo.get_cache() -> ImplInfo_Float32.get_cache()
            store_function_type_param_map(full_name, base_method, @type_param_map)

            if env_get("DEBUG_MONO_MODULE")
              STDERR.puts "[MONO_MODULE] #{full_name} -> #{return_type} params=#{@type_param_map}"
            end
          end
        end
      end

      @arena = old_arena
      @type_param_map = old_map
      @subst_cache_gen &+= 1
    end

    # Lower a class and all its methods (pass 3)
    def lower_class(node : CrystalV2::Compiler::Frontend::ClassNode)
      class_name = String.new(node.name)
      lower_class_with_name(node, class_name)
    end

    # Lower a class with a specific name (for nested classes like Foo::Bar)
    def lower_class_with_name(node : CrystalV2::Compiler::Frontend::ClassNode, class_name : String)
      # Skip generic class templates - they're lowered on-demand during monomorphization
      if @generic_templates.has_key?(class_name)
        return
      end

      if filter = env_get("DEBUG_CLASS_ARENA")
        if filter == "1" || class_name.includes?(filter)
          path = source_path_for(@arena) || "(unknown)"
          STDERR.puts "[DEBUG_CLASS_ARENA] class=#{class_name} arena=#{@arena.class}:#{@arena.size} file=#{path}"
        end
      end

      class_info = @class_info[class_name]? || return
      old_class = @current_class
      old_pending = @pending_def_annotations
      @current_class = class_name
      @pending_def_annotations = [] of Tuple(CrystalV2::Compiler::Frontend::AnnotationNode, CrystalV2::Compiler::Frontend::ArenaLike)

      # Generate allocator function: ClassName.new
      generate_allocator(class_name, class_info)

      begin
        # Lower each method
        if body = node.body
          if env_get("DEBUG_SEQ_LOWER") && class_name.includes?("LineNumbers")
            STDERR.puts "[DEBUG_SEQ_LOWER] class=#{class_name} body_size=#{body.size}"
            body.each do |expr_id|
              member_dbg = unwrap_visibility_member(@arena[expr_id])
              label = member_dbg.class.to_s.split("::").last
              if member_dbg.is_a?(CrystalV2::Compiler::Frontend::CallNode)
                callee_dbg = @arena[member_dbg.callee]
                if callee_dbg.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
                  label += " callee=#{String.new(callee_dbg.name)}"
                end
              end
              STDERR.puts "[DEBUG_SEQ_LOWER]   member=#{label}"
            end
          end
          # Lower nested types first (classes/structs/modules inside the class body).
          # These can be referenced unqualified from within the class (e.g., `EntryIterator.new` inside `Dir`).
          nested_prefix = if info = split_generic_base_and_args(class_name)
                            info[:base]
                          else
                            class_name
                          end
          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            case member
            when CrystalV2::Compiler::Frontend::ClassNode
              nested_name = String.new(member.name)
              lower_class_with_name(member, "#{nested_prefix}::#{nested_name}")
            when CrystalV2::Compiler::Frontend::ModuleNode
              nested_name = String.new(member.name)
              lower_module_with_name(member, "#{nested_prefix}::#{nested_name}")
            end
          end

          defined_full_names = collect_defined_instance_method_full_names(class_name, body)
          include_nodes = [] of CrystalV2::Compiler::Frontend::IncludeNode

          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            include_nodes << member if member.is_a?(CrystalV2::Compiler::Frontend::IncludeNode)
          end

          visited_modules = Set(String).new
          include_nodes.each do |inc|
            lower_module_instance_methods_for(class_name, class_info, inc, defined_full_names, visited_modules)
          end

          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            if debug_env_filter_match?("DEBUG_DEFERRED_CLASSVAR", class_name)
              STDERR.puts "[DEFERRED_CLASSVAR] lower_class_with_name body member: class=#{class_name} member_class=#{member.class.name.split("::").last}"
            end
            if member.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode)
              remember_effect_annotation(member, @arena)
              next
            elsif !member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
              clear_pending_effect_annotations
            end
            case member
            when CrystalV2::Compiler::Frontend::IncludeNode
              # Handled above via mixin expansion.
            when CrystalV2::Compiler::Frontend::DefNode
              if class_name == "Tuple" || class_name == "NamedTuple"
                # Defer lowering base Tuple/NamedTuple methods until callsite
                # type params are known (macros like T.size require concrete args).
                next
              end
              method_name = String.new(member.name)
              is_class_method = if recv = member.receiver
                                  String.new(recv) == "self"
                                else
                                  false
                                end
              base_name = is_class_method ? "#{class_name}.#{method_name}" : "#{class_name}##{method_name}"
              param_types = [] of TypeRef
              has_block = false
              if params = member.params
                params.each do |param|
                  next if named_only_separator?(param)
                  if param.is_block
                    has_block = true
                    next
                  end
                  param_type = if ta = param.type_annotation
                                 type_ref_for_name(String.new(ta))
                               elsif param.is_double_splat
                                 type_ref_for_name("NamedTuple")
                               else
                                 TypeRef::VOID
                               end
                  param_types << param_type
                end
              end
              full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
              callsite_args = pending_callsite_args_for_def(member, base_name, full_name)
              call_arg_types = callsite_args ? callsite_args.types : nil
              call_arg_literals = callsite_args ? callsite_args.literals : nil
              call_arg_enum_names = callsite_args ? callsite_args.enum_names : nil
              lower_method(class_name, class_info, member, call_arg_types, call_arg_literals, call_arg_enum_names)
              add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
            when CrystalV2::Compiler::Frontend::GetterNode
              # Generate synthetic getter methods
              if member.is_class?
                member.specs.each do |spec|
                  generate_class_getter_method(class_name, spec, @arena)
                end
              else
                member.specs.each do |spec|
                  generate_getter_method(class_name, class_info, spec)
                end
              end
              add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
            when CrystalV2::Compiler::Frontend::SetterNode
              # Generate synthetic setter methods
              if member.is_class?
                member.specs.each do |spec|
                  generate_class_setter_method(class_name, spec)
                end
              else
                member.specs.each do |spec|
                  generate_setter_method(class_name, class_info, spec)
                end
              end
              add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
            when CrystalV2::Compiler::Frontend::PropertyNode
              # Generate both getter and setter methods
              if member.is_class?
                member.specs.each do |spec|
                  generate_class_getter_method(class_name, spec, @arena)
                  generate_class_setter_method(class_name, spec)
                end
              else
                member.specs.each do |spec|
                  generate_getter_method(class_name, class_info, spec)
                  generate_setter_method(class_name, class_info, spec)
                end
              end
              add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
            when CrystalV2::Compiler::Frontend::CallNode
              if env_get("DEBUG_RECORD_LOWER")
                callee = @arena[member.callee]
                if callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
                   String.new(callee.name) == "record"
                  STDERR.puts "[DEBUG_RECORD_LOWER] class=#{class_name}"
                end
              end
              lower_macro_call_in_class_body(class_name, class_info, member, defined_full_names, visited_modules)
            when CrystalV2::Compiler::Frontend::AssignNode
              # Check if this is a classvar assignment (@@varname = value)
              target_node = @arena[member.target]
              if env_has?("DEBUG_DEFERRED_CLASSVAR")
                target_class = target_node.class.name.split("::").last
                STDERR.puts "[DEFERRED_CLASSVAR] lower_class_with_name AssignNode: class=#{class_name} target=#{target_class}"
              end
              if target_node.is_a?(CrystalV2::Compiler::Frontend::ClassVarNode)
                # Defer classvar initialization to run at start of __crystal_main
                @deferred_classvar_inits << {expr_id, @arena, class_name}
                if env_has?("DEBUG_DEFERRED_CLASSVAR")
                  STDERR.puts "[DEFERRED_CLASSVAR] Added from lower_class_with_name: class=#{class_name} cvar=#{String.new(target_node.as(CrystalV2::Compiler::Frontend::ClassVarNode).name)}"
                end
              end
            when CrystalV2::Compiler::Frontend::ConstantNode
              # Defer constant initialization (e.g. HEADER_SIZE = offsetof(String, @c))
              @deferred_classvar_inits << {expr_id, @arena, class_name}
            end
          end
        end
      ensure
        @current_class = old_class
        @pending_def_annotations = old_pending
      end
    end

    private def lower_class_body_expr(
      class_name : String,
      class_info : ClassInfo,
      expr_id : ExprId,
      defined_full_names : Set(String),
      visited_modules : Set(String),
    )
      return if expr_id.invalid?

      member = unwrap_visibility_member(@arena[expr_id])
      case member
      when CrystalV2::Compiler::Frontend::AnnotationNode
        remember_effect_annotation(member, @arena)
      when CrystalV2::Compiler::Frontend::DefNode
        lower_method(class_name, class_info, member)
        add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
      when CrystalV2::Compiler::Frontend::BlockNode
        member.body.each do |child_id|
          lower_class_body_expr(class_name, class_info, child_id, defined_full_names, visited_modules)
        end
      when CrystalV2::Compiler::Frontend::IncludeNode
        lower_module_instance_methods_for(class_name, class_info, member, defined_full_names, visited_modules)
      when CrystalV2::Compiler::Frontend::ExtendNode
        visited_extends = Set(String).new
        lower_module_class_methods_for(class_name, class_info, member.target, visited_extends)
      when CrystalV2::Compiler::Frontend::GetterNode
        if member.is_class?
          member.specs.each do |spec|
            generate_class_getter_method(class_name, spec, @arena)
          end
        else
          member.specs.each do |spec|
            generate_getter_method(class_name, class_info, spec)
          end
        end
        add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
      when CrystalV2::Compiler::Frontend::SetterNode
        if member.is_class?
          member.specs.each do |spec|
            generate_class_setter_method(class_name, spec)
          end
        else
          member.specs.each do |spec|
            generate_setter_method(class_name, class_info, spec)
          end
        end
        add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
      when CrystalV2::Compiler::Frontend::PropertyNode
        if member.is_class?
          member.specs.each do |spec|
            generate_class_getter_method(class_name, spec, @arena)
            generate_class_setter_method(class_name, spec)
          end
        else
          member.specs.each do |spec|
            generate_getter_method(class_name, class_info, spec)
            generate_setter_method(class_name, class_info, spec)
          end
        end
        add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
      when CrystalV2::Compiler::Frontend::ClassNode
        nested_name = String.new(member.name)
        full_name = "#{class_name}::#{nested_name}"
        register_class_with_name(member, full_name)
        lower_class_with_name(member, full_name)
      when CrystalV2::Compiler::Frontend::ModuleNode
        nested_name = String.new(member.name)
        full_name = "#{class_name}::#{nested_name}"
        register_module_with_name(member, full_name)
        lower_module_with_name(member, full_name)
      when CrystalV2::Compiler::Frontend::EnumNode
        nested_name = String.new(member.name)
        full_name = "#{class_name}::#{nested_name}"
        register_enum_with_name(member, full_name)
      when CrystalV2::Compiler::Frontend::MacroDefNode
        register_macro(member, class_name)
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        # Macro literals in class bodies can contain getters/properties/defs.
        # Parse and lower them so accessors are actually emitted.
        if raw_text = macro_literal_raw_text(member)
          expanded = expand_flag_macro_text(raw_text) || raw_text
          sanitized = strip_macro_lines(expanded)
          program = parse_macro_literal_program(expanded)
          if program.nil? && sanitized != expanded
            program = parse_macro_literal_program(sanitized)
          end
          if program
            with_arena(program.arena) do
              program.roots.each do |child_id|
                lower_class_body_expr(class_name, class_info, child_id, defined_full_names, visited_modules)
              end
            end
            return
          end
        end

        texts = macro_literal_active_texts(member)
        combined = texts.join("\n")
        sanitized = strip_macro_lines(combined)
        if parsed = parse_macro_literal_class_body(combined) || (sanitized != combined ? parse_macro_literal_class_body(sanitized) : nil)
          program, body_ids = parsed
          with_arena(program.arena) do
            body_ids.each do |child_id|
              lower_class_body_expr(class_name, class_info, child_id, defined_full_names, visited_modules)
            end
          end
        end
      when CrystalV2::Compiler::Frontend::CallNode
        if env_get("DEBUG_RECORD_LOWER")
          callee = @arena[member.callee]
          if callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
             String.new(callee.name) == "record"
            STDERR.puts "[DEBUG_RECORD_LOWER] class=#{class_name}"
          end
        end
        lower_macro_call_in_class_body(class_name, class_info, member, defined_full_names, visited_modules)
      when CrystalV2::Compiler::Frontend::AssignNode
        # Check if this is a classvar assignment (@@varname = value)
        target_node = @arena[member.target]
        if env_has?("DEBUG_DEFERRED_CLASSVAR")
          target_class = target_node.class.name.split("::").last
          STDERR.puts "[DEFERRED_CLASSVAR] Found AssignNode: class=#{class_name} target=#{target_class}"
        end
        if target_node.is_a?(CrystalV2::Compiler::Frontend::ClassVarNode)
          # Defer classvar initialization to run at start of __crystal_main
          @deferred_classvar_inits << {expr_id, @arena, class_name}
          if env_has?("DEBUG_DEFERRED_CLASSVAR")
            STDERR.puts "[DEFERRED_CLASSVAR] Added AssignNode: class=#{class_name} cvar=#{String.new(target_node.as(CrystalV2::Compiler::Frontend::ClassVarNode).name)}"
          end
        end
      when CrystalV2::Compiler::Frontend::ConstantNode
        # Defer constant initialization (e.g. HEADER_SIZE = offsetof(String, @c))
        # so it runs at start of __crystal_main when class info is available
        @deferred_classvar_inits << {expr_id, @arena, class_name}
      end
    end

    private def lower_macro_call_in_class_body(
      class_name : String,
      class_info : ClassInfo,
      node : CrystalV2::Compiler::Frontend::CallNode,
      defined_full_names : Set(String),
      visited_modules : Set(String),
    )
      callee_node = @arena[node.callee]
      return unless callee_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)

      method_name = String.new(callee_node.name)
      macro_lookup = lookup_macro_entry_with_inheritance(method_name, class_name)
      if macro_lookup.nil? && class_name != "Object"
        macro_lookup = lookup_macro_entry(method_name, "Object")
      end
      return unless macro_lookup

      macro_entry, macro_key = macro_lookup
      macro_def, macro_arena = macro_entry
      macro_args, macro_block = extract_macro_block_from_args(node.args, node.block)
      expanded_id = expand_macro_expr(macro_def, macro_arena, macro_args, node.named_args, macro_block, macro_key)
      return if expanded_id.invalid?

      old_arena = @arena
      @arena = macro_arena
      begin
        lower_class_body_expr(class_name, class_info, expanded_id, defined_full_names, visited_modules)
      ensure
        @arena = old_arena
      end
    end

    # Generate allocator: ClassName.new(...) -> allocates and returns instance
    private def generate_allocator(
      class_name : String,
      class_info : ClassInfo,
      call_arg_types : Array(TypeRef)? = nil,
      force : Bool = false,
    )
      func_name = "#{class_name}.new"

      if env_get("DEBUG_ALLOC_STATS")
        @allocator_debug_total += 1
        @allocator_debug_counts[class_name] = (@allocator_debug_counts[class_name]? || 0) + 1
        if (@allocator_debug_total % 50) == 0
          top = @allocator_debug_counts.to_a.sort_by(&.[1]).last(10).reverse
          summary = top.map { |(name, count)| "#{name}=#{count}" }.join(", ")
          STDERR.puts "[ALLOC_STATS] total=#{@allocator_debug_total} top=#{summary}"
        end
      end

      # Debug disabled for performance
      # if class_name.includes?("Slice(UInt8)")
      #   init_params_debug = @init_params[class_name]? || [] of {String, TypeRef}
      #   param_strs = init_params_debug.map { |name, type_ref| "#{name}:#{type_ref.id}" }
      #   already = @generated_allocators.includes?(class_name)
      #   has_func = @module.has_function?(func_name)
      #   STDERR.puts "[ALLOC_GEN] class=#{class_name}, init_params=[#{param_strs.join(", ")}], already=#{already}, has_func=#{has_func}"
      # end

      # Skip Pointer types - they're primitive types with no allocator
      if class_name.starts_with?("Pointer(") || class_name.starts_with?("Pointer_")
        return
      end

      # Skip primitive number types - they don't need allocators
      # (their .new methods convert from other types, not allocate)
      case class_name
      when "Int8", "Int16", "Int32", "Int64", "Int128",
           "UInt8", "UInt16", "UInt32", "UInt64", "UInt128",
           "Float32", "Float64", "Bool", "Char"
        return
      end

      # Re-lookup class_info to get the latest version (the passed-in copy may
      # be stale if the class was registered with empty ivars and later updated).
      if latest = @class_info[class_name]?
        class_info = latest
      end

      # Skip if allocator already generated (for reopened classes), but
      # still feed callsite arg types to initialize lowering when available.
      if @generated_allocators.includes?(class_name)
        if call_arg_types && call_arg_types.any? { |t| t != TypeRef::VOID }
          if init_base_name = resolve_method_with_inheritance(class_name, "initialize")
            remember_callsite_arg_types(init_base_name, call_arg_types)
            lower_function_if_needed(init_base_name)
          end
          generate_allocator_overload(class_name, class_info, call_arg_types)
        end
        return
      end

      # Don't generate allocator with empty ivars for non-struct classes — defer
      # until class is fully registered so field defaults are properly evaluated.
      # When force=true (from flush_deferred_allocators), generate anyway.
      if !force && class_info.ivars.empty? && !class_info.is_struct
        STDERR.puts "[ALLOC_DEFER] #{class_name}: deferred (empty ivars)" if class_name.includes?("Scheduler")
        @deferred_allocators << class_name
        return
      end

      @generated_allocators.add(class_name)

      # Also check if function already exists in HIR module (belt and suspenders)
      if @module.has_function?(func_name)
        if class_name.includes?("Scheduler")
          STDERR.puts "[ALLOC_SKIP] #{func_name}: already exists in module, skipping body generation"
        end
        return
      end

      # Get initialize parameters for this class
      init_params = @init_params[class_name]? || [] of {String, TypeRef}
      if class_name == "File" && env_get("DBG_FILE_NEW")
        STDERR.puts "[FILE_ALLOC] class=File init_params=#{init_params.map { |n, t| "#{n}:#{t.id}" }.join(", ")} func=#{func_name}"
      end
      allocator_params = init_params.map { |param| {param[0], param[1]} }
      if call_arg_types && call_arg_types.any? { |t| t != TypeRef::VOID }
        allocator_params.each_with_index do |(param_name, param_type), idx|
          next if idx >= call_arg_types.size
          call_type = call_arg_types[idx]
          next if call_type == TypeRef::VOID
          if param_type == TypeRef::VOID
            allocator_params[idx] = {param_name, call_type}
          end
        end
      end
      if DebugHooks::ENABLED
        debug_hook("allocator.generate", "class=#{class_name} init_params=#{init_params.size}")
      end

      # Return type is the class type (semantically)
      # LLVM backend converts to ptr for ABI
      func = @module.create_function(func_name, class_info.type_ref)
      ctx = LoweringContext.new(func, @module, @arena)

      # Add parameters to new() that match initialize()
      param_ids = [] of ValueId
      # if class_name.includes?("Slice")
      #   STDERR.puts "[ALLOC_PARAMS] func=#{func_name}, init_params.size=#{init_params.size}"
      #   init_params.each_with_index do |(name, type_ref), idx|
      #     STDERR.puts "  [#{idx}] #{name}: #{type_ref.id}"
      #   end
      # end
      allocator_params.each do |param_name, param_type|
        hir_param = func.add_param(param_name, param_type)
        ctx.register_local(param_name, hir_param.id)
        ctx.register_type(hir_param.id, param_type)
        param_ids << hir_param.id
      end

      # Propagate default literal values from the initialize DefNode to allocator params.
      # Without this, the LLVM backend pads missing args with 0 instead of the actual default.
      init_def_for_defaults = @function_defs["#{class_name}#initialize"]?
      if init_def_for_defaults && (init_def_params = init_def_for_defaults.params)
        init_arena_for_defaults = @function_def_arenas["#{class_name}#initialize"]? || @arena
        with_arena(init_arena_for_defaults) do
          param_idx = 0
          init_def_params.each do |ast_param|
            next if named_only_separator?(ast_param)
            next if ast_param.is_block
            break if param_idx >= func.params.size
            if default_lit = extract_param_default_literal(ast_param)
              func.params[param_idx].default_literal = default_lit
            end
            param_idx += 1
          end
        end
      end

      # Allocate object (struct=stack, class=heap determined by escape analysis)
      alloc = Allocate.new(ctx.next_id, class_info.type_ref, [] of ValueId, class_info.is_struct)
      ctx.emit(alloc)
      ctx.register_type(alloc.id, class_info.type_ref)

      # Initialize instance variables to zero/default or evaluate default expressions
      class_info.ivars.each do |ivar|
        # Check if this is a union type by looking up the type descriptor
        type_desc = @module.get_type_descriptor(ivar.type)
        if type_desc && type_desc.kind == TypeKind::Union
          # Union types will be initialized in initialize()
          # We can't create a simple zero literal for unions
          next
        end

        # If ivar has a non-trivial default expression, evaluate it
        # BUT skip BlockNode defaults: those are lazy getter patterns
        # (getter x : T { expr }) where @x starts as nil and the getter
        # method handles initialization on first access.
        if (default_expr_id = ivar.default_expr_id) && (default_arena = ivar.default_arena)
          default_node = default_arena[default_expr_id]
          is_lazy_getter = default_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
          unless is_lazy_getter
            # Try to resolve simple defaults without full lower_expr (avoids
            # triggering demand-driven compilation for module ivar defaults)
            resolved_literal = try_resolve_simple_default(default_node, default_arena, ivar.type)
            if resolved_literal
              default_val = Literal.new(ctx.next_id, ivar.type, resolved_literal)
              ctx.emit(default_val)
              ivar_store = FieldSet.new(ctx.next_id, TypeRef::VOID, alloc.id, ivar.name, default_val.id, ivar.offset)
              ctx.emit(ivar_store)
              next
            end

            # Handle X.empty patterns (Bytes.empty, Slice.empty) → allocate zero-filled struct
            # Our compiler heap-allocates structs, so zero-init (null pointer) is wrong.
            # GC_malloc zero-fills, so allocating a struct gives a valid pointer to zeroed memory.
            # Handle X.empty patterns (Bytes.empty, Slice.empty) → allocate zero-filled struct
            # Our compiler heap-allocates structs, so zero-init (null pointer) is wrong.
            # GC_malloc zero-fills, so allocating a struct gives a valid pointer to zeroed memory.
            if default_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
               String.new(default_node.member) == "empty"
              struct_alloc = Allocate.new(ctx.next_id, ivar.type, [] of ValueId, false)
              ctx.emit(struct_alloc)
              ctx.register_type(struct_alloc.id, ivar.type)
              ivar_store = FieldSet.new(ctx.next_id, TypeRef::VOID, alloc.id, ivar.name, struct_alloc.id, ivar.offset)
              ctx.emit(ivar_store)
              next
            end

            saved_arena = @arena
            saved_class = @current_class
            @arena = default_arena
            @current_class = class_name
            begin
              default_id = lower_expr(ctx, default_expr_id)
              ivar_store = FieldSet.new(ctx.next_id, TypeRef::VOID, alloc.id, ivar.name, default_id, ivar.offset)
              ctx.emit(ivar_store)
            rescue ex
              # Fallback to zero/nil if expression can't be lowered
              STDERR.puts "[ALLOC_DEFAULT_FAIL] #{class_name}##{ivar.name}: #{ex.message} (#{ex.class})"
              default_val = Literal.new(ctx.next_id, ivar.type, nil)
              ctx.emit(default_val)
              ivar_store = FieldSet.new(ctx.next_id, TypeRef::VOID, alloc.id, ivar.name, default_val.id, ivar.offset)
              ctx.emit(ivar_store)
            ensure
              @arena = saved_arena
              @current_class = saved_class
            end
            next
          end
          # Fall through for lazy getters: zero/nil the field below
        end

        # Use nil for pointer types, 0 for others
        is_pointer = ivar.type == TypeRef::POINTER ||
                     (type_desc && type_desc.kind == TypeKind::Pointer) ||
                     (type_desc && type_desc.name.starts_with?("Pointer"))
        default_value : (Int64 | Nil) = if is_pointer
          nil
        else
          0_i64
        end
        default_val = Literal.new(ctx.next_id, ivar.type, default_value)
        ctx.emit(default_val)
        ivar_store = FieldSet.new(ctx.next_id, TypeRef::VOID, alloc.id, ivar.name, default_val.id, ivar.offset)
        ctx.emit(ivar_store)
      end

      # Call initialize if it exists, passing through the parameters
      # Use inheritance-aware resolution to find initialize in parent classes
      init_base_name = resolve_method_with_inheritance(class_name, "initialize")
      if init_base_name
        # Mangle the initialize call with parameter types
        init_param_types = allocator_params.map { |_, t| t }
        init_name = mangle_function_name(init_base_name, init_param_types)
        callsite_init_types = if call_arg_types && call_arg_types.any? { |t| t != TypeRef::VOID }
                                call_arg_types
                              else
                                init_param_types
                              end
        remember_callsite_arg_types(init_name, callsite_init_types) unless callsite_init_types.empty?
        lower_function_if_needed(init_name)
        # If the init def wasn't lowered (e.g., pending callsite got consumed),
        # force a direct lower so the allocator call has a matching body.
        if !@module.has_function?(init_name) &&
           !function_state(init_name).in_progress? &&
           !function_state(init_name).completed?
          init_def = @function_defs[init_name]? || @function_defs[init_base_name]?
          if init_def
            init_arena = @function_def_arenas[init_name]? || @function_def_arenas[init_base_name]?
            init_arena ||= resolve_arena_for_def(init_def, @arena)
            callsite_types = callsite_init_types.empty? ? nil : callsite_init_types
            with_arena(init_arena) do
              lower_method(class_name, class_info, init_def, callsite_types, nil, nil, init_name)
            end
          end
        end
        init_call = Call.new(ctx.next_id, TypeRef::VOID, alloc.id, init_name, param_ids)
        ctx.emit(init_call)
      end

      # Return allocated object
      ctx.terminate(Return.new(alloc.id))

      # Generate instance #new wrapper for cases where type literals are lowered as receivers.
      instance_name = "#{class_name}#new"
      unless @module.has_function?(instance_name) || @function_types.has_key?(instance_name) || has_function_base?(instance_name)
        instance_func = @module.create_function(instance_name, class_info.type_ref)
        instance_ctx = LoweringContext.new(instance_func, @module, @arena)

        self_param = instance_func.add_param("self", class_info.type_ref)
        instance_ctx.register_local("self", self_param.id)
        instance_ctx.register_type(self_param.id, class_info.type_ref)

        wrapper_param_ids = [] of ValueId
        allocator_params.each do |param_name, param_type|
          hir_param = instance_func.add_param(param_name, param_type)
          instance_ctx.register_local(param_name, hir_param.id)
          instance_ctx.register_type(hir_param.id, param_type)
          wrapper_param_ids << hir_param.id
        end

        new_call = Call.new(instance_ctx.next_id, class_info.type_ref, nil, "#{class_name}.new", wrapper_param_ids)
        instance_ctx.emit(new_call)
        instance_ctx.register_type(new_call.id, class_info.type_ref)
        instance_ctx.terminate(Return.new(new_call.id))
      end

      generate_allocator_overload(class_name, class_info, call_arg_types)
    end

    private def generate_allocator_overload(
      class_name : String,
      class_info : ClassInfo,
      call_arg_types : Array(TypeRef)?,
    ) : Nil
      return unless call_arg_types
      return if call_arg_types.empty?

      return if call_arg_types.all? { |t| t == TypeRef::VOID }

      # Re-lookup class_info to get the latest version with all ivars
      if latest = @class_info[class_name]?
        class_info = latest
      end

      base_name = "#{class_name}.new"
      overload_name = mangle_function_name(base_name, call_arg_types)
      return if overload_name == base_name
      return if @module.has_function?(overload_name)

      # When auto-allocator init params have a hard type mismatch with call args
      # (e.g., File.new(path, mode) where init expects fd:Int but call passes String),
      # generate a custom allocator that calls __crystal_v2_file_open to get the fd
      # instead of the wrong ptrtoint conversion.
      init_params = @init_params[class_name]? || [] of {String, TypeRef}
      if init_params.size > 0 && class_name == "File"
        non_void_call = call_arg_types.reject { |t| t == TypeRef::VOID }
        # File.new(String, String, ...) — first two concrete args are both String
        # but initialize expects (String path, Int32 fd, String mode, ...)
        if non_void_call.size >= 2 && non_void_call[0] == TypeRef::STRING && non_void_call[1] == TypeRef::STRING
          if init_params.size >= 2 && init_params[1][1] == TypeRef::INT32
            # Generate File.new that opens the file via __crystal_v2_file_open
            generate_file_new_allocator(class_name, class_info, call_arg_types, overload_name)
            return
          end
        end
      end

      # Slice.new(size : Int32) — explicit self.new allocates memory then creates Slice.
      # Auto-allocator would wrongly map Int32 → @pointer (ptrtoint). Intercept and fix.
      init_params2 = @init_params[class_name]? || [] of {String, TypeRef}
      if init_params2.size >= 2 && class_name.includes?("Slice")
        non_void_call2 = call_arg_types.reject { |t| t == TypeRef::VOID }
        # Slice.new(Int32, ...) but init expects (Pointer, Int32, Bool)
        if non_void_call2.size >= 1 && non_void_call2[0] == TypeRef::INT32
          if init_params2[0][1].id >= TypeRef::FIRST_USER_TYPE || init_params2[0][0] == "pointer"
            generate_slice_new_allocator(class_name, class_info, call_arg_types, overload_name)
            return
          end
        end
      end

      init_params = @init_params[class_name]? || [] of {String, TypeRef}
      allocator_params = init_params.map { |param| {param[0], param[1]} }
      if allocator_params.empty?
        allocator_params = call_arg_types.map_with_index { |type_ref, idx| {"arg#{idx}", type_ref} }
      else
        allocator_params.each_with_index do |(param_name, param_type), idx|
          next if idx >= call_arg_types.size
          call_type = call_arg_types[idx]
          next if call_type == TypeRef::VOID
          if param_type == TypeRef::VOID
            allocator_params[idx] = {param_name, call_type}
          end
        end
      end

      func = @module.create_function(overload_name, class_info.type_ref)
      ctx = LoweringContext.new(func, @module, @arena)

      param_ids = [] of ValueId
      allocator_params.each do |param_name, param_type|
        hir_param = func.add_param(param_name, param_type)
        ctx.register_local(param_name, hir_param.id)
        ctx.register_type(hir_param.id, param_type)
        param_ids << hir_param.id
      end

      alloc = Allocate.new(ctx.next_id, class_info.type_ref, [] of ValueId, class_info.is_struct)
      ctx.emit(alloc)
      ctx.register_type(alloc.id, class_info.type_ref)

      class_info.ivars.each do |ivar|
        type_desc = @module.get_type_descriptor(ivar.type)
        if type_desc && type_desc.kind == TypeKind::Union
          next
        end

        # Evaluate non-trivial default expressions (same as generate_allocator)
        # Skip BlockNode defaults (lazy getter pattern)
        if (default_expr_id = ivar.default_expr_id) && (default_arena = ivar.default_arena)
          default_node = default_arena[default_expr_id]
          is_lazy_getter = default_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
          unless is_lazy_getter
            # Try simple literal resolution first
            resolved_literal = try_resolve_simple_default(default_node, default_arena, ivar.type)
            if resolved_literal
              default_val = Literal.new(ctx.next_id, ivar.type, resolved_literal)
              ctx.emit(default_val)
              ivar_store = FieldSet.new(ctx.next_id, TypeRef::VOID, alloc.id, ivar.name, default_val.id, ivar.offset)
              ctx.emit(ivar_store)
              next
            end

            # Handle X.empty patterns (Bytes.empty, Slice.empty) → allocate zero-filled struct
            if default_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
               String.new(default_node.member) == "empty"
              struct_alloc = Allocate.new(ctx.next_id, ivar.type, [] of ValueId, false)
              ctx.emit(struct_alloc)
              ctx.register_type(struct_alloc.id, ivar.type)
              ivar_store = FieldSet.new(ctx.next_id, TypeRef::VOID, alloc.id, ivar.name, struct_alloc.id, ivar.offset)
              ctx.emit(ivar_store)
              next
            end

            saved_arena = @arena
            saved_class = @current_class
            @arena = default_arena
            @current_class = class_name
            begin
              default_id = lower_expr(ctx, default_expr_id)
              ivar_store = FieldSet.new(ctx.next_id, TypeRef::VOID, alloc.id, ivar.name, default_id, ivar.offset)
              ctx.emit(ivar_store)
            rescue ex
              default_val = Literal.new(ctx.next_id, ivar.type, nil)
              ctx.emit(default_val)
              ivar_store = FieldSet.new(ctx.next_id, TypeRef::VOID, alloc.id, ivar.name, default_val.id, ivar.offset)
              ctx.emit(ivar_store)
            ensure
              @arena = saved_arena
              @current_class = saved_class
            end
            next
          end
        end

        is_pointer = ivar.type == TypeRef::POINTER ||
                     (type_desc && type_desc.kind == TypeKind::Pointer) ||
                     (type_desc && type_desc.name.starts_with?("Pointer"))
        default_value : (Int64 | Nil) = is_pointer ? nil : 0_i64
        default_val = Literal.new(ctx.next_id, ivar.type, default_value)
        ctx.emit(default_val)
        ivar_store = FieldSet.new(ctx.next_id, TypeRef::VOID, alloc.id, ivar.name, default_val.id, ivar.offset)
        ctx.emit(ivar_store)
      end

      init_base_name = resolve_method_with_inheritance(class_name, "initialize")
      if init_base_name
        init_param_types = allocator_params.map { |_, t| t }
        init_name = mangle_function_name(init_base_name, init_param_types)
        remember_callsite_arg_types(init_name, call_arg_types) unless call_arg_types.empty?
        lower_function_if_needed(init_name)
        if !@module.has_function?(init_name) &&
           !function_state(init_name).in_progress? &&
           !function_state(init_name).completed?
          init_def = @function_defs[init_name]?
          init_def_name = init_def ? init_name : nil
          unless init_def
            init_def = @function_defs[init_base_name]?
            init_def_name = init_def ? init_base_name : nil
          end
          unless init_def
            if match = lookup_function_def_for_call(init_base_name, call_arg_types.size, false, call_arg_types)
              init_def_name, init_def = match
            end
          end
          if init_def
            init_arena = @function_def_arenas[init_def_name]? || @function_def_arenas[init_base_name]?
            init_arena ||= resolve_arena_for_def(init_def, @arena)
            callsite_types = call_arg_types.empty? ? nil : call_arg_types
            with_arena(init_arena) do
              lower_method(class_name, class_info, init_def, callsite_types, nil, nil, init_name)
            end
          end
        end
        init_call = Call.new(ctx.next_id, TypeRef::VOID, alloc.id, init_name, param_ids)
        ctx.emit(init_call)
      end

      ctx.terminate(Return.new(alloc.id))
    end

    private def allocator_supported?(class_name : String) : Bool
      return false if class_name.starts_with?("Pointer(") || class_name.starts_with?("Pointer_")
      return false if primitive_self_type(class_name)
      true
    end

    # Generate File.new(path, mode) allocator that correctly opens the file.
    # File's initialize expects (path, fd:Int, mode, ...) but the call passes
    # (path, mode). This method calls __crystal_v2_file_open(path, mode) to get
    # the fd, then delegates to the normal allocator with (path, fd, mode, ...).
    private def generate_file_new_allocator(
      class_name : String,
      class_info : ClassInfo,
      call_arg_types : Array(TypeRef),
      overload_name : String,
    ) : Nil
      func = @module.create_function(overload_name, class_info.type_ref)
      ctx = LoweringContext.new(func, @module, @arena)

      # Add ALL params matching call_arg_types (including VOID) to match the normal
      # allocator's param count. The LLVM backend strips the first arg when callee has
      # N-1 params vs N caller args (self arg mismatch), so we need the full param list.
      path_id = nil.as(ValueId?)
      mode_id = nil.as(ValueId?)
      call_arg_types.each_with_index do |type_ref, idx|
        hir_param = func.add_param("arg#{idx}", type_ref)
        ctx.register_type(hir_param.id, type_ref)
        # Track first two non-VOID String params as path and mode
        if type_ref == TypeRef::STRING
          if path_id.nil?
            path_id = hir_param.id
          elsif mode_id.nil?
            mode_id = hir_param.id
          end
        end
      end

      path_id = path_id || raise "File.new allocator: missing path arg"
      mode_id = mode_id || raise "File.new allocator: missing mode arg"

      # Call __crystal_v2_file_open(path, mode) → ptr to {i32 fd, i1 blocking}
      open_call = ExternCall.new(ctx.next_id, TypeRef::POINTER, "__crystal_v2_file_open", [path_id, mode_id])
      ctx.emit(open_call)
      ctx.register_type(open_call.id, TypeRef::POINTER)
      tup_ptr = open_call.id

      # Extract fd: load i32 from byte offset 0 of tuple
      fd_get = FieldGet.new(ctx.next_id, TypeRef::INT32, tup_ptr, "fd", 0)
      ctx.emit(fd_get)
      ctx.register_type(fd_get.id, TypeRef::INT32)

      # Extract blocking: load i1 from byte offset 4 of tuple
      blocking_get = FieldGet.new(ctx.next_id, TypeRef::BOOL, tup_ptr, "blocking", 4)
      ctx.emit(blocking_get)
      ctx.register_type(blocking_get.id, TypeRef::BOOL)

      # Build args for the internal allocator: File.new(path, fd, mode, blocking, nil, nil)
      # The internal allocator expects: String, Int32, String, Bool, Nil, Nil
      internal_types = [TypeRef::STRING, TypeRef::INT32, TypeRef::STRING, TypeRef::BOOL, TypeRef::NIL, TypeRef::NIL]
      internal_name = mangle_function_name("#{class_name}.new", internal_types)

      # Ensure the internal allocator exists
      generate_allocator_overload(class_name, class_info, internal_types)

      # Emit call to internal File.new(path, fd, mode, blocking, nil, nil)
      # Create nil literals for encoding and invalid
      nil_lit1 = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit1)
      ctx.register_type(nil_lit1.id, TypeRef::NIL)
      nil_lit2 = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit2)
      ctx.register_type(nil_lit2.id, TypeRef::NIL)

      internal_call = Call.new(ctx.next_id, class_info.type_ref, nil, internal_name,
        [path_id, fd_get.id, mode_id, blocking_get.id, nil_lit1.id, nil_lit2.id])
      ctx.emit(internal_call)
      ctx.register_type(internal_call.id, class_info.type_ref)

      ctx.terminate(Return.new(internal_call.id))
    end

    # Generate custom allocator for Slice.new(size : Int32).
    # The explicit self.new allocates memory: `pointer = Pointer(T).malloc(size)`
    # then calls `new(pointer, size, read_only: false)`.
    # We replicate this by calling __crystal_v2_malloc64(size) and delegating
    # to the 3-arg allocator.
    private def generate_slice_new_allocator(
      class_name : String,
      class_info : ClassInfo,
      call_arg_types : Array(TypeRef),
      overload_name : String,
    ) : Nil
      func = @module.create_function(overload_name, class_info.type_ref)
      ctx = LoweringContext.new(func, @module, @arena)

      # Add ALL params from call_arg_types (same as File.new fix — keep full count)
      size_id = nil.as(ValueId?)
      call_arg_types.each_with_index do |type_ref, idx|
        hir_param = func.add_param("arg#{idx}", type_ref)
        ctx.register_type(hir_param.id, type_ref)
        # Track the first Int32 param as the size
        if type_ref == TypeRef::INT32 && size_id.nil?
          size_id = hir_param.id
        end
      end

      size_id = size_id || raise "Slice.new allocator: missing size arg"

      # Call __crystal_v2_malloc64(size) → ptr to allocated buffer
      # Pass i32 directly — LLVM backend's emit_extern_call handles i32→i64 promotion
      malloc_call = ExternCall.new(ctx.next_id, TypeRef::POINTER, "__crystal_v2_malloc64", [size_id])
      ctx.emit(malloc_call)
      ctx.register_type(malloc_call.id, TypeRef::POINTER)
      buffer_ptr = malloc_call.id

      # Build args for internal 3-arg allocator: Slice.new(pointer, size, read_only=false)
      false_lit = Literal.new(ctx.next_id, TypeRef::BOOL, false)
      ctx.emit(false_lit)
      ctx.register_type(false_lit.id, TypeRef::BOOL)

      # Determine element type from class_name for correct type mapping
      internal_types = [TypeRef::POINTER, TypeRef::INT32, TypeRef::BOOL]
      internal_name = mangle_function_name("#{class_name}.new", internal_types)

      # Ensure the internal 3-arg allocator exists
      generate_allocator_overload(class_name, class_info, internal_types)

      internal_call = Call.new(ctx.next_id, class_info.type_ref, nil, internal_name,
        [buffer_ptr, size_id, false_lit.id])
      ctx.emit(internal_call)
      ctx.register_type(internal_call.id, class_info.type_ref)

      ctx.terminate(Return.new(internal_call.id))
    end

    # Generate synthetic getter method: def name; @name; end
    private def generate_getter_method(class_name : String, class_info : ClassInfo, spec : CrystalV2::Compiler::Frontend::AccessorSpec)
      storage_name = accessor_storage_name(spec)
      getter_name = accessor_method_name(spec)
      ivar_name = "@#{storage_name}"
      ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
      return unless ivar_info

      if env_get("DEBUG_LAZY_GETTER")
        STDERR.puts "[LAZY_GETTER_CHECK] class=#{class_name} getter=#{getter_name} has_default=#{!spec.default_value.nil?}"
      end
      if default_expr = spec.default_value
        if env_get("DEBUG_LAZY_GETTER")
          STDERR.puts "[LAZY_GETTER] class=#{class_name} getter=#{getter_name} ivar=#{ivar_name} default_expr=#{default_expr}"
        end
        generate_lazy_getter_method(class_name, class_info, ivar_info, getter_name, default_expr)
      else
        generate_getter_method_for_ivar(class_name, class_info, ivar_info, getter_name)
      end
    end

    # Generate a lazy getter: def name; if @ivar.nil?; @ivar = default; end; @ivar; end
    private def generate_lazy_getter_method(
      class_name : String,
      class_info : ClassInfo,
      ivar_info : IVarInfo,
      accessor_name : String,
      default_expr : ExprId,
    )
      ivar_type = ivar_info.type
      base_name = "#{class_name}##{accessor_name}"
      func_name = mangle_function_name(base_name, [] of TypeRef)
      register_function_type(func_name, ivar_type)
      return if @module.has_function?(func_name)

      func = @module.create_function(func_name, ivar_type)
      ctx = LoweringContext.new(func, @module, @arena)

      self_type_ref = class_info.type_ref
      self_param = func.add_param("self", self_type_ref)
      ctx.register_local("self", self_param.id)
      ctx.register_type(self_param.id, self_type_ref)

      # Read the current ivar value
      field_get = FieldGet.new(ctx.next_id, ivar_type, self_param.id, ivar_info.name, ivar_info.offset)
      ctx.emit(field_get)
      ctx.register_type(field_get.id, ivar_type)

      # Check if it's nil (null pointer for reference types)
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      ctx.register_type(nil_lit.id, TypeRef::NIL)

      is_nil = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, field_get.id, nil_lit.id)
      ctx.emit(is_nil)
      ctx.register_type(is_nil.id, TypeRef::BOOL)

      # Branch: if nil → init block, else → return block
      scope = ctx.current_scope
      init_block = func.create_block(scope)
      return_block = func.create_block(scope)

      ctx.terminate(Branch.new(is_nil.id, init_block, return_block))

      # Init block: evaluate default expression, store it, jump to return
      ctx.switch_to_block(init_block)
      old_class = @current_class
      @current_class = class_name
      begin
        # Unwrap BlockNode: getter x : T { expr } stores a BlockNode as default.
        # We need to evaluate the body expressions inline, not create a Proc.
        default_node = @arena[default_expr]
        if default_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
          default_val = 0_u32
          default_node.body.each do |body_expr|
            default_val = lower_expr(ctx, body_expr)
          end
        else
          default_val = lower_expr(ctx, default_expr)
        end
      ensure
        @current_class = old_class
      end
      ctx.register_type(default_val, ivar_type)

      # Store the default value to the ivar
      field_set = FieldSet.new(ctx.next_id, ivar_type, self_param.id, ivar_info.name, default_val, ivar_info.offset)
      ctx.emit(field_set)
      ctx.terminate(Jump.new(return_block))

      # Return block: read the ivar again and return
      ctx.switch_to_block(return_block)
      field_get2 = FieldGet.new(ctx.next_id, ivar_type, self_param.id, ivar_info.name, ivar_info.offset)
      ctx.emit(field_get2)
      ctx.register_type(field_get2.id, ivar_type)
      ctx.terminate(Return.new(field_get2.id))
    end

    # Generate synthetic setter method: def name=(value); @name = value; end
    private def generate_setter_method(class_name : String, class_info : ClassInfo, spec : CrystalV2::Compiler::Frontend::AccessorSpec)
      accessor_name = String.new(spec.name)
      ivar_name = "@#{accessor_name}"
      ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
      return unless ivar_info

      generate_setter_method_for_ivar(class_name, class_info, ivar_info)
    end

    private def generate_getter_method_for_ivar(
      class_name : String,
      class_info : ClassInfo,
      ivar_info : IVarInfo,
      accessor_name : String? = nil,
      self_type_ref : TypeRef? = nil,
    )
      accessor_name = accessor_name || ivar_info.name.lstrip('@')
      ivar_type = ivar_info.type

      base_name = "#{class_name}##{accessor_name}"
      func_name = mangle_function_name(base_name, [] of TypeRef)
      register_function_type(func_name, ivar_type)
      return if @module.has_function?(func_name)

      # If this ivar has a default expression (lazy getter), generate lazy init
      if (default_expr = ivar_info.default_expr_id) && (default_arena = ivar_info.default_arena)
        saved_arena = @arena
        with_arena(default_arena) do
          generate_lazy_getter_method(class_name, class_info, ivar_info, accessor_name || ivar_info.name.lstrip('@'), default_expr)
        end
        return
      end

      func = @module.create_function(func_name, ivar_type)
      ctx = LoweringContext.new(func, @module, @arena)

      self_type_ref ||= class_info.type_ref
      self_param = func.add_param("self", self_type_ref)
      ctx.register_local("self", self_param.id)
      ctx.register_type(self_param.id, self_type_ref)

      field_get = FieldGet.new(ctx.next_id, ivar_type, self_param.id, ivar_info.name, ivar_info.offset)
      ctx.emit(field_get)
      ctx.register_type(field_get.id, ivar_type)

      ctx.terminate(Return.new(field_get.id))
    end

    private def generate_setter_method_for_ivar(
      class_name : String,
      class_info : ClassInfo,
      ivar_info : IVarInfo,
      use_base_name : Bool = false,
    )
      accessor_name = ivar_info.name.lstrip('@')
      ivar_type = ivar_info.type

      base_name = "#{class_name}##{accessor_name}="
      func_name = use_base_name ? base_name : mangle_function_name(base_name, [ivar_type])
      register_function_type(func_name, ivar_type)
      return if @module.has_function?(func_name)

      func = @module.create_function(func_name, ivar_type)
      ctx = LoweringContext.new(func, @module, @arena)

      self_param = func.add_param("self", class_info.type_ref)
      ctx.register_local("self", self_param.id)
      ctx.register_type(self_param.id, class_info.type_ref)

      value_param = func.add_param("value", ivar_type)
      ctx.register_local("value", value_param.id)
      ctx.register_type(value_param.id, ivar_type)

      field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, self_param.id, ivar_info.name, value_param.id, ivar_info.offset)
      ctx.emit(field_set)

      ctx.terminate(Return.new(value_param.id))
    end

    private def generate_class_getter_method(owner_name : String, spec : CrystalV2::Compiler::Frontend::AccessorSpec, arena : CrystalV2::Compiler::Frontend::ArenaLike)
      storage_name = accessor_storage_name(spec)
      method_name = accessor_method_name(spec)
      old_class = @current_class
      old_method = @current_method
      old_method_is_class = @current_method_is_class

      base_name = "#{owner_name}.#{method_name}"
      full_name = mangle_function_name(base_name, [] of TypeRef)
      return if @module.has_function?(full_name)

      @current_class = owner_name
      @current_method = method_name
      @current_method_is_class = true

      return_type = begin
        if ta = spec.type_annotation
          type_ref_for_name(String.new(ta))
        elsif spec.predicate
          TypeRef::BOOL
        elsif default_value = spec.default_value
          inferred = infer_type_from_expr(default_value, owner_name)
          inferred || TypeRef::VOID
        else
          TypeRef::VOID
        end
      end

      func = @module.create_function(full_name, return_type)
      ctx = LoweringContext.new(func, @module, arena)

      if default_value = spec.default_value
        flag_name = class_accessor_init_flag_name(storage_name)
        flag_get = ClassVarGet.new(ctx.next_id, TypeRef::BOOL, owner_name, flag_name)
        ctx.emit(flag_get)

        then_block = ctx.create_block
        else_block = ctx.create_block
        merge_block = ctx.create_block
        ctx.terminate(Branch.new(flag_get.id, then_block, else_block))

        ctx.switch_to_block(then_block)
        cached_get = ClassVarGet.new(ctx.next_id, return_type, owner_name, storage_name)
        ctx.emit(cached_get)
        ctx.terminate(Jump.new(merge_block))

        ctx.switch_to_block(else_block)
        init_value = with_arena(arena) { lower_accessor_default_value(ctx, default_value) }
        class_var_set = ClassVarSet.new(ctx.next_id, return_type, owner_name, storage_name, init_value)
        ctx.emit(class_var_set)
        flag_lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
        ctx.emit(flag_lit)
        flag_set = ClassVarSet.new(ctx.next_id, TypeRef::BOOL, owner_name, flag_name, flag_lit.id)
        ctx.emit(flag_set)
        ctx.terminate(Jump.new(merge_block))

        ctx.switch_to_block(merge_block)
        phi = Phi.new(ctx.next_id, return_type)
        phi.add_incoming(then_block, cached_get.id)
        phi.add_incoming(else_block, init_value)
        ctx.emit(phi)
        ctx.terminate(Return.new(phi.id))
      else
        value_id = ClassVarGet.new(ctx.next_id, return_type, owner_name, storage_name)
        ctx.emit(value_id)
        ctx.terminate(Return.new(value_id.id))
      end
    ensure
      @current_class = old_class
      @current_method = old_method
      @current_method_is_class = old_method_is_class || false
    end

    private def generate_class_setter_method(owner_name : String, spec : CrystalV2::Compiler::Frontend::AccessorSpec)
      storage_name = accessor_storage_name(spec)
      param_type = if ta = spec.type_annotation
                     type_ref_for_name(String.new(ta))
                   else
                     TypeRef::VOID
                   end
      base_name = "#{owner_name}.#{storage_name}="
      full_name = mangle_function_name(base_name, [param_type])
      return if @module.has_function?(full_name)

      func = @module.create_function(full_name, param_type)
      ctx = LoweringContext.new(func, @module, @arena)
      value_param = func.add_param("value", param_type)
      ctx.register_local("value", value_param.id)
      ctx.register_type(value_param.id, param_type)

      class_var_set = ClassVarSet.new(ctx.next_id, param_type, owner_name, storage_name, value_param.id)
      ctx.emit(class_var_set)
      flag_name = class_accessor_init_flag_name(storage_name)
      flag_lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
      ctx.emit(flag_lit)
      flag_set = ClassVarSet.new(ctx.next_id, TypeRef::BOOL, owner_name, flag_name, flag_lit.id)
      ctx.emit(flag_set)
      ctx.terminate(Return.new(value_param.id))
    end

    # Resolve a meta-instance method (Class/Module/Object) for a type-literal call,
    # using arity + arg types to pick the correct overload across inheritance.
    private def resolve_meta_method_overload(
      meta_owner : String,
      method_name : String,
      arg_types : Array(TypeRef),
    ) : String?
      current = meta_owner
      visited = Set(String).new
      while true
        break if visited.includes?(current)
        visited << current
        base = "#{current}##{method_name}"
        if entry = lookup_function_def_for_call(base, arg_types.size, false, arg_types, false, false)
          return entry[0]
        end
        if info = @class_info[current]?
          if parent = info.parent_name
            current = parent
            next
          end
        end
        break
      end
      nil
    end

    # Generate a class-method wrapper for type-literal calls that should dispatch to
    # meta-instance methods (e.g., Int32.to_s -> Class#to_s / Object#to_s).
    private def ensure_type_literal_class_method(
      owner_name : String,
      method_name : String,
      arg_types : Array(TypeRef),
      meta_owner : String,
    ) : String?
      meta_method = resolve_meta_method_overload(meta_owner, method_name, arg_types)
      return nil unless meta_method
      full_name = mangle_function_name("#{owner_name}.#{method_name}", arg_types)
      return full_name if @module.has_function?(full_name)

      return_type = get_function_return_type(meta_method)
      func = @module.create_function(full_name, return_type)
      ctx = LoweringContext.new(func, @module, @arena)

      arg_ids = [] of ValueId
      arg_types.each_with_index do |arg_type, idx|
        param = func.add_param("arg#{idx}", arg_type)
        ctx.register_local("arg#{idx}", param.id)
        ctx.register_type(param.id, arg_type)
        arg_ids << param.id
      end

      literal_id = lower_type_literal_from_name(ctx, owner_name)
      ctx.mark_type_literal(literal_id)

      remember_callsite_arg_types(meta_method, arg_types)
      lower_function_if_needed(meta_method)

      call = Call.new(ctx.next_id, return_type, literal_id, meta_method, arg_ids)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      if return_type == TypeRef::VOID
        ctx.terminate(Return.new(nil))
      else
        ctx.terminate(Return.new(call.id))
      end
      full_name
    end

    # Generate a class-method wrapper that forwards to an instance method using
    # the first argument as the receiver (unbound instance call).
    private def ensure_unbound_instance_method_wrapper(
      owner_name : String,
      method_name : String,
      arg_types : Array(TypeRef),
    ) : String?
      return nil if arg_types.empty?
      owner_ref = type_ref_for_name(owner_name)
      return nil if owner_ref == TypeRef::VOID
      return nil unless arg_types.first == owner_ref

      instance_arg_types = arg_types[1..]
      instance_base = "#{owner_name}##{method_name}"
      if entry = lookup_function_def_for_call(instance_base, instance_arg_types.size, false, instance_arg_types, false, false)
        instance_name = entry[0]
      else
        return nil
      end

      wrapper_name = mangle_function_name("#{owner_name}.#{method_name}", arg_types)
      return wrapper_name if @module.has_function?(wrapper_name)

      return_type = get_function_return_type(instance_name)
      func = @module.create_function(wrapper_name, return_type)
      ctx = LoweringContext.new(func, @module, @arena)

      arg_ids = [] of ValueId
      arg_types.each_with_index do |arg_type, idx|
        param = func.add_param("arg#{idx}", arg_type)
        ctx.register_local("arg#{idx}", param.id)
        ctx.register_type(param.id, arg_type)
        arg_ids << param.id
      end

      receiver_id = arg_ids.shift
      remember_callsite_arg_types(instance_name, instance_arg_types)
      lower_function_if_needed(instance_name)

      call = Call.new(ctx.next_id, return_type, receiver_id, instance_name, arg_ids)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      if return_type == TypeRef::VOID
        ctx.terminate(Return.new(nil))
      else
        ctx.terminate(Return.new(call.id))
      end
      wrapper_name
    end

    private def class_accessor_init_flag_name(accessor_name : String) : String
      "__class_accessor_init_#{accessor_name}"
    end

    private def lower_accessor_default_value(ctx : LoweringContext, default_value : CrystalV2::Compiler::Frontend::ExprId) : ValueId
      default_node = @arena[default_value]
      case default_node
      when CrystalV2::Compiler::Frontend::BlockNode
        if default_node.body.empty?
          nil_value(ctx)
        else
          lower_body(ctx, default_node.body)
        end
      else
        lower_expr(ctx, default_value)
      end
    end

    private def default_literal_for_type(ctx : LoweringContext, type_ref : TypeRef) : ValueId
      case type_ref
      when TypeRef::BOOL
        lit = Literal.new(ctx.next_id, type_ref, false)
        ctx.emit(lit)
        lit.id
      when TypeRef::INT8, TypeRef::INT16, TypeRef::INT32, TypeRef::INT64, TypeRef::INT128,
           TypeRef::UINT8, TypeRef::UINT16, TypeRef::UINT32, TypeRef::UINT64, TypeRef::UINT128
        lit = Literal.new(ctx.next_id, type_ref, 0_i64)
        ctx.emit(lit)
        lit.id
      when TypeRef::FLOAT32, TypeRef::FLOAT64
        lit = Literal.new(ctx.next_id, type_ref, 0.0_f64)
        ctx.emit(lit)
        lit.id
      when TypeRef::CHAR
        lit = Literal.new(ctx.next_id, type_ref, '\0')
        ctx.emit(lit)
        lit.id
      when TypeRef::NIL
        nil_value(ctx)
      else
        type_desc = @module.get_type_descriptor(type_ref)
        if type_desc && type_desc.kind == TypeKind::Struct
          alloc = Allocate.new(ctx.next_id, type_ref, [] of ValueId, true)
          ctx.emit(alloc)
          alloc.id
        else
          lit = Literal.new(ctx.next_id, type_ref, nil)
          ctx.emit(lit)
          lit.id
        end
      end
    end

    # Lower a method within a class
    private def lower_method(
      class_name : String,
      class_info : ClassInfo,
      node : CrystalV2::Compiler::Frontend::DefNode,
      call_arg_types : Array(TypeRef)? = nil,
      call_arg_literals : Array(Bool)? = nil,
      call_arg_enum_names : Array(String?)? = nil,
      full_name_override : String? = nil,
      force_class_method : Bool = false,
    )
      method_name = String.new(node.name)
      if env_get("DEBUG_MATH_MIN") && (method_name == "min" || method_name == "max") && class_name.includes?("Math")
        call_types = call_arg_types || [] of TypeRef
        call_type_names = call_types.map { |t| get_type_name_from_ref(t) }
        STDERR.puts "[MATH_MIN_LOWER] class=#{class_name} method=#{method_name} call_arg_types=#{call_type_names.join(", ")}"
      end
      if env_has?("DEBUG_RANGE_LOWER") && method_name == "[]"
        call_types = call_arg_types || [] of TypeRef
        call_type_names = call_types.map { |t| desc = @module.get_type_descriptor(t); desc ? "#{desc.name}(id=#{t.id})" : "T#{t.id}" }
        STDERR.puts "[RANGE_LOWER_METHOD] class=#{class_name} method=#{method_name} call_types=#{call_type_names.join(", ")}"
      end
      if env_has?("DEBUG_LOWER_BYTE") && (method_name == "byte_begin" || method_name == "byte_range")
        STDERR.puts "[LOWER_METHOD] START class=#{class_name} method=#{method_name} override=#{full_name_override || "nil"} arena=#{@arena.class}:#{@arena.size} modules=#{@class_included_modules[class_name]?.try(&.to_a.join(",")) || "nil"}"
      end
      if env_get("DEBUG_LOWER_METHOD_STATS")
        full_label = "#{class_name}##{method_name}"
        @lower_method_debug_total += 1
        @lower_method_debug_counts[full_label] = (@lower_method_debug_counts[full_label]? || 0) + 1
        if (@lower_method_debug_total % 50) == 0
          top = @lower_method_debug_counts.to_a.sort_by(&.[1]).last(10).reverse
          summary = top.map { |(name, count)| "#{name}=#{count}" }.join(", ")
          STDERR.puts "[LOWER_METHOD_STATS] total=#{@lower_method_debug_total} top=#{summary}"
        end
      end
      if env_get("DEBUG_LOWER_METHOD_NS_STATS")
        ns_key = namespace_bucket_for(class_name)
        @lower_method_ns_counts[ns_key] = (@lower_method_ns_counts[ns_key]? || 0) + 1
        if (@lower_method_debug_total % 100) == 0
          top = @lower_method_ns_counts.to_a.sort_by(&.[1]).last(10).reverse
          summary = top.map { |(name, count)| "#{name}=#{count}" }.join(", ")
          STDERR.puts "[LOWER_METHOD_NS] total=#{@lower_method_debug_total} top=#{summary}"
        end
      end
      # Check if this is a class method (def self.method_name)
      is_class_method = force_class_method || if recv = node.receiver
        String.new(recv) == "self"
      else
        false
      end

      if filter = env_get("DEBUG_METHOD_NS")
        full_label = "#{class_name}#{is_class_method ? "." : "#"}#{method_name}"
        if filter == "1" || full_label.includes?(filter)
          STDERR.puts "[DEBUG_METHOD_NS] method=#{full_label} override=#{@current_namespace_override || "nil"}"
        end
      end

      if debug_env_filter_match?("DEBUG_NESTED_CLASS", class_name, method_name)
        sep = is_class_method ? "." : "#"
        STDERR.puts "[DEBUG_LOWER_METHOD] #{class_name}#{sep}#{method_name} (class_method=#{is_class_method}, receiver=#{node.receiver})"
      end
      if DebugHooks::ENABLED && class_name.includes?('(') && @type_param_map.empty?
        debug_hook("method.lower.missing_type_params", "class=#{class_name} method=#{method_name} override=#{full_name_override || ""}")
      end
      if debug_env_filter_match?("DEBUG_STRING_METHOD_LOWER", class_name, method_name)
        sep = is_class_method ? "." : "#"
        STDERR.puts "[DEBUG_LOWER_METHOD] #{class_name}#{sep}#{method_name} override=#{full_name_override || "(none)"}"
      end
      if filter = env_get("DEBUG_METHOD_ARENA")
        full_label = "#{class_name}#{is_class_method ? "." : "#"}#{method_name}"
        if filter == "1" || full_label.includes?(filter)
          path = source_path_for(@arena) || "(unknown)"
          STDERR.puts "[DEBUG_METHOD_ARENA] method=#{full_label} arena=#{@arena.class}:#{@arena.size} file=#{path}"
        end
      end
      if debug_hook_filter_match?(class_name, method_name)
        debug_hook("method.lower.array_new", "class=#{class_name} map=#{type_param_map_debug_string} override=#{full_name_override || ""}")
      end
      if debug_hook_filter_match?(class_name, method_name)
        debug_hook("method.lower.map", "class=#{class_name} map=#{type_param_map_debug_string} override=#{full_name_override || ""}")
      end
      if debug_env_filter_match?("DEBUG_STRING_COMPARE_BODY", class_name, method_name)
        if body = node.body
          preview = body.first(10).map do |expr_id|
            @arena[expr_id].class.to_s.split("::").last
          end
          STDERR.puts "[DEBUG_STRING_COMPARE_BODY] body_classes=#{preview.join(",")}"
        else
          STDERR.puts "[DEBUG_STRING_COMPARE_BODY] body_classes=(none)"
        end
      end
      if env_get("DEBUG_STRING_COMPARE_SCAN") && class_name == "String" && method_name == "compare"
        found = false
        if body = node.body
          body.each do |expr_id|
            node_at = @arena[expr_id]
            if node_at.is_a?(CrystalV2::Compiler::Frontend::CallNode)
              callee = @arena[node_at.callee]
              if callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                member_name = String.new(callee.member)
                if member_name == "read_attribute_value"
                  found = true
                  break
                end
              end
            end
          end
        end
        STDERR.puts "[DEBUG_STRING_COMPARE_SCAN] contains_read_attribute_value=#{found}"
      end
      if env_get("DEBUG_STRING_COMPARE_DUMP") && class_name == "String" && method_name == "compare"
        if body = node.body
          source = @sources_by_arena[@arena]?
          body.each_with_index do |expr_id, idx|
            break if idx >= 50
            begin
              node_at = @arena[expr_id]
              snippet = nil
              if source
                source_str = source.not_nil!
                span = node_at.span
                start = span.start_offset
                length = span.end_offset - span.start_offset
                if length > 0 && start >= 0 && start < source_str.bytesize
                  slice_len = length > 80 ? 80 : length
                  snippet = source_str.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
                end
              end
              snippet_label = snippet ? " \"#{snippet}\"" : ""
              STDERR.puts "[DEBUG_STRING_COMPARE_DUMP] idx=#{idx} expr=#{expr_id.index} node=#{node_at.class.name}#{snippet_label}"
            rescue ex
              STDERR.puts "[DEBUG_STRING_COMPARE_DUMP] idx=#{idx} expr=#{expr_id.index} error=#{ex.message}"
            end
          end
        end
      end

      # Class methods use "." separator, instance methods use "#"
      base_name = if is_class_method
                    "#{class_name}.#{method_name}"
                  else
                    "#{class_name}##{method_name}"
                  end
      if env_get("DEBUG_HASH_PARAMS") && method_name == "hash"
        params_list = node.params.try(&.map { |param| param.name || "_" }.join(",")) || ""
        STDERR.puts "[HASH_PARAM_DEF] class=#{class_name} params=#{params_list}"
      end

      # Skip abstract methods - they have no implementation
      if node.is_abstract
        clear_pending_effect_annotations
        return
      end

      # Skip primitive methods — they are handled at call site via intrinsics.
      if prim = @pending_primitive_kind
        @pending_primitive_kind = nil
        @module.register_primitive(base_name, prim)
        if env_get("DEBUG_PRIMITIVES")
          STDERR.puts "[PRIMITIVE] Registered #{base_name} as primitive :#{prim}"
        end
        clear_pending_effect_annotations
        return
      end

      # Skip pointer primitives with no body (handled via call-site intrinsics).
      if class_name.starts_with?("Pointer(") || class_name.starts_with?("Pointer_")
        return if node.body.nil?
      end

      if full_name_override && full_name_override.includes?('$')
        suffix = method_suffix(full_name_override)
        if env_get("DEBUG_FROM_IO_LOWER") && method_name == "from_io"
          STDERR.puts "[FROM_IO_LOWER] class=#{class_name} override=#{full_name_override} suffix=#{suffix || ""}"
        end
        if suffix && !suffix.empty?
          parsed_types = parse_types_from_suffix(suffix)
          if env_get("DEBUG_FROM_IO_LOWER") && method_name == "from_io"
            parsed_ids = parsed_types.map(&.id).join(",")
            STDERR.puts "[FROM_IO_LOWER] class=#{class_name} parsed=#{parsed_ids}"
          end
          unless parsed_types.empty?
            # `full_name_override` may be either:
            # - a concrete callsite-specialized name (suffix encodes *all* args), OR
            # - a def-derived name (suffix encodes only non-VOID signature types; flags like _splat still apply).
            #
            # When suffix types are not positional (shorter than arg list), we must NOT
            # replace full callsite types with them; that would degrade receivers to
            # raw generic bases (e.g. Array(T) -> Array) and cause missing symbols.
            if call_arg_types.nil?
              call_arg_types = parsed_types
            else
              call_arg_types = merge_call_arg_types_from_suffix_with_signature(call_arg_types, parsed_types, node)
            end
            if env_get("DEBUG_FROM_IO_LOWER") && method_name == "from_io"
              merged_ids = call_arg_types.map(&.id).join(",")
              STDERR.puts "[FROM_IO_LOWER] class=#{class_name} merged=#{merged_ids}"
            end
          end
        end
      end

      # Defer lowering for untyped params until call-site types are available.
      if def_params_untyped?(node)
        if env_get("DEBUG_UNTYPED_DEFER") && (base_name == "hexstring" || base_name == "calculate_new_capacity")
          param_count = 0
          if params = node.params
            params.each do |param|
              next if named_only_separator?(param) || param.is_block
              param_count += 1
            end
          end
          call_str = call_arg_types ? call_arg_types.not_nil!.map { |t| get_type_name_from_ref(t) }.join(",") : ""
          STDERR.puts "[UNTYPED_DEFER] name=#{base_name} params=#{param_count} call_types=#{call_str.empty? ? "nil" : call_str}"
        end
        call_types = call_arg_types || [] of TypeRef
        if (call_types.empty? || call_types.all? { |t| t == TypeRef::VOID }) &&
           full_name_override && full_name_override.includes?('$')
          suffix = method_suffix(full_name_override) || ""
          parsed_types = parse_types_from_suffix(suffix)
          unless parsed_types.empty?
            call_types = parsed_types
            call_arg_types = parsed_types
          end
        end
        if call_types.empty? || call_types.all? { |t| t == TypeRef::VOID }
          if params = node.params
            inferred = [] of TypeRef
            all_defaulted = true
            params.each do |param|
              next if param.is_block || named_only_separator?(param)
              if ta = param.type_annotation
                inferred << type_ref_for_name(String.new(ta))
              elsif param.is_double_splat
                inferred << type_ref_for_name("NamedTuple")
              elsif default_value = param.default_value
                inferred_type = infer_type_from_expr(default_value, class_name)
                inferred << (inferred_type || TypeRef::VOID)
              else
                all_defaulted = false
                break
              end
            end
            if all_defaulted && inferred.any? { |t| t != TypeRef::VOID }
              call_types = inferred
              call_arg_types = inferred
            end
          end
        end
        if call_types.empty? || call_types.all? { |t| t == TypeRef::VOID }
          if params = node.params
            param_count = params.count { |p| !p.is_block && !named_only_separator?(p) }
            base_key = base_callsite_key(full_name_override || base_name)
            if !base_key.empty?
              if by_arity = @pending_arg_types_by_arity[base_key]?
                if bucket = by_arity[param_count]?
                  chosen = bucket.find { |entry| entry.types.any? { |t| t != TypeRef::VOID } } || bucket.first?
                  if chosen
                    call_types = chosen.types.dup
                    call_arg_types = chosen.types.dup
                    if chosen.literals
                      call_literal_flags = chosen.literals.not_nil!.dup
                    end
                    if chosen.enum_names
                      call_enum_names = chosen.enum_names.not_nil!.dup
                    end
                  end
                end
              end
            end
          end
        end
        if call_types.empty? || call_types.all? { |t| t == TypeRef::VOID }
          if params = node.params
            if body = node.body
              inferred = [] of TypeRef
              params.each do |param|
                next if named_only_separator?(param) || param.is_block
                if ta = param.type_annotation
                  inferred << type_ref_for_name(String.new(ta))
                  next
                end
                param_name = param.name ? String.new(param.name.not_nil!) : ""
                if param_name.empty?
                  inferred << TypeRef::VOID
                  next
                end
                if inferred_type = infer_local_type_from_body(body, param_name, class_name)
                  inferred << inferred_type
                else
                  inferred << TypeRef::VOID
                end
              end
              if inferred.any? { |t| t != TypeRef::VOID }
                call_types = inferred
                call_arg_types = inferred
              end
            end
          end
        end
        if call_types.empty? || call_types.all? { |t| t == TypeRef::VOID }
          debug_hook("method.lower.defer", "class=#{class_name} method=#{method_name} reason=untyped_params") if DebugHooks::ENABLED
          # Even when we defer lowering (no call-site types yet), the method-level effect
          # annotations are still valid and should influence analyses of callers. Register
          # them on the base name so calls like `Foo#bar$T` can still discover them.
          register_pending_method_effects(base_name, 0)
          return
        end
      end

      # Enum value tracking is per-function; preserve outer context.
      old_enum_value_types = @enum_value_types
      @enum_value_types = nil

      # Track current method for super calls
      old_class = @current_class
      old_method = @current_method
      old_method_is_class = @current_method_is_class
      @current_class = class_name
      @current_method = method_name
      @current_method_is_class = is_class_method

      # Collect parameter types first for name mangling
      param_infos = [] of Tuple(String, TypeRef, Bool) # (name, type, is_instance_var)
      param_default_literals = [] of String?
      param_type_names = [] of String?                 # Track type annotation names for enum detection
      param_literal_flags = [] of Bool
      param_types = [] of TypeRef
      has_block = false
      param_type_map = {} of String => TypeRef
      extra_type_params = {} of String => String
      old_typeof_locals = @current_typeof_locals
      old_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = param_type_map
      @current_typeof_local_names = {} of String => String
      call_types = call_arg_types || [] of TypeRef
      call_literal_flags = call_arg_literals || [] of Bool
      call_enum_names = call_arg_enum_names || [] of String?
      if debug_hook_filter_match?(base_name)
        debug_hook(
          "method.callsite_literals",
          "name=#{base_name} types=#{call_types.map(&.id).join(",")} literals=#{call_literal_flags.join(",")}"
        )
      end
      call_index = 0
      splat_param_info_index : Int32? = nil
      splat_param_types_index : Int32? = nil
      splat_param_name : String? = nil

      if params = node.params
        params.each do |param|
          next if named_only_separator?(param)
          param_name = param.name.nil? ? "_" : String.new(param.name.not_nil!)
          is_ivar_param = param.is_instance_var || param_name.starts_with?('@')
          if is_ivar_param
            param_name = param_name.lstrip('@')
          end
          type_ann_str : String? = nil
          param_type = if ta = param.type_annotation
                         type_ann_str = String.new(ta)
                         type_ref_for_name(type_ann_str)
                       elsif param.is_double_splat
                         type_ref_for_name("NamedTuple")
                       else
                         TypeRef::VOID
                       end
          if type_ann_str && bare_generic_annotation?(type_ann_str)
            # Keep the generic base type for dispatch; allow callsite refinement.
            param_type = type_ref_for_name(strip_generic_args(type_ann_str))
          end
          call_type_for_param = if !param.is_block && !param.is_splat && !param.is_double_splat && call_index < call_types.size
                                  call_types[call_index]
                                else
                                  TypeRef::VOID
                                end
          if param_type == TypeRef::VOID && method_name == "hash" && param_name == "hasher"
            inferred = type_ref_for_name("Crystal::Hasher")
            param_type = inferred if inferred != TypeRef::VOID
          end
          if param_type == TypeRef::VOID && !param.is_block && !param.is_splat && !param.is_double_splat
            if call_index < call_types.size
              inferred = call_types[call_index]
              param_type = inferred if inferred != TypeRef::VOID
            end
          end
          if !param.is_block && !param.is_splat && !param.is_double_splat && call_index < call_types.size
            old_param_type = param_type
            param_type = refine_param_type_from_call(param_type, call_types[call_index])
            if env_has?("DEBUG_RANGE_REFINE") && method_name == "[]"
              old_desc = @module.get_type_descriptor(old_param_type)
              new_desc = @module.get_type_descriptor(param_type)
              call_desc = @module.get_type_descriptor(call_types[call_index])
              STDERR.puts "[RANGE_REFINE] class=#{class_name} param=#{param_name} old=#{old_desc.try(&.name) || "T#{old_param_type.id}"} call=#{call_desc.try(&.name) || "T#{call_types[call_index].id}"} new=#{new_desc.try(&.name) || "T#{param_type.id}"}"
            end
          end
          if env_get("DEBUG_HASH_PARAMS") && method_name == "hash" && param_name == "hasher"
            hasher_ref = type_ref_for_name("Crystal::Hasher")
            STDERR.puts "[HASH_PARAM] class=#{class_name} param_type=#{get_type_name_from_ref(param_type)} hasher=#{get_type_name_from_ref(hasher_ref)}"
          end
          if param_type == TypeRef::VOID && !param.is_block && !param.is_splat && !param.is_double_splat
            if default_value = param.default_value
              default_node = @arena[default_value]
              if debug_env_filter_match?("DEBUG_PARAM_DEFAULT", base_name, param_name)
                default_kind = default_node.class.name.split("::").last
                default_extra = default_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode) ? " kind=#{default_node.kind}" : ""
                STDERR.puts "[PARAM_DEFAULT] func=#{base_name} param=#{param_name} node=#{default_kind}#{default_extra}"
              end
              if default_node.is_a?(CrystalV2::Compiler::Frontend::NilNode)
                object_ref = type_ref_for_name("Object")
                param_type = create_union_type_for_nullable(object_ref) if object_ref != TypeRef::VOID
              else
                if inferred_default = infer_type_from_expr(default_value, class_name)
                  if debug_env_filter_match?("DEBUG_PARAM_DEFAULT", base_name, param_name)
                    inferred_name = get_type_name_from_ref(inferred_default)
                    STDERR.puts "[PARAM_DEFAULT] func=#{base_name} param=#{param_name} inferred=#{inferred_name}"
                  end
                  param_type = inferred_default if inferred_default != TypeRef::VOID
                end
              end
            end
          end
          if env_get("DEBUG_PARAM_TYPES") && class_name == "IO::Error" && method_name == "initialize" && param_name == "target"
            default_kind = param.default_value ? @arena[param.default_value.not_nil!].class.name.split("::").last : "none"
            STDERR.puts "[PARAM_TYPE] class=#{class_name} param=#{param_name} type=#{get_type_name_from_ref(param_type)} default=#{default_kind}"
          end
          if module_type_ref?(param_type) && (default_value = param.default_value)
            call_type = call_index < call_types.size ? call_types[call_index] : TypeRef::VOID
            if call_type == TypeRef::VOID || call_type == param_type
              if inferred_default = infer_type_from_expr(default_value, class_name)
                if module_type_ref?(inferred_default) && inferred_default != TypeRef::VOID
                  param_type = inferred_default
                end
              end
            end
          end
          if param_name.ends_with?("_class") && call_type_for_param != TypeRef::VOID
            param_type = call_type_for_param
          end
          param_literal = !param.is_block && !param.is_splat && !param.is_double_splat &&
                          call_index < call_literal_flags.size && call_literal_flags[call_index]
          if param_name.ends_with?("_class")
            chosen_type = call_type_for_param == TypeRef::VOID ? param_type : call_type_for_param
            type_name = get_type_name_from_ref(chosen_type)
            if !type_name.empty? && type_name != "Void" && type_name != "Unknown"
              param_literal = true
            end
          end
          if param_literal
            chosen_type = call_type_for_param == TypeRef::VOID ? param_type : call_type_for_param
            type_name = get_type_name_from_ref(chosen_type)
            if !type_name.empty? && type_name != "Void" && type_name != "Unknown"
              update_typeof_local_name(param_name, type_name)
              extra_type_params[param_name] = type_name
            end
          end
          param_type_map[param_name] = param_type
          param_infos << {param_name, param_type, is_ivar_param}
          param_default_literals << extract_param_default_literal(param)
          enum_name = call_index < call_enum_names.size ? call_enum_names[call_index] : nil
          param_type_names << (type_ann_str || enum_name)
          if ta = param.type_annotation
            update_typeof_local_name(param_name, String.new(ta))
          end
          if param.is_block
            has_block = true
          else
            if param.is_splat
              splat_param_info_index = param_infos.size - 1
              splat_param_types_index = param_types.size
              splat_param_name = param_name
            elsif !param.is_double_splat
              call_index += 1
            end
            param_types << param_type
          end
          param_literal_flags << param_literal
          if debug_hook_filter_match?(base_name)
            debug_hook(
              "param.literal",
              "name=#{base_name} param=#{param_name} literal=#{param_literal}"
            )
          end
        end
      end

      if splat_param_name
        splat_type = TypeRef::VOID
        if !call_types.empty?
          remaining = call_types[call_index..-1]? || [] of TypeRef
          # Avoid re-wrapping: if single remaining arg is already a Tuple, use it directly
          if remaining.size == 1
            rname = get_type_name_from_ref(remaining[0])
            if rname.starts_with?("Tuple")
              splat_type = remaining[0]
            else
              splat_type = tuple_type_from_arg_types(remaining, allow_void: true)
            end
          else
            splat_type = tuple_type_from_arg_types(remaining, allow_void: true)
          end
        end
        if splat_type == TypeRef::VOID
          if elem_type = param_type_map[splat_param_name.not_nil!]?
            if elem_type != TypeRef::VOID
              # Avoid re-wrapping: if elem_type is already a Tuple, use it directly
              elem_name = get_type_name_from_ref(elem_type)
              if elem_name.starts_with?("Tuple")
                splat_type = elem_type
              else
                splat_type = tuple_type_from_arg_types([elem_type], allow_void: true)
              end
            end
          end
        end
        if splat_type == TypeRef::VOID
          fallback = type_ref_for_name("Tuple")
          splat_type = fallback if fallback != TypeRef::VOID
        end
        if splat_type != TypeRef::VOID
          param_type_map[splat_param_name.not_nil!] = splat_type
          if idx = splat_param_info_index
            param_infos[idx] = {splat_param_name.not_nil!, splat_type, param_infos[idx][2]}
          end
          if idx = splat_param_types_index
            param_types[idx] = splat_type
          end
        end
      end
      if !has_block
        def_arena = @function_def_arenas[base_name]? || resolve_arena_for_def(node, @arena)
        has_block = def_contains_yield?(node, def_arena)
      end

      return_type = TypeRef::VOID
      if extra_type_params.empty?
        return_type = if rt = node.return_type
                        rt_name = String.new(rt)
                        # "self" in return type means "the current class type"
                        if rt_name == "self"
                          class_info.type_ref
                        elsif module_like_type_name?(rt_name)
                          inferred = infer_concrete_return_type_from_body(node, class_name)
                          inferred || type_ref_for_name(rt_name)
                        else
                          type_ref_for_name(rt_name)
                        end
                      elsif method_name.ends_with?('?')
                        inferred = infer_unannotated_query_return_type(method_name, class_info.type_ref)
                        inferred ||= infer_concrete_return_type_from_body(node, class_name)
                        inferred || fallback_query_return_type(method_name)
                      else
                        # Try to infer return type from getter-style methods (single ivar access)
                        inferred = infer_getter_return_type(node, class_info.ivars)
                        inferred || TypeRef::VOID
                      end
        # Avoid AST-walk return type inference during lowering. We'll infer/refresh the return
        # type after lowering from the lowered body (terminators/last expression), which is
        # significantly cheaper during self-host.
      else
        with_type_param_map(extra_type_params) do
          return_type = if rt = node.return_type
                          rt_name = String.new(rt)
                          # "self" in return type means "the current class type"
                          if rt_name == "self"
                            class_info.type_ref
                          elsif module_like_type_name?(rt_name)
                            type_ref_for_name(rt_name)
                          else
                            type_ref_for_name(rt_name)
                          end
                        elsif method_name.ends_with?('?')
                          inferred = infer_unannotated_query_return_type(method_name, class_info.type_ref)
                          inferred || fallback_query_return_type(method_name)
                        else
                          # Try to infer return type from getter-style methods (single ivar access)
                          inferred = infer_getter_return_type(node, class_info.ivars)
                          inferred || TypeRef::VOID
                        end
        end
      end

      # Mangle function name with parameter types for overloading
      full_name = full_name_override || function_full_name_for_def(base_name, param_types, node.params, has_block)

      # Retrieve stored type param map for lazy lowering of generic class methods.
      # When a monomorphized class's method is lowered, we need the type parameter
      # substitutions (e.g., T => UInt8) that were stored during method registration.
      if registered_params = function_type_param_map_for(full_name, base_name)
        extra_type_params.merge!(registered_params)
        if debug_env_filter_match?("DEBUG_LOWER_METHOD_TPM", full_name, base_name)
          STDERR.puts "[LOWER_METHOD_TPM] full=#{full_name} base=#{base_name} merged=#{registered_params}"
        end
      end

      register_pending_method_effects(full_name, param_types.size)
      register_function_type(full_name, return_type)

      if debug_env_filter_match?("DEBUG_FROM_CHARS", base_name, full_name)
        STDERR.puts "[LOWER_METHOD] base_name=#{base_name}, full_name=#{full_name}, param_types=#{param_types.map(&.to_s)}, override=#{full_name_override}"
        STDERR.flush
        STDERR.puts "[LOWER_METHOD] 1. Before create_function"
        STDERR.flush
      end
      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, base_name, full_name)
        STDERR.puts "[LOWER_METHOD] enter class=#{class_name} full=#{full_name}"
      end
      func = @module.create_function(full_name, return_type)
      if debug_env_filter_match?("DEBUG_FROM_CHARS", base_name, full_name)
        STDERR.puts "[LOWER_METHOD] 2. After create_function"
        STDERR.flush
      end
      ctx = LoweringContext.new(func, @module, @arena)

      # Add implicit 'self' binding.
      # Instance methods receive a runtime self parameter.
      # Class/module methods bind self to a type literal (no runtime param).
      if is_class_method
        self_type = class_info.type_ref
        self_literal = Literal.new(ctx.next_id, self_type, nil)
        ctx.emit(self_literal)
        ctx.register_local("self", self_literal.id)
        ctx.register_type(self_literal.id, self_type)
        ctx.mark_type_literal(self_literal.id)
        @type_literal_values.add(self_literal.id)
      else
        # For primitive types (Int32, Bool, etc.), use primitive TypeRef so LLVM passes by value
        # For structs with fields, use class_info.type_ref (passed as pointer)
        self_type = primitive_self_type(class_name) || class_info.type_ref
        self_param = func.add_param("self", self_type)
        ctx.register_local("self", self_param.id)
        ctx.register_type(self_param.id, self_type)
        # Track enum type for self parameter (enables predicate method inlining)
        track_enum_value(self_param.id, class_name)
      end

      # Lower explicit parameters
      # Track @param style for auto-assignment
      auto_assign_params = [] of Tuple(String, ValueId, Int32) # (ivar_name, param_value_id, offset)

      param_infos.each_with_index do |(param_name, param_type, is_instance_var), idx|
        # If a method parameter references a concrete generic instantiation (e.g., `Hash(String, ValueId)`),
        # ensure it is monomorphized before lowering the method body so calls on the value can resolve.
        ensure_monomorphized_type(param_type) unless param_type == TypeRef::VOID

        if debug_env_filter_match?("DEBUG_MATH_MIN", class_name, method_name)
          type_name = get_type_name_from_ref(param_type)
          STDERR.puts "[MATH_MIN] class=#{class_name} method=#{method_name} param=#{param_name} type=#{type_name} (ref=#{param_type.id})"
        end

        hir_param = func.add_param(param_name, param_type)
        if default_lit = param_default_literals[idx]?
          hir_param.default_literal = default_lit
        end
        ctx.register_local(param_name, hir_param.id)
        ctx.register_type(hir_param.id, param_type)
        if debug_env_filter_match?("DEBUG_PARAM_TYPES", full_name, param_name)
          type_name = get_type_name_from_ref(param_type)
          STDERR.puts "[PARAM_TYPES] func=#{full_name} param=#{param_name} id=#{hir_param.id} type=#{type_name}(id=#{param_type.id})"
        end
        if (param_literal_flags[idx]? || param_name.ends_with?("_class")) && param_type != TypeRef::VOID
          ctx.mark_type_literal(hir_param.id) unless module_type_ref?(param_type)
        end
        if type_name = param_type_names[idx]?
          track_enum_value(hir_param.id, type_name)
        end

        # Check for @param syntax (auto-assignment to ivar via is_instance_var flag)
        if is_instance_var
          ivar_name = "@#{param_name}" # Add @ prefix for ivar lookup
          ivar_offset = get_ivar_offset(ivar_name)
          auto_assign_params << {ivar_name, hir_param.id, ivar_offset}
        end
      end

      # Emit auto-assignments for @param style parameters
      auto_assign_params.each do |(ivar_name, param_id, offset)|
        self_id = emit_self(ctx)
        param_type = ctx.type_of(param_id)
        if enum_name = @enum_value_types.try(&.[param_id]?)
          enum_map = @enum_ivar_types ||= {} of String => Hash(String, String)
          class_map = enum_map[class_name]? || begin
            new_map = {} of String => String
            enum_map[class_name] = new_map
            new_map
          end
          class_map[ivar_name] = enum_name
        end
        field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, self_id, ivar_name, param_id, offset)
        ctx.emit(field_set)
      end

      # Lower body
      # IMPORTANT: Save and clear inline yield stacks to prevent cross-context contamination.
      # When lowering a standalone function, yield should emit a Yield instruction,
      # NOT substitute an inline block from an unrelated call context.
      saved_yield_block_stack = @inline_yield_block_stack
      saved_yield_arena_stack = @inline_yield_block_arena_stack
      saved_yield_param_stack = @inline_yield_block_param_types_stack
      saved_yield_return_stack = @inline_yield_block_return_stack
      saved_yield_name_stack = @inline_yield_name_stack
      saved_inline_arenas = @inline_arenas
      @inline_yield_block_stack = [] of CrystalV2::Compiler::Frontend::BlockNode
      @inline_yield_block_arena_stack = [] of CrystalV2::Compiler::Frontend::ArenaLike
      @inline_yield_block_param_types_stack = [] of Array(TypeRef)?
      @inline_yield_block_return_stack = [] of String?
      @inline_yield_name_stack = [] of String
      @inline_arenas = nil
      last_value : ValueId? = nil
      begin
        if body = node.body
          if debug_env_filter_match?("DEBUG_BODY_EXPRS", class_name, method_name, base_name)
            body_indices = body.map(&.index).join(",")
            STDERR.puts "[BODY_EXPRS] class=#{class_name} method=#{method_name} body_size=#{body.size} indices=[#{body_indices}] node.span=#{node.span.start_offset}..#{node.span.end_offset}"
          end
          body_proc = -> {
            progress_filter = env_get("DEBUG_LOWER_PROGRESS")
            progress_match = false
            if progress_filter
              progress_match = progress_filter == "1" || base_name.includes?(progress_filter)
            end
            progress_every = env_get("DEBUG_LOWER_PROGRESS_EVERY").try(&.to_i?)
            slow_only = env_has?("DEBUG_LOWER_SLOW_ONLY")
            slow_ms = nil
            if progress_match
              slow_ms = env_get("DEBUG_LOWER_SLOW_MS").try(&.to_f) || 50.0
            end
            if debug_env_filter_match?("DEBUG_LOWER_BYTE", method_name, base_name)
              STDERR.puts "[LOWER_METHOD] BODY size=#{body.size} expressions"
              body.each_with_index do |expr_id, i|
                begin
                  expr_node = @arena[expr_id]
                  STDERR.puts "[LOWER_METHOD]   [#{i}] expr=#{expr_id.index} type=#{expr_node.class.name.split("::").last}"
                rescue
                  STDERR.puts "[LOWER_METHOD]   [#{i}] expr=#{expr_id.index} (OOB)"
                end
              end
            end
            # Use the stored arena for this function to avoid cross-file contamination.
            # When lowering methods from monomorphized generic classes, @arena may be
            # from a different file than where the method is actually defined.
            # IMPORTANT: For super calls (when full_name_override is provided), don't use
            # base_name fallback because base_name is derived from node.name (e.g., "reverse!")
            # but we want the arena for the super method. The base_name might incorrectly
            # point to the child class's method arena instead of the parent's.
            method_arena = if full_name_override.nil?
                             @function_def_arenas[full_name]? || @function_def_arenas[base_name]? || @arena
                           else
                             @function_def_arenas[full_name]? || @arena
                           end
            if debug_env_filter_match?("DEBUG_METHOD_ARENA_USE", class_name, method_name, full_name)
              stored_full = @function_def_arenas[full_name]?
              stored_base = @function_def_arenas[base_name]?
              current_path = source_path_for(@arena) || "(unknown)"
              method_path = source_path_for(method_arena) || "(unknown)"
              STDERR.puts "[METHOD_ARENA_USE] full=#{full_name} stored_full=#{!stored_full.nil?} stored_base=#{!stored_base.nil?} current=#{current_path} method=#{method_path}:#{method_arena.size}"
            end
            body.each_with_index do |expr_id, idx|
              with_arena(method_arena) do
                expr_snippet = nil
                if progress_match && !slow_only
                  if progress_every && progress_every > 0
                    if idx % progress_every == 0
                      STDERR.puts "[LOWER_PROGRESS] method=#{base_name} idx=#{idx}/#{body.size}"
                    end
                  else
                    begin
                      expr_node = @arena[expr_id]
                      if source = @sources_by_arena[@arena]?
                        source_str = source.not_nil!
                        span = expr_node.span
                        start = span.start_offset
                        length = span.end_offset - span.start_offset
                        if length > 0 && start >= 0 && start < source_str.bytesize
                          slice_len = length > 120 ? 120 : length
                          expr_snippet = source_str.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
                        end
                      end
                      if expr_snippet
                        STDERR.puts "[LOWER_PROGRESS] method=#{base_name} idx=#{idx} node=#{expr_node.class.name} offs=#{expr_node.span.start_offset} \"#{expr_snippet}\""
                      else
                        STDERR.puts "[LOWER_PROGRESS] method=#{base_name} idx=#{idx} node=#{expr_node.class.name}"
                      end
                    rescue
                      STDERR.puts "[LOWER_PROGRESS] method=#{base_name} idx=#{idx} node=(OOB)"
                    end
                  end
                end
                expr_start = slow_ms ? Time.instant : nil
                if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, base_name, full_name)
                  STDERR.puts "[LOWER_METHOD] expr=#{expr_id.index} idx=#{idx} arena=#{@arena.size}"
                  begin
                    expr_node = @arena[expr_id]
                    if source = @sources_by_arena[@arena]?
                      source_str = source.not_nil!
                      span = expr_node.span
                      start = span.start_offset
                      length = span.end_offset - span.start_offset
                      if length > 0 && start >= 0 && start < source_str.bytesize
                        slice_len = length > 120 ? 120 : length
                        snippet = source_str.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
                        STDERR.puts "[LOWER_METHOD] node=#{expr_node.class} span=#{start}..#{span.end_offset} \"#{snippet}\""
                      else
                        STDERR.puts "[LOWER_METHOD] node=#{expr_node.class} span=#{start}..#{span.end_offset}"
                      end
                    else
                      STDERR.puts "[LOWER_METHOD] node=#{expr_node.class} span=#{expr_node.span.start_offset}..#{expr_node.span.end_offset}"
                    end
                  rescue ex
                    STDERR.puts "[LOWER_METHOD] inspect_failed expr=#{expr_id.index} error=#{ex.message}"
                  end
                end
                begin
                  last_value = lower_expr(ctx, expr_id)
                rescue ex : KeyError
                  STDERR.puts "[KEY_ERROR] method=#{base_name} idx=#{idx} expr=#{expr_id.index} error=#{ex.message}"
                  STDERR.puts ex.backtrace.first(20).join("\n")
                  raise ex
                end
                if slow_ms && expr_start
                  elapsed = (Time.instant - expr_start).total_milliseconds
                  if elapsed >= slow_ms
                    snippet_label = expr_snippet ? " \"#{expr_snippet}\"" : ""
                    STDERR.puts "[LOWER_SLOW] method=#{base_name} idx=#{idx} #{elapsed.round(1)}ms#{snippet_label}"
                  end
                end
              end

              break if should_stop_sequential_lowering?(ctx)
            end
          }
          if extra_type_params.empty?
            body_proc.call
          else
            with_type_param_map(extra_type_params) { body_proc.call }
          end
        end
      ensure
        @inline_yield_block_stack = saved_yield_block_stack
        @inline_yield_block_arena_stack = saved_yield_arena_stack
        @inline_yield_block_param_types_stack = saved_yield_param_stack
        @inline_yield_block_return_stack = saved_yield_return_stack
        @inline_yield_name_stack = saved_yield_name_stack
        @inline_arenas = saved_inline_arenas
      end

      fixup_module_receiver_calls(ctx)

      # Infer return type from all Return terminators + last expression.
      # Functions with explicit `return` inside conditionals (e.g., check_downcase_ascii)
      # may return different types from different paths. We must merge all of them.
      if node.return_type.nil?
        inferred_types = [] of TypeRef

        # Collect types from all Return terminators
        func.blocks.each do |block|
          term = block.terminator
          next unless term.is_a?(Return)
          if value = term.value
            t = ctx.type_of(value)
            inferred_types << t unless t == TypeRef::VOID
          else
            inferred_types << TypeRef::NIL
          end
        end

        # Also consider the last expression
        if (last_id = last_value)
          t = ctx.type_of(last_id)
          inferred_types << t unless t == TypeRef::VOID
        end

        if inferred_types.any?
          inferred_type = merge_return_types(inferred_types)
          if inferred_type && inferred_type != TypeRef::VOID && inferred_type != return_type
            return_type = inferred_type
            func.return_type = inferred_type
          end
        end
      end

      # Ensure the return type map matches the lowered function.
      register_function_type(full_name, return_type)

      # Add implicit return if not already terminated
      # BUT don't add return after raise (which sets Unreachable terminator)
      block = ctx.get_block(ctx.current_block)
      block_has_raise = block.instructions.any? { |inst| inst.is_a?(Raise) }
      if block.terminator.is_a?(Unreachable) && !block_has_raise
        block.terminator = Return.new(last_value)
      end

      @current_typeof_locals = old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names

      @enum_value_types = old_enum_value_types

      # Restore previous method context
      @current_class = old_class
      @current_method = old_method
      @current_method_is_class = old_method_is_class || false
    end

    # Get primitive TypeRef for self if class_name is a primitive type
    # Returns nil if class_name is not a primitive (use class_info.type_ref instead)
    private def primitive_self_type(class_name : String) : TypeRef?
      case class_name
      when "Bool"    then TypeRef::BOOL
      when "Int8"    then TypeRef::INT8
      when "Int16"   then TypeRef::INT16
      when "Int32"   then TypeRef::INT32
      when "Int64"   then TypeRef::INT64
      when "Int128"  then TypeRef::INT128
      when "UInt8"   then TypeRef::UINT8
      when "UInt16"  then TypeRef::UINT16
      when "UInt32"  then TypeRef::UINT32
      when "UInt64"  then TypeRef::UINT64
      when "UInt128" then TypeRef::UINT128
      when "Float32" then TypeRef::FLOAT32
      when "Float64" then TypeRef::FLOAT64
      when "Char"    then TypeRef::CHAR
      else                nil
      end
    end

    private def builtin_alias_target?(name : String) : Bool
      return true if primitive_self_type(name)

      case name
      when "Nil", "Void", "NoReturn", "String", "Symbol", "Pointer", "Slice", "Array",
           "Hash", "Tuple", "NamedTuple", "Proc", "Range", "Regex", "IO", "Bytes",
           "Object", "Reference", "Class", "Struct", "Enum", "Module", "StaticArray", "Path"
        true
      else
        false
      end
    end

    private def primitive_class_name(type_ref : TypeRef) : String?
      case type_ref
      when TypeRef::NIL     then "Nil"
      when TypeRef::BOOL    then "Bool"
      when TypeRef::INT8    then "Int8"
      when TypeRef::INT16   then "Int16"
      when TypeRef::INT32   then "Int32"
      when TypeRef::INT64   then "Int64"
      when TypeRef::INT128  then "Int128"
      when TypeRef::UINT8   then "UInt8"
      when TypeRef::UINT16  then "UInt16"
      when TypeRef::UINT32  then "UInt32"
      when TypeRef::UINT64  then "UInt64"
      when TypeRef::UINT128 then "UInt128"
      when TypeRef::FLOAT32 then "Float32"
      when TypeRef::FLOAT64 then "Float64"
      when TypeRef::CHAR    then "Char"
      when TypeRef::STRING  then "String"
      when TypeRef::SYMBOL  then "Symbol"
      when TypeRef::POINTER then "Pointer(UInt8)"
      else                       nil
      end
    end

    private def numeric_primitive_class_name?(name : String) : Bool
      case name
      when "Int8", "Int16", "Int32", "Int64", "Int128",
           "UInt8", "UInt16", "UInt32", "UInt64", "UInt128",
           "Float32", "Float64", "Char"
        true
      else
        false
      end
    end

    private def primitive_template_owner(class_name : String) : String?
      case class_name
      when "Int8", "Int16", "Int32", "Int64", "Int128",
           "UInt8", "UInt16", "UInt32", "UInt64", "UInt128"
        "Int"
      when "Float32", "Float64"
        "Float"
      else
        nil
      end
    end

    private def primitive_template_type_map(template_owner : String, primitive_owner : String) : Hash(String, String)
      case template_owner
      when "Int"
        {"Int" => primitive_owner}
      when "Float"
        {"Float" => primitive_owner}
      else
        {} of String => String
      end
    end

    private def builtin_parent_for(class_name : String, is_struct : Bool) : String?
      base = strip_generic_args(class_name)
      case base
      when "Int8", "Int16", "Int32", "Int64", "Int128",
           "UInt8", "UInt16", "UInt32", "UInt64", "UInt128"
        "Int"
      when "Float32", "Float64"
        "Float"
      when "Int"
        "Number"
      when "Float"
        "Number"
      when "Number"
        "Value"
      when "Bool", "Char", "Symbol", "Pointer", "Tuple", "NamedTuple", "StaticArray"
        "Value"
      when "Nil", "Enum", "Struct"
        "Value"
      when "String"
        "Reference"
      when "Reference"
        "Object"
      when "Value"
        "Object"
      when "Object"
        nil
      else
        is_struct ? "Value" : "Reference"
      end
    end

    # Get type name for mangling (converts TypeRef to short string)
    private def type_name_for_mangling(type : TypeRef) : String
      case type
      when TypeRef::VOID    then "Void"
      when TypeRef::NIL     then "Nil"
      when TypeRef::BOOL    then "Bool"
      when TypeRef::INT8    then "Int8"
      when TypeRef::INT16   then "Int16"
      when TypeRef::INT32   then "Int32"
      when TypeRef::INT64   then "Int64"
      when TypeRef::INT128  then "Int128"
      when TypeRef::UINT8   then "UInt8"
      when TypeRef::UINT16  then "UInt16"
      when TypeRef::UINT32  then "UInt32"
      when TypeRef::UINT64  then "UInt64"
      when TypeRef::UINT128 then "UInt128"
      when TypeRef::FLOAT32 then "Float32"
      when TypeRef::FLOAT64 then "Float64"
      when TypeRef::CHAR    then "Char"
      when TypeRef::STRING  then "String"
      when TypeRef::SYMBOL  then "Symbol"
      when TypeRef::POINTER then "Pointer"
      else
        # User-defined type - look up name from module's type descriptors
        if desc = @module.get_type_descriptor(type)
          result = resolve_type_alias_chain(desc.name)
          if env_has?("DEBUG_RANGE_MANGLE") && result.includes?("Range")
            STDERR.puts "[RANGE_MANGLE] type.id=#{type.id} desc.name=#{result}"
          end
          result
        else
          "T#{type.id}" # Fallback to type ID
        end
      end
    end

    private def tuple_type_from_arg_types(
      arg_types : Array(TypeRef),
      allow_void : Bool = false,
    ) : TypeRef
      return TypeRef::VOID if arg_types.empty?
      return TypeRef::VOID if !allow_void && arg_types.any? { |t| t == TypeRef::VOID }

      parts = arg_types.map { |t| type_name_for_mangling(t) }
      type_ref_for_name("Tuple(#{parts.join(", ")})")
    end

    private def tuple_element_type(receiver_type : TypeRef, index : Int32?) : TypeRef?
      desc = @module.get_type_descriptor(receiver_type)
      return nil unless desc
      return nil unless desc.kind == TypeKind::Tuple || desc.name.starts_with?("Tuple(")

      types = desc.type_params.reject { |t| t == TypeRef::VOID }
      return nil if types.empty?

      if index
        idx = index
        idx += types.size if idx < 0
        return nil if idx < 0 || idx >= types.size
        elem = types[idx]
        if env_get("DBG_TUPLE_ELEM")
          STDERR.puts "[TUPLE_ELEM] idx=#{idx} elem_id=#{elem.id} name=#{get_type_name_from_ref(elem)} desc=#{desc.name}"
        end
        # Resolve type aliases for non-primitive tuple elements.
        # e.g., IO::FileDescriptor::Handle is an alias for Int32 but may be
        # interned before the alias is registered, leaving a non-primitive TypeRef.
        if elem.id >= TypeRef::FIRST_USER_TYPE
          elem_name = get_type_name_from_ref(elem)
          resolved_name = resolve_type_alias_chain(elem_name)
          if resolved_name != elem_name
            if prim = builtin_type_ref_for(resolved_name)
              elem = prim
            end
          else
            # Cross-namespace: IO::FileDescriptor::Handle → look up through included modules
            # to find Crystal::System::FileDescriptor::Handle → Int32
            if (sep = elem_name.rindex("::"))
              namespace = elem_name[0...sep]
              short = elem_name[(sep + 2)..]
              if modules = @class_included_modules[namespace]?
                modules.each do |mod_name|
                  full_alias = "#{mod_name}::#{short}"
                  alias_target = resolve_type_alias_chain(full_alias)
                  if alias_target != full_alias
                    if prim = builtin_type_ref_for(alias_target)
                      elem = prim
                      break
                    end
                  end
                end
              end
            end
          end
        end
        return elem
      end

      merged = types.first
      types[1..].each do |t|
        merged = union_type_for_values(merged, t)
      end
      merged
    end

    private def tuple_return_type_for_method(receiver_type : TypeRef, method_name : String) : TypeRef?
      if env_get("DEBUG_TUPLE_RETURN") && (method_name == "first" || method_name == "last" || method_name == "first?" || method_name == "last?")
        desc = @module.get_type_descriptor(receiver_type)
        STDERR.puts "[TUPLE_RETURN] method=#{method_name} recv=#{desc.try(&.name) || receiver_type.id}"
      end
      case method_name
      when "first"
        tuple_element_type(receiver_type, 0)
      when "last"
        tuple_element_type(receiver_type, -1)
      when "first?"
        if elem = tuple_element_type(receiver_type, 0)
          create_union_type_for_nullable(elem)
        else
          nil
        end
      when "last?"
        if elem = tuple_element_type(receiver_type, -1)
          create_union_type_for_nullable(elem)
        else
          nil
        end
      when "reverse"
        desc = @module.get_type_descriptor(receiver_type)
        return nil unless desc
        return nil unless desc.kind == TypeKind::Tuple || desc.name.starts_with?("Tuple(")
        types = desc.type_params.reject { |t| t == TypeRef::VOID }
        return nil if types.empty?
        names = types.reverse.map { |t| get_type_name_from_ref(t) }
        type_ref_for_name("Tuple(#{names.join(", ")})")
      else
        nil
      end
    end

    private def tuple_map_return_type(
      receiver_type : TypeRef,
      element_type_name : String,
    ) : TypeRef?
      return nil if element_type_name.empty?
      desc = @module.get_type_descriptor(receiver_type)
      return nil unless desc

      variants = [] of String
      if desc.kind == TypeKind::Union
        split_union_type_name(desc.name).each do |variant|
          info = split_generic_base_and_args(variant)
          next unless info && info[:base] == "Tuple"
          args = split_generic_type_args(info[:args])
          next if args.empty?
          mapped = Array.new(args.size, element_type_name).join(", ")
          variants << "Tuple(#{mapped})"
        end
      elsif desc.kind == TypeKind::Tuple || desc.name.starts_with?("Tuple(")
        args = desc.type_params.reject { |t| t == TypeRef::VOID }
        return nil if args.empty?
        mapped = Array.new(args.size, element_type_name).join(", ")
        variants << "Tuple(#{mapped})"
      end

      return nil if variants.empty?
      type_ref_for_name(variants.uniq.join(" | "))
    end

    private def tuple_size_from_type_name(type_name : String) : Int32?
      return nil unless type_name.starts_with?("Tuple(") && type_name.ends_with?(')')

      inner = type_name[6...-1]
      tuple_size = 0
      depth = 0
      unless inner.empty?
        tuple_size = 1
        inner.each_char do |c|
          case c
          when '(' then depth += 1
          when ')' then depth -= 1
          when ',' then tuple_size += 1 if depth == 0
          end
        end
      end
      tuple_size
    end

    private def refine_param_type_from_call(param_type : TypeRef, call_type : TypeRef) : TypeRef
      return param_type if call_type == TypeRef::VOID
      return param_type if param_type == call_type

      param_desc = @module.get_type_descriptor(param_type)
      call_desc = @module.get_type_descriptor(call_type)
      return param_type unless param_desc && call_desc

      if param_desc.kind == TypeKind::Module && call_desc.kind == TypeKind::Module
        param_name = resolve_type_alias_chain(param_desc.name)
        call_name = resolve_type_alias_chain(call_desc.name)
        return call_type if param_name == call_name
        includers = @module_includers[param_name]?
        if includers.nil? || includers.empty?
          short_name = last_namespace_component(param_name)
          includers = @module_includers[short_name]?
        end
        if includers
          return call_type if includers.includes?(call_name) ||
                              includers.any? { |inc| inc.ends_with?("::#{call_name}") }
        end
      end

      param_name = param_desc.name
      return param_type if param_name.includes?('(')

      call_base = strip_generic_args(call_desc.name)
      return call_type if call_base == param_name && call_desc.name.includes?('(')

      param_type
    end

    # Refine VOID arg types by tracing back to source Call instructions.
    # When an arg has VOID type but came from a Call, try to get the return type
    # of the called function (which may not have been lowered yet).
    private def refine_void_args_from_source_calls(
      ctx : LoweringContext,
      args : Array(ValueId),
      arg_types : Array(TypeRef),
    ) : Array(TypeRef)
      return arg_types unless arg_types.any? { |t| t == TypeRef::VOID }

      refined = arg_types.dup
      debug = env_get("DEBUG_VOID_REFINE")
      args.each_with_index do |arg_id, idx|
        next unless arg_types[idx] == TypeRef::VOID

        # Try to find the source value for this argument
        # Check if it came from a Copy instruction (common for local variables)
        value = ctx.value_for(arg_id)
        if debug
          STDERR.puts "[VOID_REFINE] arg_id=#{arg_id} value_type=#{value.try(&.class.name) || "nil"}"
        end
        source_value = value
        while source_value.is_a?(Copy)
          source_value = ctx.value_for(source_value.source)
          break unless source_value
        end
        if debug
          STDERR.puts "[VOID_REFINE] source_value_type=#{source_value.try(&.class.name) || "nil"}"
        end

        if source_value.is_a?(Call)
          # Get the method name and try to infer return type
          method_name = source_value.method_name
          inferred_type = get_function_return_type(method_name)
          if debug
            STDERR.puts "[VOID_REFINE] source_call=#{method_name} inferred_type=#{get_type_name_from_ref(inferred_type)}"
          end
          if inferred_type != TypeRef::VOID
            refined[idx] = inferred_type
          end
        end
      end

      refined
    end

    # Refine VOID arg types by looking at overload parameter annotations.
    # When an arg has VOID type but the target method has overloads with type
    # restrictions for that parameter, infer the type from those restrictions.
    private def refine_void_args_from_overloads(base_method_name : String, arg_types : Array(TypeRef)) : Array(TypeRef)
      return arg_types unless arg_types.any? { |t| t == TypeRef::VOID }

      candidates = [] of CrystalV2::Compiler::Frontend::DefNode

      function_def_overloads(base_method_name).each do |key|
        if def_node = @function_defs[key]?
          candidates << def_node
        end
      end

      return arg_types if candidates.empty?

      known_types = arg_types.reject { |t| t == TypeRef::VOID }
      common_numeric = common_numeric_type(known_types)

      # For each VOID position, try to find a consistent type from overloads
      refined = arg_types.dup
      void_positions = arg_types.each_index.select { |i| arg_types[i] == TypeRef::VOID }.to_a

      void_positions.each do |pos|
        inferred_types = Set(TypeRef).new
        untyped_position = false

        candidates.each do |func_def|
          next unless params = func_def.params

          # Map position to param (accounting for block params)
          param_index = 0
          params.each do |param|
            next if named_only_separator?(param)
            next if param.is_block

            if param_index == pos
              if ta = param.type_annotation
                type_str = String.new(ta)
                # Skip generic type parameters like T, E, B
                if type_str.size == 1 && type_str[0].uppercase?
                  untyped_position = true
                else
                  inferred_type = type_ref_for_name(type_str)
                  if inferred_type == TypeRef::VOID
                    untyped_position = true
                  else
                    inferred_types << inferred_type
                  end
                end
              else
                untyped_position = true
              end
              break
            end

            param_index += 1 unless param.is_splat || param.is_double_splat
          end
        end

        if untyped_position
          refined[pos] = common_numeric if common_numeric
          next
        end

        # If all overloads agree on a single type, use it
        if inferred_types.size == 1
          refined[pos] = inferred_types.first
        elsif inferred_types.size > 1
          # Multiple types - prefer Float64 over Float32 (common pattern)
          if inferred_types.includes?(TypeRef::FLOAT64)
            refined[pos] = TypeRef::FLOAT64
          elsif inferred_types.includes?(TypeRef::FLOAT32)
            refined[pos] = TypeRef::FLOAT32
          end
        end
      end

      refined
    end

    # Map operator method name to BinaryOp for primitive inlining
    # Returns nil if the method is not a binary operator
    private def binary_op_for_method(method_name : String) : BinaryOp?
      case method_name
      when "+"  then BinaryOp::Add
      when "-"  then BinaryOp::Sub
      when "*"  then BinaryOp::Mul
      when "/"  then BinaryOp::Div
      when "%"  then BinaryOp::Mod
      when "&"  then BinaryOp::BitAnd
      when "|"  then BinaryOp::BitOr
      when "^"  then BinaryOp::BitXor
      when "<<" then BinaryOp::Shl
      when ">>" then BinaryOp::Shr
      when "==", "===" then BinaryOp::Eq
      when "!=" then BinaryOp::Ne
      when "<"  then BinaryOp::Lt
      when "<=" then BinaryOp::Le
      when ">"  then BinaryOp::Gt
      when ">=" then BinaryOp::Ge
      when "&&" then BinaryOp::And
      when "||" then BinaryOp::Or
        # Wrapping operators - map to same ops (LLVM integer ops already wrap)
      when "&+" then BinaryOp::Add
      when "&-" then BinaryOp::Sub
      when "&*" then BinaryOp::Mul
      else           nil
      end
    end

    # Check if a TypeRef is a numeric primitive type (supports binary ops)
    # ── Primitive call dispatch ──────────────────────────────────────────
    # Handles @[Primitive(:kind)] methods by emitting intrinsic HIR nodes
    # instead of a regular Call.  Returns nil if the primitive is unhandled
    # and the caller should fall through to a normal call.

    private def lower_primitive_call(
      ctx : LoweringContext,
      kind : String,
      method_name : String,
      receiver_id : ValueId?,
      args : Array(ValueId),
      return_type : TypeRef,
      mangled_name : String,
    ) : ValueId?
      case kind
      when "binary"
        lower_primitive_binary(ctx, method_name, receiver_id, args, return_type)
      when "convert", "unchecked_convert"
        lower_primitive_convert(ctx, method_name, receiver_id, args, return_type, mangled_name)
      when "pointer_get"
        lower_primitive_pointer_get(ctx, receiver_id, return_type, mangled_name)
      when "pointer_set"
        lower_primitive_pointer_set(ctx, receiver_id, args, mangled_name)
      when "pointer_add"
        lower_primitive_pointer_add(ctx, method_name, receiver_id, args, mangled_name)
      when "pointer_address"
        lower_primitive_pointer_address(ctx, receiver_id)
      when "pointer_new"
        lower_primitive_pointer_new_intrinsic(ctx, args, return_type, mangled_name)
      when "pointer_malloc"
        lower_primitive_pointer_malloc(ctx, args, return_type, mangled_name)
      when "pointer_realloc"
        lower_primitive_pointer_realloc(ctx, receiver_id, args)
      when "pointer_diff"
        lower_primitive_pointer_diff(ctx, receiver_id, args, mangled_name)
      when "object_crystal_type_id"
        lower_primitive_crystal_type_id(ctx, receiver_id)
      when "object_id"
        lower_primitive_object_id(ctx, receiver_id)
      when "allocate"
        nil # Handled by existing allocator path
      when "enum_value", "enum_new"
        receiver_id || args.first? # Pass-through (identity)
      when "symbol_to_s"
        nil # TODO: symbol table lookup
      when "class"
        nil # Complex — defer to normal dispatch
      when "load_atomic"
        nil # Already handled via Atomic method dispatch in MIR
      when "store_atomic"
        nil # Already handled via Atomic method dispatch in MIR
      when "tuple_indexer_known_index"
        nil # Already handled by existing tuple code
      when "proc_call"
        nil # Already handled separately
      else
        nil # Unknown primitive — fall through to normal call
      end
    end

    private def lower_primitive_binary(
      ctx : LoweringContext,
      method_name : String,
      receiver_id : ValueId?,
      args : Array(ValueId),
      return_type : TypeRef,
    ) : ValueId?
      return nil unless receiver_id && args.size == 1
      receiver_type = ctx.type_of(receiver_id)
      return nil unless numeric_primitive?(receiver_type)
      bin_op = binary_op_for_method(method_name)
      return nil unless bin_op
      result_type = case bin_op
                    when BinaryOp::Eq, BinaryOp::Ne, BinaryOp::Lt, BinaryOp::Le,
                         BinaryOp::Gt, BinaryOp::Ge, BinaryOp::And, BinaryOp::Or
                      TypeRef::BOOL
                    else
                      receiver_type
                    end
      bin_node = BinaryOperation.new(ctx.next_id, result_type, bin_op, receiver_id, args[0])
      ctx.emit(bin_node)
      ctx.register_type(bin_node.id, result_type)
      bin_node.id
    end

    private def lower_primitive_convert(
      ctx : LoweringContext,
      method_name : String,
      receiver_id : ValueId?,
      args : Array(ValueId),
      return_type : TypeRef,
      mangled_name : String,
    ) : ValueId?
      # Convert primitives: the receiver is cast to the return type.
      # The return type is determined by the enclosing class (e.g. Int32#to_u8! → UInt8).
      return nil unless receiver_id
      target = return_type
      if target == TypeRef::VOID
        # Try to infer from method name
        target = type_ref_for_conversion_method(method_name) || return nil
      end
      cast = Cast.new(ctx.next_id, target, receiver_id, target)
      ctx.emit(cast)
      ctx.register_type(cast.id, target)
      cast.id
    end

    private def type_ref_for_conversion_method(method_name : String) : TypeRef?
      case method_name
      when "to_i", "to_i32", "to_i32!" then TypeRef::INT32
      when "to_i8", "to_i8!"           then TypeRef::INT8
      when "to_i16", "to_i16!"         then TypeRef::INT16
      when "to_i64", "to_i64!"         then TypeRef::INT64
      when "to_i128"                    then TypeRef::INT128
      when "to_u", "to_u32", "to_u32!" then TypeRef::UINT32
      when "to_u8", "to_u8!"           then TypeRef::UINT8
      when "to_u16", "to_u16!"         then TypeRef::UINT16
      when "to_u64", "to_u64!"         then TypeRef::UINT64
      when "to_u128"                    then TypeRef::UINT128
      when "to_f", "to_f64", "to_f64!" then TypeRef::FLOAT64
      when "to_f32", "to_f32!"         then TypeRef::FLOAT32
      else                                   nil
      end
    end

    private def lower_primitive_pointer_get(
      ctx : LoweringContext,
      receiver_id : ValueId?,
      return_type : TypeRef,
      mangled_name : String,
    ) : ValueId?
      return nil unless receiver_id
      receiver_type = ctx.type_of(receiver_id)
      recv_desc = @module.get_type_descriptor(receiver_type)
      is_pointer = receiver_type == TypeRef::POINTER ||
                   (recv_desc && recv_desc.kind == TypeKind::Pointer)
      return nil unless is_pointer
      deref_type = if recv_desc && recv_desc.name.starts_with?("Pointer(") && recv_desc.name.ends_with?(')')
                     type_ref_for_name(recv_desc.name[8...-1])
                   else
                     TypeRef::UINT8
                   end
      load_node = PointerLoad.new(ctx.next_id, deref_type, receiver_id, nil)
      ctx.emit(load_node)
      ctx.register_type(load_node.id, deref_type)
      load_node.id
    end

    private def lower_primitive_pointer_set(
      ctx : LoweringContext,
      receiver_id : ValueId?,
      args : Array(ValueId),
      mangled_name : String,
    ) : ValueId?
      return nil unless receiver_id && args.size == 1
      store_node = PointerStore.new(ctx.next_id, TypeRef::VOID, receiver_id, args[0], nil)
      ctx.emit(store_node)
      store_node.id
    end

    private def lower_primitive_pointer_add(
      ctx : LoweringContext,
      method_name : String,
      receiver_id : ValueId?,
      args : Array(ValueId),
      mangled_name : String,
    ) : ValueId?
      return nil unless receiver_id && args.size == 1
      receiver_type = ctx.type_of(receiver_id)
      recv_desc = @module.get_type_descriptor(receiver_type)
      is_pointer = receiver_type == TypeRef::POINTER ||
                   (recv_desc && recv_desc.kind == TypeKind::Pointer)
      return nil unless is_pointer
      offset_id = args[0]
      if method_name == "-"
        neg_one = Literal.new(ctx.next_id, TypeRef::INT32, -1_i64)
        ctx.emit(neg_one)
        ctx.register_type(neg_one.id, TypeRef::INT32)
        neg_offset = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Mul, offset_id, neg_one.id)
        ctx.emit(neg_offset)
        ctx.register_type(neg_offset.id, TypeRef::INT32)
        offset_id = neg_offset.id
      end
      element_type = if recv_desc && recv_desc.name.starts_with?("Pointer(")
                       pointer_element_type(recv_desc.name)
                     else
                       TypeRef::INT32
                     end
      result_type = receiver_type == TypeRef::VOID ? TypeRef::POINTER : receiver_type
      add_node = PointerAdd.new(ctx.next_id, result_type, receiver_id, offset_id, element_type)
      ctx.emit(add_node)
      ctx.register_type(add_node.id, result_type)
      add_node.id
    end

    private def lower_primitive_pointer_address(
      ctx : LoweringContext,
      receiver_id : ValueId?,
    ) : ValueId?
      return nil unless receiver_id
      # Pointer#address returns UInt64 (ptrtoint)
      cast = Cast.new(ctx.next_id, TypeRef::UINT64, receiver_id, TypeRef::UINT64)
      ctx.emit(cast)
      ctx.register_type(cast.id, TypeRef::UINT64)
      cast.id
    end

    private def lower_primitive_pointer_new_intrinsic(
      ctx : LoweringContext,
      args : Array(ValueId),
      return_type : TypeRef,
      mangled_name : String,
    ) : ValueId?
      return nil unless args.size == 1
      # Pointer(T).new(address : UInt64) → inttoptr
      result_type = return_type == TypeRef::VOID ? TypeRef::POINTER : return_type
      cast = Cast.new(ctx.next_id, result_type, args[0], result_type)
      ctx.emit(cast)
      ctx.register_type(cast.id, result_type)
      cast.id
    end

    private def lower_primitive_pointer_malloc(
      ctx : LoweringContext,
      args : Array(ValueId),
      return_type : TypeRef,
      mangled_name : String,
    ) : ValueId?
      return nil unless args.size == 1
      # Extract element type from the mangled class name (e.g. "Pointer(UInt8).malloc")
      element_type = if mangled_name.includes?("Pointer(")
                       pointer_element_type(mangled_name)
                     else
                       TypeRef::UINT8
                     end
      result_type = return_type == TypeRef::VOID ? TypeRef::POINTER : return_type
      malloc_node = PointerMalloc.new(ctx.next_id, result_type, element_type, args[0])
      ctx.emit(malloc_node)
      ctx.register_type(malloc_node.id, result_type)
      malloc_node.id
    end

    private def lower_primitive_pointer_realloc(
      ctx : LoweringContext,
      receiver_id : ValueId?,
      args : Array(ValueId),
    ) : ValueId?
      return nil unless receiver_id && args.size == 1
      receiver_type = ctx.type_of(receiver_id)
      result_type = receiver_type == TypeRef::VOID ? TypeRef::POINTER : receiver_type
      realloc_node = PointerRealloc.new(ctx.next_id, result_type, receiver_id, args[0])
      ctx.emit(realloc_node)
      ctx.register_type(realloc_node.id, result_type)
      realloc_node.id
    end

    private def lower_primitive_pointer_diff(
      ctx : LoweringContext,
      receiver_id : ValueId?,
      args : Array(ValueId),
      mangled_name : String,
    ) : ValueId?
      return nil unless receiver_id && args.size == 1
      # Pointer#-(other : Pointer) → Int64 (element count difference)
      # First cast both pointers to Int64
      lhs = Cast.new(ctx.next_id, TypeRef::INT64, receiver_id, TypeRef::INT64)
      ctx.emit(lhs)
      ctx.register_type(lhs.id, TypeRef::INT64)
      rhs = Cast.new(ctx.next_id, TypeRef::INT64, args[0], TypeRef::INT64)
      ctx.emit(rhs)
      ctx.register_type(rhs.id, TypeRef::INT64)
      # Subtract
      diff = BinaryOperation.new(ctx.next_id, TypeRef::INT64, BinaryOp::Sub, lhs.id, rhs.id)
      ctx.emit(diff)
      ctx.register_type(diff.id, TypeRef::INT64)
      # Divide by element size — for now emit raw byte diff (MIR/LLVM can handle sizing)
      diff.id
    end

    private def lower_primitive_crystal_type_id(
      ctx : LoweringContext,
      receiver_id : ValueId?,
    ) : ValueId?
      return nil unless receiver_id
      # Read the type_id field at offset 0 (i32)
      type_id_field = FieldGet.new(ctx.next_id, TypeRef::INT32, receiver_id, "__type_id", 0)
      ctx.emit(type_id_field)
      ctx.register_type(type_id_field.id, TypeRef::INT32)
      type_id_field.id
    end

    private def lower_primitive_object_id(
      ctx : LoweringContext,
      receiver_id : ValueId?,
    ) : ValueId?
      return nil unless receiver_id
      # object_id returns the pointer address as UInt64
      cast = Cast.new(ctx.next_id, TypeRef::UINT64, receiver_id, TypeRef::UINT64)
      ctx.emit(cast)
      ctx.register_type(cast.id, TypeRef::UINT64)
      cast.id
    end

    # ── End primitive dispatch ────────────────────────────────────────────

    private def numeric_primitive?(type : TypeRef) : Bool
      case type
      when TypeRef::INT8, TypeRef::INT16, TypeRef::INT32, TypeRef::INT64, TypeRef::INT128,
           TypeRef::UINT8, TypeRef::UINT16, TypeRef::UINT32, TypeRef::UINT64, TypeRef::UINT128,
           TypeRef::FLOAT32, TypeRef::FLOAT64, TypeRef::CHAR
        true
      else
        if desc = @module.get_type_descriptor(type)
          return desc.name == "Int" || desc.name == "Float"
        end
        false
      end
    end

    private def common_numeric_type(types : Array(TypeRef)) : TypeRef?
      return nil if types.empty?
      return nil unless types.all? { |t| numeric_primitive?(t) }

      return TypeRef::FLOAT64 if types.any? { |t| t == TypeRef::FLOAT64 }
      return TypeRef::FLOAT32 if types.any? { |t| t == TypeRef::FLOAT32 }

      max_bits = types.map { |t| integer_bit_width(t) }.compact.max?
      return nil unless max_bits

      has_unsigned = types.any? do |t|
        t == TypeRef::UINT8 || t == TypeRef::UINT16 || t == TypeRef::UINT32 ||
          t == TypeRef::UINT64 || t == TypeRef::UINT128
      end
      has_signed = types.any? do |t|
        t == TypeRef::INT8 || t == TypeRef::INT16 || t == TypeRef::INT32 ||
          t == TypeRef::INT64 || t == TypeRef::INT128 || t == TypeRef::CHAR
      end

      has_unsigned && !has_signed ? unsigned_integer_type_for_width(max_bits) : signed_integer_type_for_width(max_bits)
    end

    private def unsigned_integer_type?(type : TypeRef) : Bool
      type == TypeRef::UINT8 || type == TypeRef::UINT16 || type == TypeRef::UINT32 ||
        type == TypeRef::UINT64 || type == TypeRef::UINT128
    end

    private def signed_integer_type?(type : TypeRef) : Bool
      type == TypeRef::INT8 || type == TypeRef::INT16 || type == TypeRef::INT32 ||
        type == TypeRef::INT64 || type == TypeRef::INT128 || type == TypeRef::CHAR
    end

    # Extract element type from Pointer(T) class name or method name
    # "Pointer(Int32)" or "Pointer(Int32).malloc" -> TypeRef::INT32
    private def pointer_element_type(class_name : String) : TypeRef
      # Extract type argument from "Pointer(T)" format (may have .method suffix)
      if match = class_name.match(/^Pointer\(([^)]+)\)/)
        type_arg = match[1]
        case type_arg
        when "Int8"    then TypeRef::INT8
        when "Int16"   then TypeRef::INT16
        when "Int32"   then TypeRef::INT32
        when "Int64"   then TypeRef::INT64
        when "Int128"  then TypeRef::INT128
        when "UInt8"   then TypeRef::UINT8
        when "UInt16"  then TypeRef::UINT16
        when "UInt32"  then TypeRef::UINT32
        when "UInt64"  then TypeRef::UINT64
        when "UInt128" then TypeRef::UINT128
        when "Float32" then TypeRef::FLOAT32
        when "Float64" then TypeRef::FLOAT64
        when "Bool"    then TypeRef::BOOL
        when "Char"    then TypeRef::CHAR
        when "Void"    then TypeRef::VOID
        when "Nil"     then TypeRef::NIL
        when "Pointer" then TypeRef::POINTER
        else
          # User-defined type - look it up in class_info
          if info = @class_info[type_arg]?
            info.type_ref
          else
            TypeRef::POINTER # Unknown type → pointer size (all non-primitives are heap-allocated)
          end
        end
      else
        TypeRef::POINTER # No Pointer(...) pattern → pointer size
      end
    end

    private def unwrap_pointer_union(
      ctx : LoweringContext,
      receiver_id : ValueId,
      receiver_type : TypeRef,
      value_type : TypeRef? = nil,
    ) : {ValueId, TypeRef}?
      desc = @module.get_type_descriptor(receiver_type)
      return nil unless desc && desc.kind == TypeKind::Union

      variants = split_union_type_name(desc.name)
      best_idx : Int32? = nil
      best_type : TypeRef? = nil
      fallback_idx : Int32? = nil
      fallback_type : TypeRef? = nil

      variants.each_with_index do |variant, idx|
        next unless variant.starts_with?("Pointer")
        variant_type = type_ref_for_name(variant)
        elem_type = pointer_element_type(variant)
        if value_type
          next if elem_type == TypeRef::VOID
          if elem_type == value_type
            best_idx = idx
            best_type = variant_type
            break
          end
        else
          if elem_type != TypeRef::VOID
            if best_idx.nil?
              best_idx = idx
              best_type = variant_type
            end
          elsif fallback_idx.nil?
            fallback_idx = idx
            fallback_type = variant_type
          end
        end
      end

      if best_idx.nil? && fallback_idx
        best_idx = fallback_idx
        best_type = fallback_type
      end

      return nil unless best_idx && best_type

      unwrap = UnionUnwrap.new(ctx.next_id, best_type, receiver_id, best_idx, false)
      ctx.emit(unwrap)
      ctx.register_type(unwrap.id, best_type)
      {unwrap.id, best_type}
    end

    # Mangle function name with parameter types for overloading.
    #
    # Examples:
    # - "IO.print" + [String] -> "IO.print$String"
    # - "Int32#+ " + [Int32] -> "Int32#+$Int32"
    # - "Int32#downto" + [] + has_block=true -> "Int32#downto$block"
    #
    # Note: Using $ instead of : because LLVM doesn't support : in identifiers.
    private def mangle_function_name(
      base_name : String,
      param_types : Array(TypeRef),
      has_block : Bool = false,
      has_named_only : Bool = false,
    ) : String
      if dollar = base_name.index('$')
        base_name = base_name[0, dollar]
      end
      # Filter out VOID types (untyped parameters don't provide overload info)
      typed_params = param_types.reject { |t| t == TypeRef::VOID }

      suffix = typed_params.map { |t| type_name_for_mangling(t) }.join("_")
      if has_block
        suffix = suffix.empty? ? "block" : "#{suffix}_block"
      end
      if has_named_only
        suffix = suffix.empty? ? "named" : "#{suffix}_named"
      end

      suffix.empty? ? base_name : "#{base_name}$#{suffix}"
    end

    private def function_full_name_for_def(
      base_name : String,
      param_types : Array(TypeRef),
      params : Array(CrystalV2::Compiler::Frontend::Parameter)?,
      has_block : Bool,
    ) : String
      if params
        params.each do |param|
          if param.is_block
            has_block = true
            break
          end
        end
      end
      has_named_only = false
      full_name = mangle_function_name(base_name, param_types, has_block, has_named_only)
      return full_name unless params

      param_count = 0
      has_splat = false
      has_double_splat = false
      has_untyped = param_types.any? { |t| t == TypeRef::VOID }
      params.each do |param|
        if named_only_separator?(param)
          has_named_only = true
          next
        end
        next if param.is_block || named_only_separator?(param)
        param_count += 1
        has_splat = true if param.is_splat
        has_double_splat = true if param.is_double_splat
      end

      full_name = mangle_function_name(base_name, param_types, has_block, has_named_only)
      if has_double_splat
        full_name = full_name.includes?('$') ? "#{full_name}_double_splat" : "#{base_name}$double_splat"
      elsif has_splat
        full_name = full_name.includes?('$') ? "#{full_name}_splat" : "#{base_name}$splat"
      end

      # Untyped params with explicit arity should not claim the bare base name.
      # This keeps zero-arg overloads on the base name and avoids deferring to
      # untyped multi-arg overloads.
      if has_untyped && param_count > 0 && full_name == base_name
        full_name = "#{base_name}$arity#{param_count}"
      end

      if @function_defs.has_key?(full_name) && (full_name == base_name || has_untyped)
        full_name = "#{base_name}$arity#{param_count}"
      end

      full_name
    end

    private def should_register_base_name?(
      full_name : String,
      base_name : String,
      member : CrystalV2::Compiler::Frontend::DefNode,
      has_block : Bool,
    ) : Bool
      return false if has_block
      return true if full_name == base_name
      return false if @function_defs.has_key?(base_name)
      def_params_untyped?(member)
    end

    private def prefer_non_yield_base_name(
      base_name : String,
      member : CrystalV2::Compiler::Frontend::DefNode,
      member_arena : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : Nil
      return unless existing = @function_defs[base_name]?
      existing_arena = @function_def_arenas[base_name]? || member_arena
      return unless def_contains_yield?(existing, existing_arena)
      return if def_contains_yield?(member, member_arena)
      @function_defs[base_name] = member
      @function_def_arenas[base_name] = member_arena
    end

    private def prefer_lower_arity_base_name(
      base_name : String,
      member : CrystalV2::Compiler::Frontend::DefNode,
      member_arena : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : Nil
      return unless existing = @function_defs[base_name]?
      existing_params = count_non_block_params(existing)
      member_params = count_non_block_params(member)
      return unless member_params < existing_params
      @function_defs[base_name] = member
      @function_def_arenas[base_name] = member_arena
    end

    private def count_non_block_params(def_node : CrystalV2::Compiler::Frontend::DefNode) : Int32
      params = def_node.params
      return 0 unless params
      params.count { |param| !param.is_block && !named_only_separator?(param) }
    end

    # Resolve type name for signature collection with minimal overhead.
    # Prefer skipping deep namespace walks when the name is clearly top-level/builtin.
    private def fast_resolve_type_name_for_signature(type_name : String) : String
      return type_name if type_name.empty?
      return type_name if type_name.includes?("::")
      return resolve_type_name_in_context(type_name) if type_name.includes?('(') ||
                                                        type_name.includes?('|') ||
                                                        type_name.ends_with?('?') ||
                                                        type_name.ends_with?('*') ||
                                                        (type_name.starts_with?('{') && type_name.ends_with?('}'))
      if type_param_like?(type_name) && short_type_param_name?(type_name) && !@type_param_map.has_key?(type_name)
        return type_name
      end
      if BUILTIN_TYPE_NAMES.includes?(type_name) ||
         @top_level_type_names.includes?(type_name) ||
         @top_level_class_kinds.has_key?(type_name)
        if current = @current_class
          current_base = if info = split_generic_base_and_args(current)
                           info[:base]
                         else
                           current
                         end
          if nested = @nested_type_names[current_base]? || @nested_type_names[current]?
            return resolve_type_name_in_context(type_name) if nested.includes?(type_name)
          end
        end
        return type_name
      end
      if candidates = @short_type_index[type_name]?
        return candidates.first if candidates.size == 1
      end
      resolve_type_name_in_context(type_name)
    end

    # Fast path for parameter type annotations during signature collection.
    # Avoids full namespace resolution when the type is already cached and
    # can't be shadowed by nested types in the current class.
    private def fast_param_type_ref(type_name : String) : TypeRef
      return TypeRef::VOID if type_name.empty?
      if builtin_ref = builtin_type_ref_for(type_name)
        return builtin_ref
      end
      if info = @class_info[type_name]?
        return info.type_ref
      end
      return type_ref_for_name(type_name) if type_name.includes?("::") ||
                                             type_name.includes?('(') ||
                                             type_name.includes?('|') ||
                                             type_name.ends_with?('?') ||
                                             type_name.ends_with?('*') ||
                                             (type_name.starts_with?('{') && type_name.ends_with?('}'))
      if type_param_like?(type_name) && short_type_param_name?(type_name) && !@type_param_map.has_key?(type_name)
        return TypeRef::VOID
      end
      if current = @current_class
        current_base = if info = split_generic_base_and_args(current)
                         info[:base]
                       else
                         current
                       end
        if nested = @nested_type_names[current_base]? || @nested_type_names[current]?
          return type_ref_for_name(type_name) if nested.includes?(type_name)
        end
      end
      cache_key = type_cache_key(type_name)
      if cached = @type_cache[cache_key]?
        return cached
      end
      type_ref_for_name(type_name)
    end

    private def split_union_type_name(type_name : String) : Array(String)
      if !type_name.includes?('|') && type_name.includes?("___")
        parts = [] of String
        start = 0
        i = 0
        size = type_name.bytesize
        while i + 2 < size
          if type_name.byte_at(i) == '_'.ord &&
             type_name.byte_at(i + 1) == '_'.ord &&
             type_name.byte_at(i + 2) == '_'.ord
            part = type_name[start, i - start].strip
            parts << part unless part.empty?
            i += 3
            start = i
            next
          end
          i += 1
        end
        tail = type_name[start, size - start].strip
        parts << tail unless tail.empty?
        return parts unless parts.empty?
      end
      parts = [] of String
      depth = 0
      start = 0
      i = 0
      while i < type_name.bytesize
        ch = type_name.byte_at(i).unsafe_chr
        case ch
        when '(', '{', '['
          depth += 1
        when ')', '}', ']'
          depth -= 1 if depth > 0
        when '|'
          if depth == 0
            part = type_name[start, i - start].strip
            parts << part unless part.empty?
            start = i + 1
          end
        end
        i += 1
      end
      tail = type_name[start, type_name.size - start].strip
      parts << tail unless tail.empty?
      parts
    end

    # Normalize union type names to "A | B" spacing (handles legacy "A___B" too).
    @[AlwaysInline]
    private def normalize_union_type_name(type_name : String) : String
      return type_name unless type_name.includes?('|') || type_name.includes?("___")
      parts = split_union_type_name(type_name)
      return type_name if parts.empty?
      dedup = [] of String
      parts.each do |part|
        trimmed = part.strip
        next if trimmed.empty?
        dedup << trimmed unless dedup.includes?(trimmed)
      end
      ordered = dedup.sort_by do |name|
        nil_flag = (name == "Nil" || name.ends_with?("::Nil")) ? 0 : 1
        {nil_flag, name}
      end
      ordered.join(" | ")
    end

    @[AlwaysInline]
    private def union_type_name?(type_name : String) : Bool
      return false unless type_name.includes?('|') || type_name.includes?("___")
      split_union_type_name(type_name).size > 1
    end

    # Prefer an inferred union when it is a non-empty, concrete union that
    # doesn't add variants compared to the current union.
    private def prefer_inferred_union_type?(current_name : String, inferred_name : String) : Bool
      return false if current_name == inferred_name
      inferred_variants = split_union_type_name(inferred_name)
      return false if inferred_variants.empty?
      return false if inferred_variants.any? { |v| v == "Void" || v == "Unknown" }
      current_variants = split_union_type_name(current_name)
      return false if current_variants.empty?
      # Prefer the inferred union when it is not broader than current.
      inferred_variants.size <= current_variants.size
    end

    private def resolve_union_method_call(type_name : String, method_name : String, arg_types : Array(TypeRef), has_block_call : Bool, call_has_named_args : Bool = false) : String?
      if env_get("DEBUG_ENUM_UNION_PREDICATE") && method_name.ends_with?('?')
        STDERR.puts "[RESOLVE_UNION] type_name=#{type_name} method=#{method_name} args=#{arg_types.size} block=#{has_block_call}"
      end
      variants = split_union_type_name(type_name)
      return nil if variants.empty?

      # Prefer non-nil variants when selecting a concrete method target.
      ordered = variants.sort_by { |v| v == "Nil" ? 1 : 0 }
      ordered.each do |variant|
        resolved_variant = resolve_type_alias_chain(variant)
        if type_param_like?(resolved_variant)
          mapped = @type_param_map[resolved_variant]?
          resolved_variant = "Pointer" if mapped.nil? || mapped == resolved_variant
        end
        candidates = resolved_variant == variant ? [variant] : [resolved_variant, variant]
        candidates.uniq.each do |candidate|
          base_name = resolve_method_with_inheritance(candidate, method_name) || "#{candidate}##{method_name}"
          mangled = mangle_function_name(base_name, arg_types, has_block_call)
          if @function_types.has_key?(mangled)
            # Verify the function's arity matches before returning.
            # This prevents returning a function like UInt32#hash(hasher) for a 0-arg call to hash().
            arity_ok = false # Default to false if no def found
            if def_node = @function_defs[mangled]?
              stats = function_param_stats(mangled, def_node)
              arity_ok = arg_types.size >= stats.required && (stats.has_splat || arg_types.size <= stats.param_count)
            else
              # No def node - check if it's a base name with typed overloads
              # If we have typed args, it should be safe to return
              # If args are empty, check untyped overload instead
              if !arg_types.empty?
                arity_ok = true
              end
            end
            if arity_ok
              return mangled
            end
            # Arity mismatch - continue to check untyped overloads
          end
          if resolved = resolve_untyped_overload(base_name, arg_types.size, has_block_call, call_has_named_args)
            return resolved
          end
          base_owner = strip_generic_args(candidate)
          if base_owner != candidate
            base_fallback = "#{base_owner}##{method_name}"
            if resolved = resolve_untyped_overload(base_fallback, arg_types.size, has_block_call, call_has_named_args)
              return resolved
            end
            if inherited = resolve_method_with_inheritance(base_owner, method_name)
              if resolved = resolve_untyped_overload(inherited, arg_types.size, has_block_call, call_has_named_args)
                return resolved
              end
              if !function_def_overloads(inherited).empty?
                return inherited
              end
            end
            mangled_fallback = mangle_function_name(base_fallback, arg_types, has_block_call)
            if @function_types.has_key?(mangled_fallback)
              return mangled_fallback
            end
          end

          # Handle enum predicates on union types (e.g., Signal | Nil with .kill?)
          # Enum predicates are typically inlined, so they won't be in @function_types,
          # but we still need to return the properly-prefixed method name for the Call node.
          if method_name.ends_with?('?') && arg_types.empty? && !has_block_call
            if env_get("DEBUG_ENUM_UNION_PREDICATE")
              STDERR.puts "[ENUM_UNION_PRED] candidate=#{candidate} method=#{method_name}"
            end
            if enum_info = @enum_info
              if members = enum_info[candidate]?
                # Check if the predicate matches an enum member
                predicate_base = method_name[0...-1]
                target = underscore_lower(predicate_base)
                if env_get("DEBUG_ENUM_UNION_PREDICATE")
                  STDERR.puts "[ENUM_UNION_PRED] predicate_base=#{predicate_base} target=#{target} members=#{members.keys.first(5).join(",")}"
                end
                if members.keys.any? { |m| underscore_lower(m) == target }
                  # Return the enum-prefixed predicate method name
                  if env_get("DEBUG_ENUM_UNION_PREDICATE")
                    STDERR.puts "[ENUM_UNION_PRED] MATCHED! returning #{candidate}##{method_name}"
                  end
                  return "#{candidate}##{method_name}"
                end
              end
            end
          end
        end
      end

      # Fallback: check if Object has this method (inherited method)
      # This handles cases like hash() where variant types don't have a 0-arg version
      # but Object#hash$arity0 exists
      object_base = "Object##{method_name}"
      if has_function_base?(object_base)
        if resolved = resolve_untyped_overload(object_base, arg_types.size, has_block_call, call_has_named_args)
          return resolved
        end
      end

      # Fallback: numeric conversion on mixed unions (e.g., UInt32 | Hash).
      # Prefer the numeric variant when the method is a numeric conversion.
      if numeric_conversion_method_name?(method_name)
        ordered.each do |variant|
          resolved_variant = resolve_type_alias_chain(variant)
          next unless numeric_primitive_class_name?(resolved_variant)
          base_name = resolve_method_with_inheritance(resolved_variant, method_name) || "#{resolved_variant}##{method_name}"
          mangled = mangle_function_name(base_name, arg_types, has_block_call)
          if @function_types.has_key?(mangled) || @function_defs.has_key?(mangled) || @module.has_function?(mangled)
            return mangled
          end
          if has_function_base?(base_name)
            if resolved = resolve_untyped_overload(base_name, arg_types.size, has_block_call, call_has_named_args)
              return resolved
            end
          end
        end
      end

      nil
    end

    private def numeric_conversion_method_name?(method_name : String) : Bool
      name = method_name.rstrip('!')
      return true if name == "to_i" || name == "to_u" || name == "to_f"
      if name.starts_with?("to_i") || name.starts_with?("to_u") || name.starts_with?("to_f")
        suffix = name.starts_with?("to_f") ? name[4..] : name[4..]
        return suffix.empty? || suffix.each_char.all?(&.ascii_number?)
      end
      false
    end

    # Resolve method call for a receiver type and method name
    # Returns the properly mangled method name that should be used in the Call node
    private def normalize_method_owner_name(name : String) : String
      return name if name.empty?
      if mapped = @type_param_map[name]?
        return mapped
      end
      resolved_alias = resolve_type_alias_chain(name)
      return resolved_alias if resolved_alias != name
      if (idx = name.index("::"))
        prefix = name[0, idx]
        if mapped = @type_param_map[prefix]?
          suffix = name[(idx + 2)..]
          return "#{mapped}::#{suffix}"
        end
      end
      return "Tuple" if name.starts_with?("Tuple(")
      return "NamedTuple" if name.starts_with?("NamedTuple(")
      name
    end

    private def unresolved_generic_return_type?(type_ref : TypeRef) : Bool
      return false if type_ref == TypeRef::VOID || type_ref == TypeRef::NIL
      if desc = @module.get_type_descriptor(type_ref)
        name = desc.name
        if filter = env_get("DEBUG_UNRESOLVED_GENERIC")
          if name.includes?(filter)
            STDERR.puts "[UNRESOLVED_GENERIC] name=#{name} kind=#{desc.kind} params=#{desc.type_params.size} generic=#{@generic_templates.has_key?(name)}"
          end
        end
        return false if name.empty?
        if info = split_generic_base_and_args(name)
          args = split_generic_type_args(info[:args]).map(&.strip)
          return args.any? { |arg| unresolved_generic_type_arg?(arg) }
        end
        return @generic_templates.has_key?(name)
      end
      false
    end

    private def unresolved_generic_type_arg?(arg : String) : Bool
      arg = normalize_tuple_literal_type_name(arg.strip)
      return true if arg.empty?
      if @unresolved_generic_arg_stack.includes?(arg)
        return true
      end
      @unresolved_generic_arg_stack << arg
      @unresolved_generic_arg_depth += 1
      begin
        return true if @unresolved_generic_arg_depth > 64
        if arg.includes?('|')
          parts = split_union_type_name(arg)
          if parts.size > 1
            return parts.any? { |part| unresolved_generic_type_arg?(part.strip) }
          end
        end
        if arg.ends_with?('?')
          return unresolved_generic_type_arg?(arg[0...-1])
        end
        if info = split_generic_base_and_args(arg)
          base = resolve_type_alias_chain(info[:base])
          base_known = known_type_name?(base) || @generic_templates.has_key?(base)
          return true unless base_known
          inner_args = split_generic_type_args(info[:args]).map(&.strip)
          return inner_args.any? { |inner| unresolved_generic_type_arg?(inner) }
        end
        if type_param_like?(arg)
          return !@type_param_map.has_key?(arg)
        end
        first = arg[0]?
        if first && first.ascii_lowercase?
          return !known_type_name?(arg)
        end
        false
      ensure
        @unresolved_generic_arg_depth -= 1
        @unresolved_generic_arg_stack.delete(arg)
      end
    end

    private def method_resolution_cache_key(
      receiver_type : TypeRef,
      method_name : String,
      arg_types : Array(TypeRef),
      type_literal : Bool,
      has_block_call : Bool,
    ) : String
      String.build do |io|
        io << receiver_type.id
        io << '|'
        io << method_name
        io << '|'
        arg_types.each_with_index do |t, idx|
          io << ',' if idx > 0
          io << t.id
        end
        io << '|'
        io << (type_literal ? 1 : 0)
        io << '|'
        io << (has_block_call ? 1 : 0)
      end
    end

    private def cache_method_resolution(cache_key : String?, resolved : String) : String
      if cache_key && !cache_key.empty?
        @method_resolution_cache[cache_key] = resolved
      end
      resolved
    end

    private def resolve_method_call(
      ctx : LoweringContext,
      receiver_id : ValueId,
      method_name : String,
      arg_types : Array(TypeRef),
      has_block_call : Bool,
      call_has_named_args : Bool = false,
      named_args_count : Int32 = 0,
    ) : String
      stats = env_get("DEBUG_LOWER_METHOD_STATS") ? @lower_method_stats_stack.last? : nil
      stats_start = stats ? Time.instant : nil
      receiver_type = ctx.type_of(receiver_id)
      type_desc = @module.get_type_descriptor(receiver_type)
      cache_key : String? = nil
      if @method_resolution_cache
        scope = "#{@current_class}|#{@current_method}|#{@current_method_is_class ? 1 : 0}|#{@type_param_map.hash}"
        if scope != @method_resolution_cache_scope
          @method_resolution_cache.clear
          @method_resolution_cache_scope = scope
        end
        cache_key = method_resolution_cache_key(receiver_type, method_name, arg_types, ctx.type_literal?(receiver_id), has_block_call)
        if cached = @method_resolution_cache[cache_key]?
          return cached
        end
      end

      # Get the class name from the type descriptor
      enum_type_name = @enum_value_types.try(&.[receiver_id]?)
      class_name = enum_type_name || type_desc.try(&.name) || primitive_class_name(receiver_type) || ""
      if !class_name.empty? && !@type_param_map.empty?
        substituted = substitute_type_params_in_type_name(class_name)
        if substituted != class_name
          debug_hook("method.resolve.substitute", "before=#{class_name} after=#{substituted} method=#{method_name}")
          class_name = substituted
        end
      end
      if !class_name.empty? && @type_param_map.empty? && type_param_like?(class_name)
        if inferred_map = fallback_type_param_map_for_current
          if mapped = inferred_map[class_name]?
            class_name = mapped
            mapped_ref = type_ref_for_name(mapped)
            if mapped_ref != TypeRef::VOID
              receiver_type = mapped_ref
              type_desc = @module.get_type_descriptor(mapped_ref)
            end
          end
        end
      end
      class_name = normalize_method_owner_name(class_name)
      if !class_name.empty? && class_name.includes?("::") && !@class_info.has_key?(class_name)
        if resolved = resolve_short_type_in_namespace_chain(class_name)
          class_name = resolved
          receiver_type = type_ref_for_name(class_name)
          type_desc = @module.get_type_descriptor(receiver_type)
        end
      end
      if type_desc && type_desc.kind == TypeKind::Module
        resolved = resolve_type_alias_chain(class_name)
        if resolved != class_name
          class_name = resolved
          if preferred_desc = @module.get_type_descriptor(type_ref_for_name(class_name))
            type_desc = preferred_desc
          end
        end
      end
      if env_get("DEBUG_TUPLE_CALLS") && class_name == "Tuple"
        params = type_desc.try(&.type_params)
        param_names = params ? params.map { |ref| get_type_name_from_ref(ref) }.join(",") : ""
        kind_name = type_desc ? type_desc.kind.to_s : "nil"
        current = "#{@current_class || ""}##{@current_method || ""}"
        STDERR.puts "[TUPLE_CALL] method=#{method_name} recv=#{type_desc.try(&.name) || "nil"} kind=#{kind_name} params=#{param_names} map=#{type_param_map_debug_string} current=#{current}"
      end
      if DebugHooks::ENABLED && unresolved_generic_receiver?(class_name)
        debug_hook("method.resolve.unresolved", "method=#{method_name} receiver=#{class_name} args=#{arg_types.map { |t| type_name_for_mangling(t) }.join(",")} current=#{@current_class || ""}")
      end

      # DEBUG: Track where short names come from in method resolution
      if env_has?("DEBUG_METHOD_RESOLVE") && !class_name.includes?("::") &&
         (method_name == "file_names" || method_name == "version" || method_name == "include_directories" ||
         class_name == "LoadCommand" || class_name == "Seek" || class_name == "Section")
        STDERR.puts "[METHOD_RESOLVE] method=#{method_name}, receiver_id=#{receiver_id}, receiver_type.id=#{receiver_type.id}, type_desc_name=#{type_desc.try(&.name) || "nil"}, class_name=#{class_name}"
      end

      # RESOLVE_CALL debug disabled

      # DEBUG: Trace empty class names for specific methods
      if env_has?("DEBUG_EMPTY_CLASS") && class_name.empty?
        func_name = ctx.function.name rescue "unknown"
        current = @current_class || "(nil)"
        recv_value = ctx.value_for(receiver_id)
        recv_info = recv_value ? "#{recv_value.class.name.split("::").last}(src=#{recv_value.is_a?(Copy) ? recv_value.source : "N/A"})" : "nil"
        STDERR.puts "[EMPTY_CLASS] method=#{method_name} receiver_id=#{receiver_id} receiver_type.id=#{receiver_type.id} type_desc=#{type_desc.try(&.name) || "nil"} enum_type=#{enum_type_name || "nil"} func=#{func_name} current_class=#{current} recv_value=#{recv_info}"
      end

      # Build the base method name as ClassName#method
      base_method_name = class_name.empty? ? method_name : "#{class_name}##{method_name}"
      # `arg_types` already reflects the lowered argument list (including named args
      # after reorder_named_args). Only fall back to named_args_count when no args
      # were lowered (defensive case).
      effective_arg_count = arg_types.size
      if call_has_named_args && effective_arg_count == 0 && named_args_count > 0
        effective_arg_count = named_args_count
      end
      if env_get("DEBUG_RESOLVE_INTERNAL") && method_name == "internal_representation"
        STDERR.puts "[RESOLVE_INTERNAL] class=#{class_name} base=#{base_method_name} recv_type=#{receiver_type.id}"
      end
      if arg_types.empty? && (method_name == "inspect" || method_name == "to_s")
        if has_function_base?(base_method_name)
          if resolved = resolve_untyped_overload(base_method_name, 0, has_block_call, call_has_named_args)
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=zero_arg_prefer_base")
            return cache_method_resolution(cache_key, resolved)
          end
        end
        if class_name != "Object"
          object_base = "Object##{method_name}"
          if resolved = resolve_untyped_overload(object_base, 0, has_block_call, call_has_named_args)
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=zero_arg_object")
            return cache_method_resolution(cache_key, resolved)
          end
        end
      end
      type_is_module = type_desc.try(&.kind) == TypeKind::Module
      if arg_types.all? { |t| t == TypeRef::VOID } && !type_is_module
        if has_function_base?(base_method_name)
          if resolved = resolve_untyped_overload(base_method_name, effective_arg_count, has_block_call, call_has_named_args)
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=all_void_untyped")
            return cache_method_resolution(cache_key, resolved)
          end
        end
      end

      # Mangle with argument types
      mangled_name = mangle_function_name(base_method_name, arg_types, has_block_call)
      if env_get("DEBUG_MATH_MIN") && (method_name == "min" || method_name == "max") && class_name.includes?("Math")
        arg_type_names = arg_types.map { |t| get_type_name_from_ref(t) }
        STDERR.puts "[MATH_MIN_RESOLVE] class=#{class_name} method=#{method_name} base=#{base_method_name} mangled=#{mangled_name} args=#{arg_type_names.join(",")}"
      end
      preferred_module_class = preferred_module_typed_class_for(class_name)
      module_like_receiver = !class_name.empty? && (type_is_module || module_like_type_name?(class_name) || module_includers_match?(class_name) || !preferred_module_class.nil?)

      # For module-typed receivers, prefer module-typed dispatch (unique includer or `extend self`)
      # before returning an exact match on the module's own instance method (e.g. `M#value`).
      if module_like_receiver
        if resolved = resolve_module_typed_method(method_name, arg_types, class_name, has_block_call, @current_class)
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=module_typed_prefer")
          return cache_method_resolution(cache_key, resolved)
        end
      end

      # Try to find the function in the module.
      #
      # IMPORTANT: Don't use return type as an existence check.
      # Many valid methods return `Nil` (VOID) in our IR, and treating VOID as "missing"
      # causes qualified calls to degrade into unqualified extern calls.
      if @function_types.has_key?(mangled_name) && !(module_like_receiver && abstract_def?(mangled_name))
        if def_node = @function_defs[mangled_name]?
          param_stats = function_param_stats(mangled_name, def_node)
          arity_ok = effective_arg_count >= param_stats.required &&
                     (param_stats.has_splat || param_stats.has_double_splat || effective_arg_count <= param_stats.param_count)
          if has_block_call != param_stats.has_block
            arity_ok = false
          end
          unless arity_ok
            debug_hook("method.resolve.arity_mismatch", "base=#{base_method_name} resolved=#{mangled_name} reason=arity_mismatch")
            # fall through to overload resolution
          else
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{mangled_name} reason=mangled_exact")
            return cache_method_resolution(cache_key, mangled_name)
          end
        else
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{mangled_name} reason=mangled_exact")
          return cache_method_resolution(cache_key, mangled_name)
        end
      end
      if (@function_defs.has_key?(mangled_name) && !(module_like_receiver && abstract_def?(mangled_name))) ||
         @module.has_function?(mangled_name)
        if def_node = @function_defs[mangled_name]?
          param_stats = function_param_stats(mangled_name, def_node)
          arity_ok = effective_arg_count >= param_stats.required &&
                     (param_stats.has_splat || param_stats.has_double_splat || effective_arg_count <= param_stats.param_count)
          if has_block_call != param_stats.has_block
            arity_ok = false
          end
          unless arity_ok
            debug_hook("method.resolve.arity_mismatch", "base=#{base_method_name} resolved=#{mangled_name} reason=arity_mismatch_def")
            # fall through to overload resolution
          else
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{mangled_name} reason=mangled_def")
            return cache_method_resolution(cache_key, mangled_name)
          end
        else
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{mangled_name} reason=mangled_def")
          return cache_method_resolution(cache_key, mangled_name)
        end
      end

      if !class_name.empty? && method_name.ends_with?('=')
        info = @class_info[class_name]?
        accessor_owner = class_name
        if info.nil? && module_like_receiver
          if preferred = preferred_module_typed_class_for(class_name)
            if preferred_info = @class_info[preferred]?
              info = preferred_info
              accessor_owner = preferred
            end
          end
        end
        if info
          accessor = method_name[0, method_name.size - 1]
          ivar_name = "@#{accessor}"
          if ivar_info = info.ivars.find { |iv| iv.name == ivar_name }
            expected_base = "#{accessor_owner}##{method_name}"
            expected_name = mangle_function_name(expected_base, [ivar_info.type])
            if @function_types.has_key?(expected_name)
              debug_hook("method.resolve", "base=#{base_method_name} resolved=#{expected_name} reason=setter_accessor")
              return cache_method_resolution(cache_key, expected_name)
            end
          end
        end
      end

      if env_get("DEBUG_ENUM_UNION_PREDICATE") && method_name.ends_with?('?') && (method_name == "kill?" || method_name == "hup?" || method_name == "quit?")
        STDERR.puts "[RESOLVE_METHOD] class_name=#{class_name} method=#{method_name} has_pipe=#{class_name.includes?('|')}"
      end
      if env_get("DEBUG_UNION_CALL") && (class_name.includes?('|') || class_name.includes?("$OR$"))
        STDERR.puts "[UNION_CALL] class=#{class_name} method=#{method_name} base=#{base_method_name} union=#{union_type_name?(class_name)}"
      end
      if !class_name.empty? && union_type_name?(class_name)
        union_name = normalize_union_type_name(class_name)
        if resolved = resolve_union_method_call(union_name, method_name, arg_types, has_block_call, call_has_named_args)
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=union")
          return cache_method_resolution(cache_key, resolved)
        elsif env_get("DEBUG_UNION_RESOLVE")
          STDERR.puts "[UNION_RESOLVE] union=#{union_name} method=#{method_name} args=#{arg_types.size} block=#{has_block_call} resolved=nil"
        end
      end

      # If the receiver is module-like (e.g., Iterator(T)) or maps to a known includer,
      # resolve only when a unique includer matches the call signature.
      if module_like_receiver
        if resolved = resolve_module_typed_method(method_name, arg_types, class_name, has_block_call, @current_class)
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=module_typed")
          return cache_method_resolution(cache_key, resolved)
        end
        # Fallback: preserve module-typed receiver dispatch even when multiple
        # includers match (e.g., IO::ByteFormat). Returning the base method name
        # lets MIR generate vdispatch for module receivers.
        if type_desc && type_desc.kind == TypeKind::Module
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{base_method_name} reason=module_typed_fallback")
          return cache_method_resolution(cache_key, base_method_name)
        end
      end

      if arg_types.any? { |t| t == TypeRef::NIL }
        if resolved = resolve_nilable_function_type_overload(base_method_name, arg_types, has_block_call)
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=nilable_overload")
          return cache_method_resolution(cache_key, resolved)
        end
      end

      if !class_name.empty?
        if resolved_base = resolve_method_with_inheritance(class_name, method_name)
          if numeric_primitive_class_name?(class_name)
            resolved_mangled = mangle_function_name(resolved_base, arg_types, has_block_call)
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved_mangled} reason=inheritance_prefer_owner")
            return cache_method_resolution(cache_key, resolved_mangled)
          elsif resolved_untyped = resolve_untyped_overload(resolved_base, effective_arg_count, has_block_call, call_has_named_args)
            resolved_untyped = prefer_callsite_over_arity(resolved_untyped, resolved_base, arg_types, has_block_call)
            if callsite = prefer_callsite_specialization(resolved_base, resolved_untyped, arg_types, has_block_call)
              debug_hook("method.resolve", "base=#{base_method_name} resolved=#{callsite} reason=inheritance_callsite")
              return cache_method_resolution(cache_key, callsite)
            end
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved_untyped} reason=inheritance_overload_arity")
            return cache_method_resolution(cache_key, resolved_untyped)
          end
        end
      end

      # If any overload exists for the base name, return the base name and let
      # the MIR lowering do fuzzy matching to pick a concrete overload.
      if !class_name.empty? && has_function_base?(base_method_name)
        if resolved = resolve_untyped_overload(base_method_name, effective_arg_count, has_block_call, call_has_named_args)
          resolved = prefer_callsite_over_arity(resolved, base_method_name, arg_types, has_block_call)
          if callsite = prefer_callsite_specialization(base_method_name, resolved, arg_types, has_block_call)
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{callsite} reason=base_callsite")
            return cache_method_resolution(cache_key, callsite)
          end
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=base_overload_arity")
          return cache_method_resolution(cache_key, resolved)
        end
        if resolved = resolve_ancestor_overload(class_name, method_name, effective_arg_count, has_block_call, call_has_named_args)
          resolved = prefer_callsite_over_arity(resolved, resolved, arg_types, has_block_call)
          if callsite = prefer_callsite_specialization(resolved, resolved, arg_types, has_block_call)
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{callsite} reason=ancestor_callsite")
            return cache_method_resolution(cache_key, callsite)
          end
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=ancestor_overload_arity")
          return cache_method_resolution(cache_key, resolved)
        end
        object_base = "Object##{method_name}"
        if resolved = resolve_untyped_overload(object_base, effective_arg_count, has_block_call, call_has_named_args)
          resolved = prefer_callsite_over_arity(resolved, object_base, arg_types, has_block_call)
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=object_overload_arity")
          return cache_method_resolution(cache_key, resolved)
        end
        if lookup_function_def_for_call(base_method_name, effective_arg_count, has_block_call, arg_types, false, call_has_named_args)
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{base_method_name} reason=base_overload")
          return cache_method_resolution(cache_key, base_method_name)
        end
        debug_hook("method.resolve", "base=#{base_method_name} resolved=#{base_method_name} reason=base_overload_fallback")
        return cache_method_resolution(cache_key, base_method_name)
      end

      if !class_name.empty? && class_name != "Object"
        object_base = "Object##{method_name}"
        if resolved = resolve_untyped_overload(object_base, arg_types.size, has_block_call, call_has_named_args)
          resolved = prefer_callsite_over_arity(resolved, object_base, arg_types, has_block_call)
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=object_overload_global")
          return cache_method_resolution(cache_key, resolved)
        end
      end

      # Search through all class info for matching method (O(n) fallback).
      # Only do this when the receiver type is unknown (no descriptor name).
      if class_name.empty?
        if candidates = @method_bases_by_name[method_name]?
          matches = [] of String
          candidates.each do |test_base|
            test_mangled = mangle_function_name(test_base, arg_types, has_block_call)
            if @function_types.has_key?(test_mangled)
              matches << test_mangled
            elsif has_function_base?(test_base)
              matches << test_base
            end
          end
          if matches.size == 1
            resolved = matches.first
            reason = resolved.includes?('$') ? "fallback_unique_mangled" : "fallback_unique_base"
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=#{reason}")
            return cache_method_resolution(cache_key, resolved)
          end
        end
      end

      # For special operators like <<, try common receivers with relaxed type matching
      if method_name == "<<" && class_name.empty?
        # Try Array(T)#<< with various element types
        ["String", "Int32", "Pointer"].each do |elem_type|
          array_class = "Array(#{elem_type})"
          test_base = "#{array_class}#<<"
          test_mangled = mangle_function_name(test_base, arg_types, has_block_call)
          if @function_types[test_mangled]?
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{test_mangled} reason=operator_array")
            return cache_method_resolution(cache_key, test_mangled)
          end
          # Also try without arg types mangling
          function_type_keys_for_base(test_base).each do |key|
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{key} reason=operator_array_prefix")
            return cache_method_resolution(cache_key, key)
          end
        end
        # Try IO#<<
        ["IO", "IO::Memory", "String::Builder"].each do |io_class|
          test_base = "#{io_class}#<<"
          function_type_keys_for_base(test_base).each do |key|
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{key} reason=operator_io")
            return cache_method_resolution(cache_key, key)
          end
          if @function_types.has_key?(test_base)
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{test_base} reason=operator_io")
            return cache_method_resolution(cache_key, test_base)
          end
        end
      end

      # Fallback to mangled name
      debug_hook("method.resolve", "base=#{base_method_name} resolved=#{mangled_name} reason=fallback")
      resolved = cache_method_resolution(cache_key, mangled_name)
      if stats && stats_start
        stats.resolve_ms += (Time.instant - stats_start).total_milliseconds
        stats.resolve_calls += 1
      end
      resolved
    end

    # Resolve a single overload when argument types are unknown (all VOID).
    # Uses arity + block presence to avoid calling an unmangled base name.
    private def function_def_overloads(base_name : String, stripped_base : String? = nil) : Array(String)
      rebuild_function_def_overloads if @function_defs_cache_size != @function_defs.size
      if cached = @function_def_overloads_cache[base_name]?
        return cached
      end
      if list = @function_def_overloads[base_name]?
        @function_def_overloads_cache[base_name] = list
        return list
      end
      if base_name.includes?('#') || base_name.includes?('.')
        parts = parse_method_name_compact(base_name)
        if parts.separator && parts.method
          ensure_method_index_built
          base_owner = strip_generic_args(parts.owner)
          method_name = parts.method.not_nil!
          if @method_index_last_owner == base_owner && @method_index_last_method == method_name
            if cached_candidates = @method_index_last_candidates
              @function_def_overloads_cache[base_name] = cached_candidates
              return cached_candidates
            end
          end
          if owner_methods = @method_index[base_owner]?
            if candidates = owner_methods[method_name]?
              @method_index_last_owner = base_owner
              @method_index_last_method = method_name
              @method_index_last_candidates = candidates
              @function_def_overloads_cache[base_name] = candidates
              return candidates
            end
          end
        end
      end

      stripped = if stripped_base
                   stripped_base
                 elsif cached = @function_def_overloads_stripped_by_base[base_name]?
                   cached
                 elsif base_name.includes?('(')
                   strip_generic_receiver_for_lookup(base_name)
                 else
                   base_name
                 end
      if stripped != base_name
        if cached = @function_def_overloads_stripped_cache[stripped]?
          @function_def_overloads_cache[base_name] = cached
          return cached
        end
        if indexed = @function_def_overloads_stripped_index[stripped]?
          @function_def_overloads_cache[base_name] = indexed
          return indexed
        end
        if list = @function_def_overloads[stripped]?
          @function_def_overloads_cache[base_name] = list
          return list
        end

        # Last-resort: scan bases that match after stripping generics.
        matches = [] of String
        seen = Set(String).new
        @function_def_overloads.each do |base, keys|
          next unless strip_generic_receiver_for_lookup(base) == stripped
          keys.each do |key|
            unless seen.includes?(key)
              seen << key
              matches << key
            end
          end
        end
        if matches.empty?
          empty = [] of String
          @function_def_overloads_stripped_cache[stripped] = empty
          @function_def_overloads_cache[base_name] = empty
          return empty
        end
        @function_def_overloads_stripped_cache[stripped] = matches
        @function_def_overloads_cache[base_name] = matches
        return matches
      end

      empty = [] of String
      @function_def_overloads_cache[base_name] = empty
      empty
    end

    private def function_def_has_splat?(base_name : String) : Bool
      rebuild_function_def_overloads if @function_defs_cache_size != @function_defs.size
      if cached = @function_def_has_splat[base_name]?
        return cached
      end
      if base_name.includes?('#') || base_name.includes?('.')
        parts = parse_method_name_compact(base_name)
        if parts.separator && parts.method
          ensure_method_index_built
          base_owner = strip_generic_args(parts.owner)
          if owner_methods = @method_index[base_owner]?
            if candidates = owner_methods[parts.method.not_nil!]?
              value = candidates.any? { |name| name.includes?("_splat") }
              @function_def_has_splat[base_name] = value
              return value
            end
          end
        end
      end
      stripped = @function_def_overloads_stripped_by_base[base_name]? || strip_generic_receiver_from_base_name(base_name)
      if stripped != base_name
        if cached = @function_def_has_splat[stripped]?
          @function_def_has_splat[base_name] = cached
          return cached
        end
      end
      false
    end

    private def function_def_has_double_splat?(base_name : String) : Bool
      rebuild_function_def_overloads if @function_defs_cache_size != @function_defs.size
      if cached = @function_def_has_double_splat[base_name]?
        return cached
      end
      if base_name.includes?('#') || base_name.includes?('.')
        parts = parse_method_name_compact(base_name)
        if parts.separator && parts.method
          ensure_method_index_built
          base_owner = strip_generic_args(parts.owner)
          if owner_methods = @method_index[base_owner]?
            if candidates = owner_methods[parts.method.not_nil!]?
              value = candidates.any? { |name| name.includes?("_double_splat") }
              @function_def_has_double_splat[base_name] = value
              return value
            end
          end
        end
      end
      stripped = @function_def_overloads_stripped_by_base[base_name]? || strip_generic_receiver_from_base_name(base_name)
      if stripped != base_name
        if cached = @function_def_has_double_splat[stripped]?
          @function_def_has_double_splat[base_name] = cached
          return cached
        end
      end
      false
    end

    private def rebuild_function_def_overloads
      # Incremental: only process new entries since last rebuild
      count = 0
      @function_defs.each do |key, def_node|
        count += 1
        next if count <= @function_defs_processed_for_overloads
        base = if idx = key.index('$')
                 key[0, idx]
               else
                 key
               end
        list = @function_def_overloads[base]?
        if list
          list << key
        else
          @function_def_overloads[base] = [key]
        end
        if key.includes?("_double_splat")
          @function_def_has_double_splat[base] = true
        elsif key.includes?("_splat")
          @function_def_has_splat[base] = true
        end
        @function_def_overloads_cache[base] = @function_def_overloads[base]
        stripped_base = base
        if base.includes?('#') || base.includes?('.')
          parts = parse_method_name_compact(base)
          if parts.separator && parts.method
            owner_base = strip_generic_args(parts.owner)
            stripped_base = parts.separator == '#' ? "#{owner_base}##{parts.method.not_nil!}" : "#{owner_base}.#{parts.method.not_nil!}"
          end
        end
        if stripped_base != base && !@function_def_overloads_stripped_by_base.has_key?(base)
          @function_def_overloads_stripped_by_base[base] = stripped_base
        end
        stripped_list = @function_def_overloads_stripped_index[stripped_base]?
        if stripped_list
          stripped_list << key
        else
          @function_def_overloads_stripped_index[stripped_base] = [key]
        end
        if stripped_base != base
          if key.includes?("_double_splat")
            @function_def_has_double_splat[stripped_base] = true
          elsif key.includes?("_splat")
            @function_def_has_splat[stripped_base] = true
          end
        end
        @function_def_overloads_cache[stripped_base] = @function_def_overloads_stripped_index[stripped_base]
        if @function_def_overloads_stripped_cache.has_key?(stripped_base)
          @function_def_overloads_stripped_cache[stripped_base] = @function_def_overloads_stripped_index[stripped_base]
        end
        @function_param_stats[key] = build_param_stats(def_node) unless @function_param_stats.has_key?(key)
      end
      @function_defs_processed_for_overloads = count

      # Incremental for function_type_keys_by_base
      type_count = 0
      @function_types.each_key do |key|
        type_count += 1
        next if type_count <= @function_types_processed_for_keys
        base = if idx = key.index('$')
                 key[0, idx]
               else
                 key
               end
        list = @function_type_keys_by_base[base]?
        if list
          list << key unless list.includes?(key)
        else
          @function_type_keys_by_base[base] = [key]
        end
      end
      @function_types_processed_for_keys = type_count

      @function_type_keys_by_base_size = @function_types.size
      @function_defs_cache_size = @function_defs.size
      @function_def_overloads_cache_size = @function_defs_cache_size
    end

    private def function_type_keys_for_base(base_name : String) : Array(String)
      rebuild_function_def_overloads if @function_defs_cache_size != @function_defs.size
      if @function_type_keys_by_base_size != @function_types.size
        type_count = 0
        @function_types.each_key do |key|
          type_count += 1
          next if type_count <= @function_types_processed_for_keys
          base = if idx = key.index('$')
                   key[0, idx]
                 else
                   key
                 end
          list = @function_type_keys_by_base[base]?
          if list
            list << key unless list.includes?(key)
          else
            @function_type_keys_by_base[base] = [key]
          end
        end
        @function_types_processed_for_keys = type_count
        @function_type_keys_by_base_size = @function_types.size
      end
      @function_type_keys_by_base[base_name]? || [] of String
    end

    private def function_param_stats(name : String, def_node : CrystalV2::Compiler::Frontend::DefNode) : DefParamStats
      rebuild_function_def_overloads if @function_defs_cache_size != @function_defs.size
      if stats = @function_param_stats[name]?
        return stats
      end
      stats = build_param_stats(def_node)
      # Treat implicit-yield methods as block-accepting even without explicit &block.
      unless stats.has_block
        arena = @function_def_arenas[name]? || resolve_arena_for_def(def_node, @arena)
        if def_contains_yield?(def_node, arena)
          stats = DefParamStats.new(
            stats.param_count,
            stats.required,
            stats.has_splat,
            stats.has_double_splat,
            true,
            stats.has_named_only,
            stats.typed_param_count,
            stats.type_param_names,
            stats.has_non_type_param_annotation
          )
        end
      end
      @function_param_stats[name] = stats
      stats
    end

    private def build_param_stats(def_node : CrystalV2::Compiler::Frontend::DefNode) : DefParamStats
      param_count = 0
      required = 0
      has_splat = false
      has_double_splat = false
      has_block = false
      has_named_only = false
      typed_param_count = 0
      type_param_names = [] of String
      has_non_type_param_annotation = false

      if params = def_node.params
        params.each do |param|
          if param.is_block
            has_block = true
            next
          end
          if named_only_separator?(param)
            has_named_only = true
            next
          end
          has_splat = true if param.is_splat
          has_double_splat = true if param.is_double_splat
          param_count += 1
          if param.default_value.nil? && !param.is_splat && !param.is_double_splat
            required += 1
          end
          if ta = param.type_annotation
            typed_param_count += 1
            type_name = String.new(ta)
            if type_param_like?(type_name)
              type_param_names << type_name
            else
              has_non_type_param_annotation = true
            end
          end
        end
      end

      DefParamStats.new(
        param_count,
        required,
        has_splat,
        has_double_splat,
        has_block,
        has_named_only,
        typed_param_count,
        type_param_names,
        has_non_type_param_annotation
      )
    end

    private def untyped_candidate_for?(stats : DefParamStats) : Bool
      return false if stats.has_non_type_param_annotation
      stats.type_param_names.none? { |name| @type_param_map.has_key?(name) }
    end

    private def ensure_module_def_lookup_cache
      return if @module_def_lookup_cache_version == @module_defs_cache_version
      @module_def_lookup_cache.clear
      @module_class_def_lookup_cache.clear
      @module_def_lookup_cache_version = @module_defs_cache_version
    end

    private def ensure_instance_method_names_cache
      rebuild_function_def_overloads if @function_defs_cache_size != @function_defs.size
      return if @instance_method_names_cache_version == @function_defs_cache_size
      @instance_method_names_cache.clear
      @instance_method_names_cache_version = @function_defs_cache_size
    end

    private def ensure_method_inheritance_cache
      if @method_inheritance_cache_function_size != @function_types.size ||
         @method_inheritance_cache_class_info_version != @class_info_version ||
         @method_inheritance_cache_module_version != @module_includers_version
        @method_inheritance_cache.clear
        @class_method_inheritance_cache.clear
        @method_inheritance_cache_function_size = @function_types.size
        @method_inheritance_cache_class_info_version = @class_info_version
        @method_inheritance_cache_module_version = @module_includers_version
      end
    end

    private def resolve_untyped_overload(base_method_name : String, arg_count : Int32, has_block_call : Bool, call_has_named_args : Bool = false) : String?
      return nil if base_method_name.empty?

      if method_short_from_name(base_method_name)
        owner = method_owner_from_name(base_method_name)
        if info = generic_owner_info(owner)
          if !@monomorphized.includes?(info[:owner]) && concrete_type_args?(info[:args]) && !@suppress_monomorphization
            monomorphize_generic_class(info[:base], info[:args], info[:owner])
          end
        end
      end

      best_name : String? = nil
      best_param_count = Int32::MAX
      best_score = Int32::MIN

      overload_keys = function_def_overloads(base_method_name)
      prefer_non_named = false
      unless call_has_named_args
        prefer_non_named = overload_keys.any? do |name|
          def_node = @function_defs[name]?
          next false unless def_node
          stats = function_param_stats(name, def_node)
          !stats.has_named_only
        end
      end

      overload_keys.each do |name|
        def_node = @function_defs[name]?
        next unless def_node
        stats = function_param_stats(name, def_node)
        next if !call_has_named_args && stats.has_named_only
        next if prefer_non_named && stats.has_named_only
        param_count = stats.param_count
        required = stats.required
        has_splat = stats.has_splat
        has_double_splat = stats.has_double_splat
        def_has_block = stats.has_block

        next if has_block_call && !def_has_block
        next if !has_block_call && def_has_block
        next if arg_count < required
        next if arg_count > param_count && !has_splat && !has_double_splat

        score = 0
        score += 2 if param_count == arg_count
        score += 3 if required == arg_count  # Prefer exact required match over using defaults
        score -= 1 if has_splat
        score -= 1 if has_double_splat
        score += 1 if name.includes?('$')
        score -= 2 if name.includes?("$arity")

        if score > best_score || (score == best_score && param_count < best_param_count)
          best_name = name
          best_param_count = param_count
          best_score = score
        end
      end

      best_name
    end

    private def prefer_callsite_specialization(
      base_method_name : String,
      resolved_name : String,
      arg_types : Array(TypeRef),
      has_block_call : Bool,
    ) : String?
      return nil if base_method_name.empty?
      return nil if arg_types.empty?
      return nil if arg_types.all? { |t| t == TypeRef::VOID }

      def_node = @function_defs[base_method_name]? || @function_defs[resolved_name]?
      return nil unless def_node
      return nil unless def_params_untyped?(def_node)

      callsite = mangle_function_name(base_method_name, arg_types, has_block_call)
      return nil if callsite == resolved_name

      callsite
    end

    private def prefer_callsite_over_arity(
      resolved_name : String,
      base_method_name : String,
      arg_types : Array(TypeRef),
      has_block_call : Bool,
    ) : String
      return resolved_name unless resolved_name.includes?("$arity")
      return resolved_name if arg_types.all? { |t| t == TypeRef::VOID }

      callsite = mangle_function_name(base_method_name, arg_types, has_block_call)
      callsite.empty? ? resolved_name : callsite
    end

    private def resolve_nilable_function_type_overload(
      base_method_name : String,
      arg_types : Array(TypeRef),
      has_block_call : Bool,
    ) : String?
      return nil if base_method_name.empty?
      return nil unless arg_types.any? { |t| t == TypeRef::NIL }

      best_name : String? = nil
      best_score = Int32::MIN

      function_type_keys_for_base(base_method_name).each do |name|
        next if name == base_method_name
        suffix = method_suffix(name) || ""
        next if suffix.empty?
        has_block_suffix = suffix.ends_with?("_block")
        next if has_block_call != has_block_suffix
        clean_suffix = strip_mangled_suffix_flags(suffix)
        next if clean_suffix.empty?
        next if clean_suffix.starts_with?("arity")

        param_types = parse_types_from_suffix(clean_suffix)
        next unless param_types.size == arg_types.size

        score = 0
        compatible = true
        arg_types.each_with_index do |arg_type, idx|
          param_type = param_types[idx]
          if param_type == arg_type
            score += 2
            next
          end
          if arg_type == TypeRef::NIL
            if is_union_type?(param_type) && get_union_variant_id(param_type, TypeRef::NIL) >= 0
              score += 1
              next
            end
            compatible = false
            break
          end
          if is_union_type?(param_type) && get_union_variant_id(param_type, arg_type) >= 0
            score += 1
            next
          end
          compatible = false
          break
        end
        next unless compatible

        if score > best_score
          best_name = name
          best_score = score
        end
      end

      best_name
    end

    private def non_nil_type_for_union(type_ref : TypeRef) : TypeRef?
      type_desc = @module.get_type_descriptor(type_ref)
      return nil unless type_desc && type_desc.kind == TypeKind::Union

      variants = split_union_type_name(type_desc.name)
      non_nil = variants.reject { |name| name == "Nil" }
      return nil if non_nil.empty?
      return type_ref_for_name(non_nil.first) if non_nil.size == 1

      create_union_type(non_nil.join(" | "))
    end

    private def resolve_ancestor_overload(owner : String, method_name : String, arg_count : Int32, has_block_call : Bool, call_has_named_args : Bool = false) : String?
      # Use cached ancestor chain to avoid repeated hash lookups
      chain = get_ancestor_chain(owner)
      # Skip first element (owner itself) and iterate ancestors
      chain.each_with_index do |ancestor, idx|
        next if idx == 0 # Skip owner
        base = "#{ancestor}##{method_name}"
        if has_function_base?(base)
          if resolved = resolve_untyped_overload(base, arg_count, has_block_call, call_has_named_args)
            return resolved
          end
        end
      end
      if info = @class_info[owner]?
        if info.is_struct && owner != "Object"
          base = "Object##{method_name}"
          if has_function_base?(base)
            if resolved = resolve_untyped_overload(base, arg_count, has_block_call, call_has_named_args)
              return resolved
            end
          end
        end
      end
      nil
    end

    private def module_receiver_type_name(node : CrystalV2::Compiler::Frontend::MemberAccessNode) : String?
      obj_node = @arena[node.object]
      case obj_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(obj_node.name)
        if type_name = lookup_typeof_local_name(name)
          return type_name if module_like_type_name?(type_name)
        end
        if locals = @current_typeof_locals
          if type_ref = locals[name]?
            resolved = get_type_name_from_ref(type_ref)
            return resolved if module_like_type_name?(resolved)
          end
        end
      end
      nil
    end

    private def preferred_module_typed_class_for(module_type_name : String) : String?
      base = if paren = module_type_name.index('(')
               module_type_name[0, paren]
             else
               module_type_name
             end
      resolved = resolve_type_alias_chain(base)
      return nil if resolved == base
      resolved
    end

    private def resolve_module_typed_method(
      method_name : String,
      arg_types : Array(TypeRef),
      module_type_name : String,
      has_block : Bool,
      prefer_class : String?,
    ) : String?
      if preferred = preferred_module_typed_class_for(module_type_name)
        prefer_class = preferred
      end
      module_base = if paren = module_type_name.index('(')
                      module_type_name[0, paren]
                    else
                      module_type_name
                    end
      includers = @module_includers[module_base]?
      if includers.nil? || includers.empty?
        if matches = @module_includer_keys_by_suffix[module_base]?
          if matches.size == 1
            module_base = matches.first
            includers = @module_includers[module_base]?
          end
        end
      end
      # Fallback: try short name if full name has no includers
      # e.g., "Crystal::EventLoop::FileDescriptor" -> "FileDescriptor"
      if includers.nil? || includers.empty?
        short_name = last_namespace_component(module_base)
        if short_name != module_base
          includers = @module_includers[short_name]?
          if includers.nil? || includers.empty?
            if matches = @module_includer_keys_by_suffix[short_name]?
              if matches.size == 1
                module_base = matches.first
                includers = @module_includers[module_base]?
              end
            end
          end
        end
      end
      if includers.nil? || includers.empty?
        if prefer_class
          includers = Set(String).new
          includers << prefer_class
        else
          # RESOLVE_DEBUG disabled
          return nil
        end
      end

      if prefer_class
        unless includers.any? { |inc| prefer_class == inc || class_inherits_from?(prefer_class, inc) }
          prefer_class = nil
        end
      end

      arg_count = arg_types.size
      module_method_base = "#{module_base}.#{method_name}"
      if entry = lookup_function_def_for_call(module_method_base, arg_count, has_block, arg_types)
        def_node = entry[1]
        func_context = function_context_from_name(entry[0])
        if params_compatible_with_args?(def_node, arg_types, func_context)
          mangled = mangle_function_name(module_method_base, arg_types, has_block)
          if @function_types.has_key?(mangled) || @module.has_function?(mangled)
            return mangled unless abstract_def?(mangled)
          elsif has_function_base?(module_method_base)
            return module_method_base unless abstract_def?(module_method_base)
          end
        end
      end
      if has_function_base?(module_method_base) && !abstract_def?(module_method_base)
        return module_method_base
      end

      candidates = includers.to_a
      if module_like_type_name?(module_base) && !candidates.includes?(module_base)
        candidates << module_base
      end
      if prefer_class && !candidates.includes?(prefer_class)
        candidates << prefer_class
      end
      # Also add subclasses of includers (for abstract classes like Crystal::EventLoop)
      # The concrete implementation may be in a subclass (e.g., Polling, Kqueue)
      parent_keys = includers.to_a
      namespaced_module = module_base.includes?("::")
      unless namespaced_module
        includers.each do |inc|
          inc_short = last_namespace_component(inc)
          if inc_short != inc
            parent_keys << inc_short unless parent_keys.includes?(inc_short)
          end
        end
      end
      subclasses = collect_subclasses(parent_keys)
      subclasses.each { |entry| candidates << entry }
      candidates.uniq!
      if debug_hook_filter_match?(module_base, method_name)
        debug_hook(
          "module.resolve",
          "module=#{module_base} includers=#{includers.to_a.join(",")} candidates=#{candidates.join(",")}"
        )
      end
      if debug_env_filter_match?("DEBUG_MODULE_RESOLVE", module_base, method_name)
        STDERR.puts "[DEBUG_MODULE_RESOLVE] module=#{module_base} method=#{method_name} includers=#{includers.to_a.sort.join(",")} candidates=#{candidates.sort.join(",")}"
      end
      # RESOLVE_DEBUG2 disabled
      if prefer_class
        candidates.delete(prefer_class)
        candidates.sort!
        candidates.unshift(prefer_class)
      else
        candidates.sort!
      end

      matches = [] of String
      candidates.each do |candidate|
        sep = module_like_type_name?(candidate) ? "." : "#"
        base = "#{candidate}#{sep}#{method_name}"
        if sep == "#" && !has_function_base?(base) && !@function_defs.has_key?(base)
          if resolved = resolve_method_with_inheritance(candidate, method_name)
            base = resolved
          end
        end
        # Filter by arity/defaults first to avoid picking mismatched overloads.
        if entry = lookup_function_def_for_call(base, arg_count, has_block, arg_types)
          def_node = entry[1]
          func_context = function_context_from_name(entry[0])
          next unless params_compatible_with_args?(def_node, arg_types, func_context)
          mangled = mangle_function_name(base, arg_types, has_block)
          if @function_types.has_key?(mangled) || @module.has_function?(mangled)
            matches << mangled
          elsif has_function_base?(base)
            matches << base
          end
        elsif has_function_base?(base)
          # Accessors (property/getter/setter) often have no DefNode; generate lazily.
          if maybe_generate_accessor_for_name(base)
            matches << base
          end
        end
      end
      matches.uniq!

      return matches.first if matches.size == 1
      if matches.size > 1
        concrete_matches = matches.select do |name|
          def_node = @function_defs[name]?
          def_node && !def_node.body.nil?
        end
        return concrete_matches.first if concrete_matches.size == 1
      end
      if prefer_class
        preferred = matches.find do |name|
          name.starts_with?("#{prefer_class}#") || name.starts_with?("#{prefer_class}.")
        end
        return preferred if preferred
      end
      if matches.empty? && arg_count > 0
        # Fallback: retry without arg type filtering to avoid false negatives
        # when module-typed parameters don't match concrete includers.
        candidates.each do |candidate|
          sep = module_like_type_name?(candidate) ? "." : "#"
          base = "#{candidate}#{sep}#{method_name}"
          if lookup_function_def_for_call(base, arg_count, has_block, nil)
            mangled = mangle_function_name(base, arg_types, has_block)
            if @function_types.has_key?(mangled) || @module.has_function?(mangled)
              matches << mangled
            elsif has_function_base?(base)
              matches << base
            end
          end
        end
        return matches.first if matches.size == 1
        if prefer_class
          preferred = matches.find { |name| name.starts_with?("#{prefer_class}#") }
          return preferred if preferred
        end
      end
      nil
    end

    private def infer_return_type_from_includers(
      module_type_name : String,
      method_name : String,
      arg_types : Array(TypeRef),
      has_block : Bool,
    ) : TypeRef?
      module_base = strip_generic_args(module_type_name)
      includers = @module_includers[module_base]?.try(&.to_a)
      if includers.nil? || includers.empty?
        if matches = @module_includer_keys_by_suffix[module_base]?
          if matches.size == 1
            module_base = matches.first
            includers = @module_includers[module_base]?.try(&.to_a)
          end
        end
      end
      if includers.nil? || includers.empty?
        short_name = last_namespace_component(module_base)
        if short_name != module_base
          includers = @module_includers[short_name]?.try(&.to_a)
          if (includers.nil? || includers.empty?) && (matches = @module_includer_keys_by_suffix[short_name]?)
            if matches.size == 1
              module_base = matches.first
              includers = @module_includers[module_base]?.try(&.to_a)
            end
          end
        end
      end
      return nil if includers.nil? || includers.empty?

      candidates = includers.not_nil!.dup
      collect_subclasses(includers.not_nil!).each { |entry| candidates << entry }
      candidates.uniq!

      merged : TypeRef? = nil
      arg_count = arg_types.size
      candidates.each do |candidate|
        sep = module_like_type_name?(candidate) ? "." : "#"
        base_name = "#{candidate}#{sep}#{method_name}"
        return_type = nil
        if resolved = lookup_function_def_for_call(base_name, arg_count, has_block, arg_types)
          return_type = get_function_return_type(resolved[0])
        end
        if return_type.nil? || return_type == TypeRef::VOID
          if cached = @function_base_return_types[base_name]?
            return_type = cached
          end
        end
        next if return_type.nil? || return_type == TypeRef::VOID
        merged = merged ? union_type_for_values(merged, return_type) : return_type
      end
      merged
    end

    private def fixup_module_receiver_calls(ctx : LoweringContext) : Nil
      ctx.function.blocks.each do |block|
        block.instructions.each_with_index do |inst, idx|
          next unless inst.is_a?(Call)
          next if inst.virtual
          recv = inst.receiver
          next unless recv
          recv_type = ctx.type_of(recv)
          desc = @module.get_type_descriptor(recv_type)
          next unless desc
          next unless desc.kind == TypeKind::Module || module_like_type_name?(desc.name) || module_includers_match?(desc.name)

          parts = parse_method_name_compact(inst.method_name)
          method_base = parts.method || inst.method_name
          owner = parts.owner
          if owner.empty?
            owner = strip_generic_args(desc.name)
          end
          arg_types = inst.args.map { |arg| ctx.type_of(arg) }
          return_type = inst.type
          if return_type == TypeRef::VOID
            if inferred = infer_return_type_from_includers(owner, method_base, arg_types, !!inst.block)
              return_type = inferred
            end
          end
          new_call = Call.new(inst.id, return_type, recv, inst.method_name, inst.args, inst.block, true)
          block.instructions[idx] = new_call
          ctx.register_type(inst.id, return_type)
        end
      end
    end

    private def module_includers_match?(name : String) : Bool
      # If the name is a known class/struct, don't treat it as module-like.
      # This prevents e.g. the "File" class from matching the "Crystal::System::File" module
      # via suffix matching.
      return false if class_like_namespace?(name)

      return true if @module_includers.has_key?(name)

      return true if @module_includer_keys_by_suffix.has_key?(name)

      short_name = last_namespace_component(name)
      return true if @module_includers.has_key?(short_name)

      @module_includer_keys_by_suffix.has_key?(short_name)
    end

    private def resolve_short_type_in_namespace_chain(name : String) : String?
      return nil unless name.includes?("::")
      short = last_namespace_component(name)
      candidates = @short_type_index[short]?
      return nil unless candidates

      parts = name.split("::")
      parts.pop
      while parts.size > 0
        prefix = parts.join("::")
        matches = candidates.select { |c| c.starts_with?("#{prefix}::") }
        return matches.first if matches.size == 1
        parts.pop
      end

      return candidates.first if candidates.size == 1
      nil
    end

    private def resolve_module_typed_ivar(
      module_type_name : String,
      ivar_name : String,
      prefer_class : String? = nil,
    ) : {ClassInfo, IVarInfo}?
      if preferred = preferred_module_typed_class_for(module_type_name)
        prefer_class = preferred
      end
      module_base = if paren = module_type_name.index('(')
                      module_type_name[0, paren]
                    else
                      module_type_name
                    end
      includers = @module_includers[module_base]?
      if includers.nil? || includers.empty?
        if matches = @module_includer_keys_by_suffix[module_base]?
          if matches.size == 1
            module_base = matches.first
            includers = @module_includers[module_base]?
          end
        end
      end
      if includers.nil? || includers.empty?
        short_name = last_namespace_component(module_base)
        if short_name != module_base
          includers = @module_includers[short_name]?
          if includers.nil? || includers.empty?
            if matches = @module_includer_keys_by_suffix[short_name]?
              if matches.size == 1
                module_base = matches.first
                includers = @module_includers[module_base]?
              end
            end
          end
        end
      end
      if includers.nil? || includers.empty?
        if prefer_class
          includers = Set(String).new
          includers << prefer_class
        else
          return nil
        end
      end

      if prefer_class
        unless includers.any? { |inc| prefer_class == inc || class_inherits_from?(prefer_class, inc) }
          prefer_class = nil
        end
      end

      candidates = includers.to_a
      parent_keys = includers.to_a
      namespaced_module = module_base.includes?("::")
      unless namespaced_module
        includers.each do |inc|
          inc_short = last_namespace_component(inc)
          if inc_short != inc
            parent_keys << inc_short unless parent_keys.includes?(inc_short)
          end
        end
      end
      subclasses = collect_subclasses(parent_keys)
      subclasses.each { |name| candidates << name unless candidates.includes?(name) }
      if prefer_class && !candidates.includes?(prefer_class)
        candidates << prefer_class
      end

      if prefer_class
        candidates.delete(prefer_class)
        candidates.sort!
        candidates.unshift(prefer_class)
      else
        candidates.sort!
      end

      if env_get("DEBUG_IVAR_ACCESS") && (module_type_name.includes?("FileDescriptor") || module_type_name.includes?("Socket"))
        includer_list = includers.to_a.sort!.join(",")
        candidate_list = candidates.join(",")
        STDERR.puts "[IVAR_ACCESS] module=#{module_type_name} base=#{module_base} ivar=#{ivar_name} prefer=#{prefer_class} includers=#{includer_list} candidates=#{candidate_list}"
      end

      matches = [] of {ClassInfo, IVarInfo}
      candidates.each do |name|
        next unless info = @class_info[name]?
        if ivar_info = info.ivars.find { |iv| iv.name == ivar_name }
          matches << {info, ivar_info}
        end
      end

      if matches.size > 1 && prefer_class
        if preferred = matches.find { |(info, _)| info.name == prefer_class }
          return preferred
        end
      end

      return matches.first if matches.size == 1
      nil
    end

    private def params_compatible_with_args?(
      def_node : CrystalV2::Compiler::Frontend::DefNode,
      arg_types : Array(TypeRef),
      context : String? = nil,
    ) : Bool
      params = def_node.params
      return true unless params

      min_args = 0
      max_args = 0
      has_splat = false
      params.each do |param|
        next if param.is_block
        next if named_only_separator?(param)
        if param.is_splat || param.is_double_splat
          has_splat = true
          next
        end
        max_args += 1
        min_args += 1 unless param.default_value
      end
      return false if arg_types.size < min_args
      return false if !has_splat && arg_types.size > max_args

      arg_idx = 0
      params.each do |param|
        next if param.is_block
        next if named_only_separator?(param)
        if param.is_splat || param.is_double_splat
          return true
        end
        break if arg_idx >= arg_types.size

        param_type_name = param.type_annotation ? String.new(param.type_annotation.not_nil!) : ""
        param_resolved_name = param_type_name
        if !param_type_name.empty? && context
          param_type_name = normalize_declared_type_name(param_type_name, context)
        end
        arg_type = arg_types[arg_idx]

        # "_" is a wildcard type in Crystal (matches any argument).
        if param_type_name == "_"
          arg_idx += 1
          next
        end

        if !param_type_name.empty?
          # Resolve type alias chain FIRST, then get type ref
          resolved_name = resolve_type_alias_chain(param_type_name)
          param_resolved_name = resolved_name
          if module_like_type_name?(resolved_name)
            return false if primitive_type?(arg_type)
            arg_idx += 1
            next
          end
          # Use resolved name for type lookup
          param_type = type_ref_for_name(resolved_name)
        else
          param_type = TypeRef::VOID
        end

        if param_type != TypeRef::VOID && arg_type != TypeRef::VOID
          if param_type != arg_type && !needs_union_coercion?(arg_type, param_type)
            if numeric_compatible?(arg_type, param_type)
              arg_idx += 1
              next
            end
            if !param_type_name.empty?
              if numeric_param_target_type(param_type_name, arg_type)
                arg_idx += 1
                next
              end
            end
            # Also check if arg type's name matches after alias resolution
            arg_desc = @module.get_type_descriptor(arg_type)
            # PARAMS_COMPAT debug disabled
            if arg_desc && resolve_type_alias_chain(arg_desc.name) == resolve_type_alias_chain(param_type_name)
              # They're the same type after alias resolution, allow
              arg_idx += 1
              next
            end
            # Allow generic base match: Hash matches Hash(Int32, T), Array matches Array(T), etc.
            if arg_desc && !param_resolved_name.empty?
              param_base = param_resolved_name.split("(").first
              if BUILTIN_GENERIC_BASES.includes?(param_base) && arg_desc.name.starts_with?("#{param_base}(")
                arg_idx += 1
                next
              end
            end
            # Check if arg type is a subclass of the param type (e.g., IO::FileDescriptor -> IO)
            if arg_desc && !param_resolved_name.empty?
              arg_class = resolve_type_alias_chain(arg_desc.name)
              if @class_info.has_key?(arg_class) && @class_info.has_key?(param_resolved_name)
                if class_inherits_from?(arg_class, param_resolved_name)
                  arg_idx += 1
                  next
                end
              end
            end
            # Check if arg type includes the param type (for module methods)
            # e.g., IO::FileDescriptor includes Crystal::System::FileDescriptor
            if arg_desc
              arg_class = arg_desc.name
              param_base = param_type_name.split("(").first
              if @class_included_modules[arg_class]?.try(&.any? { |m| m.includes?(param_base) || param_base.includes?(last_namespace_component(m)) })
                arg_idx += 1
                next
              end
            end
            # Symbol → Enum autocast compatibility:
            # Crystal allows symbol literals like :sched to autocast to enum values.
            # The enum backing type is usually Int32, but arg_type will be Symbol.
            if arg_type == TypeRef::SYMBOL && @enum_info.try(&.has_key?(param_resolved_name))
              arg_idx += 1
              next
            end
            # Union of integers → Int parameter compatibility:
            # When arg is a union like UInt32|Int32 and param is an Int type,
            # allow it since at runtime only one branch is taken.
            if arg_desc && union_of_integers?(arg_desc.name) && integer_param_type?(param_resolved_name)
              arg_idx += 1
              next
            end
            return false
          end
        end

        arg_idx += 1
      end

      true
    end

    private def params_match_score(
      def_node : CrystalV2::Compiler::Frontend::DefNode,
      arg_types : Array(TypeRef),
      context : String? = nil,
    ) : Int32
      params = def_node.params
      return 0 unless params

      score = 0
      arg_idx = 0
      params.each do |param|
        next if param.is_block
        next if named_only_separator?(param)
        break if arg_idx >= arg_types.size
        if param.is_splat || param.is_double_splat
          arg_idx += 1
          next
        end

        param_type_name = param.type_annotation ? String.new(param.type_annotation.not_nil!) : ""
        if !param_type_name.empty? && context
          param_type_name = normalize_declared_type_name(param_type_name, context)
        end

        arg_type = arg_types[arg_idx]
        if param_type_name == "_"
          arg_idx += 1
          next
        end
        if !param_type_name.empty? && arg_type != TypeRef::VOID
          resolved_name = resolve_type_alias_chain(param_type_name)
          param_type = type_ref_for_name(resolved_name)
          if param_type != TypeRef::VOID
            if param_type == arg_type
              score += 2
            elsif needs_union_coercion?(arg_type, param_type)
              score += 1
            elsif numeric_compatible?(arg_type, param_type)
              score += 1
            else
              numeric_target = numeric_param_target_type(param_type_name, arg_type)
              score += 1 if numeric_target
            end
            if arg_desc = @module.get_type_descriptor(arg_type)
              param_base = resolved_name.split("(").first
              if BUILTIN_GENERIC_BASES.includes?(param_base) && arg_desc.name.starts_with?("#{param_base}(")
                score += 1
              end
            end
          end
        end

        arg_idx += 1
      end

      score
    end

    private def primitive_type?(type : TypeRef) : Bool
      case type
      when TypeRef::VOID, TypeRef::NIL, TypeRef::BOOL, TypeRef::CHAR,
           TypeRef::INT8, TypeRef::INT16, TypeRef::INT32, TypeRef::INT64, TypeRef::INT128,
           TypeRef::UINT8, TypeRef::UINT16, TypeRef::UINT32, TypeRef::UINT64, TypeRef::UINT128,
           TypeRef::FLOAT32, TypeRef::FLOAT64
        true
      else
        false
      end
    end

    private def integer_bit_width(type : TypeRef) : Int32?
      case type
      when TypeRef::INT8, TypeRef::UINT8
        8
      when TypeRef::INT16, TypeRef::UINT16
        16
      when TypeRef::INT32, TypeRef::UINT32, TypeRef::CHAR
        32
      when TypeRef::INT64, TypeRef::UINT64
        64
      when TypeRef::INT128, TypeRef::UINT128
        128
      else
        nil
      end
    end

    private def signed_integer_type_for_width(bits : Int32) : TypeRef
      case bits
      when 8
        TypeRef::INT8
      when 16
        TypeRef::INT16
      when 32
        TypeRef::INT32
      when 64
        TypeRef::INT64
      when 128
        TypeRef::INT128
      else
        TypeRef::VOID
      end
    end

    private def unsigned_integer_type_for_width(bits : Int32) : TypeRef
      case bits
      when 8
        TypeRef::UINT8
      when 16
        TypeRef::UINT16
      when 32
        TypeRef::UINT32
      when 64
        TypeRef::UINT64
      when 128
        TypeRef::UINT128
      else
        TypeRef::VOID
      end
    end

    private def numeric_compatible?(arg_type : TypeRef, param_type : TypeRef) : Bool
      arg_bits = integer_bit_width(arg_type)
      param_bits = integer_bit_width(param_type)
      return false unless arg_bits && param_bits
      arg_bits == param_bits
    end

    # Check if a type name represents a union of integer types
    # e.g., "UInt32 | Int32", "Int32 | Int64", etc.
    private def union_of_integers?(type_name : String) : Bool
      return false unless type_name.includes?('|')
      parts = split_union_type_name(type_name)
      return false if parts.size <= 1
      parts.all? do |part|
        stripped = part.strip
        INTEGER_TYPE_NAMES.includes?(stripped)
      end
    end

    # Check if a parameter type name accepts integers
    # e.g., "Int32", "Int64", "Int", etc.
    private def integer_param_type?(param_name : String) : Bool
      return false if param_name.empty?
      stripped = param_name.strip
      INTEGER_TYPE_NAMES.includes?(stripped) ||
        stripped == "Int" || stripped == "UInt" ||
        stripped == "Int::Primitive" || stripped == "Int::Signed" || stripped == "Int::Unsigned" ||
        stripped == "Number"
    end

    INTEGER_TYPE_NAMES = {"Int8", "Int16", "Int32", "Int64", "Int128",
                          "UInt8", "UInt16", "UInt32", "UInt64", "UInt128"}

    private def numeric_param_target_type(param_type_name : String, arg_type : TypeRef) : TypeRef?
      bits = integer_bit_width(arg_type)
      case param_type_name
      when "Int::Primitive", "Int::Signed"
        return signed_integer_type_for_width(bits) if bits
      when "Int::Unsigned"
        return unsigned_integer_type_for_width(bits) if bits
      end

      short_name = last_namespace_component(param_type_name)
      case short_name
      when "Int"
        return signed_integer_type_for_width(bits) if bits
      when "UInt"
        return unsigned_integer_type_for_width(bits) if bits
      when "Float"
        return arg_type if arg_type == TypeRef::FLOAT32 || arg_type == TypeRef::FLOAT64
      when "Number"
        return arg_type if numeric_primitive?(arg_type)
      end
      nil
    end

    private def yield_receiver_base_name(receiver_type : TypeRef) : String?
      name = if desc = @module.get_type_descriptor(receiver_type)
               desc.name
             else
               get_type_name_from_ref(receiver_type)
             end
      name = normalize_method_owner_name(name)
      return nil if name.empty?
      return nil if union_type_name?(name)
      if split = split_generic_base_and_args(name)
        name = split[:base]
      end
      name
    end

    private def receiver_allows_yield_owner?(receiver_base : String, owner_base : String) : Bool
      # Primitive receivers don't have full class_info chains; treat them as Object descendants
      # for yield-inline owner checks (e.g., Object#try on Int32).
      if owner_base == "Object"
        return true if primitive_self_type(receiver_base)
      end
      return true if receiver_base == owner_base
      owner_short = last_namespace_component_if_nested(owner_base)
      if owner_short && !receiver_base.includes?("::")
        return true if owner_short == receiver_base
      end
      current = receiver_base
      while current
        info = @class_info[current]?
        break unless info
        parent = info.parent_name
        if parent
          return true if parent == owner_base
          if owner_short
            parent_short = last_namespace_component_if_nested(parent)
            return true if parent_short && parent_short == owner_short
          end
        end
        current = parent
      end
      if modules = @class_included_modules[receiver_base]?
        modules.each do |mod|
          return true if mod == owner_base
          if owner_short
            mod_short = last_namespace_component_if_nested(mod)
            return true if mod_short && mod_short == owner_short
          end
        end
      end
      false
    end

    # Fallback for yield-function inlining when receiver type is unknown (often due to untyped params).
    # Tries to find a unique yield method by name + arity.
    private def find_yield_method_fallback(method_name : String, arg_count : Int32, receiver_base : String? = nil) : String?
      instance_suffix = "##{method_name}"
      class_suffix = ".#{method_name}"

      candidates = [] of String
      seen_defs = Set(UInt64).new
      @yield_functions.each do |name|
        base = strip_type_suffix(name)
        next unless base.ends_with?(instance_suffix) || base.ends_with?(class_suffix)
        if receiver_base
          owner = if idx = base.rindex('#')
                    base[0, idx]
                  elsif idx = base.rindex('.')
                    base[0, idx]
                  else
                    ""
                  end
          owner_base = if split = split_generic_base_and_args(owner)
                         split[:base]
                       else
                         owner
                       end
          next unless receiver_allows_yield_owner?(receiver_base, owner_base)
        end
        func_def = @function_defs[name]?
        func_def ||= @function_defs[base]?
        next unless func_def
        def_id = func_def.object_id
        next if seen_defs.includes?(def_id)
        non_block_params = if params = func_def.params
                             params.count { |p| !p.is_block && !named_only_separator?(p) }
                           else
                             0
                           end
        next unless non_block_params == arg_count
        candidates << name
        seen_defs << def_id
      end

      return candidates.first if candidates.size == 1

      # Multiple candidates - prefer Object methods (base class) over more specialized ones
      # This handles cases like Object#tap vs Iterator#tap
      if candidates.size > 1
        return nil if receiver_base
        object_candidate = candidates.find { |c| c.starts_with?("Object#") }
        return object_candidate if object_candidate
        # Fallback: return first candidate anyway (better than nothing)
        return candidates.first
      end
      nil
    end

    # Infer return type for getter-style methods (single ivar access in body)
    # Returns the ivar type if the method body is just "@x", nil otherwise
    private def infer_getter_return_type(node : CrystalV2::Compiler::Frontend::DefNode, ivars : Array(IVarInfo)) : TypeRef?
      body = node.body
      return nil unless body && body.size == 1

      # Single expression in body - check if it's an ivar access
      body_node = @arena[body[0]]
      case body_node
      when CrystalV2::Compiler::Frontend::InstanceVarNode
        # Body is just "@x" - find the ivar type
        ivar_name = String.new(body_node.name)
        ivar_info = ivars.find { |iv| iv.name == ivar_name }
        return ivar_info.type if ivar_info && ivar_info.type != TypeRef::VOID
      end
      nil
    end

    # Helper to get type size in bytes
    private def type_size(type : TypeRef, c_context : Bool = false) : Int32
      case type
      when TypeRef::BOOL, TypeRef::INT8, TypeRef::UINT8
        1
      when TypeRef::INT16, TypeRef::UINT16
        2
      when TypeRef::INT32, TypeRef::UINT32, TypeRef::FLOAT32
        4
      when TypeRef::CHAR
        c_context ? 1 : 4 # C char = 1 byte, Crystal Char = 4 bytes
      when TypeRef::INT64, TypeRef::UINT64, TypeRef::FLOAT64
        8
      when TypeRef::INT128, TypeRef::UINT128
        16
      when TypeRef::VOID, TypeRef::NIL
        0 # Nil/Void has no storage size
      else
        # Check if it's a union type we've registered
        mir_type_ref = hir_to_mir_type_ref(type)
        if descriptor = @union_descriptors[mir_type_ref]?
          return descriptor.total_size
        end
        # Check if it's a struct (value type) with known layout
        if info = @class_info_by_type_id[type.id]?
          if info.is_struct && info.size > 0
            return info.size
          end
        end
        # Check for StaticArray(T, N) by type name
        type_name = get_type_name_from_ref(type)
        if type_name.starts_with?("StaticArray(")
          if sa_size = compute_static_array_byte_size(type_name, c_context)
            return sa_size
          end
        end
        8 # Pointer size for reference types
      end
    end

    # Compute byte size of StaticArray(T, N) from its type name
    private def compute_static_array_byte_size(type_name : String, c_context : Bool = false) : Int32?
      paren_start = type_name.index('(')
      return nil unless paren_start
      inner = type_name[(paren_start + 1)..-2] # Remove "StaticArray(" and ")"
      # Split on last comma to separate element type from count
      last_comma = inner.rindex(',')
      return nil unless last_comma
      elem_type_name = inner[0, last_comma].strip
      count_str = inner[(last_comma + 1)..].strip
      count = count_str.to_i?
      return nil unless count
      elem_type_ref = type_ref_for_name(elem_type_name)
      elem_size = type_size(elem_type_ref, c_context)
      return nil if elem_size <= 0
      count * elem_size
    end

    # Get natural alignment for a type (matches LLVM ABI alignment rules)
    private def type_alignment(type : TypeRef, c_context : Bool = false) : Int32
      case type
      when TypeRef::BOOL, TypeRef::INT8, TypeRef::UINT8
        1
      when TypeRef::INT16, TypeRef::UINT16
        2
      when TypeRef::INT32, TypeRef::UINT32, TypeRef::FLOAT32
        4
      when TypeRef::CHAR
        c_context ? 1 : 4
      when TypeRef::INT64, TypeRef::UINT64, TypeRef::FLOAT64
        8
      when TypeRef::INT128, TypeRef::UINT128
        16
      else
        8 # Pointer/reference types align to 8
      end
    end

    # Align offset to the given alignment boundary
    private def align_offset(offset : Int32, alignment : Int32) : Int32
      return offset if alignment <= 1
      remainder = offset % alignment
      remainder == 0 ? offset : offset + (alignment - remainder)
    end

    # Register a function signature (for forward reference support)
    # Call this for all functions before lowering any function bodies
    def register_function(node : CrystalV2::Compiler::Frontend::DefNode)
      base_name = String.new(node.name)
      if env_get("DEBUG_PUTS_REGISTER") && base_name == "puts"
        params_debug = node.params.try &.map do |param|
          name = param.name ? String.new(param.name.not_nil!) : "(anon)"
          type_name = param.type_annotation ? String.new(param.type_annotation.not_nil!) : ""
          flags = [] of String
          flags << "splat" if param.is_splat
          flags << "double_splat" if param.is_double_splat
          flags << "block" if param.is_block
          "#{name}:#{type_name}#{flags.empty? ? "" : "[#{flags.join(",")}]"}"
        end
        params_debug_str = params_debug ? params_debug.join("|") : ""
        STDERR.puts "[DEBUG_PUTS_REGISTER] name=#{base_name} params=#{params_debug_str}"
      end
      if debug_env_filter_match?("DEBUG_STRING_METHOD_LOWER", base_name)
        STDERR.puts "[DEBUG_REGISTER_FUNCTION] name=#{base_name} receiver=#{node.receiver ? String.new(node.receiver.not_nil!) : "(none)"} span=#{node.span.start_line}-#{node.span.end_line}"
      end
      if base_name == "main" && @current_class.nil? && !fun_def?(node)
        base_name = TOP_LEVEL_MAIN_BASE
        @top_level_main_defined = true
      end
      param_types = [] of TypeRef
      param_type_map = {} of String => TypeRef
      has_block = false

      old_typeof_locals = @current_typeof_locals
      @current_typeof_locals = param_type_map
      if params = node.params
        params.each do |param|
          next if named_only_separator?(param)
          if param.is_block
            has_block = true
            next
          end
          param_name = param.name.nil? ? "_" : String.new(param.name.not_nil!)
          param_type = if ta = param.type_annotation
                         type_ref_for_name(String.new(ta))
                       elsif param.is_double_splat
                         type_ref_for_name("NamedTuple")
                       else
                         TypeRef::VOID
                       end
          param_type_map[param_name] = param_type
          param_types << param_type
        end
      end
      if !has_block
        has_block = def_contains_yield?(node, @arena)
      end

      return_type = if rt = node.return_type
                      type_ref_for_name(String.new(rt))
                    else
                      TypeRef::VOID
                    end
      @current_typeof_locals = old_typeof_locals

      # Register with mangled name, except for stdlib fun main (C-ABI entrypoint).
      full_name = if fun_def?(node) && base_name == "main" && @current_class.nil?
                    base_name
                  else
                    function_full_name_for_def(base_name, param_types, node.params, has_block)
                  end
      register_function_type(full_name, return_type)

      # Store AST for potential inline expansion (use mangled name)
      @function_defs[full_name] = node
      @function_def_arenas[full_name] = @arena
      if should_register_base_name?(full_name, base_name, node, has_block)
        register_function_type(base_name, return_type)
        unless @function_defs.has_key?(base_name)
          @function_defs[base_name] = node
          @function_def_arenas[base_name] = @arena
        end
      end

      # Check if function contains yield
      if def_contains_yield?(node, @arena)
        @yield_functions.add(full_name)
        debug_hook("yield.register", full_name)
      end
    end

    # Check if expression list contains yield
    private def contains_yield?(body : Array(ExprId)) : Bool
      body.any? { |expr_id| contains_yield_in_expr?(expr_id) }
    end

    private def contains_block_call?(body : Array(ExprId), block_name : String) : Bool
      body.any? { |expr_id| contains_block_call_in_expr?(expr_id, block_name) }
    end

    private def macro_text_contains_yield?(text : String) : Bool
      idx = 0
      bytesize = text.bytesize
      while idx < bytesize
        pos = text.index("yield", idx)
        break unless pos
        before = pos == 0 ? 0_u8 : text.byte_at(pos - 1)
        after_pos = pos + 5
        after = after_pos >= bytesize ? 0_u8 : text.byte_at(after_pos)
        if !identifier_byte?(before) && !identifier_byte?(after)
          return true
        end
        idx = after_pos
      end
      false
    end

    private def identifier_byte?(byte : UInt8) : Bool
      (byte >= '0'.ord && byte <= '9'.ord) ||
        (byte >= 'A'.ord && byte <= 'Z'.ord) ||
        (byte >= 'a'.ord && byte <= 'z'.ord) ||
        byte == '_'.ord
    end

    private def macro_literal_contains_yield?(node : CrystalV2::Compiler::Frontend::MacroLiteralNode) : Bool
      if raw_text = macro_literal_raw_text(node)
        return true if macro_text_contains_yield?(raw_text)
      end
      node.pieces.each do |piece|
        case piece.kind
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::Expression
          if expr_id = piece.expr
            return true if contains_yield_in_expr?(expr_id)
          end
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::Text
          if text = piece.text
            return true if macro_text_contains_yield?(text)
          end
        else
          nil
        end
      end
      false
    end

    private def def_contains_yield?(node : CrystalV2::Compiler::Frontend::DefNode, arena : CrystalV2::Compiler::Frontend::ArenaLike) : Bool
      cache_key = node.object_id
      if cached = @yield_check_cache[cache_key]?
        return cached
      end
      result = def_contains_yield_uncached?(node, arena)
      @yield_check_cache[cache_key] = result
      result
    end

    private def def_contains_yield_uncached?(node : CrystalV2::Compiler::Frontend::DefNode, arena : CrystalV2::Compiler::Frontend::ArenaLike) : Bool
      return false unless body = node.body
      resolved_arena = arena_fits_def?(arena, node) ? arena : resolve_arena_for_def(node, arena)
      return true if with_arena(resolved_arena) { contains_yield?(body) }

      # Fallback: scan source spans for "yield" tokens when AST misses it (macro/recovery paths).
      if source = @sources_by_arena[resolved_arena]?
        if snippet = slice_source_for_span(node.span, source)
          has_macro = snippet.includes?("{%") || snippet.includes?("{{")
          if has_macro && macro_text_contains_yield?(snippet)
            return true
          end
        end
        body.each do |expr_id|
          snippet = slice_source_for_expr_in_arena(expr_id, resolved_arena, source)
          next unless snippet
          return true if macro_text_contains_yield?(snippet)
        end
      end
      false
    end

    private def def_contains_block_call?(node : CrystalV2::Compiler::Frontend::DefNode, arena : CrystalV2::Compiler::Frontend::ArenaLike) : Bool
      cache_key = node.object_id
      if cached = @block_call_check_cache[cache_key]?
        return cached
      end
      result = def_contains_block_call_uncached?(node, arena)
      @block_call_check_cache[cache_key] = result
      result
    end

    private def def_contains_block_call_uncached?(node : CrystalV2::Compiler::Frontend::DefNode, arena : CrystalV2::Compiler::Frontend::ArenaLike) : Bool
      params = node.params
      return false unless params
      block_param = params.find(&.is_block)
      return false unless block_param
      return false unless name_slice = block_param.name
      block_name = String.new(name_slice)
      return false if block_name.empty?
      return false unless body = node.body
      resolved_arena = arena_fits_def?(arena, node) ? arena : resolve_arena_for_def(node, arena)
      with_arena(resolved_arena) { contains_block_call?(body, block_name) }
    end

    private def def_accepts_block_param?(node : CrystalV2::Compiler::Frontend::DefNode) : Bool
      return false unless params = node.params
      params.any?(&.is_block)
    end

    # Check if expression list contains a return
    private def contains_return?(body : Array(ExprId)) : Bool
      body.any? { |expr_id| contains_return_in_expr?(expr_id) }
    end

    private def yield_return_only?(body : Array(ExprId)) : Bool
      return false if body.empty?
      return false unless tail_is_return?(body)
      saw_return = false
      ok = true
      body.each do |expr_id|
        saw, good = scan_return_yield(expr_id)
        saw_return ||= saw
        ok &&= good
        break unless ok
      end
      saw_return && ok
    end

    private def tail_is_return?(body : Array(ExprId)) : Bool
      return false if body.empty?
      expr_id = body.last
      loop do
        expr_node = @arena[expr_id]
        case expr_node
        when CrystalV2::Compiler::Frontend::GroupingNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::MacroExpressionNode
          expr_id = expr_node.expression
        else
          return expr_node.is_a?(CrystalV2::Compiler::Frontend::ReturnNode)
        end
      end
    end

    private def yield_return_expr?(expr_id : ExprId) : Bool
      loop do
        expr_node = @arena[expr_id]
        case expr_node
        when CrystalV2::Compiler::Frontend::GroupingNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::MacroExpressionNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::YieldNode
          return true
        when CrystalV2::Compiler::Frontend::CallNode
          callee = @arena[expr_node.callee]
          return callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
            String.new(callee.name) == "yield"
        else
          return false
        end
      end
    end

    private def scan_return_yield(expr_id : ExprId) : {Bool, Bool}
      expr_node = @arena[expr_id]
      case expr_node
      when CrystalV2::Compiler::Frontend::ReturnNode
        if value = expr_node.value
          return {true, yield_return_expr?(value)}
        end
        return {true, false}
      when CrystalV2::Compiler::Frontend::IfNode
        saw = false
        ok = true
        expr_node.then_body.each do |child|
          child_saw, child_ok = scan_return_yield(child)
          saw ||= child_saw
          ok &&= child_ok
        end
        if elsifs = expr_node.elsifs
          elsifs.each do |branch|
            branch.body.each do |child|
              child_saw, child_ok = scan_return_yield(child)
              saw ||= child_saw
              ok &&= child_ok
            end
          end
        end
        if else_body = expr_node.else_body
          else_body.each do |child|
            child_saw, child_ok = scan_return_yield(child)
            saw ||= child_saw
            ok &&= child_ok
          end
        end
        return {saw, ok}
      when CrystalV2::Compiler::Frontend::CaseNode
        saw = false
        ok = true
        expr_node.when_branches.each do |branch|
          branch.body.each do |child|
            child_saw, child_ok = scan_return_yield(child)
            saw ||= child_saw
            ok &&= child_ok
          end
        end
        if else_branch = expr_node.else_branch
          else_branch.each do |child|
            child_saw, child_ok = scan_return_yield(child)
            saw ||= child_saw
            ok &&= child_ok
          end
        end
        if in_branches = expr_node.in_branches
          in_branches.each do |branch|
            branch.body.each do |child|
              child_saw, child_ok = scan_return_yield(child)
              saw ||= child_saw
              ok &&= child_ok
            end
          end
        end
        return {saw, ok}
      when CrystalV2::Compiler::Frontend::BeginNode
        saw = false
        ok = true
        expr_node.body.each do |child|
          child_saw, child_ok = scan_return_yield(child)
          saw ||= child_saw
          ok &&= child_ok
        end
        if clauses = expr_node.rescue_clauses
          clauses.each do |clause|
            clause.body.each do |child|
              child_saw, child_ok = scan_return_yield(child)
              saw ||= child_saw
              ok &&= child_ok
            end
          end
        end
        if else_body = expr_node.else_body
          else_body.each do |child|
            child_saw, child_ok = scan_return_yield(child)
            saw ||= child_saw
            ok &&= child_ok
          end
        end
        if ensure_body = expr_node.ensure_body
          ensure_body.each do |child|
            child_saw, child_ok = scan_return_yield(child)
            saw ||= child_saw
            ok &&= child_ok
          end
        end
        return {saw, ok}
      when CrystalV2::Compiler::Frontend::BlockNode
        if body = expr_node.body
          saw = false
          ok = true
          body.each do |child|
            child_saw, child_ok = scan_return_yield(child)
            saw ||= child_saw
            ok &&= child_ok
          end
          return {saw, ok}
        end
      when CrystalV2::Compiler::Frontend::LoopNode
        saw = false
        ok = true
        expr_node.body.each do |child|
          child_saw, child_ok = scan_return_yield(child)
          saw ||= child_saw
          ok &&= child_ok
        end
        return {saw, ok}
      when CrystalV2::Compiler::Frontend::ForNode
        saw = false
        ok = true
        expr_node.body.each do |child|
          child_saw, child_ok = scan_return_yield(child)
          saw ||= child_saw
          ok &&= child_ok
        end
        return {saw, ok}
      end
      {false, true}
    end

    private def yield_return_function?(name : String) : Bool
      return true if @yield_return_functions.includes?(name)
      return false if @yield_return_checked.includes?(name)
      @yield_return_checked.add(name)
      if def_node = @function_defs[name]?
        if body = def_node.body
          arena = @function_def_arenas[name]? || @arena
          with_arena(arena) do
            if yield_return_only?(body)
              @yield_return_functions.add(name)
              STDERR.puts "[YIELD_RETURN] mark=#{name}" if env_get("DEBUG_YIELD_RETURN")
            end
          end
        end
      end
      @yield_return_functions.includes?(name)
    end

    private def yield_return_function_for_call(mangled_name : String, base_name : String) : Bool
      result = yield_return_function?(mangled_name) || yield_return_function?(base_name)
      if mangled_base = strip_type_suffix(mangled_name)
        result ||= yield_return_function?(mangled_base)
      end
      STDERR.puts "[YIELD_RETURN] call mangled=#{mangled_name} base=#{base_name} result=#{result}" if env_get("DEBUG_YIELD_RETURN")
      result
    end

    private def yield_function_name_for(method_name : String) : String?
      @yield_name_cache.fetch(method_name) do
        result = yield_function_name_for_uncached(method_name)
        @yield_name_cache[method_name] = result
        result
      end
    end

    private def yield_function_name_for_uncached(method_name : String) : String?
      return method_name if @yield_functions.includes?(method_name)

      parts = parse_method_name_compact(method_name)
      base_name = parts.base
      return base_name if @yield_functions.includes?(base_name)

      stripped = strip_generic_receiver_from_base_name(base_name)
      return stripped if @yield_functions.includes?(stripped)

      # Use pre-built stripped name map instead of O(N) loop
      if @yield_functions.size != @yield_functions_stripped_map_size
        rebuild_yield_functions_stripped_map
      end
      if found = @yield_functions_stripped_map[stripped]?
        return found
      end

      nil
    end

    private def rebuild_yield_functions_stripped_map : Nil
      map = @yield_functions_stripped_map
      map.clear
      @yield_functions.each do |name|
        parts = parse_method_name_compact(name)
        stripped = strip_generic_receiver_from_base_name(parts.base)
        map[stripped] = name unless map.has_key?(stripped)
      end
      @yield_functions_stripped_map_size = @yield_functions.size
    end

    private def infer_ivars_from_body(body : Array(ExprId), ivars : Array(IVarInfo), offset_ref : Pointer(Int32)) : Nil
      body.each { |expr_id| infer_ivars_from_expr(expr_id, ivars, offset_ref) }
    end

    private def update_getter_return_types_for_ivar(class_name : String, ivar_name : String, inferred : TypeRef) : Nil
      return if inferred == TypeRef::VOID

      accessor_name = ivar_name.lstrip('@')
      ["#{class_name}##{accessor_name}", "#{class_name}##{accessor_name}?"].each do |base_name|
        full_name = mangle_function_name(base_name, [] of TypeRef)
        if existing = @function_types[full_name]?
          if existing == TypeRef::VOID || existing == TypeRef::NIL
            if env_get("DEBUG_IVAR_GETTER_UPDATE")
              STDERR.puts "[IVAR_GETTER_UPDATE] class=#{class_name} ivar=#{ivar_name} getter=#{full_name} from=#{get_type_name_from_ref(existing)} to=#{get_type_name_from_ref(inferred)}"
            end
            register_function_type(full_name, inferred)
          end
        end
      end
    end

    private def infer_ivars_from_expr(expr_id : ExprId, ivars : Array(IVarInfo), offset_ref : Pointer(Int32)) : Nil
      return if expr_id.invalid?
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::AssignNode
        target_node = @arena[node.target]
        if target_node.is_a?(CrystalV2::Compiler::Frontend::InstanceVarNode)
          ivar_name = String.new(target_node.name)
          value_node = @arena[node.value]
          inferred = infer_type_from_class_ivar_assign(value_node)
          if env_has?("DEBUG_IVAR_INFER")
            inferred_name = inferred == TypeRef::VOID ? "Void" : get_type_name_from_ref(inferred)
            STDERR.puts "[IVAR_INFER] class=#{@current_class || ""} ivar=#{ivar_name} inferred=#{inferred_name}"
          end
          if inferred != TypeRef::VOID
            if idx = ivars.index { |iv| iv.name == ivar_name }
              if ivars[idx].type == TypeRef::VOID
                ivars[idx] = IVarInfo.new(ivar_name, inferred, ivars[idx].offset)
                if class_name = @current_class
                  update_getter_return_types_for_ivar(class_name, ivar_name, inferred)
                end
              end
            else
              ivars << IVarInfo.new(ivar_name, inferred, offset_ref.value)
              offset_ref.value += type_size(inferred)
              if class_name = @current_class
                update_getter_return_types_for_ivar(class_name, ivar_name, inferred)
              end
            end
          end
        end
        infer_ivars_from_expr(node.value, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::ReturnNode
        node.value ? infer_ivars_from_expr(node.value.not_nil!, ivars, offset_ref) : nil
      when CrystalV2::Compiler::Frontend::IfNode
        infer_ivars_from_expr(node.condition, ivars, offset_ref)
        infer_ivars_from_body(node.then_body, ivars, offset_ref)
        infer_ivars_from_body(node.else_body.not_nil!, ivars, offset_ref) if node.else_body
      when CrystalV2::Compiler::Frontend::UnlessNode
        infer_ivars_from_expr(node.condition, ivars, offset_ref)
        infer_ivars_from_body(node.then_branch, ivars, offset_ref)
        infer_ivars_from_body(node.else_branch.not_nil!, ivars, offset_ref) if node.else_branch
      when CrystalV2::Compiler::Frontend::WhileNode
        infer_ivars_from_expr(node.condition, ivars, offset_ref)
        infer_ivars_from_body(node.body, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::UntilNode
        infer_ivars_from_expr(node.condition, ivars, offset_ref)
        infer_ivars_from_body(node.body, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::LoopNode
        infer_ivars_from_body(node.body, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::BlockNode
        infer_ivars_from_body(node.body, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::ProcLiteralNode
        infer_ivars_from_body(node.body, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::CaseNode
        node.when_branches.each { |w| infer_ivars_from_body(w.body, ivars, offset_ref) }
        infer_ivars_from_body(node.else_branch.not_nil!, ivars, offset_ref) if node.else_branch
      when CrystalV2::Compiler::Frontend::CallNode
        node.args.each { |arg| infer_ivars_from_expr(arg, ivars, offset_ref) }
        if block_id = node.block
          infer_ivars_from_expr(block_id, ivars, offset_ref)
        end
        if named = node.named_args
          named.each { |na| infer_ivars_from_expr(na.value, ivars, offset_ref) }
        end
      when CrystalV2::Compiler::Frontend::GroupingNode
        infer_ivars_from_expr(node.expression, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        infer_ivars_from_expr(node.expression, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::UnaryNode
        infer_ivars_from_expr(node.operand, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::BinaryNode
        infer_ivars_from_expr(node.left, ivars, offset_ref)
        infer_ivars_from_expr(node.right, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::IndexNode
        infer_ivars_from_expr(node.object, ivars, offset_ref)
        node.indexes.each { |idx| infer_ivars_from_expr(idx, ivars, offset_ref) }
      when CrystalV2::Compiler::Frontend::RangeNode
        infer_ivars_from_expr(node.begin_expr, ivars, offset_ref)
        infer_ivars_from_expr(node.end_expr, ivars, offset_ref)
      end
    end

    private def collect_yield_arg_lists(body : Array(ExprId), lists : Array(Array(ExprId))) : Nil
      body.each { |expr_id| collect_yield_arg_lists(expr_id, lists) }
    end

    private def collect_yield_arg_lists(expr_id : ExprId, lists : Array(Array(ExprId))) : Nil
      return if expr_id.invalid?
      node = node_for_expr(expr_id)
      return unless node

      case node
      when CrystalV2::Compiler::Frontend::YieldNode
        if args = node.args
          lists << args
        else
          lists << [] of ExprId
        end
      when CrystalV2::Compiler::Frontend::AssignNode
        collect_yield_arg_lists(node.target, lists)
        collect_yield_arg_lists(node.value, lists)
      when CrystalV2::Compiler::Frontend::MultipleAssignNode
        node.targets.each { |target| collect_yield_arg_lists(target, lists) }
        collect_yield_arg_lists(node.value, lists)
      when CrystalV2::Compiler::Frontend::ReturnNode
        collect_yield_arg_lists(node.value.not_nil!, lists) if node.value
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        collect_yield_arg_lists(node.object, lists)
      when CrystalV2::Compiler::Frontend::CallNode
        if callee_id = node.callee
          callee_node = node_for_expr(callee_id)
          if callee_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            lists << node.args if String.new(callee_node.name) == "yield"
          end
          collect_yield_arg_lists(callee_id, lists)
        end
        node.args.each { |arg| collect_yield_arg_lists(arg, lists) }
        if block_id = node.block
          collect_yield_arg_lists(block_id, lists)
        end
        if named = node.named_args
          named.each { |na| collect_yield_arg_lists(na.value, lists) }
        end
      when CrystalV2::Compiler::Frontend::UnaryNode
        collect_yield_arg_lists(node.operand, lists)
      when CrystalV2::Compiler::Frontend::BinaryNode
        collect_yield_arg_lists(node.left, lists)
        collect_yield_arg_lists(node.right, lists)
      when CrystalV2::Compiler::Frontend::TernaryNode
        collect_yield_arg_lists(node.condition, lists)
        collect_yield_arg_lists(node.true_branch, lists)
        collect_yield_arg_lists(node.false_branch, lists)
      when CrystalV2::Compiler::Frontend::GroupingNode
        collect_yield_arg_lists(node.expression, lists)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        collect_yield_arg_lists(node.expression, lists)
      when CrystalV2::Compiler::Frontend::ConstantNode
        collect_yield_arg_lists(node.value, lists)
      when CrystalV2::Compiler::Frontend::IfNode
        collect_yield_arg_lists(node.condition, lists)
        collect_yield_arg_lists(node.then_body, lists)
        if elsifs = node.elsifs
          elsifs.each do |branch|
            collect_yield_arg_lists(branch.condition, lists)
            collect_yield_arg_lists(branch.body, lists)
          end
        end
        collect_yield_arg_lists(node.else_body.not_nil!, lists) if node.else_body
      when CrystalV2::Compiler::Frontend::UnlessNode
        collect_yield_arg_lists(node.condition, lists)
        collect_yield_arg_lists(node.then_branch, lists)
        collect_yield_arg_lists(node.else_branch.not_nil!, lists) if node.else_branch
      when CrystalV2::Compiler::Frontend::WhileNode
        collect_yield_arg_lists(node.condition, lists)
        collect_yield_arg_lists(node.body, lists)
      when CrystalV2::Compiler::Frontend::UntilNode
        collect_yield_arg_lists(node.condition, lists)
        collect_yield_arg_lists(node.body, lists)
      when CrystalV2::Compiler::Frontend::LoopNode
        collect_yield_arg_lists(node.body, lists)
      when CrystalV2::Compiler::Frontend::BlockNode
        collect_yield_arg_lists(node.body, lists)
      when CrystalV2::Compiler::Frontend::ProcLiteralNode
        collect_yield_arg_lists(node.body, lists)
      when CrystalV2::Compiler::Frontend::CaseNode
        node.when_branches.each { |w| collect_yield_arg_lists(w.body, lists) }
        collect_yield_arg_lists(node.else_branch.not_nil!, lists) if node.else_branch
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        node.elements.each { |el| collect_yield_arg_lists(el, lists) }
        collect_yield_arg_lists(node.of_type.not_nil!, lists) if node.of_type
      when CrystalV2::Compiler::Frontend::TupleLiteralNode
        node.elements.each { |el| collect_yield_arg_lists(el, lists) }
      when CrystalV2::Compiler::Frontend::HashLiteralNode
        node.entries.each do |entry|
          collect_yield_arg_lists(entry.key, lists)
          collect_yield_arg_lists(entry.value, lists)
        end
      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        node.entries.each { |entry| collect_yield_arg_lists(entry.value, lists) }
      when CrystalV2::Compiler::Frontend::StringInterpolationNode
        node.pieces.each do |piece|
          if piece.kind == CrystalV2::Compiler::Frontend::StringPiece::Kind::Expression && piece.expr
            collect_yield_arg_lists(piece.expr.not_nil!, lists)
          end
        end
      when CrystalV2::Compiler::Frontend::IndexNode
        collect_yield_arg_lists(node.object, lists)
        node.indexes.each { |idx| collect_yield_arg_lists(idx, lists) }
      when CrystalV2::Compiler::Frontend::RangeNode
        collect_yield_arg_lists(node.begin_expr, lists)
        collect_yield_arg_lists(node.end_expr, lists)
      when CrystalV2::Compiler::Frontend::BeginNode
        collect_yield_arg_lists(node.body, lists)
        if clauses = node.rescue_clauses
          clauses.each { |cl| collect_yield_arg_lists(cl.body, lists) }
        end
        collect_yield_arg_lists(node.else_body.not_nil!, lists) if node.else_body
        collect_yield_arg_lists(node.ensure_body.not_nil!, lists) if node.ensure_body
      end
    end

    private def contains_yield_in_expr?(expr_id : ExprId) : Bool
      return false if expr_id.invalid?
      node = node_for_expr(expr_id)
      return false unless node
      case node
      when CrystalV2::Compiler::Frontend::YieldNode
        true
      when CrystalV2::Compiler::Frontend::AssignNode
        contains_yield_in_expr?(node.target) || contains_yield_in_expr?(node.value)
      when CrystalV2::Compiler::Frontend::MultipleAssignNode
        return true if contains_yield_in_expr?(node.value)
        node.targets.any? { |target| contains_yield_in_expr?(target) }
      when CrystalV2::Compiler::Frontend::ReturnNode
        node.value ? contains_yield_in_expr?(node.value.not_nil!) : false
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        contains_yield_in_expr?(node.object)
      when CrystalV2::Compiler::Frontend::CallNode
        if callee_id = node.callee
          callee_node = node_for_expr(callee_id)
          if callee_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            return true if String.new(callee_node.name) == "yield"
          end
          return true if contains_yield_in_expr?(callee_id)
        end
        node.args.each do |arg|
          return true if contains_yield_in_expr?(arg)
        end
        if block_id = node.block
          return true if contains_yield_in_expr?(block_id)
        end
        if named = node.named_args
          named.each do |na|
            return true if contains_yield_in_expr?(na.value)
          end
        end
        false
      when CrystalV2::Compiler::Frontend::UnaryNode
        contains_yield_in_expr?(node.operand)
      when CrystalV2::Compiler::Frontend::BinaryNode
        contains_yield_in_expr?(node.left) || contains_yield_in_expr?(node.right)
      when CrystalV2::Compiler::Frontend::TernaryNode
        contains_yield_in_expr?(node.condition) ||
          contains_yield_in_expr?(node.true_branch) ||
          contains_yield_in_expr?(node.false_branch)
      when CrystalV2::Compiler::Frontend::GroupingNode
        contains_yield_in_expr?(node.expression)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        contains_yield_in_expr?(node.expression)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        return true if contains_yield_in_expr?(node.condition)
        return true if contains_yield_in_expr?(node.then_body)
        if node.else_body
          return true if contains_yield_in_expr?(node.else_body.not_nil!)
        end
        false
      when CrystalV2::Compiler::Frontend::MacroForNode
        return true if contains_yield_in_expr?(node.iterable)
        contains_yield_in_expr?(node.body)
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        macro_literal_contains_yield?(node)
      when CrystalV2::Compiler::Frontend::ConstantNode
        contains_yield_in_expr?(node.value)
      when CrystalV2::Compiler::Frontend::IfNode
        contains_yield_in_expr?(node.condition) ||
          contains_yield?(node.then_body) ||
          (node.elsifs && node.elsifs.not_nil!.any? do |branch|
            contains_yield_in_expr?(branch.condition) || contains_yield?(branch.body)
          end) ||
          (node.else_body ? contains_yield?(node.else_body.not_nil!) : false)
      when CrystalV2::Compiler::Frontend::UnlessNode
        contains_yield_in_expr?(node.condition) ||
          contains_yield?(node.then_branch) ||
          (node.else_branch ? contains_yield?(node.else_branch.not_nil!) : false)
      when CrystalV2::Compiler::Frontend::WhileNode
        contains_yield_in_expr?(node.condition) || contains_yield?(node.body)
      when CrystalV2::Compiler::Frontend::UntilNode
        contains_yield_in_expr?(node.condition) || contains_yield?(node.body)
      when CrystalV2::Compiler::Frontend::LoopNode
        contains_yield?(node.body)
      when CrystalV2::Compiler::Frontend::BlockNode
        contains_yield?(node.body)
      when CrystalV2::Compiler::Frontend::ProcLiteralNode
        contains_yield?(node.body)
      when CrystalV2::Compiler::Frontend::CaseNode
        node.when_branches.any? { |w| contains_yield?(w.body) } ||
          (node.else_branch ? contains_yield?(node.else_branch.not_nil!) : false)
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        return true if node.elements.any? { |el| contains_yield_in_expr?(el) }
        node.of_type ? contains_yield_in_expr?(node.of_type.not_nil!) : false
      when CrystalV2::Compiler::Frontend::TupleLiteralNode
        node.elements.any? { |el| contains_yield_in_expr?(el) }
      when CrystalV2::Compiler::Frontend::HashLiteralNode
        node.entries.any? do |entry|
          contains_yield_in_expr?(entry.key) || contains_yield_in_expr?(entry.value)
        end
      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        node.entries.any? { |entry| contains_yield_in_expr?(entry.value) }
      when CrystalV2::Compiler::Frontend::StringInterpolationNode
        node.pieces.any? do |piece|
          piece.kind == CrystalV2::Compiler::Frontend::StringPiece::Kind::Expression &&
            piece.expr && contains_yield_in_expr?(piece.expr.not_nil!)
        end
      when CrystalV2::Compiler::Frontend::IndexNode
        return true if contains_yield_in_expr?(node.object)
        node.indexes.any? { |idx| contains_yield_in_expr?(idx) }
      when CrystalV2::Compiler::Frontend::RangeNode
        contains_yield_in_expr?(node.begin_expr) || contains_yield_in_expr?(node.end_expr)
      when CrystalV2::Compiler::Frontend::BeginNode
        return true if contains_yield?(node.body)
        if clauses = node.rescue_clauses
          return true if clauses.any? { |cl| contains_yield?(cl.body) }
        end
        return true if node.else_body && contains_yield?(node.else_body.not_nil!)
        return true if node.ensure_body && contains_yield?(node.ensure_body.not_nil!)
        false
      else
        false
      end
    end

    private def contains_block_call_in_expr?(expr_id : ExprId, block_name : String) : Bool
      return false if expr_id.invalid?
      node = node_for_expr(expr_id)
      return false unless node
      case node
      when CrystalV2::Compiler::Frontend::AssignNode
        contains_block_call_in_expr?(node.target, block_name) || contains_block_call_in_expr?(node.value, block_name)
      when CrystalV2::Compiler::Frontend::MultipleAssignNode
        return true if contains_block_call_in_expr?(node.value, block_name)
        node.targets.any? { |target| contains_block_call_in_expr?(target, block_name) }
      when CrystalV2::Compiler::Frontend::ReturnNode
        node.value ? contains_block_call_in_expr?(node.value.not_nil!, block_name) : false
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        contains_block_call_in_expr?(node.object, block_name)
      when CrystalV2::Compiler::Frontend::CallNode
        if callee_id = node.callee
          callee_node = node_for_expr(callee_id)
          if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
            if String.new(callee_node.member) == "call"
              obj_node = node_for_expr(callee_node.object)
              if obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
                 String.new(obj_node.name) == block_name
                return true
              end
            end
          end
          return true if contains_block_call_in_expr?(callee_id, block_name)
        end
        node.args.each do |arg|
          return true if contains_block_call_in_expr?(arg, block_name)
        end
        if block_id = node.block
          return true if contains_block_call_in_expr?(block_id, block_name)
        end
        if named = node.named_args
          named.each do |na|
            return true if contains_block_call_in_expr?(na.value, block_name)
          end
        end
        false
      when CrystalV2::Compiler::Frontend::UnaryNode
        contains_block_call_in_expr?(node.operand, block_name)
      when CrystalV2::Compiler::Frontend::BinaryNode
        contains_block_call_in_expr?(node.left, block_name) || contains_block_call_in_expr?(node.right, block_name)
      when CrystalV2::Compiler::Frontend::TernaryNode
        contains_block_call_in_expr?(node.condition, block_name) ||
          contains_block_call_in_expr?(node.true_branch, block_name) ||
          contains_block_call_in_expr?(node.false_branch, block_name)
      when CrystalV2::Compiler::Frontend::GroupingNode
        contains_block_call_in_expr?(node.expression, block_name)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        contains_block_call_in_expr?(node.expression, block_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        return true if contains_block_call_in_expr?(node.condition, block_name)
        return true if contains_block_call_in_expr?(node.then_body, block_name)
        if node.else_body
          return true if contains_block_call_in_expr?(node.else_body.not_nil!, block_name)
        end
        false
      when CrystalV2::Compiler::Frontend::MacroForNode
        return true if contains_block_call_in_expr?(node.iterable, block_name)
        contains_block_call_in_expr?(node.body, block_name)
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        macro_literal_contains_yield?(node)
      when CrystalV2::Compiler::Frontend::ConstantNode
        contains_block_call_in_expr?(node.value, block_name)
      when CrystalV2::Compiler::Frontend::IfNode
        contains_block_call_in_expr?(node.condition, block_name) ||
          contains_block_call?(node.then_body, block_name) ||
          (node.elsifs && node.elsifs.not_nil!.any? do |branch|
            contains_block_call_in_expr?(branch.condition, block_name) || contains_block_call?(branch.body, block_name)
          end) ||
          (node.else_body ? contains_block_call?(node.else_body.not_nil!, block_name) : false)
      when CrystalV2::Compiler::Frontend::UnlessNode
        contains_block_call_in_expr?(node.condition, block_name) ||
          contains_block_call?(node.then_branch, block_name) ||
          (node.else_branch ? contains_block_call?(node.else_branch.not_nil!, block_name) : false)
      when CrystalV2::Compiler::Frontend::WhileNode
        contains_block_call_in_expr?(node.condition, block_name) || contains_block_call?(node.body, block_name)
      when CrystalV2::Compiler::Frontend::UntilNode
        contains_block_call_in_expr?(node.condition, block_name) || contains_block_call?(node.body, block_name)
      when CrystalV2::Compiler::Frontend::LoopNode
        contains_block_call?(node.body, block_name)
      when CrystalV2::Compiler::Frontend::BlockNode
        contains_block_call?(node.body, block_name)
      when CrystalV2::Compiler::Frontend::ProcLiteralNode
        contains_block_call?(node.body, block_name)
      when CrystalV2::Compiler::Frontend::CaseNode
        node.when_branches.any? { |w| contains_block_call?(w.body, block_name) } ||
          (node.else_branch ? contains_block_call?(node.else_branch.not_nil!, block_name) : false)
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        return true if node.elements.any? { |el| contains_block_call_in_expr?(el, block_name) }
        node.of_type ? contains_block_call_in_expr?(node.of_type.not_nil!, block_name) : false
      when CrystalV2::Compiler::Frontend::TupleLiteralNode
        node.elements.any? { |el| contains_block_call_in_expr?(el, block_name) }
      when CrystalV2::Compiler::Frontend::HashLiteralNode
        node.entries.any? do |entry|
          contains_block_call_in_expr?(entry.key, block_name) || contains_block_call_in_expr?(entry.value, block_name)
        end
      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        node.entries.any? { |entry| contains_block_call_in_expr?(entry.value, block_name) }
      when CrystalV2::Compiler::Frontend::StringInterpolationNode
        node.pieces.any? do |piece|
          piece.kind == CrystalV2::Compiler::Frontend::StringPiece::Kind::Expression &&
            piece.expr && contains_block_call_in_expr?(piece.expr.not_nil!, block_name)
        end
      when CrystalV2::Compiler::Frontend::IndexNode
        return true if contains_block_call_in_expr?(node.object, block_name)
        node.indexes.any? { |idx| contains_block_call_in_expr?(idx, block_name) }
      when CrystalV2::Compiler::Frontend::RangeNode
        contains_block_call_in_expr?(node.begin_expr, block_name) || contains_block_call_in_expr?(node.end_expr, block_name)
      when CrystalV2::Compiler::Frontend::BeginNode
        return true if contains_block_call?(node.body, block_name)
        if clauses = node.rescue_clauses
          return true if clauses.any? { |cl| contains_block_call?(cl.body, block_name) }
        end
        return true if node.else_body && contains_block_call?(node.else_body.not_nil!, block_name)
        return true if node.ensure_body && contains_block_call?(node.ensure_body.not_nil!, block_name)
        false
      else
        false
      end
    end

    private def contains_return_in_expr?(expr_id : ExprId) : Bool
      return false if expr_id.invalid?
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::ReturnNode
        true
      when CrystalV2::Compiler::Frontend::AssignNode
        contains_return_in_expr?(node.target) || contains_return_in_expr?(node.value)
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        contains_return_in_expr?(node.object)
      when CrystalV2::Compiler::Frontend::CallNode
        if callee_id = node.callee
          return true if contains_return_in_expr?(callee_id)
        end
        if args = node.args
          args.each do |arg|
            return true if contains_return_in_expr?(arg)
          end
        end
        if block_id = node.block
          return true if contains_return_in_expr?(block_id)
        end
        if named = node.named_args
          named.each do |na|
            return true if contains_return_in_expr?(na.value)
          end
        end
        false
      when CrystalV2::Compiler::Frontend::UnaryNode
        contains_return_in_expr?(node.operand)
      when CrystalV2::Compiler::Frontend::BinaryNode
        contains_return_in_expr?(node.left) || contains_return_in_expr?(node.right)
      when CrystalV2::Compiler::Frontend::GroupingNode
        contains_return_in_expr?(node.expression)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        contains_return_in_expr?(node.expression)
      when CrystalV2::Compiler::Frontend::IfNode
        contains_return_in_expr?(node.condition) ||
          contains_return?(node.then_body) ||
          (node.elsifs && node.elsifs.not_nil!.any? do |branch|
            contains_return_in_expr?(branch.condition) || contains_return?(branch.body)
          end) ||
          (node.else_body ? contains_return?(node.else_body.not_nil!) : false)
      when CrystalV2::Compiler::Frontend::UnlessNode
        contains_return_in_expr?(node.condition) ||
          contains_return?(node.then_branch) ||
          (node.else_branch ? contains_return?(node.else_branch.not_nil!) : false)
      when CrystalV2::Compiler::Frontend::WhileNode
        contains_return_in_expr?(node.condition) || contains_return?(node.body)
      when CrystalV2::Compiler::Frontend::UntilNode
        contains_return_in_expr?(node.condition) || contains_return?(node.body)
      when CrystalV2::Compiler::Frontend::LoopNode
        contains_return?(node.body)
      when CrystalV2::Compiler::Frontend::BlockNode
        contains_return?(node.body)
      when CrystalV2::Compiler::Frontend::ProcLiteralNode
        contains_return?(node.body)
      when CrystalV2::Compiler::Frontend::CaseNode
        node.when_branches.any? { |w| contains_return?(w.body) } ||
          (node.else_branch ? contains_return?(node.else_branch.not_nil!) : false)
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        return true if node.elements.any? { |el| contains_return_in_expr?(el) }
        node.of_type ? contains_return_in_expr?(node.of_type.not_nil!) : false
      when CrystalV2::Compiler::Frontend::TupleLiteralNode
        node.elements.any? { |el| contains_return_in_expr?(el) }
      when CrystalV2::Compiler::Frontend::HashLiteralNode
        node.entries.any? do |entry|
          contains_return_in_expr?(entry.key) || contains_return_in_expr?(entry.value)
        end
      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        node.entries.any? { |entry| contains_return_in_expr?(entry.value) }
      when CrystalV2::Compiler::Frontend::StringInterpolationNode
        node.pieces.any? do |piece|
          piece.kind == CrystalV2::Compiler::Frontend::StringPiece::Kind::Expression &&
            piece.expr && contains_return_in_expr?(piece.expr.not_nil!)
        end
      when CrystalV2::Compiler::Frontend::IndexNode
        return true if contains_return_in_expr?(node.object)
        node.indexes.any? { |idx| contains_return_in_expr?(idx) }
      when CrystalV2::Compiler::Frontend::RangeNode
        contains_return_in_expr?(node.begin_expr) || contains_return_in_expr?(node.end_expr)
      when CrystalV2::Compiler::Frontend::BeginNode
        return true if contains_return?(node.body)
        if clauses = node.rescue_clauses
          return true if clauses.any? { |cl| contains_return?(cl.body) }
        end
        return true if node.else_body && contains_return?(node.else_body.not_nil!)
        return true if node.ensure_body && contains_return?(node.ensure_body.not_nil!)
        false
      else
        false
      end
    end

    # Check if a module method exists (with any signature - for module detection)
    private def is_module_method?(module_name : String, method_name : String) : Bool
      base_name = "#{module_name}.#{method_name}"
      # O(1) lookup: check exact match or mangled version exists
      @function_types.has_key?(base_name) || has_function_base?(base_name)
    end

    private def lookup_function_def_for_return(
      name : String,
      base_name : String,
    ) : CrystalV2::Compiler::Frontend::DefNode?
      @function_defs[name]? || @function_defs[base_name]? || begin
        stripped_name = strip_generic_receiver_from_base_name(name)
        stripped_base = strip_generic_receiver_from_base_name(base_name)
        @function_defs[stripped_name]? || @function_defs[stripped_base]?
      end
    end

    # Return type shortcuts for ultra-common methods that are always the same
    # regardless of receiver type. Avoids expensive force_lower_function_for_return_type.
    private def well_known_method_return_type(base_name : String) : TypeRef?
      # Extract method name after the last '#'
      hash_idx = base_name.rindex('#')
      return nil unless hash_idx
      method_name = base_name[(hash_idx + 1)..]
      case method_name
      when "to_s", "inspect", "to_unsafe_s", "pretty_inspect"
        TypeRef::STRING
      when "hash"
        # Crystal's hash method signature: hash(hasher : Hasher) → Hasher
        # But standalone hash → UInt64. Check if it has a Hasher param.
        nil # Skip — hash return type varies
      when "==", "!=", "<", ">", "<=", ">=", "empty?", "nil?",
           "is_a?", "responds_to?", "none?", "any?", "all?",
           "includes?", "has_key?", "ascii?", "uppercase?", "lowercase?",
           "blank?", "presence?", "valid?", "zero?", "positive?", "negative?",
           "even?", "odd?", "finite?", "infinite?", "nan?"
        TypeRef::BOOL
      when "size", "length", "bytesize", "count"
        TypeRef::INT32
      when "object_id"
        TypeRef::UINT64
      when "class"
        TypeRef::STRING # .class in our compiler returns the class name string
      else
        nil
      end
    end

    # Look up return type of a function by name
    private def get_function_return_type(name : String) : TypeRef
      base_name = strip_type_suffix(name)
      if debug_name = env_get("DEBUG_GET_RETURN")
        if name.includes?(debug_name) || base_name.includes?(debug_name)
          func_type = @function_types[name]?
          base_type = @function_types[base_name]?
          func_rt = @module.function_by_name(name).try(&.return_type)
          STDERR.puts "[GET_RETURN] name=#{name} base=#{base_name} func_type=#{func_type ? get_type_name_from_ref(func_type) : "(nil)"} base_type=#{base_type ? get_type_name_from_ref(base_type) : "(nil)"} module_rt=#{func_rt ? get_type_name_from_ref(func_rt) : "(nil)"}"
        end
      end
      existing_type = @function_types[name]?
      if existing_type && existing_type != TypeRef::VOID
        if def_node = lookup_function_def_for_return(name, base_name)
          if def_node.return_type
            if resolved = resolve_return_type_from_def(name, base_name, nil)
              if resolved != TypeRef::VOID && resolved != existing_type
                @function_types[name] = resolved
                @function_base_return_types[base_name] = resolved unless base_name.includes?('$')
                existing_type = resolved
              end
            end
          end
        end
      end
      if existing_type == TypeRef::VOID
        # Check base_name cache early (before AST-walk / force_lower).
        if base_rt = @function_base_return_types[base_name]?
          if base_rt != TypeRef::VOID
            @function_types[name] = base_rt
            existing_type = base_rt
          end
        end
        # Check well-known method return types (to_s→String, hash→UInt64, ==→Bool, etc.)
        if existing_type == TypeRef::VOID
          if wk_rt = well_known_method_return_type(base_name)
            @function_types[name] = wk_rt
            @function_base_return_types[base_name] = wk_rt unless base_name.includes?('$')
            existing_type = wk_rt
          end
        end
        # Try AST-walk inference first (non-recursive, no stack depth risk).
        if existing_type == TypeRef::VOID
          if def_node = lookup_function_def_for_return(name, base_name)
            owner_name = function_context_from_name(base_name)
            if inferred = infer_return_type_from_body_without_callsite(def_node, owner_name)
              if inferred != TypeRef::VOID
                @function_types[name] = inferred
                @function_base_return_types[base_name] = inferred unless base_name.includes?('$')
                existing_type = inferred
              end
            end
          end
        end

        # Fall back to force_lower only when AST-walk couldn't determine the type.
        if existing_type == TypeRef::VOID
          if @infer_body_context.nil? && !function_state(name).in_progress? && !@module.has_function?(name)
            if lookup_function_def_for_return(name, base_name)
              unless force_lower_function_for_return_type(name)
                lower_function_if_needed(name)
              end
              if func = @module.function_by_name(name)
                func_rt = func.return_type
                if func_rt != TypeRef::VOID
                  @function_types[name] = func_rt
                  @function_base_return_types[base_name] = func_rt unless base_name.includes?('$')
                  existing_type = func_rt
                end
              end
            end
          end
        end
      end

      if existing_type.nil?
        # Check base_name cache early.
        if base_rt = @function_base_return_types[base_name]?
          if base_rt != TypeRef::VOID
            @function_types[name] = base_rt
            return base_rt
          end
        end
        # Check well-known method return types.
        if wk_rt = well_known_method_return_type(base_name)
          @function_types[name] = wk_rt
          @function_base_return_types[base_name] = wk_rt unless base_name.includes?('$')
          return wk_rt
        end
        # Try AST-walk inference and explicit return type annotations first (non-recursive).
        if def_node = lookup_function_def_for_return(name, base_name)
          if def_node.return_type
            if resolved = resolve_return_type_from_def(name, base_name, nil)
              return resolved unless resolved == TypeRef::VOID
            end
          end
          owner_name = function_context_from_name(base_name)
          if inferred = infer_return_type_from_body_without_callsite(def_node, owner_name)
            if inferred != TypeRef::VOID
              @function_types[name] = inferred
              @function_base_return_types[base_name] = inferred unless base_name.includes?('$')
              return inferred
            end
          end
        end

        # Fall back to force_lower only when AST-walk couldn't determine the type.
        if @infer_body_context.nil? && !function_state(name).in_progress?
          if lookup_function_def_for_return(name, base_name)
            unless force_lower_function_for_return_type(name)
              lower_function_if_needed(name)
            end
            if func = @module.function_by_name(name)
              func_rt = func.return_type
              if func_rt != TypeRef::VOID
                @function_types[name] = func_rt
                @function_base_return_types[base_name] = func_rt unless base_name.includes?('$')
                return func_rt
              end
            end
          end
        end
        if cached = @function_base_return_types[base_name]?
          return cached unless cached == TypeRef::VOID
        end
        if base_type = @function_types[base_name]?
          unionish = false
          if base_desc = @module.get_type_descriptor(base_type)
            unionish = base_desc.kind == TypeKind::Union
          end
          if !unionish
            base_type_name = get_type_name_from_ref(base_type)
            unionish = base_type_name.includes?('|')
          end
          if unionish
            def_node = lookup_function_def_for_return(name, base_name)
            if def_node
              if rt = def_node.return_type
                # Respect explicit return annotations; do not override them with body inference.
                return base_type if rt.size > 0
              end
              owner_name = nil.as(String?)
              if idx = base_name.rindex('#')
                owner_name = base_name[0, idx]
              elsif idx = base_name.rindex('.')
                owner_name = base_name[0, idx]
              end
              if inferred = infer_return_type_from_body_without_callsite(def_node, owner_name)
                if inferred != TypeRef::VOID
                  inferred_desc = @module.get_type_descriptor(inferred)
                  if inferred_desc.nil? || inferred_desc.kind != TypeKind::Union
                    @function_types[base_name] = inferred
                    @function_base_return_types[base_name] = inferred unless base_name.includes?('$')
                  elsif inferred_desc && inferred_desc.kind == TypeKind::Union
                    current_union_name = base_desc ? base_desc.name : get_type_name_from_ref(base_type)
                    if prefer_inferred_union_type?(current_union_name, inferred_desc.name)
                      @function_types[base_name] = inferred
                      @function_base_return_types[base_name] = inferred unless base_name.includes?('$')
                    end
                  end
                end
              end
            end
          end
        end
      end
      # First check pre-registered signatures (for forward references)
      if type = @function_types[name]?
        if func = @module.function_by_name(name)
          func_rt = func.return_type
          if func_rt != TypeRef::VOID
            if unresolved_generic_return_type?(type) && !unresolved_generic_return_type?(func_rt)
              @function_types[name] = func_rt
              type = func_rt
            end
            # Prefer concrete lowered return types over overly broad unions.
            # This fixes cases where early inference polluted @function_types
            # (e.g., Hash#key_hash returning a union at call sites).
            if type != func_rt
              if type_desc = @module.get_type_descriptor(type)
                if type_desc.kind == TypeKind::Union
                  @function_types[name] = func_rt
                  type = func_rt
                end
              end
            end
          end
        end
        unionish = false
        if type_desc = @module.get_type_descriptor(type)
          unionish = type_desc.kind == TypeKind::Union
        end
        if !unionish
          type_name = get_type_name_from_ref(type)
          unionish = type_name.includes?('|')
        end
        if unionish
          def_node = lookup_function_def_for_return(name, base_name)
          if def_node
            if rt = def_node.return_type
              # Respect explicit return annotations; do not override them with body inference.
              return type if rt.size > 0
            end
            owner_name = nil.as(String?)
            if idx = base_name.rindex('#')
              owner_name = base_name[0, idx]
            elsif idx = base_name.rindex('.')
              owner_name = base_name[0, idx]
            end
            if inferred = infer_return_type_from_body_without_callsite(def_node, owner_name)
              if inferred != TypeRef::VOID
                inferred_desc = @module.get_type_descriptor(inferred)
                if inferred_desc.nil? || inferred_desc.kind != TypeKind::Union
                  @function_types[name] = inferred
                  @function_base_return_types[base_name] = inferred unless base_name.includes?('$')
                  type = inferred
                elsif inferred_desc && inferred_desc.kind == TypeKind::Union
                  current_union_name = type_desc ? type_desc.name : get_type_name_from_ref(type)
                  if prefer_inferred_union_type?(current_union_name, inferred_desc.name)
                    @function_types[name] = inferred
                    @function_base_return_types[base_name] = inferred unless base_name.includes?('$')
                    type = inferred
                  end
                end
              end
            end
          end
        end
        if unresolved_generic_return_type?(type)
          def_node = lookup_function_def_for_return(name, base_name)
          if def_node
            if rt = def_node.return_type
              # Respect explicit return annotations; do not override them with body inference.
              return type if rt.size > 0
            end
            owner_name = nil.as(String?)
            if idx = base_name.rindex('#')
              owner_name = base_name[0, idx]
            elsif idx = base_name.rindex('.')
              owner_name = base_name[0, idx]
            end
            if inferred = infer_return_type_from_body_without_callsite(def_node, owner_name)
              if inferred != TypeRef::VOID
                @function_types[name] = inferred
                @function_base_return_types[base_name] = inferred unless base_name.includes?('$')
                type = inferred
              end
            end
          end
        end
        # For base names (no $ suffix), treat VOID/NIL as unknown and fall back
        # to cached base return types from other overloads.
        if name.includes?('$')
          if type != TypeRef::VOID
            return type
          end
          if ivar_type = ivar_return_type_for_method(base_name)
            return ivar_type
          end
          if base_type = @function_types[base_name]?
            return base_type unless base_type == TypeRef::VOID
          end
          if cached = @function_base_return_types[base_name]?
            return cached
          end
          if def_node = lookup_function_def_for_return(base_name, base_name)
            owner_name = nil.as(String?)
            if idx = base_name.rindex('#')
              owner_name = base_name[0, idx]
            elsif idx = base_name.rindex('.')
              owner_name = base_name[0, idx]
            end
            if inferred = infer_return_type_from_body_without_callsite(def_node, owner_name)
              if inferred != TypeRef::VOID
                @function_base_return_types[base_name] = inferred
                @function_types[base_name] = inferred
                return inferred
              end
            end
          end
          # Before returning VOID, check if the function was already lowered
          # with a concrete return type (e.g., extension module methods)
          if type == TypeRef::VOID
            if func = @module.function_by_name(name)
              return func.return_type unless func.return_type == TypeRef::VOID
            end
          end
          return type
        end
        if type == TypeRef::VOID
          if func = @module.function_by_name(name)
            return func.return_type unless func.return_type == TypeRef::VOID
          end
          if def_node = lookup_function_def_for_return(name, base_name)
            owner_name = nil.as(String?)
            if idx = name.rindex('#')
              owner_name = name[0, idx]
            elsif idx = name.rindex('.')
              owner_name = name[0, idx]
            end
            if inferred = infer_return_type_from_body_without_callsite(def_node, owner_name)
              if inferred != TypeRef::VOID
                @function_base_return_types[name] = inferred unless name.includes?('$')
                @function_types[name] = inferred
                return inferred
              end
            end
          end
        end
        if type == TypeRef::BOOL && name.ends_with?('?')
          receiver_name = nil.as(String?)
          method_name = nil.as(String?)
          if idx = name.rindex('#')
            receiver_name = name[0, idx]
            method_name = name[(idx + 1)..]
          elsif idx = name.rindex('.')
            receiver_name = name[0, idx]
            method_name = name[(idx + 1)..]
          end
          if receiver_name && method_name && NILABLE_QUERY_METHODS.includes?(method_name)
            receiver_ref = type_ref_for_name(receiver_name)
            if receiver_ref != TypeRef::VOID
              if inferred = infer_unannotated_query_return_type(method_name, receiver_ref)
                return inferred
              end
            end
          end
        end
        # Special case: X#to_s with no args should return String, not Nil
        # In Crystal, to_s() without args returns String by convention:
        # - Enums: to_s : String returns member_name || value.to_s
        # - Other types: to_s : String returns String.build { |io| to_s(io) }
        # The NIL return type comes from to_s(io : IO) : Nil being the only registered variant
        if (type == TypeRef::VOID || type == TypeRef::NIL) && name.ends_with?("#to_s")
          return TypeRef::STRING
        end
        if type == TypeRef::VOID
          if ivar_type = ivar_return_type_for_method(name)
            return ivar_type
          end
        end
        return type unless type == TypeRef::VOID
      end
      if ivar_type = ivar_return_type_for_method(base_name)
        return ivar_type
      end
      if name.ends_with?("#value")
        if idx = name.rindex('#')
          owner_name = name[0, idx]
          if enum_name = resolve_enum_name(owner_name)
            return enum_base_type(enum_name)
          end
        end
      end
      # If this is a base name (no $ suffix), use cached return type if available.
      if cached = @function_base_return_types[base_name]?
        return cached
      end
      if name.ends_with?('?')
        receiver_name = nil.as(String?)
        method_name = nil.as(String?)
        if idx = name.rindex('#')
          receiver_name = name[0, idx]
          method_name = name[(idx + 1)..]
        elsif idx = name.rindex('.')
          receiver_name = name[0, idx]
          method_name = name[(idx + 1)..]
        end
        if receiver_name && method_name && NILABLE_QUERY_METHODS.includes?(method_name)
          receiver_ref = type_ref_for_name(receiver_name)
          if receiver_ref != TypeRef::VOID
            if inferred = infer_unannotated_query_return_type(method_name, receiver_ref)
              return inferred
            end
          end
        end
      end
      # Fall back to already-lowered functions
      if func = @module.function_by_name(name)
        return func.return_type
      end
      TypeRef::VOID
    end

    private def ivar_return_type_for_method(name : String) : TypeRef?
      return nil unless hash_idx = name.rindex('#')
      receiver_name = name[0, hash_idx]
      method_name = name[(hash_idx + 1)..]
      if method_name.includes?('$')
        method_name = strip_type_suffix(method_name)
      end
      return nil if method_name.empty?
      return nil unless class_info = @class_info[receiver_name]?

      ivar_method = method_name.ends_with?('?') ? method_name[0, method_name.size - 1] : method_name
      ivar_name = "@#{ivar_method}"
      if ivar = class_info.ivars.find { |iv| iv.name == ivar_name }
        return ivar.type unless ivar.type == TypeRef::VOID
      end
      nil
    end

    # Get instance variable offset from current class
    private def get_ivar_offset(name : String) : Int32
      if class_name = @current_class
        if class_info = @class_info[class_name]?
          class_info.ivars.each do |ivar|
            if ivar.name == name
              if env_has?("DEBUG_IVAR_OFFSET") && class_name.includes?("Entry")
                STDERR.puts "[IVAR_OFFSET] #{class_name}##{name} FOUND offset=#{ivar.offset} (#{class_info.ivars.map { |iv| "#{iv.name}:#{iv.offset}" }.join(", ")})"
              end
              return ivar.offset
            end
          end
        end
      end
      0 # Default offset
    end

    # Get instance variable type from current class
    private def get_ivar_type(name : String) : TypeRef?
      if class_name = @current_class
        if class_info = @class_info[class_name]?
          class_info.ivars.each do |ivar|
            return ivar.type if ivar.name == name
          end
        end
      end
      nil
    end

    private def class_info_for_type(receiver_type : TypeRef) : ClassInfo?
      return nil if receiver_type == TypeRef::VOID

      if info = @class_info_by_type_id[receiver_type.id]?
        return info
      end

      if desc = @module.get_type_descriptor(receiver_type)
        if info = @class_info[desc.name]?
          return info
        end
        if candidates = @short_type_index[desc.name]?
          if candidate = candidates.first?
            return @class_info[candidate]?
          end
        end
      end

      nil
    end

    private def type_name_exists?(name : String) : Bool
      # Hot path: type resolution calls this millions of times when lowering stdlib.
      # Cache positive results aggressively (monotonic as the type set only grows).
      cache = (@type_name_exists_cache ||= {} of String => Bool)
      if cached = cache[name]?
        return cached
      end
      result = @class_info.has_key?(name) ||
               @generic_templates.has_key?(name) ||
               @type_aliases.has_key?(name) ||
               (@enum_info && @enum_info.not_nil!.has_key?(name)) ||
               @module_defs.has_key?(name) ||
               @module.is_lib?(name) ||
               @top_level_type_names.includes?(name) ||
               @top_level_class_kinds.has_key?(name)
      # Only cache false results during signature scans (where the type universe is stable).
      if @signature_scan_mode
        cache[name] = result
      elsif result
        cache[name] = true
      end
      result
    end

    private def constant_name_exists?(name : String) : Bool
      @constant_defs.includes?(name)
    end

    private def constant_full_name(owner_name : String?, name : String) : String
      if owner_name && !owner_name.empty?
        "#{owner_name}::#{name}"
      else
        name
      end
    end

    private def constant_storage_info(full_name : String) : Tuple(String, String)
      if idx = full_name.rindex("::")
        owner = full_name[0, idx]
        const_name = full_name[(idx + 2)..-1]
      else
        owner = "Object"
        const_name = full_name
      end
      {owner, const_name}
    end

    # Try to resolve a self class-method that returns a type literal.
    # Looks up the method body, expands macros, and checks if it returns a known type path.
    # Used for patterns like: backend_class.new → Crystal::EventLoop::Kqueue.new
    private def try_resolve_type_returning_method(class_name : String, method_name : String) : String?
      # Look up the class method definition
      func_name = "#{class_name}.#{method_name}"
      if def_node = @function_defs[func_name]?
        arena = @function_def_arenas[func_name]?
        return nil unless arena
        body = def_node.body
        return nil unless body
        with_arena(arena) do
          body.each do |body_id|
            body_node = @arena[body_id]
            resolved_type = extract_type_from_macro_body(body_node)
            if resolved_type && type_name_exists?(resolved_type)
              return resolved_type
            end
          end
        end
      end
      nil
    end

    # Extract a type name from a macro body (handles MacroIfNode → MacroLiteralNode → type path)
    private def extract_type_from_macro_body(node : AstNode) : String?
      case node
      when CrystalV2::Compiler::Frontend::MacroIfNode
        result = try_evaluate_macro_condition(node.condition)
        if result == true
          body = @arena[node.then_body]
          return extract_type_from_macro_body(body)
        elsif result == false
          if else_node = node.else_body
            else_body = @arena[else_node]
            return extract_type_from_macro_body(else_body)
          end
        end
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        if raw_text = macro_literal_raw_text(node)
          text = raw_text.strip
          # If text contains nested {% %}, expand them
          if text.includes?("{%")
            if expanded = expand_flag_macro_text(text)
              text = expanded.strip
            else
              return nil
            end
          end
          # Check if the text is a valid type path (e.g., Crystal::EventLoop::Kqueue)
          if text.match(/\A[A-Z][A-Za-z0-9_]*(::[A-Z][A-Za-z0-9_]*)*\z/)
            return text
          end
        end
      when CrystalV2::Compiler::Frontend::PathNode
        path = collect_path_string(node)
        resolved = resolve_path_string_in_context(path)
        return resolved if type_name_exists?(resolved)
      when CrystalV2::Compiler::Frontend::BlockNode
        # Method body is a block — check last expression
        if !node.body.empty?
          last_id = node.body.last
          last_node = @arena[last_id]
          return extract_type_from_macro_body(last_node)
        end
      end
      nil
    end

    private def resolve_constant_name_in_context(name : String) : String?
      return nil if name.empty?
      if debug_filter = env_get("DEBUG_CONST_LOOKUP")
        if debug_filter == "1" || name.includes?(debug_filter)
          STDERR.puts "[CONST_LOOKUP] name=#{name} current=#{@current_class || "nil"} override=#{@current_namespace_override || "nil"}"
        end
      end
      return name if constant_name_exists?(name)

      if name.includes?("::")
        resolved = resolve_path_string_in_context(name)
        return resolved if constant_name_exists?(resolved)
        return name if constant_name_exists?(name)
        return nil
      end

      namespaces = [] of String
      if override = @current_namespace_override
        namespaces << override
        if info = split_generic_base_and_args(override)
          namespaces << info[:base] unless namespaces.includes?(info[:base])
        end
      end
      if current = @current_class
        namespaces << current unless namespaces.includes?(current)
        if info = split_generic_base_and_args(current)
          namespaces << info[:base] unless namespaces.includes?(info[:base])
        end
      end

      namespaces.each do |namespace|
        parts = namespace.split("::")
        while parts.size > 0
          qualified_name = (parts + [name]).join("::")
          if debug_filter = env_get("DEBUG_CONST_LOOKUP")
            if debug_filter == "1" || name.includes?(debug_filter)
              STDERR.puts "[CONST_LOOKUP] try=#{qualified_name} exists=#{constant_name_exists?(qualified_name)}"
            end
          end
          return qualified_name if constant_name_exists?(qualified_name)
          parts.pop
        end
      end

      nil
    end

    private def record_constant_definition(owner_name : String?, name : String, value_id : ExprId, arena : CrystalV2::Compiler::Frontend::ArenaLike)
      full_name = constant_full_name(owner_name, name)
      @constant_defs.add(full_name)
      if env_get("DEBUG_CONST_REG") && name == "CACHE"
        STDERR.puts "[CONST_REG] full_name=#{full_name} owner=#{owner_name || ""} name=#{name}"
      end
      if env_get("DEBUG_USE_LIBICONV") && name == "USE_LIBICONV"
        STDERR.puts "[USE_LIBICONV] record_constant_definition owner=#{owner_name || ""}"
      end

      if @constant_literal_values.has_key?(full_name)
      else
        if literal = constant_literal_value_from_expr(value_id, arena, owner_name)
          @constant_literal_values[full_name] = literal
        else
          # Check if expression is an offsetof — save for re-evaluation after class info is ready
          old_a = @arena
          @arena = arena
          expr_node = @arena[value_id]
          if expr_node.is_a?(CrystalV2::Compiler::Frontend::OffsetofNode)
            @pending_offsetof_constants << {full_name, value_id, arena, owner_name}
          end
          @arena = old_a
        end
      end

      if existing = @constant_types[full_name]?
        return if existing != TypeRef::VOID
      end

      old_arena = @arena
      old_class = @current_class
      @arena = arena
      @current_class = owner_name
      inferred = infer_type_from_expr(value_id, owner_name) || TypeRef::VOID
      if inferred == TypeRef::VOID
        value_node = @arena[value_id]
        if value_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
          callee_node = @arena[value_node.callee]
          if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
            member_name = String.new(callee_node.member)
            if member_name == "literal"
              if type_str = stringify_type_expr(callee_node.object)
                type_str = resolve_type_name_in_context(type_str)
                fallback = type_ref_for_name(type_str)
                inferred = fallback if fallback != TypeRef::VOID
              end
            end
          end
        end
      end
      @current_class = old_class
      @arena = old_arena

      @constant_types[full_name] = inferred

      # Defer runtime initialization for non-numeric constants (string literals, etc.)
      # Numeric constants are stored directly as global initial values, but string
      # constants need to be initialized at runtime by storing a pointer to the string data.
      unless @constant_literal_values[full_name]?.is_a?(CrystalV2::Compiler::Semantic::MacroNumberValue) ||
             @constant_literal_values[full_name]?.is_a?(CrystalV2::Compiler::Semantic::MacroBoolValue)
        old_a2 = @arena
        @arena = arena
        val_node = @arena[value_id]
        needs_deferred = val_node.is_a?(CrystalV2::Compiler::Frontend::StringNode)
        @arena = old_a2
        if needs_deferred
          owner = owner_name || "$"
          @deferred_constant_inits << {owner, name, value_id, arena}
        end
      end

      if env_get("DEBUG_USE_LIBICONV") && name == "USE_LIBICONV"
        literal = @constant_literal_values[full_name]?
        literal_str = literal ? literal.to_macro_output : "nil"
        STDERR.puts "[USE_LIBICONV] owner=#{owner_name || ""} literal=#{literal_str} inferred=#{inferred.id}"
      end
    end

    private def constant_literal_value_from_expr(
      value_id : ExprId,
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      owner_name : String?,
    ) : CrystalV2::Compiler::Semantic::MacroValue?
      old_arena = @arena
      old_class = @current_class
      @arena = arena
      @current_class = owner_name
      begin
        value = macro_value_for_expr(value_id)
        case value
        when CrystalV2::Compiler::Semantic::MacroBoolValue,
             CrystalV2::Compiler::Semantic::MacroNumberValue,
             CrystalV2::Compiler::Semantic::MacroStringValue,
             CrystalV2::Compiler::Semantic::MacroSymbolValue
          value
        else
          nil
        end
      ensure
        @current_class = old_class
        @arena = old_arena
      end
    end

    private def emit_constant_get(ctx : LoweringContext, full_name : String) : ValueId
      owner, const_name = constant_storage_info(full_name)
      const_type = @constant_types[full_name]? || TypeRef::VOID
      get = ClassVarGet.new(ctx.next_id, const_type, owner, const_name)
      ctx.emit(get)
      ctx.register_type(get.id, const_type)
      get.id
    end

    private def resolve_type_name_in_context(name : String) : String
      return name if name.empty?
      name = normalize_missing_generic_parens(name)
      if mapped = @type_param_map[name]?
        return resolve_type_name_in_context(mapped) if mapped != name
      end
      if (idx = name.index("::"))
        prefix = name[0, idx]
        if mapped = @type_param_map[prefix]?
          mapped_name = "#{mapped}#{name[idx..]}"
          return resolve_type_name_in_context(mapped_name) if mapped_name != name
        end
      end
      if name.starts_with?(':')
        stripped = name.size > 1 ? name[1..] : ""
        return stripped.empty? ? "" : resolve_type_name_in_context(stripped)
      end
      if local_name = @current_typeof_local_names.try(&.[name]?)
        return local_name unless local_name.empty?
      end
      if cached = resolved_type_name_cache_get(name)
        return cached unless nested_shadowed_type_name?(name)
      end
      if value_literal_name?(name)
        resolved_type_name_cache_set(name, name)
        return name
      end
      if name.includes?('|')
        parts = split_union_type_name(name)
        if parts.size > 1
          resolved = parts.map { |part| resolve_type_name_in_context(part) }.join(" | ")
          resolved_type_name_cache_set(name, resolved)
          return resolved
        end
      end
      if name.ends_with?('?')
        base = name[0, name.size - 1]
        resolved_base = resolve_type_name_in_context(base)
        resolved = "#{resolved_base}?"
        resolved_type_name_cache_set(name, resolved)
        return resolved
      end
      if name.ends_with?('*')
        base = name
        star_count = 0
        while base.ends_with?('*')
          base = base[0...-1]
          star_count += 1
        end
        base = base.strip
        resolved_base = base.empty? ? base : resolve_type_name_in_context(base)
        resolved = "#{resolved_base}#{("*" * star_count)}"
        resolved_type_name_cache_set(name, resolved)
        return resolved
      end
      if name.starts_with?("::")
        stripped = name.size > 2 ? name[2..] : ""
        if stripped.empty?
          resolved_type_name_cache_set(name, "")
          return ""
        end
        if info = split_generic_base_and_args(stripped)
          resolved_args = split_generic_type_args(info[:args]).map do |arg|
            arg = arg.strip
            if arg.starts_with?(':')
              arg = arg.size > 1 ? arg[1..] : ""
            end
            if arg == "self"
              @current_class || arg
            else
              resolve_type_name_in_context(arg)
            end
          end.join(", ")
          resolved = "#{info[:base]}(#{resolved_args})"
          resolved_type_name_cache_set(name, resolved)
          return resolved
        end
        if stripped == "self"
          resolved = @current_class || stripped
          resolved_type_name_cache_set(name, resolved)
          return resolved
        end
        resolved_type_name_cache_set(name, stripped)
        return stripped
      end
      if (tuple_index = name.index("::{")) && name.ends_with?('}')
        tuple_literal = name[(tuple_index + 2)..]
        resolved = resolve_type_name_in_context(tuple_literal)
        resolved_type_name_cache_set(name, resolved)
        return resolved
      end

      if name == "self"
        resolved = @current_class || name
        resolved_type_name_cache_set(name, resolved)
        return resolved
      end
      # Preserve short unbound type params (T/U/V) to avoid creating forward
      # references like Namespace::U for method generic params.
      if type_param_like?(name) && short_type_param_name?(name) && !@type_param_map.has_key?(name)
        resolved_type_name_cache_set(name, name)
        return name
      end
      if name.starts_with?('{') && name.ends_with?('}')
        inner = name[1, name.size - 2].strip
        if inner.empty?
          tuple_name = "Tuple()"
        else
          tuple_args = split_generic_type_args(inner).map do |arg|
            resolve_type_name_in_context(arg.strip)
          end
          tuple_name = "Tuple(#{tuple_args.join(", ")})"
        end
        resolved_type_name_cache_set(name, tuple_name)
        return tuple_name
      end

      if info = split_generic_base_and_args(name)
        resolved_base = resolve_type_name_in_context(info[:base])
        resolved_args = split_generic_type_args(info[:args]).map do |arg|
          arg = arg.strip
          if arg.starts_with?(':')
            arg = arg.size > 1 ? arg[1..] : ""
          end
          # Preserve short unbound type params in generic args (T/U/V) so they
          # don't get namespace-qualified into fake nested classes.
          if type_param_like?(arg) && short_type_param_name?(arg) && !@type_param_map.has_key?(arg)
            normalize_tuple_literal_type_name(arg)
          else
            normalize_tuple_literal_type_name(resolve_type_name_in_context(arg))
          end
        end.join(", ")
        resolved = resolved_base == info[:base] && resolved_args == info[:args] ? name : "#{resolved_base}(#{resolved_args})"
        resolved_type_name_cache_set(name, resolved)
        return resolved
      end

      unless name.includes?("::")
        # Nested types of the current class/namespace take priority over
        # top-level names, included module types, and type aliases.
        # E.g., bare "Entry" inside Hash must resolve to Hash::Entry,
        # not to Crystal::System::Dir::Entry via alias/include.
        if current_or_override_has_nested_type?(name)
          resolved = resolve_class_name_in_context(name)
          resolved_type_name_cache_set(name, resolved)
          return resolved
        end
        if @top_level_type_names.includes?(name) || @top_level_class_kinds.has_key?(name) || BUILTIN_TYPE_NAMES.includes?(name)
          unless nested_shadowed_type_name?(name)
            resolved_type_name_cache_set(name, name)
            return name
          end
        end
        if resolved_included = resolve_included_type_name(name)
          resolved_type_name_cache_set(name, resolved_included)
          return resolved_included
        end
        if alias_target = resolve_type_alias_by_suffix(name)
          resolved = resolve_type_name_in_context(alias_target)
          resolved_type_name_cache_set(name, resolved)
          return resolved
        end
        resolved = resolve_class_name_in_context(name)
        resolved_type_name_cache_set(name, resolved)
        return resolved
      end
      # Resolve relative path heads in type contexts (e.g., Location::Zone inside Time::Location).
      resolved_path = resolve_path_string_in_context(name)
      if resolved_path != name
        resolved_type_name_cache_set(name, resolved_path)
        return resolved_path
      end
      head = first_namespace_component(name)
      if @top_level_type_names.includes?(head)
        resolved_type_name_cache_set(name, name)
        return name
      end
      if type_name_exists?(name)
        resolved_type_name_cache_set(name, name)
        return name
      end

      if current = @current_class
        base = current
        loop do
          qualified_name = "#{base}::#{name}"
          if type_name_exists?(qualified_name)
            resolved_type_name_cache_set(name, qualified_name)
            return qualified_name
          end
          idx = base.rindex("::")
          break unless idx
          base = base[0, idx]
        end
      end

      resolved_type_name_cache_set(name, name)
      if env_get("DEBUG_FIBER_RESOLVE") && name == "Fiber"
        STDERR.puts "[DEBUG_FIBER_RESOLVE] name=#{name} current=#{@current_class || "nil"} override=#{@current_namespace_override || "nil"} resolved=#{name} top_level=#{@top_level_type_names.includes?(name)}"
      end
      name
    end

    # Check if the current class or namespace override (or any ancestor
    # namespace) has a nested type with the given short name. Unlike
    # nested_shadowed_type_name? this does NOT require the name to also be
    # a top-level type. Walks up the namespace hierarchy so that code
    # inside Hash::Entry can still see Hash::Entry via the parent Hash.
    private def current_or_override_has_nested_type?(name : String) : Bool
      if override = @current_namespace_override
        return true if namespace_chain_has_nested?(override, name)
      end
      if current = @current_class
        return true if namespace_chain_has_nested?(current, name)
      end
      false
    end

    private def namespace_chain_has_nested?(ns : String, name : String) : Bool
      base = if info = split_generic_base_and_args(ns)
               info[:base]
             else
               ns
             end
      loop do
        if (nested = @nested_type_names[base]?) && nested.includes?(name)
          return true
        end
        idx = base.rindex("::")
        break unless idx
        base = base[0, idx]
      end
      false
    end

    # Resolve a short name to the closest nested type in the current namespace
    # chain (including forward references discovered during the pre-scan).
    #
    # This is a hot path during stdlib lowering and avoids deep namespace walks
    # and repeated type_name_exists? calls for nested constants/types.
    private def nested_type_full_name_in_namespace_chain(ns : String, name : String) : String?
      base = if info = split_generic_base_and_args(ns)
               info[:base]
             else
               ns
             end
      loop do
        if (nested = @nested_type_names[base]?) && nested.includes?(name)
          return "#{base}::#{name}"
        end
        idx = base.rindex("::")
        break unless idx
        base = base[0, idx]
      end
      nil
    end

    private def nested_shadowed_type_name?(name : String) : Bool
      return false unless @top_level_type_names.includes?(name) ||
                          @top_level_class_kinds.has_key?(name) ||
                          BUILTIN_TYPE_NAMES.includes?(name)
      if override = @current_namespace_override
        override_base = if info = split_generic_base_and_args(override)
                          info[:base]
                        else
                          override
                        end
        if nested = @nested_type_names[override_base]? || @nested_type_names[override]?
          return true if nested.includes?(name)
        end
      end
      if current = @current_class
        current_base = if info = split_generic_base_and_args(current)
                         info[:base]
                       else
                         current
                       end
        if nested = @nested_type_names[current_base]? || @nested_type_names[current]?
          return true if nested.includes?(name)
        end
      end
      false
    end

    private def qualify_unqualified_type_in_namespace(name : String, namespace : String) : String
      name = name.strip
      return name if name.empty?
      return name if name.includes?("::")
      candidate = "#{namespace}::#{name}"
      if env_get("DEBUG_WUINT128") && name == "UInt128" && namespace.includes?("Dragonbox::WUInt")
        exists = type_name_exists?(candidate) ||
                 @class_info.has_key?(candidate) ||
                 @generic_templates.has_key?(candidate)
        STDERR.puts "[DEBUG_WUINT128] qualify name=#{name} namespace=#{namespace} candidate=#{candidate} exists=#{exists ? 1 : 0}"
      end
      return candidate if type_name_exists?(candidate) ||
                          @class_info.has_key?(candidate) ||
                          @generic_templates.has_key?(candidate)
      name
    end

    private def resolve_nested_builtin_shadow(name : String) : String?
      if override = @current_namespace_override
        if shadow = nested_type_shadow_in_namespace(name, override)
          return shadow
        end
      end
      if current = @current_class
        if shadow = nested_type_shadow_in_namespace(name, current)
          return shadow
        end
      end
      nil
    end

    private def nested_type_shadow_in_namespace(name : String, namespace : String) : String?
      namespace_base = if info = split_generic_base_and_args(namespace)
                         info[:base]
                       else
                         namespace
                       end
      nested = @nested_type_names[namespace_base]? || @nested_type_names[namespace]?

      candidate = "#{namespace}::#{name}"
      if nested && nested.includes?(name)
        return candidate if namespace_base == namespace
        return "#{namespace_base}::#{name}"
      end
      return candidate if type_name_exists?(candidate)
      if namespace_base != namespace
        base_candidate = "#{namespace_base}::#{name}"
        return base_candidate if type_name_exists?(base_candidate)
      end
      nil
    end

    private def resolve_path_string_in_context(path : String) : String
      return path if path.empty?
      return path if value_literal_name?(path)
      if type_param_like?(path) && short_type_param_name?(path) && !@type_param_map.has_key?(path)
        return path
      end
      if path.starts_with?("::")
        return path.size > 2 ? path[2..] : ""
      end
      return resolve_type_name_in_context(path) unless path.includes?("::")

      parts = path.split("::")
      return path if parts.empty?

      resolved_head = resolve_class_name_in_context(parts.first)
      return path if resolved_head == parts.first

      resolved = ([resolved_head] + parts[1..]).join("::")
      return resolved if type_name_exists?(resolved)
      return path if type_name_exists?(path)
      resolved
    end

    private def function_context_from_name(name : String) : String?
      base = name
      if dollar = base.index('$')
        base = base[0, dollar]
      end

      if hash = base.index('#')
        return base[0, hash]
      elsif dot = base.index('.')
        return base[0, dot]
      end

      nil
    end

    # Resolve method name with inheritance: look in class and all parent classes
    # Resolve a short class name to its fully qualified name using current context
    # E.g., if @current_class is "CrystalV2::Compiler::Frontend::Span" and name is "Span",
    # returns "CrystalV2::Compiler::Frontend::Span"
    private def resolve_class_name_in_context(name : String) : String
      record_resolve_histo(name) if @debug_resolve_histo_enabled
      if @signature_scan_mode
        if fast = resolve_class_name_in_signature_context(name)
          return fast
        end
      end
      if mapped = @type_param_map[name]?
        return mapped
      end
      if current = @current_class
        if info = generic_owner_info(current)
          if mapped = info[:map][name]?
            return mapped
          end
        end
      end
      if env_get("DEBUG_FILE_RESOLVE") && name == "File"
        STDERR.puts "[DEBUG_FILE_RESOLVE] current=#{@current_class || ""} override=#{@current_namespace_override || ""} top_level=#{@top_level_type_names.includes?(name)}"
      end
      if filter = env_get("DEBUG_TOP_LEVEL_NAMES")
        filters = filter.split(",").map(&.strip)
        if filter == "*" || filters.includes?(name)
          STDERR.puts "[DEBUG_TOP_LEVEL] name=#{name} current=#{@current_class || ""} top_level=#{@top_level_type_names.includes?(name)}"
        end
      end
      if primitive_self_type(name) || LIBC_TYPE_ALIASES.has_key?(name) || builtin_alias_target?(name)
        return name
      end
      if BUILTIN_TYPE_NAMES.includes?(name)
        if shadow = resolve_nested_builtin_shadow(name)
          return shadow
        end
        return name
      end
      if name == "Int" || name == "Float" || name == "Number" || name == "Atomic"
        return name
      end
      if type_param_like?(name) && short_type_param_name?(name) && !@type_param_map.has_key?(name)
        return name
      end

      # Fast path: if this is a known nested type in the current namespace chain,
      # resolve it directly without a deep namespace walk.
      if override = @current_namespace_override
        if nested = nested_type_full_name_in_namespace_chain(override, name)
          return nested
        end
      end
      if current = @current_class
        if nested = nested_type_full_name_in_namespace_chain(current, name)
          return nested
        end
      end

      # Performance fast path: reuse the signature-scan resolver even outside
      # signature collection. It is based on nested hints + short_type_index and
      # avoids deep namespace walks with repeated type_name_exists? calls.
      #
      # This is critical for stdlib-heavy lowering (e.g., OpenSSL) where naive
      # namespace scanning becomes O(N^2).
      unless @signature_scan_mode
        if fast = resolve_class_name_in_signature_context(name)
          return fast
        end
      end

      # If this is a generic type name, resolve the base in context and
      # reconstruct with the original type args.
      if info = split_generic_base_and_args(name)
        resolved_base = resolve_class_name_in_context(info[:base])
        result = resolved_base == info[:base] ? name : "#{resolved_base}(#{info[:args]})"
        debug_hook_type_resolve(name, @current_class || "", result)
        return result
      end

      if override = @current_namespace_override
        if last_namespace_component(override) == name && type_name_exists?(override)
          return override
        end
      end
      if current = @current_class
        if last_namespace_component(current) == name && type_name_exists?(current)
          return current
        end
      end

      result = name # Default fallback

      namespaces = [] of String
      if override = @current_namespace_override
        namespaces << override
        if info = split_generic_base_and_args(override)
          namespaces << info[:base] unless namespaces.includes?(info[:base])
        end
      end
      if current = @current_class
        namespaces << current unless namespaces.includes?(current)
        if info = split_generic_base_and_args(current)
          namespaces << info[:base] unless namespaces.includes?(info[:base])
        end
      end

      found = false
      if env_get("DEBUG_WUINT128") && name == "UInt128"
        STDERR.puts "[DEBUG_WUINT128] resolve_class_name_in_context name=#{name} namespaces=#{namespaces} current_class=#{@current_class || "(nil)"}"
      end
      # Prefer the override namespace (module mixins), then the current class namespace.
      namespaces.each do |namespace|
        namespace_base = if info = split_generic_base_and_args(namespace)
                           info[:base]
                         else
                           namespace
                         end
        # Extract namespace: "Foo::Bar::Baz" -> "Foo::Bar"
        parts = namespace.split("::")

        # Try full namespace first (e.g., Foo::Bar::Baz::Name), then increasingly shorter
        # This handles cases where we're inside module Foo::Bar and reference Name
        # which should resolve to Foo::Bar::Name before trying Foo::Name
        while parts.size > 0
          qualified_name = (parts + [name]).join("::")
          if env_get("DEBUG_WUINT128") && name == "UInt128"
            STDERR.puts "[DEBUG_WUINT128] trying qualified_name=#{qualified_name} namespace=#{namespace} type_name_exists=#{type_name_exists?(qualified_name)}"
          end
          if type_name_exists?(qualified_name)
            if qualified_name == "#{namespace_base}::#{name}"
              if nested = @nested_type_names[namespace_base]? || @nested_type_names[namespace]?
                unless nested.includes?(name)
                  parts.pop
                  next
                end
              end
            end
            # Prefer a top-level class/struct over a namespaced module when the
            # short name is known to be a class (e.g., Fiber vs Crystal::System::Fiber).
            # But inside module namespaces, prefer sibling modules to avoid
            # resolving to unrelated top-level classes (e.g., File vs Crystal::System::File).
            if @module_defs.has_key?(qualified_name) && @top_level_class_kinds.has_key?(name)
              unless @module_defs.has_key?(namespace)
                parts.pop
                next
              end
            end
            # Avoid resolving to a namespaced struct when a top-level class exists
            # unless we're explicitly inside that namespace (module override or class scope).
            if info = @class_info[qualified_name]?
              if info.is_struct && @top_level_type_names.includes?(name)
                ns = qualified_name.rpartition("::")[0]
                if !ns.empty?
                  current = @current_class
                  override = @current_namespace_override
                  unless (current && (current == ns || current.starts_with?("#{ns}::"))) ||
                         (override && (override == ns || override.starts_with?("#{ns}::")))
                    parts.pop
                    next
                  end
                end
              end
            end
            result = qualified_name
            found = true
            break
          end
          parts.pop
        end
        break if found
      end

      unless found
        # Look in ancestor classes for nested constants/types (e.g., TZLocation -> Location::Zone).
        if current = @current_class
          current_base = if info = split_generic_base_and_args(current)
                           info[:base]
                         else
                           current
                         end
          ancestor = @class_info[current_base]?.try(&.parent_name)
          while ancestor
            qualified_name = "#{ancestor}::#{name}"
            if type_name_exists?(qualified_name)
              result = qualified_name
              found = true
              break
            end
            ancestor = @class_info[ancestor]?.try(&.parent_name)
          end
        end
      end

      unless found
        # Prefer a forward reference in the current namespace for unresolved
        # capitalized names (Crystal allows forward declarations in the same scope).
        # This avoids resolving to outer namespaces when the nested type is defined later.
        if current = @current_class
          current_base = if info = split_generic_base_and_args(current)
                           info[:base]
                         else
                           current
                         end
          if name[0]?.try(&.uppercase?) &&
             !type_name_exists?(name) &&
             !@top_level_class_kinds.has_key?(name)
            if nested = @nested_type_names[current_base]? || @nested_type_names[current]?
              if nested.includes?(name)
                result = "#{current_base}::#{name}"
                found = true
              end
            end
          end
        end
      end

      unless found
        # Fall back to a top-level type
        if type_name_exists?(name) || @top_level_class_kinds.has_key?(name)
          result = name
          # Resolve to the override namespace if it matches the short name.
        elsif (override = @current_namespace_override) && last_namespace_component(override) == name && type_name_exists?(override)
          result = override
          # Also try the exact class name if current class matches
          # E.g., inside Span, "Span" should resolve to the same class
        elsif (current = @current_class) && last_namespace_component(current) == name && type_name_exists?(current)
          result = current
        end
      end

      # If unresolved and inside a namespace, first check if a sibling type exists
      # in the parent namespace using short_type_index. This handles cases like:
      # - Inside PollDescriptor, "Waiters" should resolve to Polling::Waiters (sibling)
      # - NOT to PollDescriptor::Waiters (nested forward reference)
      if result == name && (current = @current_class) && name[0]?.try(&.uppercase?)
        unless builtin_alias_target?(name) || LIBC_TYPE_ALIASES.has_key?(name)
          unless @top_level_type_names.includes?(name)
            current_base = if info = split_generic_base_and_args(current)
                             info[:base]
                           else
                             current
                           end
            if current_base.includes?("::")
              parent_namespace = current_base.rpartition("::")[0]
              nested = @nested_type_names[current_base]? || @nested_type_names[current]?
              if parent_namespace &&
                 (nested.nil? || !nested.includes?(name)) &&
                 (@module_defs.has_key?(parent_namespace) || @class_info.has_key?(parent_namespace) || @generic_templates.has_key?(parent_namespace) || @module.class_parents.has_key?(parent_namespace))
                result = "#{parent_namespace}::#{name}"
                found = true
              end
            end
            return result if found
            if result == name
              if nested = @nested_type_names[current_base]? || @nested_type_names[current]?
                if nested.includes?(name)
                  result = "#{current_base}::#{name}"
                end
              end
            end
            # First, check short_type_index for matches in the current namespace,
            # then fall back to sibling matches in the parent namespace.
            if (candidates = @short_type_index[name]?) && candidates.size >= 1
              current_matches = candidates.select { |c| c.starts_with?("#{current_base}::") }
              if current_matches.size == 1
                result = current_matches.first
              elsif current_matches.size > 1
                # Multiple nested matches, prefer the shortest (closest to current namespace)
                result = current_matches.min_by(&.size)
              else
                # Find candidates that are siblings (in parent namespace, not nested)
                parent_namespace = current_base.includes?("::") ? current_base.rpartition("::")[0] : nil
                if parent_namespace
                  sibling_matches = candidates.select { |c| c.starts_with?("#{parent_namespace}::") && !c.starts_with?("#{current_base}::") }
                  if sibling_matches.size == 1
                    result = sibling_matches.first
                  elsif sibling_matches.size > 1
                    # Multiple siblings, prefer the shortest (most direct sibling)
                    result = sibling_matches.min_by(&.size)
                  elsif candidates.size == 1
                    # No sibling matches but only one candidate - use it
                    result = candidates.first
                  end
                elsif candidates.size == 1
                  result = candidates.first
                end
              end
            end

            # Only create forward reference as nested type if no sibling found
            if result == name
              if override = @current_namespace_override
                parent_namespace = override.includes?("::") ? override.rpartition("::")[0] : nil
                if parent_namespace
                  # Prefer siblings in the override's parent namespace (module mixins).
                  result = "#{parent_namespace}::#{name}"
                elsif @module_defs.has_key?(override)
                  result = "#{override}::#{name}"
                end
              end
            end
          end
        end
      end

      if result == name
        # Check if parent namespace is a module (not a class) - if so, prefer
        # the parent namespace because the type is likely a sibling in the module.
        # This avoids creating incorrect nested types like PollDescriptor::Waiters
        # when the type should be Polling::Waiters (a sibling struct in the module).
        if current = @current_class
          current_base = if info = split_generic_base_and_args(current)
                           info[:base]
                         else
                           current
                         end
          nested = @nested_type_names[current_base]? || @nested_type_names[current]?
          skip_namespace = @top_level_type_names.includes?(name) || builtin_alias_target?(name) || LIBC_TYPE_ALIASES.has_key?(name)
          skip_namespace = false if nested && nested.includes?(name)
          unless skip_namespace
            parent_namespace = current_base.includes?("::") ? current_base.rpartition("::")[0] : nil
            parent_is_module = parent_namespace && @module_defs.has_key?(parent_namespace)

            if nested && nested.includes?(name)
              result = "#{current_base}::#{name}"
            elsif type_name_exists?("#{current_base}::#{name}")
              result = "#{current_base}::#{name}"
            elsif (parent_name = (@class_info[current_base]?.try(&.parent_name) || @module.class_parents[current_base]?))
              parent_full = parent_name
              if !parent_full.includes?("::") && parent_namespace
                parent_full = "#{parent_namespace}::#{parent_full}"
              end
              if parent_full.includes?("::")
                candidate = "#{parent_full}::#{name}"
                if type_name_exists?(candidate)
                  result = candidate
                elsif (candidates = @short_type_index[name]?) && candidates.includes?(candidate)
                  result = candidate
                elsif !type_name_exists?("#{current_base}::#{name}")
                  # Prefer a forward reference in the current namespace over an ancestor.
                  result = "#{current_base}::#{name}"
                end
              end
            elsif parent_namespace && type_name_exists?("#{parent_namespace}::#{name}")
              result = "#{parent_namespace}::#{name}"
            elsif parent_namespace && !@top_level_type_names.includes?(name)
              candidate = "#{parent_namespace}::#{name}"
              if type_name_exists?(candidate)
                result = candidate
              elsif candidates = @short_type_index[name]?
                if candidates.includes?(candidate)
                  result = candidate
                elsif parent_is_module || @class_info.has_key?(parent_namespace) || @generic_templates.has_key?(parent_namespace) || @module.class_parents.has_key?(parent_namespace)
                  # Forward reference inside a known namespace (module or class).
                  result = candidate
                end
              elsif parent_is_module || @class_info.has_key?(parent_namespace) || @generic_templates.has_key?(parent_namespace) || @module.class_parents.has_key?(parent_namespace)
                # Forward reference inside a known namespace (module or class).
                result = candidate
              end
            else
              namespace = nil
              if current_base.includes?("::") || @module_defs.has_key?(current_base)
                nested = @nested_type_names[current_base]? || @nested_type_names[current]?
                if nested && nested.includes?(name)
                  namespace = current_base
                else
                  parent_namespace = current_base.includes?("::") ? current_base.rpartition("::")[0] : nil
                  if parent_namespace && !parent_namespace.empty?
                    if @module_defs.has_key?(parent_namespace) || @class_info.has_key?(parent_namespace) || @generic_templates.has_key?(parent_namespace) || @module.class_parents.has_key?(parent_namespace)
                      namespace = parent_namespace
                    else
                      namespace = current_base
                    end
                  else
                    namespace = current_base
                  end
                end
              end
              # Prefer parent namespace for forward references when the current scope
              # doesn't declare the nested type (avoids PollDescriptor::Waiters).
              result = "#{namespace}::#{name}" if namespace
            end
          end
        end
      end

      # Last-resort: if we are inside a generic class, try matching nested generic templates
      # by short name under the current class namespace (stripping generic args if needed).
      if result == name && (current = @current_class)
        prefixes = [] of String
        prefixes << current
        if info = split_generic_base_and_args(current)
          prefixes << info[:base] unless prefixes.includes?(info[:base])
        end
        candidates = [] of String
        @generic_templates.each_key do |key|
          next unless key.ends_with?("::#{name}")
          next unless prefixes.any? { |prefix| key.starts_with?(prefix) }
          candidates << key
        end
        if candidates.size == 1
          result = candidates.first
        end
      end

      # Final fallback: resolve unique short-name matches (avoids short-name leakage)
      # If the name is known to be top-level, keep it as-is to avoid
      # accidentally binding to a namespaced sibling (e.g., Fiber -> Crystal::System::Fiber).
      if result == name && !@top_level_type_names.includes?(name)
        if candidates = @short_type_index[name]?
          if candidates.size == 1
            result = candidates.first
          end
        end
      end

      debug_hook_type_resolve(name, @current_class || "", result)
      if env_get("DEBUG_FILE_RESOLVE") && name == "File"
        STDERR.puts "[DEBUG_FILE_RESOLVE] result=#{result}"
      end
      if env_get("DEBUG_PROCESS_RESOLVE") && name == "Process"
        STDERR.puts "[DEBUG_PROCESS_RESOLVE] current=#{@current_class || "nil"} override=#{@current_namespace_override || "nil"} resolved=#{result}"
      end
      if env_get("DEBUG_FIBER_RESOLVE") && name == "Fiber"
        STDERR.puts "[DEBUG_FIBER_RESOLVE] name=#{name} current=#{@current_class || "nil"} override=#{@current_namespace_override || "nil"} result=#{result} top_level=#{@top_level_type_names.includes?(name)}"
      end
      result
    end

    private def resolve_class_name_for_definition(name : String) : String
      if name.starts_with?("::")
        name = name.size > 2 ? name[2..] : ""
      end
      return normalize_missing_generic_parens(name) if name.includes?("::")
      if current = @current_class
        return normalize_missing_generic_parens("#{current}::#{name}")
      end
      normalize_missing_generic_parens(name)
    end

    private def record_resolve_histo(name : String) : Nil
      histo = @debug_resolve_histo ||= {} of String => Int32
      histo[name] = (histo[name]? || 0) + 1
      @debug_resolve_histo_calls += 1
      now = Time.instant
      last = @debug_resolve_histo_last_report
      if last.nil?
        @debug_resolve_histo_last_report = now
        return
      end
      if (now - last).total_seconds < 3.0 && (@debug_resolve_histo_calls % 50_000) != 0
        return
      end
      @debug_resolve_histo_last_report = now
      top = histo.to_a.sort_by { |entry| -entry[1] }
      limit = top.size > 10 ? 10 : top.size
      return if limit == 0
      io = String::Builder.new
      io << "[DEBUG_RESOLVE_HISTO] top="
      idx = 0
      while idx < limit
        name_entry = top[idx][0]
        count = top[idx][1]
        io << name_entry << ":" << count
        io << "," if idx + 1 < limit
        idx += 1
      end
      STDERR.puts io.to_s
    end

    private def pick_short_type_candidate(candidates : Set(String), namespace : String) : String?
      prefix = "#{namespace}::"
      best : String? = nil
      candidates.each do |candidate|
        next unless candidate.starts_with?(prefix)
        if best.nil? || candidate.size < best.not_nil!.size
          best = candidate
        end
      end
      best
    end

    # Fast path for signature scans: resolve simple type names using short_type_index
    # and nested type hints without deep namespace walks or repeated type_name_exists? calls.
    private def resolve_class_name_in_signature_context(name : String) : String?
      return name if name.empty?
      if primitive_self_type(name) || LIBC_TYPE_ALIASES.has_key?(name) || builtin_alias_target?(name)
        return name
      end
      if name == "Int" || name == "Float" || name == "Number" || name == "Atomic"
        return name
      end
      if type_param_like?(name) && short_type_param_name?(name) && !@type_param_map.has_key?(name)
        return name
      end

      if info = split_generic_base_and_args(name)
        resolved_base = resolve_class_name_in_signature_context(info[:base]) || info[:base]
        resolved_args = split_generic_type_args(info[:args]).map do |arg|
          arg = arg.strip
          if arg.starts_with?(':')
            arg = arg.size > 1 ? arg[1..] : ""
          end
          resolve_type_name_in_context(arg)
        end.join(", ")
        return resolved_base == info[:base] && resolved_args == info[:args] ? name : "#{resolved_base}(#{resolved_args})"
      end

      if override = @current_namespace_override
        if last_namespace_component(override) == name
          return override
        end
      end
      if current = @current_class
        if last_namespace_component(current) == name
          return current
        end
      end

      # Walk the namespace chain for nested types (not just direct parent).
      # E.g., when @current_class = "CrystalV2::Compiler::Diagnostic" and name = "Span",
      # we need to check @nested_type_names["CrystalV2::Compiler"] to find Span.
      if override = @current_namespace_override
        if nested = nested_type_full_name_in_namespace_chain(override, name)
          return nested
        end
      end
      if current = @current_class
        if nested = nested_type_full_name_in_namespace_chain(current, name)
          return nested
        end
      end

      # Prefer top-level types over short_type_index module matches.
      # e.g., "Time" should resolve to top-level "Time" struct, not "Crystal::System::Time" module.
      if @top_level_type_names.includes?(name) || @top_level_class_kinds.has_key?(name)
        return name
      end

      if candidates = @short_type_index[name]?
        return candidates.first if candidates.size == 1
        # Walk the namespace chain for candidate matching (not just direct parent).
        # E.g., when @current_class = "A::B::C", check "A::B::C::", then "A::B::", then "A::".
        if override = @current_namespace_override
          override_base = if info = split_generic_base_and_args(override)
                            info[:base]
                          else
                            override
                          end
          ns = override_base
          loop do
            if picked = pick_short_type_candidate(candidates, ns)
              return picked
            end
            idx = ns.rindex("::")
            break unless idx
            ns = ns[0, idx]
          end
        end
        if current = @current_class
          current_base = if info = split_generic_base_and_args(current)
                           info[:base]
                         else
                           current
                         end
          ns = current_base
          loop do
            if picked = pick_short_type_candidate(candidates, ns)
              return picked
            end
            idx = ns.rindex("::")
            break unless idx
            ns = ns[0, idx]
          end
        end
        return name if candidates.includes?(name)
        return candidates.min_by(&.size)
      end

      return name if @top_level_type_names.includes?(name) || @top_level_class_kinds.has_key?(name)
      nil
    end

    private def resolve_type_alias_chain(name : String) : String
      resolved = @type_aliases[name]? || LIBC_TYPE_ALIASES[name]? || name
      depth = 0
      while (next_resolved = @type_aliases[resolved]? || LIBC_TYPE_ALIASES[resolved]?) && next_resolved != resolved && depth < 10
        resolved = next_resolved
        depth += 1
      end
      resolved
    end

    private def resolve_type_alias_by_suffix(name : String) : String?
      return nil if name.empty? || name.includes?("::")
      suffix = "::#{name}"
      match = nil
      @type_aliases.each_key do |key|
        next unless key.ends_with?(suffix)
        return nil if match
        match = key
      end
      match ? @type_aliases[match]? : nil
    end

    # Split a generic type argument list like "String, Array(Int32), Hash(K, V)"
    # into top-level arguments, respecting nested parentheses and proc type arrows.
    private def split_generic_type_args(params_str : String) : Array(String)
      if cached = @split_generic_args_cache[params_str]?
        return cached
      end
      args = [] of String
      depth = 0
      start = 0
      i = 0
      while i < params_str.bytesize
        ch = params_str.byte_at(i).unsafe_chr
        case ch
        when '(', '{', '['
          depth += 1
        when ')', '}', ']'
          depth -= 1 if depth > 0
        when ','
          if depth == 0
            # If the next argument begins with `{`, this comma is a generic-arg
            # separator even if a top-level `->` appears later. This avoids
            # mis-parsing lists like `String, {String, _} ->` as a single proc
            # continuation arg.
            j = i + 1
            while j < params_str.bytesize
              byte = params_str.byte_at(j)
              if byte == 32_u8 || byte == 9_u8 || byte == 10_u8 || byte == 13_u8
                j += 1
                next
              end
              break
            end
            next_arg_is_braced = j < params_str.bytesize && params_str.byte_at(j) == '{'.ord.to_u8

            # If a top-level proc arrow appears before the next top-level comma,
            # this comma belongs to a proc type like "A, B -> C".
            if !next_arg_is_braced && proc_arrow_ahead?(params_str, i + 1)
              i += 1
              next
            end
            part = params_str[start, i - start].strip
            args << part unless part.empty?
            start = i + 1
          end
        end
        i += 1
      end
      tail = params_str[start, params_str.size - start].strip
      args << tail unless tail.empty?
      @split_generic_args_cache[params_str] = args
      args
    end

    # Split a union type string like "UInt32 | Int32" into top-level parts,
    # respecting nested parentheses and proc arrows.
    private def split_union_type_names(type_name : String) : Array(String)
      parts = [] of String
      depth = 0
      start = 0
      i = 0
      while i < type_name.bytesize
        ch = type_name.byte_at(i).unsafe_chr
        case ch
        when '(', '{', '['
          depth += 1
        when ')', '}', ']'
          depth -= 1 if depth > 0
        when '|'
          if depth == 0
            part = type_name[start, i - start].strip
            parts << part unless part.empty?
            start = i + 1
          end
        end
        i += 1
      end
      tail = type_name[start, type_name.size - start].strip
      parts << tail unless tail.empty?
      parts
    end

    private def proc_arrow_ahead?(source : String, start_idx : Int32) : Bool
      depth = 0
      i = start_idx
      seen_type = false

      # If the next argument is an explicitly delimited proc type (`{...} -> ...`),
      # the preceding comma is a generic-arg separator, not part of an unbraced proc
      # type like `A, B -> C`.
      j = i
      while j < source.bytesize
        byte = source.byte_at(j)
        if byte == 32_u8 || byte == 9_u8 || byte == 10_u8 || byte == 13_u8
          j += 1
          next
        end
        break
      end
      if j < source.bytesize && source.byte_at(j) == '{'.ord.to_u8
        return false
      end

      while i + 1 < source.bytesize
        ch = source.byte_at(i).unsafe_chr
        case ch
        when '(', '{', '['
          depth += 1
          seen_type = true
        when ')', '}', ']'
          depth -= 1 if depth > 0
          seen_type = true
        when ','
          return false if depth == 0
        when '-'
          if depth == 0 && source.byte_at(i + 1).unsafe_chr == '>'
            # Disambiguate generic arg lists from proc type continuations.
            #
            # In a generic arg list like `Foo(A, -> B)` we must split at the comma,
            # even though a top-level `->` appears later. Our heuristic for proc
            # continuations ("A, B -> C") should not trigger when the arrow is
            # preceded by a namespace separator (e.g. `X::->`), which is never a
            # valid proc input type token and typically comes from unresolved /
            # partially-resolved proc shorthand types.
            prev = i - 1
            while prev >= start_idx
              pch = source.byte_at(prev).unsafe_chr
              break unless pch == ' ' || pch == '\t' || pch == '\n'
              prev -= 1
            end
            if prev >= 1
              if source.byte_at(prev).unsafe_chr == ':' && source.byte_at(prev - 1).unsafe_chr == ':'
                return false
              end
            end
            # Only treat as proc continuation if there's a type name before
            # the arrow (e.g., "B -> C" in "A, B -> C"). A bare "-> C" after
            # a comma is a separate zero-arg proc type, not a continuation.
            return seen_type
          end
          seen_type = true
        when ' ', '\t', '\n'
          # whitespace doesn't count as type content
        else
          seen_type = true
        end
        i += 1
      end
      false
    end

    # Split a full generic type name into base and args, handling nested parens in the base.
    # Example: "Foo(Bar, Baz)::Entry(Qux)" -> base="Foo(Bar, Baz)::Entry", args="Qux"
    private def split_generic_base_and_args(name : String) : NamedTuple(base: String, args: String)?
      if cached = @generic_split_cache[name]?
        return cached
      end

      parse_name = name
      if !name.ends_with?(')') && !name.includes?('(') && name.includes?(',')
        normalized = normalize_missing_generic_parens(name)
        parse_name = normalized unless normalized == name
      end

      if parse_name != name
        if cached = @generic_split_cache[parse_name]?
          @generic_split_cache[name] = cached
          return cached
        end
      end

      unless parse_name.ends_with?(')')
        @generic_split_cache[name] = nil
        @generic_split_cache[parse_name] = nil unless parse_name == name
        return nil
      end

      depth = 0
      i = parse_name.bytesize - 1
      while i >= 0
        ch = parse_name.byte_at(i).unsafe_chr
        case ch
        when ')'
          depth += 1
        when '('
          depth -= 1
          if depth == 0
            base = parse_name.byte_slice(0, i)
            args = parse_name.byte_slice(i + 1, parse_name.size - i - 2)
            result = {base: base, args: args}
            @generic_split_cache[parse_name] = result
            @generic_split_cache[name] = result unless parse_name == name
            return result
          end
        end
        i -= 1
      end

      @generic_split_cache[parse_name] = nil
      @generic_split_cache[name] = nil unless parse_name == name
      nil
    end

    private def substitute_type_params_in_type_name(name : String) : String
      # --- Cache check (invalidate on type_param_map or current_class change) ---
      cc = @current_class
      if cc != @subst_cache_class || @subst_cache_gen != @subst_cache_last_gen
        @subst_cache.clear
        @subst_cache_class = cc
        @subst_cache_last_gen = @subst_cache_gen
      end
      if cached = @subst_cache[name]?
        return cached
      end

      # --- Recursion guard (do NOT cache cycle-break returns) ---
      if @substitute_type_params_stack.includes?(name)
        return name
      end
      @substitute_type_params_stack << name
      @substitute_type_params_depth += 1
      if @substitute_type_params_depth > 40
        @substitute_type_params_depth -= 1
        @substitute_type_params_stack.delete(name)
        return name
      end
      begin
        # Replace 'self' with @current_class in type annotations
        # e.g., "(self, K -> V)?" becomes "(Hash(String, Int32), String -> Int32)?"
        if name == "self" && (current = @current_class)
          return @subst_cache[name] = current
        end
        type_param_map = @type_param_map
        fallback_map : Hash(String, String)? = nil
        if current = @current_class
          if info = generic_owner_info(current)
            fallback_map = info[:map]
          end
        end
        substitution = type_param_map[name]? || (fallback_map ? fallback_map[name]? : nil)
        if substitution
          return @subst_cache[name] = substitution
        end
        if local_name = @current_typeof_local_names.try(&.[name]?)
          unless local_name.empty?
            return @subst_cache[name] = local_name
          end
        end

        if name.includes?("::")
          # Check if the prefix before :: is a type param (e.g., ImplInfo::CarrierUInt)
          if idx = name.index("::")
            prefix = name[0, idx]
            suffix = name[(idx + 2)..]
            substitution = type_param_map[prefix]? || (fallback_map ? fallback_map[prefix]? : nil)
            if substitution
              # Recursively substitute the suffix in case it also contains type params
              return @subst_cache[name] = "#{substitution}::#{substitute_type_params_in_type_name(suffix)}"
            end
          end
          # Also check if the suffix after the last :: is a type param
          if idx = name.rindex("::")
            suffix = name[(idx + 2)..]
            substitution = type_param_map[suffix]? || (fallback_map ? fallback_map[suffix]? : nil)
            if substitution
              return @subst_cache[name] = substitution
            end
          end
        end

        if name.includes?('|')
          parts = split_union_type_name(name).map(&.strip)
          if parts.size > 1
            return @subst_cache[name] = parts.map { |part| substitute_type_params_in_type_name(part) }.join(" | ")
          end
        end

        if name.ends_with?('?')
          base = name[0, name.size - 1]
          return @subst_cache[name] = "#{substitute_type_params_in_type_name(base)}?"
        end

        # Handle Proc shorthand syntax: (A, B -> C) or (A -> B)
        # This must be checked before split_generic_base_and_args
        if name.starts_with?('(') && name.ends_with?(')')
          inner = name[1, name.size - 2]
          if arrow_idx = find_top_level_arrow(inner)
            inputs_str = inner[0, arrow_idx].strip
            output_str = inner[arrow_idx + 2, inner.size - arrow_idx - 2].strip
            # Parse inputs (comma-separated at depth 0)
            inputs = split_proc_type_inputs(inputs_str)
            new_inputs = inputs.map { |inp| substitute_type_params_in_type_name(inp.strip) }
            new_output = substitute_type_params_in_type_name(output_str)
            return @subst_cache[name] = "(#{new_inputs.join(", ")} -> #{new_output})"
          end
        end

        if info = split_generic_base_and_args(name)
          args = split_generic_type_args(info[:args])
          new_args = args.map do |arg|
            normalize_tuple_literal_type_name(substitute_type_params_in_type_name(arg.strip))
          end
          return @subst_cache[name] = "#{info[:base]}(#{new_args.join(", ")})"
        end

        @subst_cache[name] = normalize_missing_generic_parens(name)
      ensure
        @substitute_type_params_depth -= 1
        @substitute_type_params_stack.delete(name)
      end
    end

    private def find_top_level_arrow(name : String) : Int32?
      depth = 0
      i = 0
      while i + 1 < name.bytesize
        ch = name.byte_at(i).unsafe_chr
        case ch
        when '(', '{', '['
          depth += 1
        when ')', '}', ']'
          depth -= 1 if depth > 0
        when '-'
          if depth == 0 && name.byte_at(i + 1).unsafe_chr == '>'
            return i
          end
        end
        i += 1
      end
      nil
    end

    # Split Proc input types by comma, respecting nested parens.
    # Unlike split_generic_type_args, this doesn't skip commas before arrows
    # since we've already extracted the inputs portion.
    private def split_proc_type_inputs(inputs_str : String) : Array(String)
      args = [] of String
      depth = 0
      start = 0
      i = 0
      while i < inputs_str.bytesize
        ch = inputs_str.byte_at(i).unsafe_chr
        case ch
        when '(', '{', '['
          depth += 1
        when ')', '}', ']'
          depth -= 1 if depth > 0
        when ','
          if depth == 0
            part = inputs_str[start, i - start].strip
            args << part unless part.empty?
            start = i + 1
          end
        end
        i += 1
      end
      tail = inputs_str[start, inputs_str.size - start].strip
      args << tail unless tail.empty?
      args
    end

    private def extract_proc_return_type_name(type_name : String) : String?
      stripped = type_name.strip
      if stripped.starts_with?("Proc(") && stripped.ends_with?(')')
        inner = stripped[5, stripped.size - 6]
        args = split_generic_type_args(inner)
        if ret = args.last?
          ret = ret.strip
          return ret unless ret.empty?
        end
      end
      if arrow_index = find_top_level_arrow(stripped)
        right = stripped[arrow_index + 2, stripped.size - arrow_index - 2].strip
        return right unless right.empty?
      end
      nil
    end

    private def proc_input_type_names(type_name : String) : Array(String)?
      stripped = type_name.strip
      return nil if stripped.empty?

      if stripped.starts_with?("Proc(") && stripped.ends_with?(')')
        inner = stripped[5, stripped.size - 6]
        args = split_generic_type_args(inner)
        return [] of String if args.size <= 1
        return args[0...-1]
      end

      if arrow_index = find_top_level_arrow(stripped)
        left = stripped[0, arrow_index].strip
        return [] of String if left.empty?
        # Support explicitly braced proc inputs to avoid ambiguity inside generic
        # argument lists (e.g. `Hash(String, {String, _} ->)`).
        #
        # If the arrow's RHS is empty, we interpret `{A, B} ->` as:
        # inputs=[A] return=B  (so `{String, _} ->` means `String -> _`).
        if left.starts_with?('{') && left.ends_with?('}')
          inner = left[1, left.size - 2].strip
          parts = inner.empty? ? ([] of String) : split_proc_type_inputs(inner)
          right = stripped[arrow_index + 2, stripped.size - arrow_index - 2].strip
          if right.empty?
            return parts if parts.size <= 1
            return parts[0...-1]
          end
          return parts
        end
        return split_generic_type_args(left)
      end

      nil
    end

    private def substitute_type_param(type_name : String, param_name : String, actual_name : String) : String
      return type_name if param_name.empty? || actual_name.empty?
      return type_name unless type_name.includes?(param_name)
      # Fast string-based word-boundary substitution (avoids creating Regex objects).
      result = type_name
      search_from = 0
      while (idx = result.index(param_name, search_from))
        # Check left boundary: must be start-of-string or non-identifier char
        left_ok = idx == 0 || !ident_char?(result.byte_at(idx - 1))
        # Check right boundary: must be end-of-string or non-identifier char
        right_idx = idx + param_name.bytesize
        right_ok = right_idx >= result.bytesize || !ident_char?(result.byte_at(right_idx))
        if left_ok && right_ok
          result = String.build(result.bytesize - param_name.bytesize + actual_name.bytesize) do |io|
            io.write(result.to_slice[0, idx])
            io << actual_name
            io.write(result.to_slice[right_idx, result.bytesize - right_idx])
          end
          search_from = idx + actual_name.bytesize
        else
          search_from = idx + param_name.bytesize
        end
      end
      result
    end

    @[AlwaysInline]
    private def ident_char?(byte : UInt8) : Bool
      (byte >= 'A'.ord && byte <= 'Z'.ord) ||
        (byte >= 'a'.ord && byte <= 'z'.ord) ||
        (byte >= '0'.ord && byte <= '9'.ord) ||
        byte == '_'.ord || byte == ':'.ord
    end

    private def type_param_map_debug_string : String
      return "" if @type_param_map.empty?
      @type_param_map.map { |param, actual| "#{param}=#{actual}" }.join(",")
    end

    private def short_type_param_name?(name : String) : Bool
      return false if name.empty?
      if name.size == 1
        return name[0].uppercase?
      end
      return name.size == 2 && name[0].uppercase? && name[1].ascii_number?
    end

    private def value_literal_name?(name : String) : Bool
      return true if name == "true" || name == "false"
      name.matches?(/\A-?(0x[0-9A-Fa-f_]+|0b[01_]+|0o[0-7_]+|[0-9_]+)(_[iu](8|16|32|64|128))?\z/)
    end

    private def type_param_like?(name : String) : Bool
      return false if name.empty?
      return false if name.includes?("::")
      return false unless name.matches?(/\A[A-Z][A-Za-z0-9_]*\z/)
      return false if primitive_self_type(name)
      return false if builtin_alias_target?(name)
      return false if @class_info.has_key?(name)
      return false if @enum_info && @enum_info.not_nil!.has_key?(name)
      return false if @short_type_index.has_key?(name)
      return false if @module_defs.has_key?(name)
      return false if @type_aliases.has_key?(name)
      return false if LIBC_TYPE_ALIASES.has_key?(name)
      true
    end

    private def known_type_name?(name : String) : Bool
      return true if name.empty?
      return true if primitive_self_type(name)
      return true if @class_info.has_key?(name)
      return true if @enum_info && @enum_info.not_nil!.has_key?(name)
      return true if @module_defs.has_key?(name)
      return true if @type_aliases.has_key?(name)
      return true if LIBC_TYPE_ALIASES.has_key?(name)
      false
    end

    private def unbound_type_params_from_type_name(type_name : String) : Set(String)
      return Set(String).new if type_name.empty?
      tokens = [] of String
      type_name.scan(/[A-Z][A-Za-z0-9_]*/) do |match|
        tokens << match[0]
      end
      return Set(String).new if tokens.empty?

      unbound = Set(String).new
      tokens.each do |token|
        next if @type_param_map.has_key?(token)
        next if known_type_name?(token)
        unbound.add(token)
      end

      unbound
    end

    private def def_has_unbound_type_params?(node : CrystalV2::Compiler::Frontend::DefNode) : Bool
      if params = node.params
        params.each do |param|
          if ta = param.type_annotation
            if param.is_block
              if type_param_name = extract_proc_return_type_name(String.new(ta))
                if type_param_like?(type_param_name) && !@type_param_map.has_key?(type_param_name)
                  return true
                end
              end
            end
            return true unless unbound_type_params_from_type_name(String.new(ta)).empty?
          end
        end
      end

      if rt = node.return_type
        return true unless unbound_type_params_from_type_name(String.new(rt)).empty?
      end

      false
    end

    private def type_name_includes_param?(type_name : String, param_name : String) : Bool
      return false if param_name.empty?
      return false unless type_name.includes?(param_name)
      # Fast word-boundary check without Regex allocation
      search_from = 0
      while (idx = type_name.index(param_name, search_from))
        left_ok = idx == 0 || !ident_char?(type_name.byte_at(idx - 1))
        right_idx = idx + param_name.bytesize
        right_ok = right_idx >= type_name.bytesize || !ident_char?(type_name.byte_at(right_idx))
        return true if left_ok && right_ok
        search_from = idx + param_name.bytesize
      end
      false
    end

    private def unresolved_generic_receiver?(type_name : String) : Bool
      info = split_generic_base_and_args(type_name)
      return false unless info

      template = @generic_templates[info[:base]]?
      return false unless template

      args = split_generic_type_args(info[:args]).map(&.strip)
      return false unless args.size == template.type_params.size

      template.type_params.any? do |param|
        args.any? { |arg| type_name_includes_param?(arg, param) }
      end
    end

    private def substitute_type_params(type_name : String, param_map : Hash(String, String)) : String
      result = type_name
      param_map.each do |param, actual|
        result = substitute_type_param(result, param, actual)
      end
      result
    end

    private def receiver_name_from_method_name(method_name : String) : String?
      if idx = method_name.index('#')
        return method_name[0, idx]
      elsif idx = method_name.index('.')
        return method_name[0, idx]
      end
      nil
    end

    private def type_param_map_for_receiver_name(method_name : String) : Hash(String, String)
      receiver = receiver_name_from_method_name(method_name)
      return {} of String => String unless receiver

      info = split_generic_base_and_args(receiver)
      return {} of String => String unless info

      base = info[:base]
      args = split_generic_type_args(info[:args]).map do |arg|
        normalize_tuple_literal_type_name(arg.strip)
      end
      template = @generic_templates[base]?
      return {} of String => String unless template && template.type_params.size == args.size

      mapping = {} of String => String
      template.type_params.each_with_index do |param, i|
        mapping[param] = args[i].strip
      end
      mapping
    end

    private def type_param_map_for_receiver_type(receiver_type : TypeRef) : Hash(String, String)
      desc = @module.get_type_descriptor(receiver_type)
      return {} of String => String unless desc

      if desc.kind == TypeKind::Tuple
        args = desc.type_params
        return {} of String => String if args.empty?
        names = args.map do |ref|
          name = get_type_name_from_ref(ref)
          (name == "Void" || name == "Unknown") ? "Unknown" : name
        end
        return {
          "T"        => names.join(" | "),
          "T__tuple" => names.join(", "),
        }
      end

      info = split_generic_base_and_args(desc.name)
      return {} of String => String unless info

      template = @generic_templates[info[:base]]?
      return {} of String => String unless template

      args = split_generic_type_args(info[:args]).map do |arg|
        normalize_tuple_literal_type_name(arg.strip)
      end
      return {} of String => String unless template.type_params.size == args.size

      mapping = {} of String => String
      template.type_params.each_with_index do |param, i|
        mapping[param] = args[i].strip
      end
      mapping
    end

    private def fallback_type_param_map_for_current : Hash(String, String)?
      return nil unless @type_param_map.empty?
      if current = @current_class
        map = type_param_map_for_receiver_name("#{current}#_")
        return map unless map.empty?
      end
      if override = @current_namespace_override
        map = type_param_map_for_receiver_name("#{override}#_")
        return map unless map.empty?
      end
      nil
    end

    private def strip_generic_receiver_from_method_name(method_name : String) : String
      method_id = method_name.object_id
      if method_id == @strip_generic_receiver_last_id
        if cached = @strip_generic_receiver_last
          record_cache_stat("strip_generic_receiver", true)
          return cached
        end
      end
      slot = (method_id & @strip_generic_receiver_table_mask).to_i
      if @strip_generic_receiver_table_keys[slot] == method_id
        if cached = @strip_generic_receiver_table_vals[slot]
          record_cache_stat("strip_generic_receiver", true)
          @strip_generic_receiver_last_id = method_id
          @strip_generic_receiver_last = cached
          return cached
        end
      end
      bytesize = method_name.bytesize
      sep_idx : Int32? = nil
      paren_idx : Int32? = nil
      i = 0
      while i < bytesize
        byte = method_name.to_unsafe[i]
        if byte == '('.ord
          paren_idx ||= i
        elsif byte == '#'.ord || byte == '.'.ord
          sep_idx = i
          break
        end
        i += 1
      end
      return method_name unless sep_idx && paren_idx && paren_idx < sep_idx
      if cached = @strip_generic_receiver_name_cache[method_name]?
        record_cache_stat("strip_generic_receiver", true)
        @strip_generic_receiver_last_id = method_id
        @strip_generic_receiver_last = cached
        return cached
      end
      record_cache_stat("strip_generic_receiver", false)
      total = bytesize - (sep_idx - paren_idx)
      ptr = method_name.to_unsafe
      result = String.build(total) do |io|
        io.write Slice.new(ptr, paren_idx)
        io.write Slice.new(ptr + sep_idx, bytesize - sep_idx)
      end
      @strip_generic_receiver_last_id = method_id
      @strip_generic_receiver_last = result
      @strip_generic_receiver_table_keys[slot] = method_id
      @strip_generic_receiver_table_vals[slot] = result
      @strip_generic_receiver_name_cache[method_name] = result
      @strip_generic_receiver_name_cache_size += 1
      if @strip_generic_receiver_name_cache_size > @strip_generic_receiver_name_cache_limit
        @strip_generic_receiver_name_cache.clear
        @strip_generic_receiver_name_cache_size = 0
      end
      result
    end

    @[AlwaysInline]
    private def record_cache_stat(name : String, hit : Bool) : Nil
      return unless @debug_cache_histo
      counts = @debug_cache_stats[name]? || {0, 0}
      if hit
        counts = {counts[0] + 1, counts[1]}
      else
        counts = {counts[0], counts[1] + 1}
      end
      @debug_cache_stats[name] = counts

      last = @debug_cache_last
      return unless last
      now = Time.instant
      return if (now - last).total_milliseconds < 3000

      @debug_cache_last = now
      entries = @debug_cache_stats.to_a
      entries.sort_by! { |entry| -(entry[1][0] + entry[1][1]) }
      top = entries.first(5)
      formatted = top.map do |entry|
        key = entry[0]
        hits = entry[1][0]
        misses = entry[1][1]
        "#{key}=#{hits}/#{misses}"
      end
      STDERR.puts "[CACHE_HISTO] " + formatted.join(", ")
    end

    # Hot-path variant for overload lookup: avoid cache hash cost.
    private def strip_generic_receiver_for_lookup(method_name : String) : String
      if method_name.includes?('#') || method_name.includes?('.')
        return strip_generic_receiver_from_base_name(method_name)
      end
      method_name
    end

    private def strip_generic_receiver_uncached(method_name : String) : String
      bytesize = method_name.bytesize
      sep_idx : Int32? = nil
      paren_idx : Int32? = nil
      sep_char : UInt8? = nil
      i = 0
      while i < bytesize
        byte = method_name.to_unsafe[i]
        if byte == '('.ord
          paren_idx ||= i
        elsif byte == '#'.ord || byte == '.'.ord
          sep_idx = i
          sep_char = byte
          break
        end
        i += 1
      end

      return method_name unless sep_idx && paren_idx && paren_idx < sep_idx

      total = bytesize - (sep_idx - paren_idx)
      ptr = method_name.to_unsafe
      String.build(total) do |io|
        io.write Slice.new(ptr, paren_idx)
        io.write Slice.new(ptr + sep_idx, bytesize - sep_idx)
      end
    end

    private def block_return_type_name(ctx : LoweringContext, block_id : BlockId) : String?
      block = ctx.get_block(block_id)
      term = block.terminator
      return nil unless term.is_a?(Return)
      value_id = term.value
      return nil unless value_id
      type_ref = ctx.type_of(value_id)
      return nil if type_ref == TypeRef::VOID
      type_name = get_type_name_from_ref(type_ref)
      return nil if type_name == "Void" || type_name == "Unknown"
      type_name
    end

    private def inline_block_return_type_name(
      block : CrystalV2::Compiler::Frontend::BlockNode,
      param_types : Array(TypeRef)?,
      self_type_name : String?,
    ) : String?
      old_arena = @arena
      block_id = block.object_id
      block_arena = cached_block_arena(block_id)
      block_arena ||= resolve_arena_for_block(block, old_arena)
      if block_arena
        store_block_arena(block_id, block_arena)
        @arena = block_arena
      end
      if env_get("DEBUG_BLOCK_ARENA")
        mapped = cached_block_arena(block_id)
        STDERR.puts "[BLOCK_ARENA] block=#{block.object_id} mapped=#{!!mapped} current=#{old_arena.object_id} target=#{mapped ? mapped.object_id : "nil"}"
      end

      body = block.body
      old_locals = @current_typeof_locals
      old_names = @current_typeof_local_names
      local_map = old_locals ? old_locals.dup : {} of String => TypeRef
      name_map = old_names ? old_names.dup : {} of String => String

      if params = block.params
        params.each_with_index do |param, idx|
          next unless pname = param.name
          name = String.new(pname)
          param_type = if param_types && (override = param_types[idx]?)
                         override
                       elsif ta = param.type_annotation
                         type_ref_for_name(String.new(ta))
                       else
                         TypeRef::VOID
                       end
          local_map[name] = param_type if param_type != TypeRef::VOID
        end
      end

      @current_typeof_locals = local_map
      @current_typeof_local_names = name_map
      begin
        return nil if body.empty?
        last_expr = body.last?
        return nil unless last_expr
        if inferred = infer_type_from_expr(last_expr, self_type_name)
          type_name = get_type_name_from_ref(inferred)
          return nil if type_name == "Void" || type_name == "Unknown"
          return type_name
        end
      ensure
        @current_typeof_locals = old_locals
        @current_typeof_local_names = old_names
        @arena = old_arena
      end

      nil
    end

    private def inline_proc_return_type_name(
      proc_node : CrystalV2::Compiler::Frontend::ProcLiteralNode,
      param_types : Array(TypeRef)?,
      self_type_name : String?,
    ) : String?
      body = proc_node.body
      return nil unless body && !body.empty?

      old_locals = @current_typeof_locals
      old_names = @current_typeof_local_names
      local_map = old_locals ? old_locals.dup : {} of String => TypeRef
      name_map = old_names ? old_names.dup : {} of String => String

      if params = proc_node.params
        params.each_with_index do |param, idx|
          next unless pname = param.name
          name = String.new(pname)
          param_type = if param_types && (override = param_types[idx]?)
                         override
                       elsif ta = param.type_annotation
                         type_ref_for_name(String.new(ta))
                       else
                         TypeRef::VOID
                       end
          local_map[name] = param_type if param_type != TypeRef::VOID
        end
      end

      @current_typeof_locals = local_map
      @current_typeof_local_names = name_map
      begin
        last_expr = body.last?
        return nil unless last_expr
        if inferred = infer_type_from_expr(last_expr, self_type_name)
          type_name = get_type_name_from_ref(inferred)
          return nil if type_name == "Void" || type_name == "Unknown"
          return type_name
        end
      ensure
        @current_typeof_locals = old_locals
        @current_typeof_local_names = old_names
      end

      nil
    end

    private def infer_try_block_return_type(
      block_id : ExprId,
      param_types : Array(TypeRef),
      self_type_name : String?,
    ) : TypeRef?
      arena = arena_for_expr?(block_id)
      return nil unless arena
      return nil if block_id.index >= arena.size

      old_arena = @arena
      @arena = arena
      begin
        node = @arena[block_id]
        if node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
          if shorthand = infer_try_shorthand_block_return_type(node, param_types, self_type_name)
            return shorthand
          end
          if name = inline_block_return_type_name(node, param_types, self_type_name)
            return type_ref_for_name(name)
          end
        elsif node.is_a?(CrystalV2::Compiler::Frontend::ProcLiteralNode)
          if name = inline_proc_return_type_name(node, param_types, self_type_name)
            return type_ref_for_name(name)
          end
        end
      ensure
        @arena = old_arena
      end

      nil
    end

    # Handle &.method shorthand blocks for try (block has no params, body is implicit receiver call).
    private def infer_try_shorthand_block_return_type(
      block : CrystalV2::Compiler::Frontend::BlockNode,
      param_types : Array(TypeRef),
      self_type_name : String?,
    ) : TypeRef?
      return nil if param_types.empty?
      # Only handle implicit shorthand (no explicit params).
      params = block.params
      param_name = nil.as(String?)
      if params && !params.empty?
        if first = params.first?
          if pname = first.name
            param_name = String.new(pname)
          end
        end
      end

      body = block.body
      return nil if body.empty?
      last_expr = body.last?
      return nil unless last_expr
      expr_node = node_for_expr(last_expr)
      return nil unless expr_node

      member_name : String? = nil
      receiver_is_implicit = false

      case expr_node
      when CrystalV2::Compiler::Frontend::CallNode
        callee = node_for_expr(expr_node.callee)
        if callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          member_name = String.new(callee.member)
          recv_node = node_for_expr(callee.object)
          receiver_is_implicit = recv_node.is_a?(CrystalV2::Compiler::Frontend::ImplicitObjNode)
          if !receiver_is_implicit && param_name && recv_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            receiver_is_implicit = String.new(recv_node.name) == param_name
          end
        end
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        member_name = String.new(expr_node.member)
        recv_node = node_for_expr(expr_node.object)
        receiver_is_implicit = recv_node.is_a?(CrystalV2::Compiler::Frontend::ImplicitObjNode)
        if !receiver_is_implicit && param_name && recv_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          receiver_is_implicit = String.new(recv_node.name) == param_name
        end
      end

      return nil unless receiver_is_implicit && member_name

      recv_type = param_types.first
      return nil if recv_type == TypeRef::VOID
      owner_name = get_type_name_from_ref(recv_type)
      return nil if owner_name.empty? || owner_name == "Void" || owner_name == "Unknown"

      base_name = resolve_method_with_inheritance(owner_name, member_name) || "#{owner_name}##{member_name}"
      if ret = resolve_return_type_from_def(base_name, base_name, recv_type)
        return ret if ret != TypeRef::VOID
      end
      if ret = get_function_return_type(base_name)
        return ret if ret != TypeRef::VOID
      end

      nil
    end

    private def infer_return_type_from_callsite(
      node : CrystalV2::Compiler::Frontend::DefNode,
      owner_name : String?,
      call_args : Array(ExprId),
      named_args : Array(CrystalV2::Compiler::Frontend::NamedArgument)?,
      self_type_name : String?,
    ) : TypeRef?
      call_types = call_args.map do |arg|
        inferred = infer_type_from_expr(arg, self_type_name) || TypeRef::VOID
        if inferred == TypeRef::VOID
          if type_str = stringify_type_expr(arg)
            resolved = type_ref_for_name(type_str)
            inferred = resolved if resolved != TypeRef::VOID
          end
        end
        inferred
      end
      local_map = {} of String => TypeRef
      name_map = {} of String => String

      if params = node.params
        call_index = 0
        params.each do |param|
          next if named_only_separator?(param)
          if param.is_block
            next
          elsif param.is_splat || param.is_double_splat
            call_index += 1 unless param.is_double_splat
            next
          end
          param_name = param.name.nil? ? "_" : String.new(param.name.not_nil!)
          if call_index < call_types.size
            param_type = call_types[call_index]
            if param_type != TypeRef::VOID
              local_map[param_name] = param_type
              name_map[param_name] = get_type_name_from_ref(param_type)
            end
          end
          call_index += 1
        end
      end

      if named_args
        named_args.each do |named|
          name = String.new(named.name)
          if inferred = infer_type_from_expr(named.value, self_type_name)
            if inferred != TypeRef::VOID
              local_map[name] = inferred
              name_map[name] = get_type_name_from_ref(inferred)
            end
          end
        end
      end

      old_locals = @current_typeof_locals
      old_names = @current_typeof_local_names
      @current_typeof_locals = local_map
      @current_typeof_local_names = name_map
      begin
        inferred = infer_concrete_return_type_from_body(node, owner_name)
        if env_get("DEBUG_INFER_CALLSITE")
          method_name = String.new(node.name)
          if method_name.includes?(env_get("DEBUG_INFER_CALLSITE").to_s)
            types_str = call_types.map { |t| get_type_name_from_ref(t) }.join(",")
            inferred_name = inferred ? get_type_name_from_ref(inferred) : "nil"
            STDERR.puts "[INFER_CALLSITE] method=#{method_name} owner=#{owner_name || "nil"} args=#{types_str} inferred=#{inferred_name}"
          end
        end
        inferred
      ensure
        @current_typeof_locals = old_locals
        @current_typeof_local_names = old_names
      end
    end

    private def infer_call_block_return_name(
      block_expr : ExprId?,
      block_pass_expr : ExprId?,
      span : CrystalV2::Compiler::Frontend::Span,
      param_types : Array(TypeRef)?,
      self_type_name : String?,
    ) : String?
      if block_expr
        if block_node = node_for_expr(block_expr)
          case block_node
          when CrystalV2::Compiler::Frontend::BlockNode
            return inline_block_return_type_name(block_node, param_types, self_type_name)
          when CrystalV2::Compiler::Frontend::ProcLiteralNode
            return inline_proc_return_type_name(block_node, param_types, self_type_name)
          end
        end
      elsif block_pass_expr
        if pass_node = node_for_expr(block_pass_expr)
          case pass_node
          when CrystalV2::Compiler::Frontend::ProcLiteralNode
            return inline_proc_return_type_name(pass_node, param_types, self_type_name)
          when CrystalV2::Compiler::Frontend::BlockNode
            return inline_block_return_type_name(pass_node, param_types, self_type_name)
          end
        end
        if param_types
          block_for_inline = build_block_from_block_pass(block_pass_expr, param_types, span)
          return inline_block_return_type_name(block_for_inline, param_types, self_type_name)
        end
      end

      nil
    end

    private def resolve_block_dependent_return_type(
      mangled_method_name : String,
      base_method_name : String,
      block_return_name : String,
    ) : TypeRef?
      return nil if block_return_name.empty?

      func_def = @function_defs[mangled_method_name]? || @function_defs[base_method_name]?
      return nil unless func_def

      return_type_slice = func_def.return_type
      return nil unless return_type_slice
      return_type_name = String.new(return_type_slice)
      return nil if return_type_name.empty?

      block_param = func_def.params.try(&.find(&.is_block))
      return nil unless block_param

      block_type = block_param.type_annotation
      return nil unless block_type

      block_type_name = String.new(block_type)
      type_param_name = extract_proc_return_type_name(block_type_name)
      return nil unless type_param_name && !type_param_name.empty?

      substituted = substitute_type_param(return_type_name, type_param_name, block_return_name)
      return nil if substituted == return_type_name

      type_ref_for_name(substituted)
    end

    private def block_return_type_param_name(
      mangled_method_name : String,
      base_method_name : String,
    ) : String?
      func_def = @function_defs[mangled_method_name]? || @function_defs[base_method_name]?
      return nil unless func_def

      block_param = func_def.params.try(&.find(&.is_block))
      return nil unless block_param

      block_type = block_param.type_annotation
      return nil unless block_type

      type_param_name = extract_proc_return_type_name(String.new(block_type))
      return nil unless type_param_name && !type_param_name.empty?
      return "_" if type_param_name == "_"
      return nil unless type_param_like?(type_param_name)

      type_param_name
    end

    private def resolve_return_type_from_def(
      mangled_method_name : String,
      base_method_name : String,
      receiver_type : TypeRef?,
    ) : TypeRef?
      func_def = @function_defs[mangled_method_name]? || @function_defs[base_method_name]?
      return nil unless func_def

      return_type_slice = func_def.return_type
      return nil unless return_type_slice

      return_type_name = String.new(return_type_slice)
      return nil if return_type_name.empty?

      owner_override = method_owner(base_method_name)
      if owner_override.empty?
        owner_override = method_owner(mangled_method_name)
      end
      qualified_return_type = return_type_name
      if !owner_override.empty? && !return_type_name.includes?("::")
        candidate = "#{owner_override}::#{return_type_name}"
        if @class_info.has_key?(candidate) || @generic_templates.has_key?(candidate) || @module_defs.has_key?(candidate)
          qualified_return_type = candidate
        end
      end

      if cached = @function_types[mangled_method_name]? || @function_types[base_method_name]?
        if cached != TypeRef::VOID &&
           return_type_name != "self" &&
           !return_type_name.includes?("typeof(") &&
           !return_type_name.includes?('(') &&
           !return_type_name.includes?('|') &&
           !return_type_name.includes?(',') &&
           !return_type_name.includes?('{') &&
           !return_type_name.ends_with?('?') &&
           !return_type_name.ends_with?('*') &&
           !(type_param_like?(return_type_name) && !@type_param_map.has_key?(return_type_name))
          resolved = if qualified_return_type == return_type_name && !owner_override.empty? && !return_type_name.includes?("::")
                       old_class = @current_class
                       @current_class = owner_override
                       begin
                         type_ref_for_name(return_type_name)
                       ensure
                         @current_class = old_class
                       end
                     else
                       type_ref_for_name(qualified_return_type)
                     end
          if resolved != TypeRef::VOID && resolved != TypeRef::NIL && resolved != cached
            return resolved
          end
          return cached
        end
      end

      if return_type_name == "self"
        if receiver_type && receiver_type != TypeRef::VOID
          return receiver_type
        end
      end

      param_map = function_type_param_map_for(mangled_method_name, base_method_name)
      receiver_map = type_param_map_for_receiver_name(base_method_name)
      if receiver_map.empty?
        receiver_map = type_param_map_for_receiver_name(mangled_method_name)
      end
      if receiver_map.empty? && receiver_type && receiver_type != TypeRef::VOID
        if desc = @module.get_type_descriptor(receiver_type)
          if info = split_generic_base_and_args(desc.name)
            if template = @generic_templates[info[:base]]?
              if desc.type_params.size == template.type_params.size
                template.type_params.each_with_index do |param, idx|
                  receiver_map[param] = get_type_name_from_ref(desc.type_params[idx])
                end
              end
            end
          end
        end
      end

      merged = {} of String => String
      if param_map && !param_map.empty?
        merged.merge!(param_map)
      end
      if !receiver_map.empty?
        merged.merge!(receiver_map)
      end

      if merged.empty?
        resolved = if qualified_return_type == return_type_name && !owner_override.empty? && !return_type_name.includes?("::")
                     old_class = @current_class
                     @current_class = owner_override
                     begin
                       type_ref_for_name(return_type_name)
                     ensure
                       @current_class = old_class
                     end
                   else
                     type_ref_for_name(qualified_return_type)
                   end
        if debug_env_filter_match?("DEBUG_RETURN_DEF", mangled_method_name, base_method_name)
          STDERR.puts "[RETURN_DEF] name=#{mangled_method_name} base=#{base_method_name} rt=#{return_type_name} map=none resolved=#{get_type_name_from_ref(resolved)}"
        end
        return resolved
      end

      with_type_param_map(merged) do
        resolved = if qualified_return_type == return_type_name && !owner_override.empty? && !return_type_name.includes?("::")
                     old_class = @current_class
                     @current_class = owner_override
                     begin
                       type_ref_for_name(return_type_name)
                     ensure
                       @current_class = old_class
                     end
                   else
                     type_ref_for_name(qualified_return_type)
                   end
        if debug_env_filter_match?("DEBUG_RETURN_DEF", mangled_method_name, base_method_name)
          params_str = merged.map { |k, v| "#{k}=#{v}" }.join(",")
          STDERR.puts "[RETURN_DEF] name=#{mangled_method_name} base=#{base_method_name} rt=#{return_type_name} map=#{params_str} resolved=#{get_type_name_from_ref(resolved)}"
        end
        resolved
      end
    end

    private def block_param_types_for_call(
      mangled_method_name : String,
      base_method_name : String,
      receiver_type : TypeRef?,
    ) : Array(TypeRef)?
      resolved_base = base_method_name
      resolved_mangled = mangled_method_name
      func_def = @function_defs[resolved_mangled]? || @function_defs[resolved_base]?
      if func_def.nil?
        stripped_base = strip_generic_receiver_from_base_name(base_method_name)
        stripped_mangled = strip_generic_receiver_from_base_name(mangled_method_name)
        if stripped_base != base_method_name || stripped_mangled != mangled_method_name
          resolved_base = stripped_base
          resolved_mangled = stripped_mangled
          func_def = @function_defs[resolved_mangled]? || @function_defs[resolved_base]?
        end
      end
      debug_block_params = env_get("DEBUG_BLOCK_PARAMS") &&
                           (mangled_method_name.includes?("min_by") || base_method_name.includes?("min_by") ||
                            mangled_method_name.includes?("each_with_index") || base_method_name.includes?("each_with_index"))
      if debug_block_params
        STDERR.puts "[BLOCK_PARAMS] lookup base=#{resolved_base} mangled=#{resolved_mangled} func_def=#{!func_def.nil?}"
      end

      # String.new { |buffer| ... } yields a Pointer(UInt8)
      if resolved_base == "String#new" || resolved_base == "String.new" || resolved_mangled.starts_with?("String$Dnew")
        return [type_ref_for_name("Pointer(UInt8)")]
      end
      if resolved_base.ends_with?(".new") ||
         (resolved_base == "new" && resolved_mangled.includes?(".new"))
        owner = method_owner(resolved_base)
        if owner.empty?
          owner = method_owner(resolved_mangled)
        end
        unless owner.empty?
          return [type_ref_for_name(owner)]
        end
      end

      # String#each_char yields a Char; each_char_with_index yields (Char, Int32)
      if resolved_base == "String#each_char" || resolved_base.ends_with?("String#each_char")
        return [TypeRef::CHAR]
      end
      if resolved_base == "String#each_char_with_index" || resolved_base.ends_with?("String#each_char_with_index")
        return [TypeRef::CHAR, TypeRef::INT32]
      end
      if resolved_base.ends_with?("#sort_by") || resolved_base.ends_with?("#sort_by!") ||
         resolved_base.ends_with?("#unstable_sort_by") || resolved_base.ends_with?("#unstable_sort_by!")
        if receiver_type && receiver_type != TypeRef::VOID
          if recv_desc = @module.get_type_descriptor(receiver_type)
            if elem_name = element_type_for_type_name(recv_desc.name)
              return [type_ref_for_name(elem_name)]
            end
          end
        end
      end

      return fallback_block_param_types(resolved_base, receiver_type) unless func_def

      # Hot-path: internal_to_s yields (Pointer(UInt8), Int32, Bool)
      if resolved_base.ends_with?("internal_to_s")
        return [type_ref_for_name("Pointer(UInt8)"), TypeRef::INT32, TypeRef::BOOL]
      end

      block_param = func_def.params.try(&.find(&.is_block))
      if debug_block_params
        STDERR.puts "[BLOCK_PARAMS] block_param=#{!block_param.nil?}"
      end
      return fallback_block_param_types(base_method_name, receiver_type) unless block_param

      param_map = function_type_param_map_for(resolved_mangled, resolved_base)
      if param_map && !param_map.empty?
        param_map = param_map.dup
      else
        param_map = nil
      end

      receiver_map = type_param_map_for_receiver_name(resolved_base)
      if param_map.nil? || param_map.empty?
        param_map = receiver_map
      end

      receiver_type_map = {} of String => String
      if receiver_type && receiver_type != TypeRef::VOID
        receiver_type_map = type_param_map_for_receiver_type(receiver_type)
        if !receiver_type_map.empty?
          if param_map && !param_map.empty?
            param_map = param_map.merge(receiver_type_map)
          else
            param_map = receiver_type_map
          end
        end
      end

      if !@type_param_map.empty?
        if param_map && !param_map.empty?
          param_map = @type_param_map.merge(param_map)
        else
          param_map = @type_param_map.dup
        end
      end

      type_slice = block_param.type_annotation
      if debug_block_params
        STDERR.puts "[BLOCK_PARAMS] type_slice=#{type_slice ? String.new(type_slice) : "nil"}"
      end
      if type_slice.nil?
        if inferred = infer_yield_param_types_from_body(
             func_def,
             resolved_mangled,
             resolved_base,
             receiver_type,
             param_map
           )
          return inferred
        end
        return fallback_block_param_types(resolved_base, receiver_type)
      end

      input_names = proc_input_type_names(String.new(type_slice))
      if debug_block_params
        STDERR.puts "[BLOCK_PARAMS] inputs=#{input_names ? input_names.join(",") : "nil"}"
      end
      unless input_names && !input_names.empty?
        if inferred = infer_yield_param_types_from_body(
             func_def,
             resolved_mangled,
             resolved_base,
             receiver_type,
             param_map
           )
          return inferred
        end
        return fallback_block_param_types(resolved_base, receiver_type)
      end

      if receiver_type && receiver_type != TypeRef::VOID
        needs_fallback = param_map.nil? || param_map.empty? ||
                         input_names.any? do |name|
                           type_param_like?(name) && (receiver_type_map.empty? || !receiver_type_map.has_key?(name))
                         end
        if needs_fallback
          if type_desc = @module.get_type_descriptor(receiver_type)
            if element_name = element_type_for_type_name(type_desc.name)
              param_map = param_map ? param_map.not_nil!.dup : {} of String => String
              input_names.each do |name|
                next unless type_param_like?(name)
                if receiver_type_map.empty? || !receiver_type_map.has_key?(name)
                  param_map[name] = element_name
                end
              end
            end
          end
        end
      end

      resolved_names = if param_map.nil? || param_map.empty?
                         input_names
                       else
                         input_names.map { |name| substitute_type_params(name, param_map.not_nil!) }
                       end
      # Resolve `self` type in block parameter annotations (e.g., Int32#upto(&block : self ->))
      if receiver_type && receiver_type != TypeRef::VOID
        recv_name = get_type_name_from_ref(receiver_type)
        if recv_name != "Void" && recv_name != "Unknown"
          resolved_names = resolved_names.map { |name| name == "self" ? recv_name : name }
        end
      end
      if receiver_type && receiver_type != TypeRef::VOID
        if recv_desc = @module.get_type_descriptor(receiver_type)
          if elem_name = element_type_for_type_name(recv_desc.name)
            resolved_names = resolved_names.map do |name|
              if name.starts_with?("Union(*") && name.ends_with?(')')
                elem_name
              else
                name
              end
            end
          end
        end
      end

      if debug_block_params
        map_str = param_map ? param_map.not_nil!.map { |k, v| "#{k}=#{v}" }.join(",") : ""
        STDERR.puts "[BLOCK_PARAMS] resolved=#{resolved_names.join(",")} map=#{map_str}"
      end

      if debug_hook_filter_match?(base_method_name, mangled_method_name)
        map_str = param_map ? param_map.not_nil!.map { |k, v| "#{k}=#{v}" }.join(",") : ""
        debug_hook(
          "block.param.types",
          "method=#{base_method_name} mangled=#{mangled_method_name} inputs=#{input_names.join(",")} resolved=#{resolved_names.join(",")} map=#{map_str}"
        )
      end

      resolved_names.map { |name| type_ref_for_name(name) }
    end

    private def infer_yield_param_types_from_body(
      func_def : CrystalV2::Compiler::Frontend::DefNode,
      func_name : String,
      base_method_name : String,
      receiver_type : TypeRef?,
      param_map : Hash(String, String)?,
    ) : Array(TypeRef)?
      body = func_def.body
      return nil unless body && !body.empty?

      def_arena = @function_def_arenas[func_name]? || @function_def_arenas[base_method_name]? || @arena
      old_arena = @arena
      old_locals = @current_typeof_locals
      old_names = @current_typeof_local_names
      old_namespace = @current_namespace_override
      owner_override = function_context_from_name(func_name) || function_context_from_name(base_method_name)
      owner_override = strip_generic_args(owner_override) if owner_override
      local_map = old_locals ? old_locals.dup : {} of String => TypeRef
      name_map = old_names ? old_names.dup : {} of String => String

      if params = func_def.params
        params.each do |param|
          next unless pname = param.name
          name = String.new(pname)
          param_type = TypeRef::VOID
          if ta = param.type_annotation
            type_name = String.new(ta)
            if param_map && !param_map.empty?
              if template = @generic_templates[type_name]?
                mapped_args = template.type_params.map { |param| param_map[param]? }
                if mapped_args.all?(&.itself)
                  type_name = "#{type_name}(#{mapped_args.join(", ")})"
                end
              end
              type_name = substitute_type_params(type_name, param_map)
            end
            param_type = type_ref_for_name(type_name)
          end
          local_map[name] = param_type if param_type != TypeRef::VOID
        end
      end
      if receiver_type && receiver_type != TypeRef::VOID
        local_map["self"] = receiver_type
      end

      @arena = def_arena
      @current_typeof_locals = local_map
      @current_typeof_local_names = name_map
      @current_namespace_override = owner_override if owner_override
      begin
        lists = [] of Array(ExprId)
        collect_yield_arg_lists(body, lists)
        return nil if lists.empty?

        if lists.all?(&.empty?)
          return [] of TypeRef
        end

        self_type_name = if receiver_type && receiver_type != TypeRef::VOID
                           get_type_name_from_ref(receiver_type)
                         else
                           @current_class
                         end

        # Pre-infer locals used by yield args from the body so identifiers resolve.
        lists.each do |args|
          args.each do |arg|
            arg_node = node_for_expr(arg)
            next unless arg_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            name = String.new(arg_node.name)
            next if local_map.has_key?(name)
            if inferred = infer_local_type_from_body(body, name, self_type_name)
              next if inferred == TypeRef::VOID
              local_map[name] = inferred
              name_map[name] = get_type_name_from_ref(inferred)
            end
          end
        end

        compute = -> do
          merged_types = nil
          lists.each do |args|
            next if args.empty?
            inferred = args.map do |arg|
              infer_type_from_expr(arg, self_type_name) || TypeRef::VOID
            end
            next if inferred.all? { |t| t == TypeRef::VOID }
            if merged_types.nil?
              merged_types = inferred
            elsif merged_types.size == inferred.size
              merged_types = merged_types.zip(inferred).map do |left, right|
                if left == TypeRef::VOID
                  right
                elsif right == TypeRef::VOID
                  left
                else
                  union_type_for_values(left, right)
                end
              end
            end
          end
          merged_types
        end

        if param_map && !param_map.empty?
          return with_type_param_map(param_map) { compute.call }
        end
        compute.call
      ensure
        @current_typeof_locals = old_locals
        @current_typeof_local_names = old_names
        @current_namespace_override = old_namespace
        @arena = old_arena
      end
    end

    private def fallback_block_param_types(
      base_method_name : String,
      receiver_type : TypeRef?,
    ) : Array(TypeRef)?
      return nil unless receiver_type && receiver_type != TypeRef::VOID
      recv_desc = @module.get_type_descriptor(receiver_type)
      return nil unless recv_desc
      recv_name = recv_desc.name
      method = if hash = base_method_name.rindex('#')
                 base_method_name[(hash + 1)..]
               elsif dot = base_method_name.rindex('.')
                 base_method_name[(dot + 1)..]
               else
                 base_method_name
               end
      elem_ref = nil
      if recv_name == "String"
        case method
        when "each_byte", "each_byte_with_index"
          elem_ref = TypeRef::UINT8
        when "each_char", "each_char_with_index"
          elem_ref = TypeRef::CHAR
        when "each_codepoint", "each_codepoint_with_index"
          elem_ref = TypeRef::INT32
        end
      end
      if elem_ref.nil?
        if elem_name = element_type_for_type_name(recv_name)
          elem_ref = type_ref_for_name(elem_name)
        end
      end
      return nil unless elem_ref
      if method.ends_with?("_with_index")
        return [elem_ref, TypeRef::INT32]
      end
      [elem_ref]
    end

    private def intern_proc_type(type_names : Array(String)) : TypeRef
      names = type_names
      names = ["Nil"] if names.empty?
      type_refs = names.map { |tn| type_ref_for_name(tn) }
      @module.intern_type(TypeDescriptor.new(TypeKind::Proc, "Proc", type_refs))
    end

    private def proc_type_ref_for_name(name : String) : TypeRef?
      stripped = name.strip
      return nil if stripped.empty?

      if stripped.starts_with?("Proc(") && stripped.ends_with?(')')
        inner = stripped[5, stripped.size - 6]
        return intern_proc_type(split_generic_type_args(inner))
      end

      # Handle top-level arrow syntax: A, B -> C
      if arrow_index = find_top_level_arrow(stripped)
        left = stripped[0, arrow_index].strip
        right = stripped[arrow_index + 2, stripped.size - arrow_index - 2].strip
        if left.starts_with?('{') && left.ends_with?('}')
          inner = left[1, left.size - 2].strip
          parts = inner.empty? ? ([] of String) : split_proc_type_inputs(inner)
          if right.empty?
            if parts.empty?
              return intern_proc_type(["Nil"])
            elsif parts.size == 1
              # `{A} ->` is treated as a single input with implicit Nil return.
              return intern_proc_type([parts.first, "Nil"])
            else
              # `{A, B} ->` means `A -> B` (last part is return type).
              inputs = parts[0...-1]
              ret_name = parts.last
              return intern_proc_type(inputs + [ret_name])
            end
          else
            # `{A, B} -> C` means `A, B -> C` (parts are inputs).
            return intern_proc_type(parts + [right])
          end
        end

        args = left.empty? ? [] of String : split_generic_type_args(left)
        ret_name = right.empty? ? "Nil" : right
        return intern_proc_type(args + [ret_name])
      end

      # Handle parenthesized Proc shorthand: (A, B -> C)
      # The arrow is NOT at top level (depth > 0 due to outer parens), so unwrap and retry
      if stripped.starts_with?('(') && stripped.ends_with?(')')
        inner = stripped[1, stripped.size - 2]
        if inner.includes?("->")
          if arrow_index = find_top_level_arrow(inner)
            left = inner[0, arrow_index].strip
            right = inner[arrow_index + 2, inner.size - arrow_index - 2].strip
            args = left.empty? ? [] of String : split_proc_type_inputs(left)
            ret_name = right.empty? ? "Nil" : right
            return intern_proc_type(args + [ret_name])
          end
        end
      end

      nil
    end

    # Ensure a generic instantiation referenced via a type annotation (e.g. `Hash(String, ValueId)`)
    # is monomorphized before lowering code that calls methods on it.
    private def ensure_monomorphized_type(type_ref : TypeRef) : Nil
      type_desc = @module.get_type_descriptor(type_ref)
      return unless type_desc

      name = type_desc.name
      info = split_generic_base_and_args(name)
      return unless info

      base = info[:base]
      return if base == "Pointer"
      template = @generic_templates[base]?
      return unless template
      return if @monomorphized.includes?(name)

      type_args = split_generic_type_args(info[:args])
      return unless template.type_params.size == type_args.size

      old_defer = @defer_body_return_inference
      @defer_body_return_inference = true
      begin
        monomorphize_generic_class(base, type_args, name)
      ensure
        @defer_body_return_inference = old_defer
      end
    end

    # Returns the fully qualified method name (e.g., "Animal#age" or "Animal#age:Int32") or nil if not found
    # Note: Returns the base name without mangling - caller should mangle with actual arg types
    private def resolve_method_with_inheritance(class_name : String, method_name : String) : String?
      class_name = normalize_method_owner_name(class_name)
      origin = class_name
      if env_get("DEBUG_METHOD_INHERIT") && method_name == "internal_representation"
        STDERR.puts "[METHOD_INHERIT] class=#{class_name} method=#{method_name}"
      end
      if env_get("DEBUG_ENTRY_HASH") && method_name == "hash" && class_name.includes?("Entry") && !class_name.includes?('(')
        STDERR.puts "[ENTRY_HASH_RESOLVE] class=#{class_name} origin=#{origin} current_class=#{@current_class} current_method=#{@current_method}"
        caller.first(5).each { |frame| STDERR.puts "  #{frame}" }
      end
      ensure_method_inheritance_cache
      cache_key = "#{class_name}##{method_name}"
      if @method_inheritance_cache.has_key?(cache_key)
        return @method_inheritance_cache[cache_key]
      end
      current = class_name
      visited = Set(String).new
      while true
        break if visited.includes?(current)
        visited << current
        test_name = "#{current}##{method_name}"
        if env_get("DEBUG_ENTRY_HASH") && method_name == "hash" && origin.includes?("Entry")
          has_func = @function_types.has_key?(test_name)
          has_base = has_function_base?(test_name)
          STDERR.puts "[ENTRY_HASH_CHECK] current=#{current} test=#{test_name} has_func=#{has_func} has_base=#{has_base}"
        end
        # O(1) lookup: check exact match first, then check if base name exists
        if @function_types.has_key?(test_name) || has_function_base?(test_name)
          resolved = if current == origin
                       test_name
                     elsif numeric_primitive_class_name?(origin)
                       "#{origin}##{method_name}"
                     else
                       test_name
                     end
          @method_inheritance_cache[cache_key] = resolved
          return resolved # Return base name - caller will mangle
        end
        current_base = strip_generic_args(current)
        if current_base != current
          base_test = "#{current_base}##{method_name}"
          if @function_types.has_key?(base_test) || has_function_base?(base_test)
            @method_inheritance_cache[cache_key] = base_test
            return base_test
          end
        end
        # Also check included modules for this class (transitive).
        # This is required for chains like Array(T) -> Indexable::Mutable(T) -> Indexable(T).
        included = [] of String
        if direct = @class_included_modules[current]?
          direct.each { |m| push_unique_module_name(included, m) }
        end
        if current_base != current
          if base = @class_included_modules[current_base]?
            base.each { |m| push_unique_module_name(included, m) }
          end
        end
        unless included.empty?
          queue = included.dup
          visited_modules = Set(String).new
          # Use shift (FIFO) not pop (LIFO) — modules are ordered from most specific
          # to least specific (e.g., Indexable::Mutable, Indexable, Enumerable).
          # LIFO would check Enumerable first, missing Indexable's overrides like empty?.
          while mod = queue.shift?
            next if visited_modules.includes?(mod)
            visited_modules << mod
            base_module = strip_generic_args(mod)
            module_method = "#{base_module}##{method_name}"
            if @function_types.has_key?(module_method) || has_function_base?(module_method)
              # Return with class prefix so it gets lowered for this class
              resolved = current == origin ? test_name : "#{origin}##{method_name}"
              @method_inheritance_cache[cache_key] = resolved
              return resolved
            end
            if submods = @class_included_modules[mod]?
              submods.each { |m| queue << m }
            end
            if base_module != mod
              if submods = @class_included_modules[base_module]?
                submods.each { |m| queue << m }
              end
            end
          end
        end
        # Try parent class
        if info = @class_info[current]?
          if parent = info.parent_name
            current = parent
          else
            break
          end
        else
          break
        end
      end
      if template_owner = primitive_template_owner(class_name)
        template_method = "#{template_owner}##{method_name}"
        if @function_types.has_key?(template_method) || has_function_base?(template_method)
          resolved = "#{class_name}##{method_name}"
          @method_inheritance_cache[cache_key] = resolved
          return resolved
        end
      end
      if class_name != "Object"
        object_method = "Object##{method_name}"
        if @function_types.has_key?(object_method) || has_function_base?(object_method)
          if env_get("DEBUG_ENTRY_HASH") && method_name == "hash" && origin.includes?("Entry")
            STDERR.puts "[ENTRY_HASH_FALLBACK] origin=#{origin} falling back to Object#hash"
          end
          resolved = object_method
          @method_inheritance_cache[cache_key] = resolved
          return resolved
        end
      end
      # Check generic templates for methods (for types like Proc that skip monomorphization)
      if info = split_generic_base_and_args(class_name)
        base_name = info[:base]
        if env_get("DEBUG_GENERIC_RESOLVE") && method_name == "internal_representation"
          STDERR.puts "[GENERIC_RESOLVE] class=#{class_name} base=#{base_name} has_template=#{@generic_templates.has_key?(base_name)}"
        end
        if template = @generic_templates[base_name]?
          if find_method_in_generic_template(template, method_name)
            resolved = "#{class_name}##{method_name}"
            @method_inheritance_cache[cache_key] = resolved
            return resolved
          end
          # Also check reopenings
          if reopenings = @generic_reopenings[base_name]?
            reopenings.each do |reopen_template|
              if find_method_in_generic_template(reopen_template, method_name)
                resolved = "#{class_name}##{method_name}"
                @method_inheritance_cache[cache_key] = resolved
                return resolved
              end
            end
          end
        end
      end
      @method_inheritance_cache[cache_key] = nil
      nil
    end

    # Resolve class method name (Class.method) with inheritance.
    # Returns base name without mangling or nil if not found.
    private def resolve_class_method_with_inheritance(class_name : String, method_name : String) : String?
      class_name = normalize_method_owner_name(class_name)
      origin = class_name
      ensure_method_inheritance_cache
      cache_key = "#{class_name}.#{method_name}"
      if @class_method_inheritance_cache.has_key?(cache_key)
        return @class_method_inheritance_cache[cache_key]
      end
      current = class_name
      visited = Set(String).new
      while true
        break if visited.includes?(current)
        visited << current
        test_name = "#{current}.#{method_name}"
        if @function_defs.has_key?(test_name) ||
           class_method_overload_exists?(test_name) ||
           @class_accessor_entries.has_key?(test_name)
          resolved = current == origin ? test_name : "#{origin}.#{method_name}"
          @class_method_inheritance_cache[cache_key] = resolved
          return resolved
        end
        if info = @class_info[current]?
          if parent = info.parent_name
            current = parent
            next
          end
        end
        break
      end
      if class_name != "Object"
        object_method = "Object.#{method_name}"
        if @function_defs.has_key?(object_method) ||
           class_method_overload_exists?(object_method) ||
           @class_accessor_entries.has_key?(object_method)
          resolved = "#{origin}.#{method_name}"
          @class_method_inheritance_cache[cache_key] = resolved
          return resolved
        end
      end
      @class_method_inheritance_cache[cache_key] = nil
      nil
    end

    private def class_method_overload_exists?(base_name : String) : Bool
      return false unless base_name.includes?('.')
      overloads = function_def_overloads(base_name)
      return false if overloads.empty?
      expected_base = strip_type_suffix(base_name)
      overloads.any? do |name|
        next false unless @function_defs.has_key?(name)
        parts = parse_method_name_compact(name)
        parts.separator == '.' && parts.base == expected_base
      end
    end

    private def class_method_defined?(name : String) : Bool
      return false if name.empty?
      @function_defs.has_key?(name) ||
        @function_types.has_key?(name) ||
        has_function_base?(name) ||
        class_method_overload_exists?(name) ||
        @class_accessor_entries.has_key?(name)
    end

    # Infer type argument for generic class constructor call
    # E.g., Array.new(size, value) -> infer T from value's type
    #       Array.new(size) { block } -> infer T from block's return type
    private def infer_type_name_from_expr_id(expr_id : ExprId) : String?
      if inferred = infer_type_from_expr(@arena[expr_id])
        return inferred
      end
      if inferred_ref = infer_type_from_expr(expr_id, @current_class)
        inferred_name = get_type_name_from_ref(inferred_ref)
        return inferred_name unless inferred_name.empty? || inferred_name == "Void" || inferred_name == "Unknown"
      end
      nil
    end

    private def infer_generic_type_arg(
      class_name : String,
      args : Array(CrystalV2::Compiler::Frontend::ExprId)?,
      block : CrystalV2::Compiler::Frontend::ExprId?,
      ctx : LoweringContext,
      named_args : Array(CrystalV2::Compiler::Frontend::NamedArgument)? = nil,
    ) : String?
      # For Array.new(size, initial_value), infer from initial_value (second arg)
      if class_name == "Array" && args && args.size >= 2
        value_arg = @arena[args[1]]
        return infer_type_from_expr(value_arg)
      end

      # For Array.new(size) { block }, infer from block's return type
      if class_name == "Array" && block
        block_node = @arena[block]
        if block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
          if body = block_node.body
            # Look at last expression in block to infer return type
            last_expr_id = body.last?
            if last_expr_id
              last_expr = @arena[last_expr_id]
              return infer_type_from_expr(last_expr)
            end
          end
        end
      end

      # For Atomic.new(value), infer from the value type.
      if class_name == "Atomic" && args && args.size >= 1
        arg_node = @arena[args[0]]
        if inferred = infer_type_from_expr(arg_node)
          return inferred
        end
      end

      # For Pointer::Appender.new(pointer), infer element type from Pointer(T).
      if class_name == "Pointer::Appender" && args && args.size >= 1
        arg_node = @arena[args[0]]
        if inferred = infer_type_from_expr(arg_node)
          if elem_ref = pointer_element_type(inferred)
            elem_name = get_type_name_from_ref(elem_ref)
            return elem_name unless elem_name.empty? || elem_name == "Void" || elem_name == "Unknown"
          end
        end
      end

      # For Slice.new(pointer, size, ...), infer from first arg's pointed-to type
      # MUST be before the generic fallback — otherwise the fallback infers T=Pointer(UInt8)
      # instead of T=UInt8 (the first arg IS a Pointer(T), not T itself).
      if class_name == "Slice" && args && args.size >= 1
        if current = @current_class
          if info = split_generic_base_and_args(current)
            base = normalize_method_owner_name(info[:base])
            if base == "Slice"
              type_args = split_generic_type_args(info[:args])
              if elem_name = type_args.first?
                elem_name = elem_name.strip
                return elem_name unless elem_name.empty?
              end
            end
          end
        end
        pointer_arg_id = args[0]
        pointer_arg = @arena[pointer_arg_id]
        # Try to get the pointer's element type
        # First check if it's an ivar access (like @buffer which is Pointer(UInt8))
        if pointer_arg.is_a?(CrystalV2::Compiler::Frontend::InstanceVarNode)
          ivar_name = String.new(pointer_arg.name)
          # Look up ivar type in current class
          if current_class_name = @current_class
            if class_info = @class_info[current_class_name]?
              if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
                ivar_type = ivar_info.type
                # If it's a Pointer type, extract element type
                if type_desc = @module.get_type_descriptor(ivar_type)
                  type_str = type_desc.name
                  if type_str.starts_with?("Pointer(") && type_str.ends_with?(')')
                    element_type = type_str[8...-1] # Extract "UInt8" from "Pointer(UInt8)"
                    return element_type
                  end
                end
              end
            end
          end
        end
        # Default to UInt8 for Slice (Bytes is Slice(UInt8))
        # This is the most common case and avoids side effects from lower_expr
        return "UInt8"
      end

      # Generic fallback (single type param) from positional or named args.
      if template = @generic_templates[class_name]?
        if template.type_params.size == 1
          if args && !args.empty?
            arg_id = args[0]
            arg_node = @arena[arg_id]
            if inferred = infer_type_from_expr(arg_node)
              return inferred
            end
            if inferred_ref = infer_type_from_expr(arg_id, @current_class)
              inferred_name = get_type_name_from_ref(inferred_ref)
              return inferred_name unless inferred_name.empty? || inferred_name == "Void" || inferred_name == "Unknown"
            end
          end
          if named_args && !named_args.empty?
            preferred = named_args.find { |named| String.new(named.name) == "value" }
            selected = preferred || named_args.first?
            if selected
              arg_id = selected.value
              arg_node = @arena[arg_id]
              if inferred = infer_type_from_expr(arg_node)
                return inferred
              end
              if inferred_ref = infer_type_from_expr(arg_id, @current_class)
                inferred_name = get_type_name_from_ref(inferred_ref)
                return inferred_name unless inferred_name.empty? || inferred_name == "Void" || inferred_name == "Unknown"
              end
            end
          end
        end
      end

      # For Atomic.new(value), infer from the value's type.
      if class_name == "Atomic" && args && args.size >= 1
        if inferred_ref = infer_type_from_expr(args[0], @current_class)
          inferred_name = get_type_name_from_ref(inferred_ref)
          return inferred_name unless inferred_name.empty? || inferred_name == "Void" || inferred_name == "Unknown"
        end
        value_node = @arena[args[0]]
        if inferred_name = infer_type_from_expr(value_node)
          return inferred_name
        end
      end

      # For Hash.new, return nil (needs two type params - more complex)
      nil
    end

    # Infer type name from an expression AST node
    private def infer_type_from_expr(node) : String?
      case node
      when CrystalV2::Compiler::Frontend::StringNode, CrystalV2::Compiler::Frontend::StringInterpolationNode
        "String"
      when CrystalV2::Compiler::Frontend::NumberNode
        # Check if it's a float (has decimal point or exponent)
        num_str = String.new(node.value)
        if num_str.includes?('.') || num_str.includes?('e') || num_str.includes?('E')
          "Float64"
        else
          "Int32"
        end
      when CrystalV2::Compiler::Frontend::BoolNode
        "Bool"
      when CrystalV2::Compiler::Frontend::CharNode
        "Char"
      when CrystalV2::Compiler::Frontend::SymbolNode
        "Symbol"
      when CrystalV2::Compiler::Frontend::NilNode
        "Nil"
      when CrystalV2::Compiler::Frontend::PathNode
        full_name = resolve_path_string_in_context(collect_path_string(node))
        # Check if this is a constant — if so, return the constant's value type, not its name
        if resolved = resolve_constant_name_in_context(full_name)
          if const_type = @constant_types[resolved]?
            if const_type != TypeRef::VOID
              return get_type_name_from_ref(const_type)
            end
          end
          # Try literal value
          if literal = @constant_literal_values[resolved]?
            return literal.type_name
          end
          # Known constant but type unknown — return nil (don't use constant name as type)
          return nil
        end
        full_name
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(node.name)
        if locals = @current_typeof_locals
          if type_ref = locals[name]?
            if type_name = concrete_type_name_for(type_ref)
              return type_name
            end
            type_name = get_type_name_from_ref(type_ref)
            return type_name unless type_name.empty? || type_name == "Void" || type_name == "Unknown"
          end
        end
        if type_name = lookup_typeof_local_name(name)
          return type_name
        end
        nil
      when CrystalV2::Compiler::Frontend::InstanceVarNode
        if current_class_name = @current_class
          if info = @class_info[current_class_name]?
            ivar_name = String.new(node.name)
            if ivar = info.ivars.find { |entry| entry.name == ivar_name }
              if type_name = concrete_type_name_for(ivar.type)
                return type_name
              end
              type_name = get_type_name_from_ref(ivar.type)
              return type_name unless type_name.empty? || type_name == "Void" || type_name == "Unknown"
            end
          end
        end
        nil
      when CrystalV2::Compiler::Frontend::CallNode
        # For calls like String.new(...), try to get return type
        callee = node.callee
        callee_node = @arena[callee]
        case callee_node
        when CrystalV2::Compiler::Frontend::MemberAccessNode
          obj_node = @arena[callee_node.object]
          member_name = String.new(callee_node.member)
          if obj_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode) && member_name == "new"
            # ClassName.new() returns ClassName
            name = String.new(obj_node.name)
            if name == "Array"
              if args = node.args
                if args.size >= 2
                  if inferred = infer_type_from_expr(@arena[args[1]])
                    return "Array(#{inferred})"
                  end
                end
              end
              if block_id = node.block
                block_node = @arena[block_id]
                if block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                  if body = block_node.body
                    if last_id = body.last?
                      if inferred = infer_type_from_expr(@arena[last_id])
                        return "Array(#{inferred})"
                      end
                    end
                  end
                end
              end
            end
            return name
          elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && member_name == "new"
            name = String.new(obj_node.name)
            if name[0].uppercase?
              return name
            end
            if locals = @current_typeof_locals
              if type_ref = locals[name]?
                type_name = get_type_name_from_ref(type_ref)
                return type_name unless type_name.empty? || type_name == "Void" || type_name == "Unknown"
              end
            end
            if type_name = lookup_typeof_local_name(name)
              return type_name
            end
          end
        end
        nil
      else
        nil
      end
    end

    # Infer type from class-level ivar assignment: @vec = SomeType.new
    # Used during class registration (pass 2) to handle implicit ivars
    # Returns true for literals and simple values that generate_allocator already
    # handles correctly with 0/nil defaults (e.g., integer 0, false, nil).
    private def is_trivial_default(value_node) : Bool
      case value_node
      when CrystalV2::Compiler::Frontend::NumberNode
        # Numeric literal 0 is handled by default
        String.new(value_node.value) == "0"
      when CrystalV2::Compiler::Frontend::BoolNode
        !value_node.value # false is handled by 0 default
      when CrystalV2::Compiler::Frontend::NilNode
        true
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # Pointer(T).null, Bytes.empty, etc. — all produce zero/null values
        member_name = String.new(value_node.member)
        member_name == "null"
      else
        false
      end
    end

    # Try to resolve a simple default expression to a literal value without calling lower_expr.
    # This avoids triggering demand-driven compilation for module ivar defaults.
    # Returns the literal value (Int64 or nil) if resolvable, nil otherwise.
    private def try_resolve_simple_default(
      default_node,
      default_arena : CrystalV2::Compiler::Frontend::ArenaLike,
      ivar_type : TypeRef,
    ) : (Int64 | Nil)?
      case default_node
      when CrystalV2::Compiler::Frontend::BoolNode
        return default_node.value ? 1_i64 : 0_i64
      when CrystalV2::Compiler::Frontend::NumberNode
        num_str = String.new(default_node.value)
        # Strip type suffix (e.g., "10_u8" → "10")
        num_str = num_str.gsub('_', "")
        if num_str.includes?('.')
          return nil # Float — can't represent as Int64 literal
        end
        return num_str.to_i64?
      when CrystalV2::Compiler::Frontend::PathNode
        # Constant reference like IO::DEFAULT_BUFFER_SIZE
        old_arena = @arena
        @arena = default_arena
        begin
          raw_path = collect_path_string(default_node)
          full_name = resolve_path_string_in_context(raw_path)
          if resolved = resolve_constant_name_in_context(full_name)
            if literal = @constant_literal_values[resolved]?
              if literal.is_a?(CrystalV2::Compiler::Semantic::MacroNumberValue)
                val = literal.value
                return val.is_a?(Int64) ? val : val.to_i64
              end
            end
          end
        ensure
          @arena = old_arena
        end
        nil
      when CrystalV2::Compiler::Frontend::ConstantNode
        name = String.new(default_node.name)
        if resolved = resolve_constant_name_in_context(name)
          if literal = @constant_literal_values[resolved]?
            if literal.is_a?(CrystalV2::Compiler::Semantic::MacroNumberValue)
              val = literal.value
              return val.is_a?(Int64) ? val : val.to_i64
            end
          end
        end
        nil
      else
        nil
      end
    end

    # Discover implicit ivars from method body AST nodes.
    # Looks for `out @ivar` and `@ivar = expr` patterns, returning {name, type} pairs.
    private def discover_implicit_ivars_in_body(
      body : Array(CrystalV2::Compiler::Frontend::ExprId),
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      class_name : String,
    ) : Array({String, TypeRef})
      result = [] of {String, TypeRef}
      seen = Set(String).new
      scan_nodes_for_ivars(body, arena, class_name, result, seen, 0)
      result
    end

    private def scan_nodes_for_ivars(
      exprs : Array(CrystalV2::Compiler::Frontend::ExprId),
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      class_name : String,
      result : Array({String, TypeRef}),
      seen : Set(String),
      depth : Int32,
    )
      return if depth > 5  # Limit recursion depth
      exprs.each do |expr_id|
        node = arena[expr_id]
        case node
        when CrystalV2::Compiler::Frontend::AssignNode
          # @ivar = expr — register ivar with inferred type
          target = arena[node.target]
          if target.is_a?(CrystalV2::Compiler::Frontend::InstanceVarNode)
            ivar_name = String.new(target.name)
            unless seen.includes?(ivar_name)
              seen << ivar_name
              value_node = arena[node.value]
              ivar_type = infer_type_from_class_ivar_assign(value_node)
              result << {ivar_name, ivar_type} unless ivar_type == TypeRef::VOID
            end
          end
          # Recurse into value
          scan_nodes_for_ivars([node.value], arena, class_name, result, seen, depth + 1)
        when CrystalV2::Compiler::Frontend::CallNode
          # Look for extern calls with `out @ivar` args
          scan_call_for_out_ivars(node, arena, class_name, result, seen)
          # Recurse into args
          scan_nodes_for_ivars(node.args.to_a, arena, class_name, result, seen, depth + 1)
          # Recurse into callee
          scan_nodes_for_ivars([node.callee], arena, class_name, result, seen, depth + 1)
        when CrystalV2::Compiler::Frontend::IfNode
          scan_nodes_for_ivars([node.condition], arena, class_name, result, seen, depth + 1)
          if then_body = node.then_body
            scan_nodes_for_ivars(then_body, arena, class_name, result, seen, depth + 1)
          end
          if else_body = node.else_body
            scan_nodes_for_ivars(else_body, arena, class_name, result, seen, depth + 1)
          end
        when CrystalV2::Compiler::Frontend::UnlessNode
          scan_nodes_for_ivars([node.condition], arena, class_name, result, seen, depth + 1)
          scan_nodes_for_ivars(node.then_branch, arena, class_name, result, seen, depth + 1)
          if else_branch = node.else_branch
            scan_nodes_for_ivars(else_branch, arena, class_name, result, seen, depth + 1)
          end
        end
      end
    end

    private def scan_call_for_out_ivars(
      call : CrystalV2::Compiler::Frontend::CallNode,
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      class_name : String,
      result : Array({String, TypeRef}),
      seen : Set(String),
    )
      # Check if this is a call to an extern function with `out @ivar` args
      # Pattern: LibC.func_name(out @ivar, ...) — callee is MemberAccessNode
      callee_node = arena[call.callee]
      return unless callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
      obj_node = arena[callee_node.object]
      lib_name = case obj_node
                 when CrystalV2::Compiler::Frontend::ConstantNode
                   String.new(obj_node.name)
                 when CrystalV2::Compiler::Frontend::IdentifierNode
                   String.new(obj_node.name)
                 else
                   nil
                 end
      return unless lib_name
      method_name = String.new(callee_node.member)

      extern_func = @module.get_extern_function(lib_name, method_name)
      return unless extern_func

      call.args.each_with_index do |arg_expr, idx|
        arg_node = arena[arg_expr]
        next unless arg_node.is_a?(CrystalV2::Compiler::Frontend::OutNode)
        out_name = String.new(arg_node.identifier)
        next unless out_name.starts_with?('@')
        ivar_name = out_name
        next if seen.includes?(ivar_name)
        seen << ivar_name

        # Infer type from extern function parameter (it's a pointer, we want the element type)
        param_type = extern_func.param_types[idx]?
        if param_type
          alloc_type = out_alloc_type_for_param(param_type)
          result << {ivar_name, alloc_type} unless alloc_type == TypeRef::VOID
        end
      end
    end

    private def infer_type_from_class_ivar_assign(value_node) : TypeRef
      if inferred_name = infer_type_from_expr(value_node)
        inferred_ref = type_ref_for_name(inferred_name)
        return inferred_ref unless inferred_ref == TypeRef::VOID
      end

      case value_node
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # Direct member access: SomeType.new (without call parens)
        obj_node = @arena[value_node.object]
        member_name = String.new(value_node.member)
        if env_has?("DEBUG_TYPE_INFER")
          STDERR.puts "[TYPE_INFER] Direct MemberAccess member=#{member_name}, obj_node type: #{obj_node.class}"
        end
        if member_name == "new" || member_name == "empty" || member_name == "null" || member_name == "malloc" || member_name == "create"
          type_name = extract_type_name_from_node(obj_node)
          if env_has?("DEBUG_TYPE_INFER")
            STDERR.puts "[TYPE_INFER] extracted type_name=#{type_name || "nil"}"
          end
          if type_name
            resolved = resolve_type_alias_chain(type_name)
            if env_has?("DEBUG_TYPE_INFER")
              STDERR.puts "[TYPE_INFER] resolved type_name=#{resolved}"
            end
            return type_ref_for_name(resolved)
          end
        end
      when CrystalV2::Compiler::Frontend::CallNode
        # For calls like SomeClass.new() or GenericClass(T).new()
        callee = value_node.callee
        callee_node = @arena[callee]
        if env_has?("DEBUG_TYPE_INFER")
          STDERR.puts "[TYPE_INFER] CallNode callee_node type: #{callee_node.class}"
        end
        case callee_node
        when CrystalV2::Compiler::Frontend::MemberAccessNode
          obj_node = @arena[callee_node.object]
          member_name = String.new(callee_node.member)
          if env_has?("DEBUG_TYPE_INFER")
            STDERR.puts "[TYPE_INFER] MemberAccess member=#{member_name}, obj_node type: #{obj_node.class}"
          end
          if member_name == "new" || member_name == "empty" || member_name == "null" || member_name == "malloc" || member_name == "create"
            type_name = extract_type_name_from_node(obj_node)
            if env_has?("DEBUG_TYPE_INFER")
              STDERR.puts "[TYPE_INFER] extracted type_name=#{type_name || "nil"}"
            end
            if type_name
              resolved = resolve_type_alias_chain(type_name)
              if env_has?("DEBUG_TYPE_INFER")
                STDERR.puts "[TYPE_INFER] resolved type_name=#{resolved}"
              end
              return type_ref_for_name(resolved)
            end
          end
        end
      when CrystalV2::Compiler::Frontend::StringNode, CrystalV2::Compiler::Frontend::StringInterpolationNode
        return TypeRef::STRING
      when CrystalV2::Compiler::Frontend::NumberNode
        num_str = String.new(value_node.value)
        if num_str.includes?('.') || num_str.includes?('e') || num_str.includes?('E')
          return TypeRef::FLOAT64
        else
          return TypeRef::INT32
        end
      when CrystalV2::Compiler::Frontend::BoolNode
        return TypeRef::BOOL
      when CrystalV2::Compiler::Frontend::CharNode
        return TypeRef::CHAR
      when CrystalV2::Compiler::Frontend::NilNode
        return TypeRef::VOID
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        # Array literal - infer element type from first element
        if of_type = value_node.of_type
          if type_name = stringify_type_expr(of_type)
            return type_ref_for_name("Array(#{normalize_declared_type_name(type_name)})")
          end
        end
        if elements = value_node.elements
          if first_id = elements.first?
            first_node = @arena[first_id]
            if elem_type = infer_type_from_expr(first_node)
              return type_ref_for_name("Array(#{elem_type})")
            end
          end
        end
        return type_ref_for_name("Array(String)") # Default
      when CrystalV2::Compiler::Frontend::HashLiteralNode
        if key_type = value_node.of_key_type
          value_type = value_node.of_value_type
          if value_type
            key_name = normalize_declared_type_name(String.new(key_type))
            value_name = normalize_declared_type_name(String.new(value_type))
            value_name = "NamedTuple" if value_name.starts_with?("NamedTuple")
            return type_ref_for_name("Hash(#{key_name}, #{value_name})")
          end
        end
        if entries = value_node.entries
          if first_entry = entries.first?
            key_node = @arena[first_entry.key]
            value_node_inner = @arena[first_entry.value]
            key_type = infer_type_from_expr(key_node)
            value_type = infer_type_from_expr(value_node_inner)
            if key_type && value_type
              return type_ref_for_name("Hash(#{key_type}, #{value_type})")
            end
          end
        end
        return type_ref_for_name("Hash(String, String)")
      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        return type_ref_for_name("NamedTuple")
      when CrystalV2::Compiler::Frontend::UninitializedNode
        if type_str = stringify_type_expr(value_node.type)
          return type_ref_for_name(normalize_declared_type_name(type_str))
        end
      end
      TypeRef::VOID # Default to VOID if we can't infer
    end

    # Extract type name from AST node (ConstantNode, GenericNode, etc.)
    private def extract_type_name_from_node(node) : String?
      case node
      when CrystalV2::Compiler::Frontend::ConstantNode
        name = String.new(node.name)
        if name == "self" || name == "Self"
          return @current_class || @current_namespace_override
        end
        name
      when CrystalV2::Compiler::Frontend::IdentifierNode
        # Identifiers can be type names (uppercase) or constants used as type args
        name = String.new(node.name)
        if name == "self" || name == "Self"
          return @current_class || @current_namespace_override
        end
        name
      when CrystalV2::Compiler::Frontend::GenericNode
        # GenericClass(T, U) -> "GenericClass(T, U)"
        base_node = @arena[node.base_type]
        base_name = extract_type_name_from_node(base_node)
        if base_name && (type_args = node.type_args)
          # Resolve type args (may be type params like T that need substitution)
          arg_names = type_args.map do |arg_id|
            arg_node = @arena[arg_id]
            extract_type_name_from_node(arg_node) || "UNKNOWN"
          end
          "#{base_name}(#{arg_names.join(", ")})"
        else
          base_name
        end
      when CrystalV2::Compiler::Frontend::PathNode
        resolve_path_string_in_context(collect_path_string(node))
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # Nested::Class - reconstruct qualified name
        obj_node = @arena[node.object]
        member_name = String.new(node.member)
        if obj_name = extract_type_name_from_node(obj_node)
          "#{obj_name}::#{member_name}"
        else
          member_name
        end
      else
        nil
      end
    end

    # Check if a type is a union type
    private def is_union_type?(type_ref : TypeRef) : Bool
      if type_desc = @module.get_type_descriptor(type_ref)
        type_desc.kind == TypeKind::Union
      else
        false
      end
    end

    # Get variant type_id for a value being assigned to union
    # Returns the index of the matching variant, or -1 if not found
    private def get_union_variant_id(union_type : TypeRef, value_type : TypeRef) : Int32
      mir_union_ref = hir_to_mir_type_ref(union_type)
      if descriptor = @union_descriptors[mir_union_ref]?
        mir_value_ref = hir_to_mir_type_ref(value_type)
        descriptor.variants.each_with_index do |variant, idx|
          if variant.type_ref == mir_value_ref
            return idx
          end
        end
      end

      # Fallback: if a union has a single pointer-like non-nil variant, allow
      # pointer-like values to wrap into that variant (common for struct/reference
      # types lowered as pointers in LLVM).
      if pointer_like_type?(value_type)
        if fallback = pointer_like_union_variant_id(union_type)
          return fallback
        end
      end

      -1
    end

    private def pointer_like_union_variant_id(union_type : TypeRef) : Int32?
      mir_union_ref = hir_to_mir_type_ref(union_type)
      descriptor = @union_descriptors[mir_union_ref]?
      return nil unless descriptor

      candidates = [] of Int32
      descriptor.variants.each_with_index do |variant, idx|
        hir_variant = mir_to_hir_type_ref(variant.type_ref)
        next if hir_variant == TypeRef::NIL || hir_variant == TypeRef::VOID

        if pointer_like_type?(hir_variant)
          candidates << idx
        end
      end

      if candidates.size == 1
        if env_get("DEBUG_UNION_WRAP_PTR")
          STDERR.puts "[UNION_WRAP_PTR] union=#{get_type_name_from_ref(union_type)} variant_id=#{candidates.first}"
        end
        return candidates.first
      end

      nil
    end

    private def pointer_like_type?(type_ref : TypeRef) : Bool
      return true if type_ref == TypeRef::POINTER || type_ref == TypeRef::STRING
      if desc = @module.get_type_descriptor(type_ref)
        # Class, Struct, Pointer all stored as ptr in LLVM.
        # Module can appear when a value is typed by its enclosing module context
        # (e.g., @@current_thread in Crystal::System::Thread typed as Thread).
        return desc.kind == TypeKind::Struct || desc.kind == TypeKind::Class ||
          desc.kind == TypeKind::Pointer || desc.kind == TypeKind::Module
      end
      # Types without descriptors that are not primitives are likely reference types
      return true if type_ref.id >= TypeRef::FIRST_USER_TYPE
      false
    end

    # Find an existing union type in the module that can represent all required types.
    # Prefer the smallest matching union (fewest variants) to avoid needlessly wide phis.
    private def find_covering_union_type(required_types : Array(TypeRef)) : TypeRef?
      required_mir = required_types.map { |t| hir_to_mir_type_ref(t) }.uniq

      best_ref : TypeRef? = nil
      best_variant_count = Int32::MAX

      @module.types.each_with_index do |desc, idx|
        next unless desc.kind == TypeKind::Union

        hir_union_ref = TypeRef.new(TypeRef::FIRST_USER_TYPE + idx.to_u32)
        mir_union_ref = hir_to_mir_type_ref(hir_union_ref)
        descriptor = @union_descriptors[mir_union_ref]?
        next unless descriptor

        variants = descriptor.variants.map(&.type_ref)
        next unless required_mir.all? { |rt| variants.includes?(rt) }

        if variants.size < best_variant_count
          best_variant_count = variants.size
          best_ref = hir_union_ref
        end
      end

      best_ref
    end

    # Get class variable type from current class
    private def get_class_var_type(name : String) : TypeRef
      if class_name = @current_class
        if class_info = @class_info[class_name]?
          class_info.class_vars.each do |cvar|
            return cvar.type if cvar.name == name
          end
        end
        if module_vars = @module_class_vars[class_name]?
          module_vars.each do |cvar|
            return cvar.type if cvar.name == name
          end
        end
      end
      TypeRef::VOID
    end

    private def infer_class_var_type_from_owner(owner_name : String?, cvar_name : String) : TypeRef?
      return nil unless owner_name
      key = "#{owner_name}::#{cvar_name}"
      return nil if @class_var_infer_stack.includes?(key)
      @class_var_infer_stack.add(key)
      if env_get("DEBUG_CLASSVAR_INFER")
        STDERR.puts "[CVAR_INFER] owner=#{owner_name} var=#{cvar_name}"
      end

      types = [] of TypeRef
      if defs = @module_defs[owner_name]?
        if env_get("DEBUG_CLASSVAR_INFER")
          STDERR.puts "[CVAR_INFER] owner=#{owner_name} defs=#{defs.size}"
        end
        defs.each do |(mod_node, mod_arena)|
          if env_get("DEBUG_CLASSVAR_INFER") && owner_name == "Crystal::AtExitHandlers"
            current_path = @paths_by_arena[mod_arena]? || "(unknown)"
            STDERR.puts "[CVAR_INFER] owner=#{owner_name} file=#{current_path} arena=#{mod_arena.class.name.split("::").last}"
          end
          body = mod_node.body
          next unless body
          with_arena(mod_arena) do
            old_class = @current_class
            @current_class = owner_name
            begin
              body.each do |expr_id|
                member = unwrap_visibility_member(@arena[expr_id])
                case member
                when CrystalV2::Compiler::Frontend::DefNode
                  if env_get("DEBUG_CLASSVAR_INFER") && owner_name == "Crystal::AtExitHandlers"
                    def_name = String.new(member.name)
                    STDERR.puts "[CVAR_INFER] scan def=#{def_name} body=#{member.body.try(&.size) || 0}"
                    if def_name == "add"
                      if def_body = member.body
                        def_body.each do |child|
                          child_node = @arena[child]
                          if child_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
                            if block_id = child_node.block
                              block_node = @arena[block_id]
                              block_size = block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode) ? block_node.body.try(&.size) || 0 : 0
                              STDERR.puts "[CVAR_INFER] add block body=#{block_size}"
                            end
                          end
                        end
                      end
                    end
                  end
                  if def_body = member.body
                    def_body.each do |child|
                      collect_class_var_assignment_types(child, cvar_name, owner_name, types)
                    end
                  end
                when CrystalV2::Compiler::Frontend::AssignNode,
                     CrystalV2::Compiler::Frontend::ClassVarDeclNode
                  collect_class_var_assignment_types(expr_id, cvar_name, owner_name, types)
                end
              end
            ensure
              @current_class = old_class
            end
          end
        end
      end

      begin
        return nil if types.empty?
        merged = types.first
        types[1..].each { |t| merged = union_type_for_values(merged, t) }
        record_class_var_type(owner_name, cvar_name, merged)
        if env_get("DEBUG_CLASSVAR_INFER")
          STDERR.puts "[CVAR_INFER] owner=#{owner_name} var=#{cvar_name} type=#{get_type_name_from_ref(merged)}"
        end
        merged
      ensure
        @class_var_infer_stack.delete(key)
      end
    end

    private def infer_class_var_assignment_type(
      value_id : ExprId,
      cvar_name : String,
      self_type_name : String?,
    ) : TypeRef?
      value_node = @arena[value_id]
      if value_node.is_a?(CrystalV2::Compiler::Frontend::BinaryNode) &&
         value_node.operator_string == "||"
        left = @arena[value_node.left]
        if left.is_a?(CrystalV2::Compiler::Frontend::ClassVarNode)
          left_name = String.new(left.name).lstrip('@')
          if left_name == cvar_name
            return infer_type_from_expr(value_node.right, self_type_name)
          end
        end
      end
      infer_type_from_expr(value_id, self_type_name)
    end

    private def collect_class_var_assignment_types(
      expr_id : ExprId,
      cvar_name : String,
      self_type_name : String?,
      output : Array(TypeRef),
    ) : Nil
      expr_node = @arena[expr_id]
      case expr_node
      when CrystalV2::Compiler::Frontend::AssignNode
        target = @arena[expr_node.target]
        if env_get("DEBUG_CLASSVAR_INFER") && cvar_name == "handlers" && @current_class == "Crystal::AtExitHandlers"
          target_name = target.is_a?(CrystalV2::Compiler::Frontend::ClassVarNode) ? String.new(target.name) : target.class.name.split("::").last
          span = expr_node.span
          STDERR.puts "[CVAR_INFER] assign_node target=#{target_name} span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column}"
        end
        if target.is_a?(CrystalV2::Compiler::Frontend::ClassVarNode)
          name = String.new(target.name).lstrip('@')
          if name == cvar_name
            if inferred = infer_class_var_assignment_type(expr_node.value, cvar_name, self_type_name)
              output << inferred if inferred != TypeRef::VOID
              if env_get("DEBUG_CLASSVAR_INFER")
                STDERR.puts "[CVAR_INFER] assign=#{cvar_name} type=#{get_type_name_from_ref(inferred)}"
              end
            elsif env_get("DEBUG_CLASSVAR_INFER")
              STDERR.puts "[CVAR_INFER] assign=#{cvar_name} type=nil"
            end
          end
        end
        collect_class_var_assignment_types(expr_node.value, cvar_name, self_type_name, output)
      when CrystalV2::Compiler::Frontend::ClassVarDeclNode
        name = String.new(expr_node.name).lstrip('@')
        if name == cvar_name
          cvar_type = type_ref_for_name(String.new(expr_node.type))
          output << cvar_type if cvar_type != TypeRef::VOID
        end
        if value_id = expr_node.value
          collect_class_var_assignment_types(value_id, cvar_name, self_type_name, output)
        end
      when CrystalV2::Compiler::Frontend::DefNode
        if body = expr_node.body
          body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) }
        end
      when CrystalV2::Compiler::Frontend::BlockNode
        if body = expr_node.body
          if env_get("DEBUG_CLASSVAR_INFER") && cvar_name == "handlers" && @current_class == "Crystal::AtExitHandlers"
            spans = body.map { |child| @arena[child].span.start_line }
            STDERR.puts "[CVAR_INFER] block spans=#{spans.join(",")}"
          end
          body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) }
        end
      when CrystalV2::Compiler::Frontend::IfNode
        expr_node.then_body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) }
        if elsifs = expr_node.elsifs
          elsifs.each { |branch| branch.body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) } }
        end
        if else_body = expr_node.else_body
          else_body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) }
        end
      when CrystalV2::Compiler::Frontend::CaseNode
        expr_node.when_branches.each { |branch| branch.body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) } }
        if else_branch = expr_node.else_branch
          else_branch.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) }
        end
        if in_branches = expr_node.in_branches
          in_branches.each { |branch| branch.body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) } }
        end
      when CrystalV2::Compiler::Frontend::BeginNode
        expr_node.body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) }
        if clauses = expr_node.rescue_clauses
          clauses.each { |clause| clause.body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) } }
        end
        if else_body = expr_node.else_body
          else_body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) }
        end
        if ensure_body = expr_node.ensure_body
          ensure_body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) }
        end
      when CrystalV2::Compiler::Frontend::WhileNode
        expr_node.body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) }
      when CrystalV2::Compiler::Frontend::UntilNode
        expr_node.body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) }
      when CrystalV2::Compiler::Frontend::LoopNode
        expr_node.body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) }
      when CrystalV2::Compiler::Frontend::ForNode
        expr_node.body.each { |child| collect_class_var_assignment_types(child, cvar_name, self_type_name, output) }
      when CrystalV2::Compiler::Frontend::CallNode
        if env_get("DEBUG_CLASSVAR_INFER") && cvar_name == "handlers" && @current_class == "Crystal::AtExitHandlers"
          if block_id = expr_node.block
            block_node = @arena[block_id]
            block_size = block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode) ? block_node.body.try(&.size) || 0 : 0
            STDERR.puts "[CVAR_INFER] call block=yes block_type=#{block_node.class.name.split("::").last} body=#{block_size}"
          else
            STDERR.puts "[CVAR_INFER] call block=no"
          end
        end
        if block = expr_node.block
          collect_class_var_assignment_types(block, cvar_name, self_type_name, output)
        end
      when CrystalV2::Compiler::Frontend::ReturnNode
        if value = expr_node.value
          collect_class_var_assignment_types(value, cvar_name, self_type_name, output)
        end
      when CrystalV2::Compiler::Frontend::GroupingNode
        collect_class_var_assignment_types(expr_node.expression, cvar_name, self_type_name, output)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        collect_class_var_assignment_types(expr_node.expression, cvar_name, self_type_name, output)
      end
    end

    private def record_class_var_type(owner_name : String, cvar_name : String, cvar_type : TypeRef, initial_value : Int64? = nil) : Nil
      return if owner_name.empty?
      return if cvar_type == TypeRef::VOID
      if env_get("DEBUG_CVAR_TYPE")
        STDERR.puts "[DEBUG_CVAR_TYPE] owner=#{owner_name} var=#{cvar_name} type=#{get_type_name_from_ref(cvar_type)}"
      end

      if class_info = @class_info[owner_name]?
        if idx = class_info.class_vars.index { |cv| cv.name == cvar_name }
          if class_info.class_vars[idx].type == TypeRef::VOID
            class_info.class_vars[idx] = ClassVarInfo.new(cvar_name, cvar_type, class_info.class_vars[idx].initial_value)
          end
        else
          class_info.class_vars << ClassVarInfo.new(cvar_name, cvar_type, initial_value)
        end
        return
      end

      return unless @module_defs.has_key?(owner_name)
      vars = @module_class_vars[owner_name]? || begin
        new_vars = [] of ClassVarInfo
        @module_class_vars[owner_name] = new_vars
        new_vars
      end
      if idx = vars.index { |cv| cv.name == cvar_name }
        if vars[idx].type == TypeRef::VOID
          vars[idx] = ClassVarInfo.new(cvar_name, cvar_type, vars[idx].initial_value)
        end
      else
        vars << ClassVarInfo.new(cvar_name, cvar_type, initial_value)
      end
    end

    # Lower a function definition
    def lower_def(
      node : CrystalV2::Compiler::Frontend::DefNode,
      call_arg_types : Array(TypeRef)? = nil,
      call_arg_literals : Array(Bool)? = nil,
      call_arg_enum_names : Array(String?)? = nil,
      full_name_override : String? = nil,
    ) : Function
      # Enum value tracking is per-function; preserve outer context.
      old_enum_value_types = @enum_value_types
      @enum_value_types = nil
      base_name = String.new(node.name)
      if debug_env_filter_match?("DEBUG_STRING_METHOD_LOWER", base_name)
        STDERR.puts "[DEBUG_LOWER_DEF] name=#{base_name} override=#{full_name_override || "(none)"} current_class=#{@current_class || "(none)"}"
      end
      if base_name == "main" && @current_class.nil? && !fun_def?(node)
        base_name = TOP_LEVEL_MAIN_BASE
        @top_level_main_defined = true
      end

      # Lower parameters
      param_infos = [] of Tuple(String, TypeRef)
      param_default_literals = [] of String?
      param_types = [] of TypeRef
      param_type_names = [] of String? # Track type annotation names for enum detection
      param_literal_flags = [] of Bool
      has_block = false
      param_type_map = {} of String => TypeRef
      extra_type_params = {} of String => String
      old_typeof_locals = @current_typeof_locals
      old_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = param_type_map
      @current_typeof_local_names = {} of String => String
      call_types = call_arg_types || [] of TypeRef
      call_literal_flags = call_arg_literals || [] of Bool
      call_enum_names = call_arg_enum_names || [] of String?
      call_index = 0
      splat_param_info_index : Int32? = nil
      splat_param_types_index : Int32? = nil
      splat_param_name : String? = nil
      registered_param_map = function_type_param_map_for(full_name_override || base_name, base_name)

      if params = node.params
        param_loop = -> {
          params.each do |param|
            next if named_only_separator?(param)
            param_name = param.name.nil? ? "_" : String.new(param.name.not_nil!)
            type_ann_str : String? = nil
            param_type = if ta = param.type_annotation
                           type_ann_str = String.new(ta)
                           type_ref_for_name(type_ann_str)
                         elsif param.is_double_splat
                           type_ref_for_name("NamedTuple")
                         else
                           TypeRef::VOID # Unknown type
                         end
            if param_type == TypeRef::VOID && type_ann_str && type_ann_str.includes?('|')
              union_name = normalize_union_type_name(type_ann_str)
              union_ref = create_union_type(union_name)
              param_type = union_ref if union_ref != TypeRef::VOID
            end
            if param_type == TypeRef::VOID && type_ann_str
              resolved_name = resolve_type_name_in_context(type_ann_str)
              resolved = resolve_type_alias_chain(resolved_name)
              if resolved.includes?('|')
                union_name = normalize_union_type_name(resolved)
                union_ref = create_union_type(union_name)
                param_type = union_ref if union_ref != TypeRef::VOID
              end
            end
            if type_ann_str && bare_generic_annotation?(type_ann_str)
              # Keep the generic base type for dispatch; allow callsite refinement.
              param_type = type_ref_for_name(strip_generic_args(type_ann_str))
            end
            call_type_for_param = if !param.is_block && !param.is_splat && !param.is_double_splat && call_index < call_types.size
                                    call_types[call_index]
                                  else
                                    TypeRef::VOID
                                  end
            if param_type == TypeRef::VOID && base_name == "hash" && param_name == "hasher"
              inferred = type_ref_for_name("Crystal::Hasher")
              param_type = inferred if inferred != TypeRef::VOID
            end
            if param_type == TypeRef::VOID && !param.is_block && !param.is_splat && !param.is_double_splat
              if call_index < call_types.size
                inferred = call_types[call_index]
                param_type = inferred if inferred != TypeRef::VOID
              end
            end
            if !param.is_block && !param.is_splat && !param.is_double_splat && call_index < call_types.size
              param_type = refine_param_type_from_call(param_type, call_types[call_index])
            end

            if base_name == "fit_in_indices"
              current_class = @current_class
              if current_class && current_class.starts_with?("Hash(")
                type_name = get_type_name_from_ref(param_type)
                if type_name.includes?('|')
                  variants = split_union_type_name(type_name)
                  if chosen = variants.find { |v| v.starts_with?("UInt") || v.starts_with?("Int") }
                    resolved = type_ref_for_name(chosen)
                    param_type = resolved if resolved != TypeRef::VOID
                  end
                end
              end
            end

            if param_name.ends_with?("_class") && call_type_for_param != TypeRef::VOID
              param_type = call_type_for_param
            end

            param_type_map[param_name] = param_type
            param_infos << {param_name, param_type}
            param_default_literals << extract_param_default_literal(param)
            # Track type annotation name for enum detection
            enum_name = call_index < call_enum_names.size ? call_enum_names[call_index] : nil
            param_type_names << (param.type_annotation ? String.new(param.type_annotation.not_nil!) : enum_name)
            if ta = param.type_annotation
              update_typeof_local_name(param_name, String.new(ta))
            end
            param_literal = !param.is_block && !param.is_splat && !param.is_double_splat &&
                            call_index < call_literal_flags.size && call_literal_flags[call_index]
            if param_name.ends_with?("_class")
              chosen_type = call_type_for_param == TypeRef::VOID ? param_type : call_type_for_param
              type_name = get_type_name_from_ref(chosen_type)
              if !type_name.empty? && type_name != "Void" && type_name != "Unknown"
                param_literal = true
              end
            end
            if param_literal
              chosen_type = call_type_for_param == TypeRef::VOID ? param_type : call_type_for_param
              type_name = get_type_name_from_ref(chosen_type)
              if !type_name.empty? && type_name != "Void" && type_name != "Unknown"
                update_typeof_local_name(param_name, type_name)
                extra_type_params[param_name] = type_name
              end
            end
            if param.is_block
              has_block = true
            else
              if param.is_splat
                splat_param_info_index = param_infos.size - 1
                splat_param_types_index = param_types.size
                splat_param_name = param_name
              elsif !param.is_double_splat
                call_index += 1
              end
              param_types << param_type
            end
            param_literal_flags << param_literal
          end
        }
        if registered_param_map
          with_type_param_map(registered_param_map) { param_loop.call }
        else
          param_loop.call
        end
      end

      if splat_param_name
        splat_type = TypeRef::VOID
        if !call_types.empty?
          remaining = call_types[call_index..-1]? || [] of TypeRef
          splat_type = tuple_type_from_arg_types(remaining, allow_void: true)
        end
        if splat_type == TypeRef::VOID
          if elem_type = param_type_map[splat_param_name.not_nil!]?
            if elem_type != TypeRef::VOID
              splat_type = tuple_type_from_arg_types([elem_type], allow_void: true)
            end
          end
        end
        if splat_type == TypeRef::VOID
          fallback = type_ref_for_name("Tuple")
          splat_type = fallback if fallback != TypeRef::VOID
        end
        if splat_type != TypeRef::VOID
          param_type_map[splat_param_name.not_nil!] = splat_type
          if idx = splat_param_info_index
            param_infos[idx] = {splat_param_name.not_nil!, splat_type}
          end
          if idx = splat_param_types_index
            param_types[idx] = splat_type
          end
        end
      end
      if !has_block
        def_arena = @function_def_arenas[base_name]? || resolve_arena_for_def(node, @arena)
        has_block = def_contains_yield?(node, def_arena)
      end

      # Determine return type (default to Void if not specified)
      return_type = TypeRef::VOID
      if extra_type_params.empty?
        return_type = if rt = node.return_type
                        rt_string = String.new(rt)
                        type_ref_for_name(rt_string)
                      elsif base_name.ends_with?('?')
                        TypeRef::BOOL
                      else
                        TypeRef::VOID
                      end
      else
        with_type_param_map(extra_type_params) do
          return_type = if rt = node.return_type
                          rt_string = String.new(rt)
                          type_ref_for_name(rt_string)
                        elsif base_name.ends_with?('?')
                          TypeRef::BOOL
                        else
                          TypeRef::VOID
                        end
        end
      end

      # Top-level functions support overloading, so use mangled names consistently.
      # Exception: stdlib fun main is a C-ABI entrypoint and must stay unmangled.
      if full_name_override.nil? && fun_def?(node) && base_name == "main" && @current_class.nil?
        full_name_override = base_name
      end
      full_name = full_name_override || function_full_name_for_def(base_name, param_types, node.params, has_block)

      # Retrieve stored type param map for lazy lowering of generic class methods.
      # When a monomorphized class's method is lowered, we need the type parameter
      # substitutions (e.g., T => UInt8) that were stored during method registration.
      if registered_params = function_type_param_map_for(full_name, base_name)
        extra_type_params.merge!(registered_params)
        if env_has?("DEBUG_LOWER_DEF_TPM") && (full_name.includes?("Slice") && full_name.includes?("hash"))
          STDERR.puts "[LOWER_DEF_TPM] full=#{full_name} base=#{base_name} merged=#{registered_params}"
        end
      end

      if registered = @function_types[full_name]?
        if (return_type == TypeRef::VOID || return_type == TypeRef::NIL) &&
           registered != TypeRef::VOID && registered != TypeRef::NIL
          return_type = registered
        end
      end
      # Idempotency: avoid lowering the same function twice (can happen with conditional defs).
      if existing = @module.function_by_name(full_name)
        @enum_value_types = old_enum_value_types
        return existing
      end

      # Ensure function type is registered even when caller skipped register_function (e.g. conditional defs).
      if existing = @function_types[full_name]?
        if existing == TypeRef::VOID ||
           (existing == TypeRef::NIL && return_type != TypeRef::NIL) ||
           (existing == TypeRef::POINTER && return_type != TypeRef::POINTER)
          register_function_type(full_name, return_type)
        end
      else
        register_function_type(full_name, return_type)
      end
      if should_register_base_name?(full_name, base_name, node, has_block)
        if existing = @function_types[base_name]?
          if existing == TypeRef::VOID ||
             (existing == TypeRef::NIL && return_type != TypeRef::NIL) ||
             (existing == TypeRef::POINTER && return_type != TypeRef::POINTER)
            register_function_type(base_name, return_type)
          end
        else
          register_function_type(base_name, return_type)
        end

        # Keep AST around for signatureHelp/named args and for yield inlining.
        unless @function_defs.has_key?(base_name)
          @function_defs[base_name] = node
          @function_def_arenas[base_name] = @arena
        end
      end
      @function_defs[full_name] = node
      @function_def_arenas[full_name] = @arena

      func = @module.create_function(full_name, return_type)
      ctx = LoweringContext.new(func, @module, @arena)

      param_infos.each_with_index do |(param_name, param_type), idx|
        hir_param = func.add_param(param_name, param_type)
        if default_lit = param_default_literals[idx]?
          hir_param.default_literal = default_lit
        end
        ctx.register_local(param_name, hir_param.id)
        ctx.register_type(hir_param.id, param_type) # Track param type for inference
        if (param_literal_flags[idx]? || param_name.ends_with?("_class")) && param_type != TypeRef::VOID
          ctx.mark_type_literal(hir_param.id) unless module_type_ref?(param_type)
        end
        # Track enum type for predicate method inlining
        if type_name = param_type_names[idx]?
          track_enum_value(hir_param.id, type_name)
        end
      end

      # Lower body
      # IMPORTANT: Save and clear inline yield stacks to prevent cross-context contamination.
      # When lowering a standalone function, yield should emit a Yield instruction,
      # NOT substitute an inline block from an unrelated call context.
      saved_yield_block_stack = @inline_yield_block_stack
      saved_yield_arena_stack = @inline_yield_block_arena_stack
      saved_yield_param_stack = @inline_yield_block_param_types_stack
      saved_yield_return_stack = @inline_yield_block_return_stack
      saved_yield_name_stack = @inline_yield_name_stack
      saved_inline_arenas = @inline_arenas
      @inline_yield_block_stack = [] of CrystalV2::Compiler::Frontend::BlockNode
      @inline_yield_block_arena_stack = [] of CrystalV2::Compiler::Frontend::ArenaLike
      @inline_yield_block_param_types_stack = [] of Array(TypeRef)?
      @inline_yield_block_return_stack = [] of String?
      @inline_yield_name_stack = [] of String
      @inline_arenas = nil
      last_value : ValueId? = nil
      begin
        if body = node.body
          body_proc = -> {
            def_arena = @arena
            i = 0
            while i < body.size
              expr_id = body[i]
              with_arena(def_arena) do
                last_value = lower_expr(ctx, expr_id)
              end
              break if should_stop_sequential_lowering?(ctx)
              i += 1
            end
          }
          if extra_type_params.empty?
            body_proc.call
          else
            with_type_param_map(extra_type_params) { body_proc.call }
          end
        end
      ensure
        @inline_yield_block_stack = saved_yield_block_stack
        @inline_yield_block_arena_stack = saved_yield_arena_stack
        @inline_yield_block_param_types_stack = saved_yield_param_stack
        @inline_yield_block_return_stack = saved_yield_return_stack
        @inline_yield_name_stack = saved_yield_name_stack
        @inline_arenas = saved_inline_arenas
      end

      # Add implicit return if not already terminated
      # BUT don't add return after raise (which sets Unreachable terminator)
      block = ctx.get_block(ctx.current_block)
      block_has_raise = block.instructions.any? { |inst| inst.is_a?(Raise) }
      if block.terminator.is_a?(Unreachable) && !block_has_raise
        block.terminator = Return.new(last_value)
      end

      # Infer return type from last expression if not explicitly specified
      # This handles methods with implicit returns like `def root_buffer; @buffer - @offset; end`
      if return_type == TypeRef::VOID
        inferred_types = [] of TypeRef

        # Prefer actual lowered return terminators over a separate AST-walk inference pass.
        # This avoids doubling work (and avoids triggering extra monomorphization while
        # lowering large pending queues during self-host).
        func.blocks.each do |block|
          term = block.terminator
          next unless term.is_a?(Return)
          if value = term.value
            t = ctx.type_of(value)
            inferred_types << t unless t == TypeRef::VOID
          else
            inferred_types << TypeRef::NIL
          end
        end

        # Also consider the last expression as a fallback (covers single-expression bodies
        # where lowering didn't emit an explicit return terminator yet).
        if (last_id = last_value)
          t = ctx.type_of(last_id)
          inferred_types << t unless t == TypeRef::VOID
        end

        if inferred_types.any?
          inferred_type = merge_return_types(inferred_types)
          if inferred_type && inferred_type != TypeRef::VOID
            func.return_type = inferred_type
            register_function_type(full_name, inferred_type)
            register_function_type(base_name, inferred_type)
          end
        end
      end

      @current_typeof_locals = old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names

      @enum_value_types = old_enum_value_types

      func
    end

    # Lower top-level expressions into a synthetic main function
    # Note: Named __crystal_main because stdlib's fun main calls LibCrystalMain.__crystal_main
    def lower_main(main_exprs : Array(Tuple(CrystalV2::Compiler::Frontend::ExprId, CrystalV2::Compiler::Frontend::ArenaLike))) : Function
      # Create __crystal_main function with void return type
      # Signature: fun __crystal_main(argc : Int32, argv : UInt8**)
      func = @module.create_function("__crystal_main", TypeRef::VOID)

      # Add parameters to match lib declaration
      argc_param = func.add_param("argc", TypeRef::INT32)
      argv_type = type_ref_for_name("Pointer(Pointer(UInt8))")
      argv_type = TypeRef::POINTER if argv_type == TypeRef::VOID
      argv_param = func.add_param("argv", argv_type)

      ctx = LoweringContext.new(func, @module, @arena)

      # Register parameters in context for potential use
      ctx.register_local("argc", argc_param.id)
      ctx.register_local("argv", argv_param.id)
      ctx.register_type(argc_param.id, TypeRef::INT32)
      ctx.register_type(argv_param.id, argv_type)
      ctx.register_local("ARGC_UNSAFE", argc_param.id)
      ctx.register_local("ARGV_UNSAFE", argv_param.id)
      old_main_class = @current_class
      old_main_namespace = @current_namespace_override
      @current_class = nil
      @current_namespace_override = nil

      # Process deferred classvar initializations FIRST, before any other code.
      # This ensures classvars like @@skip are initialized before being used.
      if env_has?("DEBUG_DEFERRED_CLASSVAR")
        STDERR.puts "[DEFERRED_CLASSVAR] Processing #{@deferred_classvar_inits.size} deferred inits"
      end
      old_arena = @arena
      @deferred_classvar_inits.each do |(init_expr_id, init_arena, owner_class)|
        @arena = init_arena
        old_class = @current_class
        @current_class = owner_class
        begin
          node = @arena[init_expr_id]
          case node
          when CrystalV2::Compiler::Frontend::ClassVarDeclNode
            # Generate: @@varname = initial_value
            if val_id = node.value
              # Skip `uninitialized` classvars — they're zero-initialized by default
              # and may be explicitly initialized later (e.g. in Thread.init/Fiber.init).
              # Generating a deferred init for these would overwrite the proper value.
              val_node = @arena[val_id]
              next if val_node.is_a?(CrystalV2::Compiler::Frontend::UninitializedNode)

              raw_name = String.new(node.name)
              cvar_name = raw_name.lstrip('@')
              value_id = lower_expr(ctx, val_id)
              value_type = ctx.type_of(value_id)
              # Emit ClassVarSet to store the initialized value
              class_var_set = ClassVarSet.new(ctx.next_id, value_type, owner_class, cvar_name, value_id)
              ctx.emit(class_var_set)
            end
          when CrystalV2::Compiler::Frontend::AssignNode
            # Skip `uninitialized` classvars — they're zero-initialized by default
            # and may be explicitly initialized later (e.g. in Thread.init/Fiber.init).
            rhs_node = @arena[node.value]
            next if rhs_node.is_a?(CrystalV2::Compiler::Frontend::UninitializedNode)

            # Regular assignment - just lower it
            if env_has?("DEBUG_DEFERRED_CLASSVAR")
              target = @arena[node.target]
              target_name = target.is_a?(CrystalV2::Compiler::Frontend::ClassVarNode) ? String.new(target.name) : "?"
              STDERR.puts "[DEFERRED_CLASSVAR] Lowering AssignNode: class=#{owner_class} target=#{target_name}"
            end
            lower_expr(ctx, init_expr_id)
          when CrystalV2::Compiler::Frontend::ConstantNode
            # Constant definition (e.g. HEADER_SIZE = offsetof(String, @c))
            lower_expr(ctx, init_expr_id)
          end
        ensure
          @current_class = old_class
        end
      end
      @arena = old_arena
      @deferred_classvar_inits.clear

      # Process deferred constant initializations (string literals, etc.)
      if env_has?("DEBUG_DEFERRED_CONST")
        STDERR.puts "[DEFERRED_CONST] Processing #{@deferred_constant_inits.size} deferred constant inits"
        @deferred_constant_inits.each do |(owner, const_name, value_id, init_arena)|
          STDERR.puts "[DEFERRED_CONST]   #{owner}::#{const_name}"
        end
      end
      @deferred_constant_inits.each do |(owner, const_name, value_id, init_arena)|
        @arena = init_arena
        old_class = @current_class
        @current_class = owner == "$" ? nil : owner
        begin
          value = lower_expr(ctx, value_id)
          value_type = ctx.type_of(value)
          full_name = constant_full_name(owner == "$" ? nil : owner, const_name)
          storage_owner, storage_name = constant_storage_info(full_name)
          set = ClassVarSet.new(ctx.next_id, value_type, storage_owner, storage_name, value)
          ctx.emit(set)
        ensure
          @current_class = old_class
        end
      end
      @arena = old_arena
      @deferred_constant_inits.clear

      # Lower each top-level expression in order
      last_value : ValueId? = nil
      debug_main = env_has?("DEBUG_MAIN")
      slow_only = env_has?("DEBUG_MAIN_SLOW_ONLY")
      progress_every = env_get("DEBUG_MAIN_PROGRESS_EVERY").try(&.to_i?) || 500
      slow_ms = env_get("DEBUG_MAIN_SLOW_MS").try(&.to_f) || 50.0
      if debug_main
        STDERR.puts "[MAIN] lower_main exprs=#{main_exprs.size}"
      end
      main_exprs.each_with_index do |(expr_id, arena), idx|
        # Switch arena context for this expression
        @arena = arena
        if debug_main && !slow_only
          node = @arena[expr_id]
          snippet = nil
          if source = @sources_by_arena[@arena]?
            span = node.span
            start = span.start_offset
            length = span.end_offset - span.start_offset
            if length > 0 && start >= 0 && start < source.bytesize
              max_len = 80
              slice_len = length > max_len ? max_len : length
              snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
            end
          end
          if snippet
            STDERR.puts "[MAIN] start #{idx + 1}/#{main_exprs.size} #{node.class} offs=#{node.span.start_offset} \"#{snippet}\""
          else
            STDERR.puts "[MAIN] start #{idx + 1}/#{main_exprs.size} #{node.class}"
          end
        end
        expr_start = debug_main ? Time.instant : nil
        last_value = lower_expr(ctx, expr_id)
        if debug_main && expr_start
          elapsed = (Time.instant - expr_start).total_milliseconds
          if elapsed > slow_ms
            node = @arena[expr_id]
            snippet = nil
            if source = @sources_by_arena[@arena]?
              span = node.span
              start = span.start_offset
              length = span.end_offset - span.start_offset
              if length > 0 && start >= 0 && start < source.bytesize
                max_len = 80
                slice_len = length > max_len ? max_len : length
                snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
              end
            end
            if snippet
              STDERR.puts "[MAIN] expr #{idx + 1}/#{main_exprs.size} #{node.class} #{elapsed.round(1)}ms \"#{snippet}\""
            else
              STDERR.puts "[MAIN] expr #{idx + 1}/#{main_exprs.size} #{node.class} #{elapsed.round(1)}ms"
            end
          elsif (idx % progress_every == 0) || (idx + 1 == main_exprs.size)
            STDERR.puts "[MAIN] progress #{idx + 1}/#{main_exprs.size}"
          end
        end
      end

      # Return void (stdlib's fun main handles the return value)
      block = ctx.get_block(ctx.current_block)
      if block.terminator.is_a?(Unreachable)
        block.terminator = Return.new(nil)
      end

      # WORK QUEUE: Process all pending functions that were deferred during lowering.
      # This breaks the recursive cycle by processing functions iteratively.
      process_pending_lower_functions

      @current_class = old_main_class
      @current_namespace_override = old_main_namespace
      func
    end

    # Lower a synthetic __crystal_main that calls a user-defined main.
    # Used when there are no top-level expressions (no implicit main body).
    def lower_main_from_def(node : CrystalV2::Compiler::Frontend::DefNode) : Function
      if existing = @module.function_by_name("__crystal_main")
        return existing
      end

      # Ensure user main is lowered (lazy lowering in CLI).
      lower_def(node)

      # Create __crystal_main(argc, argv)
      func = @module.create_function("__crystal_main", TypeRef::VOID)
      argc_param = func.add_param("argc", TypeRef::INT32)
      argv_type = type_ref_for_name("Pointer(Pointer(UInt8))")
      argv_type = TypeRef::POINTER if argv_type == TypeRef::VOID
      argv_param = func.add_param("argv", argv_type)

      ctx = LoweringContext.new(func, @module, @arena)
      ctx.register_local("argc", argc_param.id)
      ctx.register_local("argv", argv_param.id)
      ctx.register_type(argc_param.id, TypeRef::INT32)
      ctx.register_type(argv_param.id, argv_type)
      ctx.register_local("ARGC_UNSAFE", argc_param.id)
      ctx.register_local("ARGV_UNSAFE", argv_param.id)

      # Build the call to main with argc/argv if requested by the signature.
      param_types = [] of TypeRef
      has_block = false
      if params = node.params
        params.each do |param|
          next if named_only_separator?(param)
          if param.is_block
            has_block = true
            next
          end
          param_types << (param.type_annotation ? type_ref_for_name(String.new(param.type_annotation.not_nil!)) : TypeRef::VOID)
        end
      end

      main_base = if String.new(node.name) == "main" && @current_class.nil? && !fun_def?(node)
                    @top_level_main_defined = true
                    TOP_LEVEL_MAIN_BASE
                  else
                    "main"
                  end
      main_name = mangle_function_name(main_base, param_types, has_block)
      return_type = get_function_return_type(main_name)
      args = [] of ValueId
      args << argc_param.id if param_types.size >= 1
      args << argv_param.id if param_types.size >= 2
      call = Call.new(ctx.next_id, return_type, nil, main_name, args)
      ctx.emit(call)

      ctx.terminate(Return.new(nil))

      # WORK QUEUE: Process all pending functions that were deferred during lowering.
      process_pending_lower_functions

      func
    end

    # Public method to flush pending functions from external callers (e.g., CLI after lower_def)
    def flush_pending_functions
      process_pending_lower_functions
      # Fix #2: Emit all tracked signatures to ensure functions called from
      # conditional branches or with specific type instantiations are lowered.
      emit_all_tracked_signatures
      # Final pass: lower any remaining call targets that already appear in HIR.
      lower_missing_call_targets
      if env_get("DEBUG_MONO_SOURCES") && !@mono_sources_reported && !@mono_source_counts.empty?
        top_n = env_get("DEBUG_MONO_SOURCES_TOP").try(&.to_i?) || 15
        STDERR.puts "[MONO_SOURCES] top=#{top_n} total=#{@mono_source_counts.size}"
        @mono_source_counts.to_a
          .sort_by { |entry| -entry[1] }
          .first(top_n)
          .each do |name, count|
            STDERR.puts "  #{name}: #{count}"
            if env_get("DEBUG_MONO_SOURCES_SAMPLES")
              if samples = @mono_source_samples[name]?
                samples.each { |sample| STDERR.puts "    - #{sample}" }
              end
            end
          end
        if env_get("DEBUG_MONO_CALLER") && !@mono_caller_counts.empty?
          caller_top = env_get("DEBUG_MONO_CALLER_TOP").try(&.to_i?) || 20
          STDERR.puts "[MONO_CALLERS] top=#{caller_top} total=#{@mono_caller_counts.size}"
          @mono_caller_counts.to_a
            .sort_by { |entry| -entry[1] }
            .first(caller_top)
            .each do |key, count|
              STDERR.puts "  #{key}: #{count}"
            end
        end
        @mono_sources_reported = true
      end
    end

    # Emit all tracked callsite signatures that haven't been lowered yet.
    # This ensures functions referenced in conditional code paths are included.
    private def emit_all_tracked_signatures
      max_iterations = 100
      attempted = Set(String).new
      sig_budget = env_get("CRYSTAL_V2_SIG_BUDGET").try(&.to_i?) || 0
      iteration = 0
      debug_emit = env_has?("DEBUG_EMIT_SIGS")

      while iteration < max_iterations
        # Collect all unique function names from pending arg types
        sigs_to_lower = [] of String
        sigs_seen = Set(String).new
        skipped_void = 0
        skipped_bare = 0
        skipped_seen = 0
        considered = 0
        @pending_arg_types.each do |name, args|
          considered += 1
          next if @module.has_function?(name)
          next if function_state(name).completed?
          next if function_state(name).in_progress?
          next if attempted.includes?(name)
          if !args.types.empty? && args.types.all? { |t| t == TypeRef::VOID }
            skipped_void += 1 if debug_emit
            next
          end
          # Skip incomplete names (must have class prefix with # or .)
          base_name = strip_type_suffix(name)
          next unless base_name.includes?('#') || base_name.includes?('.')
          # Skip functions with bare generic types (they need concrete instantiation)
          base_name = strip_type_suffix(name)
          has_double_splat_def = function_def_has_double_splat?(base_name)
          has_bare_generic = args.types.any? do |t|
            if desc = @module.get_type_descriptor(t)
              is_bare = !desc.name.includes?('(') && KNOWN_GENERIC_TYPES.includes?(desc.name)
              if is_bare && desc.name == "NamedTuple" && has_double_splat_def
                false
              else
                is_bare
              end
            else
              false
            end
          end
          if has_bare_generic
            skipped_bare += 1 if debug_emit
            next
          end
          if sigs_seen.includes?(name)
            skipped_seen += 1 if debug_emit
            next
          end
          sigs_seen.add(name)
          sigs_to_lower << name
        end

        @recorded_arg_types_by_signature.each do |signature, entries|
          base_name = signature.base_name
          next if base_name.empty?
          next unless base_name.includes?('#') || base_name.includes?('.')
          has_double_splat_def = function_def_has_double_splat?(base_name)
          entries.each do |args|
            if !args.types.empty? && args.types.all? { |t| t == TypeRef::VOID }
              skipped_void += 1 if debug_emit
              next
            end
            has_splat_def = function_def_has_splat?(base_name) || function_def_has_double_splat?(base_name)
            name = if entry = lookup_function_def_for_call(base_name, args.types.size, signature.has_block, args.types, has_splat_def)
                     entry[0]
                   else
                     mangle_function_name(base_name, args.types, signature.has_block)
                   end
            next if @module.has_function?(name)
            next if function_state(name).completed?
            next if function_state(name).in_progress?
            next if attempted.includes?(name)
            has_bare_generic = args.types.any? do |t|
              if desc = @module.get_type_descriptor(t)
                is_bare = !desc.name.includes?('(') && KNOWN_GENERIC_TYPES.includes?(desc.name)
                if is_bare && desc.name == "NamedTuple" && has_double_splat_def
                  false
                else
                  is_bare
                end
              else
                false
              end
            end
            if has_bare_generic
              skipped_bare += 1 if debug_emit
              next
            end
            if sigs_seen.includes?(name)
              skipped_seen += 1 if debug_emit
              next
            end
            sigs_seen.add(name)
            sigs_to_lower << name
          end
        end

        break if sigs_to_lower.empty?

        if sig_budget > 0 && sigs_to_lower.size > sig_budget
          sigs_to_lower = sigs_to_lower.first(sig_budget)
        end

        if debug_emit
          budget_note = sig_budget > 0 ? " budget=#{sig_budget}" : ""
          STDERR.puts "[EMIT_SIGS] iteration=#{iteration} sigs=#{sigs_to_lower.size}#{budget_note} considered=#{considered} skipped_void=#{skipped_void} skipped_bare=#{skipped_bare} skipped_seen=#{skipped_seen}"
          if iteration == 0 && sigs_to_lower.size > 0
            sigs_to_lower.first(10).each do |name|
              STDERR.puts "[EMIT_SIGS] sample: #{name}"
            end
          end
        end

        sigs_to_lower.each do |name|
          attempted.add(name)
          lower_function_if_needed(name)
        end

        # Process any functions that were added during lowering
        process_pending_lower_functions

        iteration += 1
      end

      if debug_emit
        STDERR.puts "[EMIT_SIGS] done after #{iteration} iterations"
      end
    end

    # Lower any missing call targets that already appear in the HIR module.
    # This is a safety net for late-resolved overloads (defaults, implicit generics).
    private def lower_missing_call_targets
      max_iterations = 20
      budget = env_get("CRYSTAL_V2_MISSING_BUDGET").try(&.to_i?) || 0
      iteration = 0
      STDERR.puts "[MISSING_LOWER] start" if env_get("DEBUG_MISSING_LOWER")

      while iteration < max_iterations
        missing = [] of String
        @module.functions.each do |func|
          func.blocks.each do |block|
            block.instructions.each do |inst|
              next unless inst.is_a?(Call)
              name = inst.method_name
              if parts = parse_method_name_compact(name)
                owner = parts.owner
                method = parts.method
                if owner && method && union_type_name?(owner)
                  union_name = normalize_union_type_name(owner)
                  arg_types = inst.args.map { TypeRef::VOID }
                  has_block_call = !!inst.block
                  if env_get("DEBUG_UNION_REWRITE")
                    STDERR.puts "[UNION_REWRITE] call=#{name} union=#{union_name} method=#{method} args=#{arg_types.size}"
                  end
                  if resolved = resolve_union_method_call(union_name, method, arg_types, has_block_call)
                    STDERR.puts "[UNION_REWRITE] resolved=#{resolved}" if env_get("DEBUG_UNION_REWRITE")
                    inst.method_name = resolved
                    name = resolved
                  end
                end
              end
              # Resolve module class-method calls to their includer class.
              # e.g., Crystal::System::Time.leap_year?$Int32 → Time.leap_year?$Int32
              if !@module.has_function?(name) && name.includes?('.')
                if parts2 = parse_method_name_compact(name)
                  if (owner2 = parts2.owner) && module_like_type_name?(owner2)
                    if includers = @module_includers[owner2]?
                      method2 = parts2.method || ""
                      base2 = parts2.base
                      suffix2 = name.bytesize > base2.bytesize ? name[base2.bytesize..] : ""
                      includers.each do |includer|
                        alt_base = "#{includer}.#{method2}"
                        alt_name = "#{alt_base}#{suffix2}"
                        if @function_defs.has_key?(alt_name) || @function_defs.has_key?(alt_base) ||
                           class_method_overload_exists?(alt_base)
                          inst.method_name = alt_name
                          name = alt_name
                          break
                        end
                      end
                    end
                  end
                end
              end
              next if name.empty?
              next if @module.has_function?(name)
              if function_state(name).completed?
                # Some flows mark completed without emitting a function body.
                # Clear the completed state to allow a re-lower pass.
                @function_lowering_states.delete(name)
              end
              next if function_state(name).in_progress?
              missing << name
            end
          end
        end
        missing.uniq!
        break if missing.empty?

        if budget > 0 && missing.size > budget
          missing = missing.first(budget)
        end

        before = @module.functions.size
        missing.each do |name|
          lower_function_if_needed(name)
          # If the missing call is a module/class method and still unresolved,
          # attempt a direct module-method lower against the recorded def.
          # This handles cases where untyped module methods were registered
          # but skipped during normal lowering.
          if name.includes?('.') && !@module.has_function?(name)
            force_lower_module_method_by_name(name)
          end
        end
        process_pending_lower_functions
        iteration += 1
        break if @module.functions.size == before
      end
    end

    private def force_lower_module_method_by_name(name : String) : Nil
      return unless name.includes?('.')
      return if @module.has_function?(name)
      base_name = strip_type_suffix(name)
      func_def = @function_defs[name]? || @function_defs[base_name]?
      return unless func_def
      func_arena = @function_def_arenas[name]? || @function_def_arenas[base_name]?
      owner = method_owner(base_name)
      # Avoid re-lowering if already completed/in-progress in the state map.
      return if function_state(name).in_progress?
      if function_state(name).completed?
        # Clear completed state to allow a direct lower (some flows mark completed without emit).
        @function_lowering_states.delete(name)
      end
      with_arena(func_arena || @arena) do
        lower_module_method(owner, func_def, nil, nil, nil, name)
      end
    end

    # WORK QUEUE: Process functions that were deferred during lowering.
    # This breaks the recursive stack overflow by processing functions iteratively.
    # Each iteration may add more functions to the queue, so we loop until empty.
    private def process_pending_lower_functions
      max_iterations = 10000 # Safety limit to prevent infinite loops
      iteration = 0
      budget = env_get("CRYSTAL_V2_PENDING_BUDGET").try(&.to_i?) || 0
      debug_pending = env_has?("DEBUG_PENDING")
      pending_sources_mode = env_get("DEBUG_PENDING_SOURCES")
      pending_sources_each = pending_sources_mode == "each"
      pending_sources_top = env_get("DEBUG_PENDING_SOURCES_TOP").try(&.to_i?) || 15
      pending_sources_samples = env_has?("DEBUG_PENDING_SOURCES_SAMPLES")
      mono_sources_each = env_has?("DEBUG_MONO_SOURCES_EACH")
      mono_sources_top = env_get("DEBUG_MONO_SOURCES_TOP").try(&.to_i?) || 15
      mono_sources_samples = env_has?("DEBUG_MONO_SOURCES_SAMPLES")

      attempt_counts = Hash(String, Int32).new(0)
      while pending_functions.size > 0 && iteration < max_iterations
        # Take a snapshot of currently pending functions — skip stuck ones (max 3 attempts)
        pending = pending_functions.dup
        pending.reject! { |name| attempt_counts[name] >= 3 }
        if budget > 0 && pending.size > budget
          pending = pending.first(budget)
        end
        if debug_pending
          STDERR.puts "[PENDING] iteration=#{iteration} pending=#{pending.size}"
          if pending_sources_mode && (pending_sources_each || iteration == 0) && !@pending_source_counts.empty?
            STDERR.puts "[PENDING_SOURCES] top=#{pending_sources_top} total=#{@pending_source_counts.size}"
            @pending_source_counts.to_a
              .sort_by { |entry| -entry[1] }
              .first(pending_sources_top)
              .each do |name, count|
                STDERR.puts "  #{name}: #{count}"
                if pending_sources_samples
                  if samples = @pending_source_samples[name]?
                    samples.each do |sample|
                      STDERR.puts "    - #{sample}"
                    end
                  end
                end
              end
          end
          if mono_sources_each && !@mono_source_counts.empty?
            STDERR.puts "[MONO_SOURCES] top=#{mono_sources_top} total=#{@mono_source_counts.size}"
            @mono_source_counts.to_a
              .sort_by { |entry| -entry[1] }
              .first(mono_sources_top)
              .each do |name, count|
                STDERR.puts "  #{name}: #{count}"
                if mono_sources_samples
                  if samples = @mono_source_samples[name]?
                    samples.each { |sample| STDERR.puts "    - #{sample}" }
                  end
                end
              end
          end
          if env_get("DEBUG_MONO_CALLER") && !@mono_caller_counts.empty?
            caller_top = env_get("DEBUG_MONO_CALLER_TOP").try(&.to_i?) || 20
            STDERR.puts "[MONO_CALLERS] top=#{caller_top} total=#{@mono_caller_counts.size}"
            @mono_caller_counts.to_a
              .sort_by { |entry| -entry[1] }
              .first(caller_top)
              .each do |key, count|
                STDERR.puts "  #{key}: #{count}"
              end
          end
        end

        # Clear pending state (transition to NotStarted so they can be lowered)
        pending.each { |name| @function_lowering_states.delete(name) }
        # Remove from queue so we don't reprocess endlessly
        if pending.size == @pending_function_queue.size
          @pending_function_queue.clear
        else
          pending_set = pending.to_set
          @pending_function_queue.reject! { |name| pending_set.includes?(name) }
        end

        # Reset lowering depth to allow these functions to be processed
        saved_depth = @lowering_depth
        @lowering_depth = 0

        lowered_this_iter = 0
        defs_before = @function_defs.size
        mono_before = @monomorphized.size
        pending.each do |name|
          # Skip if already lowered or currently being lowered
          next if @module.has_function?(name)
          next if function_state(name).completed?
          next if function_state(name).in_progress?

          attempt_counts[name] += 1
          lower_function_if_needed(name)
          lowered_this_iter += 1
        end

        @lowering_depth = saved_depth
        iteration += 1
        defs_after = @function_defs.size
        mono_after = @monomorphized.size
        new_pending = pending_functions.size
        STDERR.puts "[PROGRESS] iter=#{iteration} lowered=#{lowered_this_iter}/#{pending.size} pending=#{new_pending} funcs=#{@module.function_count} defs=#{defs_before}->#{defs_after}(+#{defs_after - defs_before}) mono=#{mono_before}->#{mono_after}(+#{mono_after - mono_before})"
        break if pending.empty?
      end

      pending_remaining = pending_functions
      STDERR.puts "[LOWER] Finished lowering: #{iteration} iterations, #{@module.function_count} functions, #{@monomorphized.size} types, #{@function_defs.size} defs"
      if iteration >= max_iterations && pending_remaining.size > 0
        STDERR.puts "[WARNING] process_pending_lower_functions hit iteration limit, #{pending_remaining.size} functions remaining"
      end
    end

    # Lower a single expression, returns ValueId of result
    def lower_expr(ctx : LoweringContext, expr_id : ExprId) : ValueId
      if env_get("DEBUG_INLINE_CRASH")
        if @inline_yield_name_stack.any? { |name| name.includes?("Char::Reader#decode_char_at") }
          stack = @inline_yield_name_stack.join(" -> ")
          if ctx.current_block >= ctx.function.blocks.size
            STDERR.puts "[INLINE_CRASH] block_oob expr=#{expr_id.index} block=#{ctx.current_block} size=#{ctx.function.blocks.size} stack=#{stack}"
          end
          STDERR.puts "[INLINE_CRASH] lower_expr id=#{expr_id.index} arena=#{@arena.class} size=#{@arena.size} stack=#{stack}"
          if expr_id.index >= 300 && expr_id.index <= 306
            begin
              node = @arena[expr_id]
              if source = @sources_by_arena[@arena]?
                span = node.span
                start = span.start_offset
                length = span.end_offset - span.start_offset
                if length > 0 && start >= 0 && start < source.bytesize
                  slice_len = length > 120 ? 120 : length
                  snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
                  STDERR.puts "[INLINE_CRASH] node=#{node.class} span=#{start}..#{span.end_offset} \"#{snippet}\""
                else
                  STDERR.puts "[INLINE_CRASH] node=#{node.class} span=#{start}..#{span.end_offset}"
                end
              else
                STDERR.puts "[INLINE_CRASH] node=#{node.class} span=#{node.span.start_offset}..#{node.span.end_offset}"
              end
            rescue ex
              STDERR.puts "[INLINE_CRASH] failed to inspect expr=#{expr_id.index} error=#{ex.message}"
            end
          end
        end
      end
      arena = arena_for_expr?(expr_id) || @arena
      if filter = env_get("DEBUG_EXPR_ARENA")
        if filter == "1" || ctx.function.name.includes?(filter)
          if arena != @arena
            current_path = source_path_for(@arena) || "(unknown)"
            chosen_path = source_path_for(arena) || "(unknown)"
            STDERR.puts "[DEBUG_EXPR_ARENA] func=#{ctx.function.name} expr=#{expr_id.index} current=#{@arena.class}:#{@arena.size} chosen=#{arena.class}:#{arena.size} current_file=#{current_path} chosen_file=#{chosen_path}"
          end
        end
      end
      if expr_id.index < 0 || expr_id.index >= arena.size
        if env_get("DEBUG_EXPR_OOB")
          stack = @inline_yield_name_stack.join(" -> ")
          block_debug = ""
          if blk = @inline_yield_block_stack.last?
            invalid_body = blk.body.count(&.invalid?) rescue 0
            block_debug = " block_invalid=#{invalid_body}"
          end
          STDERR.puts "[EXPR_OOB] expr=#{expr_id.index} arena=#{arena.class}:#{arena.size} func=#{ctx.function.name} current=#{@current_class || ""} method=#{@current_method || ""} inline=#{stack}#{block_debug}"
          caller.first(10).each { |line| STDERR.puts "  #{line}" }
        end
        raise "ExprId out of bounds: #{expr_id.index} (arena=#{arena.class}:#{arena.size})"
      end
      if arena == @arena
        node = @arena[expr_id]
        lower_node(ctx, node)
      else
        with_arena(arena) do
          node = @arena[expr_id]
          lower_node(ctx, node)
        end
      end
    end

    # Lower an AST node to HIR
    def lower_node(ctx : LoweringContext, node : AstNode) : ValueId
      maybe_log_lower_histo(node)
      if !@pending_def_annotations.empty? &&
         !node.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode) &&
         !node.is_a?(CrystalV2::Compiler::Frontend::DefNode)
        clear_pending_effect_annotations
      end

      case node
      # ═══════════════════════════════════════════════════════════════════
      # LITERALS
      # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::NumberNode
        lower_number(ctx, node)
      when CrystalV2::Compiler::Frontend::StringNode
        lower_string(ctx, node)
      when CrystalV2::Compiler::Frontend::StringInterpolationNode
        lower_string_interpolation(ctx, node)
      when CrystalV2::Compiler::Frontend::RegexNode
        lower_regex(ctx, node)
      when CrystalV2::Compiler::Frontend::CharNode
        lower_char(ctx, node)
      when CrystalV2::Compiler::Frontend::BoolNode
        lower_bool(ctx, node)
      when CrystalV2::Compiler::Frontend::NilNode
        lower_nil(ctx, node)
      when CrystalV2::Compiler::Frontend::SymbolNode
        lower_symbol(ctx, node)
        # ═══════════════════════════════════════════════════════════════════
        # VARIABLES
        # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::IdentifierNode
        lower_identifier(ctx, node)
      when CrystalV2::Compiler::Frontend::InstanceVarNode
        lower_instance_var(ctx, node)
      when CrystalV2::Compiler::Frontend::ClassVarNode
        lower_class_var(ctx, node)
      when CrystalV2::Compiler::Frontend::SelfNode
        lower_self(ctx, node)
      when CrystalV2::Compiler::Frontend::ImplicitObjNode
        # Implicit object (like .foo) is treated as self in current context
        lower_self_implicit(ctx, node)
      when CrystalV2::Compiler::Frontend::SuperNode
        lower_super(ctx, node)
      when CrystalV2::Compiler::Frontend::PreviousDefNode
        lower_previous_def(ctx, node)
      when CrystalV2::Compiler::Frontend::GlobalNode
        lower_global(ctx, node)
        # ═══════════════════════════════════════════════════════════════════
        # OPERATIONS
        # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::BinaryNode
        lower_binary(ctx, node)
      when CrystalV2::Compiler::Frontend::UnaryNode
        lower_unary(ctx, node)
        # ═══════════════════════════════════════════════════════════════════
        # CONTROL FLOW
        # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::IfNode
        lower_if(ctx, node)
      when CrystalV2::Compiler::Frontend::UnlessNode
        lower_unless(ctx, node)
      when CrystalV2::Compiler::Frontend::WhileNode
        lower_while(ctx, node)
      when CrystalV2::Compiler::Frontend::UntilNode
        lower_until(ctx, node)
      when CrystalV2::Compiler::Frontend::TernaryNode
        lower_ternary(ctx, node)
      when CrystalV2::Compiler::Frontend::CaseNode
        lower_case(ctx, node)
        # ═══════════════════════════════════════════════════════════════════
        # FUNCTION-RELATED
        # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::ReturnNode
        lower_return(ctx, node)
      when CrystalV2::Compiler::Frontend::YieldNode
        if blk = @inline_yield_block_stack.last?
          inline_block_body(ctx, node, blk)
        else
          lower_yield(ctx, node)
        end
      when CrystalV2::Compiler::Frontend::BreakNode
        lower_break(ctx, node)
      when CrystalV2::Compiler::Frontend::NextNode
        lower_next(ctx, node)
      when CrystalV2::Compiler::Frontend::BeginNode
        lower_begin(ctx, node)
      when CrystalV2::Compiler::Frontend::RaiseNode
        lower_raise(ctx, node)
        # ═══════════════════════════════════════════════════════════════════
        # CALLS
        # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::CallNode
        lower_call(ctx, node)
      when CrystalV2::Compiler::Frontend::IndexNode
        lower_index(ctx, node)
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        if env_get("DEBUG_IVAR_ACCESS")
          STDERR.puts "[IVAR_ACCESS_NODE] member=#{String.new(node.member)}"
        end
        lower_member_access(ctx, node)

        # ═══════════════════════════════════════════════════════════════════
        # ASSIGNMENT
        # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::AssignNode
        lower_assign(ctx, node)
      when CrystalV2::Compiler::Frontend::MultipleAssignNode
        lower_multiple_assign(ctx, node)
        # ═══════════════════════════════════════════════════════════════════
        # CLOSURES
        # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::BlockNode
        lower_block(ctx, node)
      when CrystalV2::Compiler::Frontend::ProcLiteralNode
        lower_proc_literal(ctx, node)
        # ═══════════════════════════════════════════════════════════════════
        # COLLECTIONS
        # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        lower_array_literal(ctx, node)
      when CrystalV2::Compiler::Frontend::HashLiteralNode
        lower_hash_literal(ctx, node)
      when CrystalV2::Compiler::Frontend::TupleLiteralNode
        lower_tuple_literal(ctx, node)
      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        lower_named_tuple_literal(ctx, node)
      when CrystalV2::Compiler::Frontend::RangeNode
        lower_range(ctx, node)
        # ═══════════════════════════════════════════════════════════════════
        # TYPE OPERATIONS
        # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::AsNode
        lower_as(ctx, node)
      when CrystalV2::Compiler::Frontend::AsQuestionNode
        lower_as_question(ctx, node)
      when CrystalV2::Compiler::Frontend::IsANode
        lower_is_a(ctx, node)
      when CrystalV2::Compiler::Frontend::RespondsToNode
        lower_responds_to(ctx, node)
        # ═══════════════════════════════════════════════════════════════════
        # MISC
        # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::GroupingNode
        # Just unwrap grouping
        lower_expr(ctx, node.expression)
      when CrystalV2::Compiler::Frontend::SplatNode
        # Lower the inner expression (splat semantics handled at call site)
        lower_expr(ctx, node.expr)
      when CrystalV2::Compiler::Frontend::PathNode
        lower_path(ctx, node)
      when CrystalV2::Compiler::Frontend::GenericNode
        # Generic type like Array(Int32) - lower as type reference for use as receiver
        lower_generic_type_ref(ctx, node)
      when CrystalV2::Compiler::Frontend::UninitializedNode
        # uninitialized Type - returns undefined value of given type
        lower_uninitialized(ctx, node)
      when CrystalV2::Compiler::Frontend::TypeDeclarationNode
        # x : Type = value - local variable with type annotation
        lower_type_declaration(ctx, node)
      when CrystalV2::Compiler::Frontend::LoopNode
        # loop do ... end - infinite loop (exits via break)
        lower_loop(ctx, node)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        # Handle macro conditionals like {% if flag?(:darwin) %}
        lower_macro_if(ctx, node)
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        # Handle macro literals with text pieces that may contain {% if flag?() %}
        lower_macro_literal(ctx, node)
      when CrystalV2::Compiler::Frontend::MacroVarNode
        # Macro vars are compile-time only; return nil at runtime.
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::MacroForNode
        lower_macro_for(ctx, node)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        lower_macro_expression(ctx, node)
      when CrystalV2::Compiler::Frontend::PointerofNode
        lower_pointerof(ctx, node)
      when CrystalV2::Compiler::Frontend::AnnotationNode
        # Annotations like @[Link("c")] - store for later processing
        # For now, just return nil (annotations are metadata, not values)
        remember_effect_annotation(node, @arena)
        lower_annotation(ctx, node)
      when CrystalV2::Compiler::Frontend::LibNode
        # lib LibC ... end - C library bindings
        lower_lib(ctx, node)
      when CrystalV2::Compiler::Frontend::FunNode
        # fun malloc(size : Int64) : Void* - external C function
        lower_fun(ctx, node)
      when CrystalV2::Compiler::Frontend::DefNode
        # Top-level method definition
        lower_top_level_def(ctx, node)
      when CrystalV2::Compiler::Frontend::TypeofNode
        # typeof(x) - returns type at compile time, for runtime just return nil
        lower_typeof(ctx, node)
      when CrystalV2::Compiler::Frontend::SizeofNode
        # sizeof(T) - returns size of type
        lower_sizeof(ctx, node)
      when CrystalV2::Compiler::Frontend::OffsetofNode
        # offsetof(T, @field) - returns field offset
        lower_offsetof(ctx, node)
      when CrystalV2::Compiler::Frontend::MacroDefNode
        # Macro definitions - skip at runtime, just return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::ModuleNode
        # Module definitions inside expressions - skip, just return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::ClassNode
        # Class definitions inside expressions - skip, just return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::RequireNode
        # Require directives - already processed, return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::GlobalVarDeclNode
        # Global variable declaration ($name : Type) - declaration only, return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::AnnotationDefNode
        # Annotation definition (annotation Foo) - declaration only, return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::ConstantNode
        # Constant definition (FOO = value) - evaluate and return the value
        const_name = String.new(node.name)
        full_name = constant_full_name(@current_class, const_name)
        value_id = lower_expr(ctx, node.value)
        value_type = ctx.type_of(value_id)
        @constant_defs.add(full_name)
        if value_type != TypeRef::VOID
          if existing = @constant_types[full_name]?
            @constant_types[full_name] = value_type if existing == TypeRef::VOID
          else
            @constant_types[full_name] = value_type
          end
        end
        owner, short_name = constant_storage_info(full_name)
        const_set = ClassVarSet.new(ctx.next_id, value_type, owner, short_name, value_id)
        ctx.emit(const_set)
        ctx.register_type(const_set.id, value_type)
        value_id
      when CrystalV2::Compiler::Frontend::VisibilityModifierNode
        # Visibility modifier (private, protected) - just lower the target expression
        lower_expr(ctx, node.expression)
      when CrystalV2::Compiler::Frontend::OutNode
        # out x - creates a pointer to a local variable for C functions
        # The variable name is in node.identifier
        var_name = String.new(node.identifier)
        # Create the local variable if it doesn't exist
        var_id = ctx.lookup_local(var_name)
        if var_id.nil?
          # Create uninitialized variable
          alloc = Allocate.new(ctx.next_id, TypeRef::POINTER, [] of ValueId, true)
          ctx.emit(alloc)
          record_allocation_location(ctx, alloc.id, @arena, node)
          ctx.register_local(var_name, alloc.id)
          var_id = alloc.id
        end
        # Get address of the variable
        ptr = AddressOf.new(ctx.next_id, TypeRef::POINTER, var_id)
        ctx.emit(ptr)
        ptr.id
      when CrystalV2::Compiler::Frontend::EnumNode
        # Enum declarations are processed during registration phase
        # Just return nil literal during lowering
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::GetterNode,
           CrystalV2::Compiler::Frontend::SetterNode,
           CrystalV2::Compiler::Frontend::PropertyNode
        # Accessor declarations are processed during class registration/generation
        # If encountered during expression lowering, return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::SpawnNode
        lower_spawn(ctx, node)
      else
        raise LoweringError.new("Unsupported AST node type: #{node.class}", node)
      end
    end

    # ═══════════════════════════════════════════════════════════════════════
    # LITERAL LOWERING
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_number(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::NumberNode) : ValueId
      type = case node.kind
             when .i8?   then TypeRef::INT8
             when .i16?  then TypeRef::INT16
             when .i32?  then TypeRef::INT32
             when .i64?  then TypeRef::INT64
             when .i128? then TypeRef::INT128
             when .u8?   then TypeRef::UINT8
             when .u16?  then TypeRef::UINT16
             when .u32?  then TypeRef::UINT32
             when .u64?  then TypeRef::UINT64
             when .u128? then TypeRef::UINT128
             when .f32?  then TypeRef::FLOAT32
             when .f64?  then TypeRef::FLOAT64
             else             TypeRef::INT32
             end

      # Remove underscores and type suffixes (42_000i64 -> 42000)
      value_str = String.new(node.value).gsub('_', "")
      # Strip type suffix (i8, i16, i32, i64, i128, u8, u16, u32, u64, u128, f32, f64)
      value_str = value_str.gsub(/[iuf]\d+$/, "")

      # Handle empty string case (malformed number)
      if value_str.empty?
        value = 0_i64
      elsif node.kind.f32? || node.kind.f64?
        value = value_str.to_f64
      else
        # Handle hex (0x), binary (0b), and octal (0o)
        # Use UInt64 for parsing to handle large hex values, then cast to Int64
        raw = if value_str.starts_with?("0x") || value_str.starts_with?("0X")
                digits = value_str[2..]
                digits.empty? ? 0_u64 : digits.to_u64(16)
              elsif value_str.starts_with?("0b") || value_str.starts_with?("0B")
                digits = value_str[2..]
                digits.empty? ? 0_u64 : digits.to_u64(2)
              elsif value_str.starts_with?("0o") || value_str.starts_with?("0O")
                digits = value_str[2..]
                digits.empty? ? 0_u64 : digits.to_u64(8)
              else
                # Try to parse as UInt64 first (handles numbers > Int64::MAX)
                value_str.to_u64? || value_str.to_i64?.try(&.to_u64!) || 0_u64
              end
        value = raw.to_i64! # Bitcast to Int64
      end

      lit = Literal.new(ctx.next_id, type, value)
      ctx.emit(lit)
      lit.id
    end

    private def lower_string(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::StringNode) : ValueId
      str = String.new(node.value)
      lit = Literal.new(ctx.next_id, TypeRef::STRING, str)
      ctx.emit(lit)
      lit.id
    end

    private def lower_regex(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::RegexNode) : ValueId
      # Regex literal /pattern/
      # For now, store as a string pattern - full regex support requires PCRE bindings
      pattern = String.new(node.pattern)
      regex_type = ctx.get_type("Regex")
      lit = Literal.new(ctx.next_id, regex_type, pattern)
      ctx.emit(lit)
      lit.id
    end

    private def lower_type_declaration(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::TypeDeclarationNode) : ValueId
      # x : Type = value - local variable declaration with type annotation
      var_name = String.new(node.name)
      type_name = String.new(node.declared_type)
      type_ref = type_ref_for_name(type_name)
      if DebugHooks::ENABLED && env_get("CRYSTAL_V2_DEBUG_UNINITIALIZED_REF")
        debug_hook("uninitialized.type_ref", "type=#{type_name} id=#{type_ref.id} resolved=#{get_type_name_from_ref(type_ref)}")
      end

      if value_id = node.value
        # Has initial value: x : Type = value
        value = lower_expr(ctx, value_id)
        # Coerce to declared type (e.g., wrap Int32 into Nil | Int32 for Int32?)
        value = coerce_value_to_type(ctx, value, type_ref)
        # Register as local variable
        ctx.register_local(var_name, value)
        value_type = ctx.type_of(value)
        # If the declared type is module-like and the initializer is concrete,
        # keep the concrete type for call resolution to avoid includer heuristics.
        if module_like_type_name?(type_name) && value_type != TypeRef::VOID
          ctx.register_type(value, value_type)
          update_typeof_local(var_name, value_type)
          if concrete_name = concrete_type_name_for(value_type)
            update_typeof_local_name(var_name, concrete_name)
          else
            update_typeof_local_name(var_name, type_name)
          end
        else
          ctx.register_type(value, type_ref)
          update_typeof_local(var_name, type_ref)
          update_typeof_local_name(var_name, type_name)
        end
        value
      else
        # No initial value: x : Type (uninitialized)
        # Create undefined value for the type
        undefined_value : Int64 | Float64 | String | Bool | Nil = case type_ref
        when TypeRef::BOOL                      then false
        when TypeRef::FLOAT32, TypeRef::FLOAT64 then 0.0
        when TypeRef::STRING, TypeRef::POINTER  then nil
        else                                         0_i64
        end

        lit = Literal.new(ctx.next_id, type_ref, undefined_value)
        ctx.emit(lit)
        ctx.register_local(var_name, lit.id)
        ctx.register_type(lit.id, type_ref)
        update_typeof_local(var_name, type_ref)
        update_typeof_local_name(var_name, type_name)
        lit.id
      end
    end

    private def lower_uninitialized(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::UninitializedNode) : ValueId
      # uninitialized Type - returns undefined value of given type
      type_node = @arena[node.type]
      type_name = stringify_type_expr(node.type)
      if type_name && type_name.includes?("Unknown")
        if type_node.is_a?(CrystalV2::Compiler::Frontend::IndexNode)
          base_node = @arena[type_node.object]
          base_name = case base_node
                      when CrystalV2::Compiler::Frontend::IdentifierNode
                        String.new(base_node.name)
                      when CrystalV2::Compiler::Frontend::ConstantNode
                        String.new(base_node.name)
                      when CrystalV2::Compiler::Frontend::PathNode
                        collect_path_string(base_node)
                      else
                        nil
                      end
          if base_name
            size_str = "0"
            if type_node.indexes.size > 0
              size_node = @arena[type_node.indexes[0]]
              size_str = String.new(size_node.value) if size_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
            end
            type_name = "StaticArray(#{base_name}, #{size_str})"
          end
        end
      end
      debug_hook("uninitialized.type", "type=#{type_name} node=#{type_node.class.name}")
      type_name ||= case type_node
                    when CrystalV2::Compiler::Frontend::IdentifierNode
                      String.new(type_node.name)
                    when CrystalV2::Compiler::Frontend::ConstantNode
                      String.new(type_node.name)
                    when CrystalV2::Compiler::Frontend::PathNode
                      resolve_path_string_in_context(collect_path_string(type_node))
                    when CrystalV2::Compiler::Frontend::GenericNode
                      # Generic type - extract base and type args
                      base = @arena[type_node.base_type]
                      base_name = case base
                                  when CrystalV2::Compiler::Frontend::IdentifierNode
                                    String.new(base.name)
                                  when CrystalV2::Compiler::Frontend::ConstantNode
                                    String.new(base.name)
                                  when CrystalV2::Compiler::Frontend::PathNode
                                    resolve_path_string_in_context(collect_path_string(base))
                                  else
                                    "Unknown"
                                  end
                      type_args = type_node.type_args.map do |arg_id|
                        arg = @arena[arg_id]
                        case arg
                        when CrystalV2::Compiler::Frontend::IdentifierNode
                          String.new(arg.name)
                        when CrystalV2::Compiler::Frontend::ConstantNode
                          String.new(arg.name)
                        when CrystalV2::Compiler::Frontend::PathNode
                          resolve_path_string_in_context(collect_path_string(arg))
                        else
                          "Unknown"
                        end
                      end
                      "#{base_name}(#{type_args.join(", ")})"
                    when CrystalV2::Compiler::Frontend::IndexNode
                      # Static array type: UInt8[256] -> StaticArray(UInt8, 256)
                      base = @arena[type_node.object]
                      base_name = case base
                                  when CrystalV2::Compiler::Frontend::IdentifierNode
                                    String.new(base.name)
                                  when CrystalV2::Compiler::Frontend::ConstantNode
                                    String.new(base.name)
                                  when CrystalV2::Compiler::Frontend::PathNode
                                    resolve_path_string_in_context(collect_path_string(base))
                                  else
                                    "Unknown"
                                  end
                      # Get size from first index
                      if type_node.indexes.size > 0
                        size_node = @arena[type_node.indexes[0]]
                        size_str = case size_node
                                   when CrystalV2::Compiler::Frontend::NumberNode
                                     String.new(size_node.value)
                                   else
                                     "0"
                                   end
                        "StaticArray(#{base_name}, #{size_str})"
                      else
                        "StaticArray(#{base_name}, 0)"
                      end
                    else
                      "Unknown"
                    end

      type_ref = type_ref_for_name(type_name)

      # For non-primitive types (C structs, lib types), create an Allocate
      # so that pointerof(x) can return the actual storage address.
      # Primitive types use a Literal since they don't need addressable storage.
      is_primitive = case type_ref
                     when TypeRef::BOOL, TypeRef::INT8, TypeRef::INT16, TypeRef::INT32,
                          TypeRef::INT64, TypeRef::INT128, TypeRef::UINT8, TypeRef::UINT16,
                          TypeRef::UINT32, TypeRef::UINT64, TypeRef::UINT128,
                          TypeRef::FLOAT32, TypeRef::FLOAT64, TypeRef::CHAR,
                          TypeRef::STRING, TypeRef::POINTER, TypeRef::NIL, TypeRef::VOID,
                          TypeRef::SYMBOL
                       true
                     else
                       false
                     end

      if !is_primitive
        # Non-primitive: allocate storage on stack (value type = struct semantics)
        alloc = Allocate.new(ctx.next_id, type_ref, [] of ValueId, true)
        ctx.emit(alloc)
        record_allocation_location(ctx, alloc.id, @arena, node)
        ctx.register_type(alloc.id, type_ref)
        return alloc.id
      end

      # Primitive: use literal (value doesn't matter, it's uninitialized)
      undefined_value : Int64 | Float64 | String | Bool | Nil = case type_ref
      when TypeRef::BOOL                      then false
      when TypeRef::FLOAT32, TypeRef::FLOAT64 then 0.0
      when TypeRef::STRING, TypeRef::POINTER  then nil
      else                                         0_i64
      end

      lit = Literal.new(ctx.next_id, type_ref, undefined_value)
      ctx.emit(lit)
      ctx.register_type(lit.id, type_ref)
      lit.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # LIB BINDINGS (C FFI)
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_annotation(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::AnnotationNode) : ValueId
      # Annotations like @[Link("c")] are metadata
      # Store Link annotations for the linker
      register_link_libraries_from_annotation(node)

      # Annotations don't produce values
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def register_link_libraries_from_annotation(node : CrystalV2::Compiler::Frontend::AnnotationNode) : Nil
      # node.name is an ExprId pointing to IdentifierNode or PathNode
      annotation_name = resolve_annotation_name(node.name)
      return unless annotation_name == "Link"

      # Positional args: @[Link("c")]
      node.args.each do |arg_id|
        arg_node = @arena[arg_id]
        if arg_node.is_a?(CrystalV2::Compiler::Frontend::StringNode)
          lib_name = String.new(arg_node.value)
          @module.add_link_library(lib_name)
        end
      end

      # Named args: @[Link(framework: "Cocoa")] or @[Link(pkg_config: "libfoo")]
      if named_args = node.named_args
        named_args.each do |named_arg|
          value_node = @arena[named_arg.value]
          if value_node.is_a?(CrystalV2::Compiler::Frontend::StringNode)
            named_lib_name = String.new(value_node.value)
            named_key = String.new(named_arg.name)
            prefix = case named_key
                     when "pkg_config" then "pkg_config:"
                     when "framework"  then "framework:"
                     when "dll"        then "dll:"
                     else                   "#{named_key}:"
                     end
            @module.add_link_library("#{prefix}#{named_lib_name}")
          end
        end
      end
    end

    private def lower_lib(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::LibNode) : ValueId
      # lib LibC ... end - C library bindings
      # Process the body to register external functions
      lib_name = String.new(node.name)

      if body = node.body
        # Pass 1: process annotations and register lib-local types before externs.
        body.each do |expr_id|
          body_node = @arena[expr_id]
          case body_node
          when CrystalV2::Compiler::Frontend::AnnotationNode
            # Process annotations within lib (e.g., @[Link])
            lower_annotation(ctx, body_node)
          when CrystalV2::Compiler::Frontend::AliasNode
            # type aliases within lib - register for later resolution
            alias_name = String.new(body_node.name)
            old_class = @current_class
            @current_class = lib_name
            target_name = resolve_alias_target(String.new(body_node.value), lib_name)
            @current_class = old_class
            full_alias_name = "#{lib_name}::#{alias_name}"
            register_type_alias(full_alias_name, target_name)
          when CrystalV2::Compiler::Frontend::EnumNode
            # Enums within lib - register with lib prefix
            enum_name = String.new(body_node.name)
            full_enum_name = "#{lib_name}::#{enum_name}"
            register_enum_with_name(body_node, full_enum_name)
          when CrystalV2::Compiler::Frontend::ClassNode
            # Struct/union within lib are parsed as ClassNode with flags.
            struct_name = String.new(body_node.name)
            full_struct_name = "#{lib_name}::#{struct_name}"
            @lib_structs.add(full_struct_name)
            register_class_with_name(body_node, full_struct_name)
            lower_class_with_name(body_node, full_struct_name)
          end
        end

        # Pass 2: register externs after types are available.
        body.each do |expr_id|
          body_node = @arena[expr_id]
          case body_node
          when CrystalV2::Compiler::Frontend::FunNode
            # Register external function
            register_extern_fun(lib_name, body_node)
          when CrystalV2::Compiler::Frontend::GlobalVarDeclNode
            raw_name = String.new(body_node.name)
            var_name = raw_name.lstrip('$')
            type_name = String.new(body_node.type)
            register_extern_global(lib_name, var_name, type_name)
          when CrystalV2::Compiler::Frontend::AssignNode
            target_node = @arena[body_node.target]
            value_node = @arena[body_node.value]
            if target_node.is_a?(CrystalV2::Compiler::Frontend::GlobalNode) &&
               value_node.is_a?(CrystalV2::Compiler::Frontend::TypeDeclarationNode)
              raw_name = String.new(target_node.name)
              var_name = raw_name.lstrip('$')
              real_name = String.new(value_node.name)
              type_name = String.new(value_node.declared_type)
              register_extern_global(lib_name, var_name, type_name, real_name)
            else
              lower_node(ctx, body_node)
            end
          when CrystalV2::Compiler::Frontend::AnnotationNode,
               CrystalV2::Compiler::Frontend::AliasNode,
               CrystalV2::Compiler::Frontend::EnumNode,
               CrystalV2::Compiler::Frontend::ClassNode
            # Already handled in pass 1.
          else
            # Other declarations - process recursively
            lower_node(ctx, body_node)
          end
        end
      end

      # Lib declarations don't produce values
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_fun(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::FunNode) : ValueId
      # fun malloc(size : Int64) : Void* - external C function
      # Register in current lib context (or global if not in lib)
      register_extern_fun(nil, node)

      # Fun declarations don't produce values
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def register_extern_fun(lib_name : String?, node : CrystalV2::Compiler::Frontend::FunNode)
      fun_name = String.new(node.name)
      real_name = node.real_name ? String.new(node.real_name.not_nil!) : fun_name

      # Top-level `fun main` in the stdlib is a C-ABI entrypoint in the real compiler.
      # Our bootstrap uses a synthetic wrapper main, so skip registering it as an extern
      # to avoid LLVM redefinition (declare + define).
      if lib_name.nil? && fun_name == "main"
        return
      end

      old_class = @current_class
      @current_class = lib_name if lib_name
      # Build parameter types
      param_types = [] of TypeRef
      return_type = TypeRef::VOID
      begin
        if params = node.params
          params.each do |param|
            if type_ann = param.type_annotation
              type_name = String.new(type_ann)
              param_types << type_ref_for_c_type(type_name)
            else
              param_types << TypeRef::POINTER # Default to pointer for untyped params
            end
          end
        end

        # Return type
        return_type = if ret = node.return_type
                        type_ref_for_c_type(String.new(ret))
                      else
                        TypeRef::VOID
                      end
      ensure
        @current_class = old_class
      end

      if env_get("DEBUG_LIBC_EXTERN") && lib_name == "LibC" && fun_name == "dladdr"
        param_names = param_types.map { |t| get_type_name_from_ref(t) }.join(", ")
        STDERR.puts "[DEBUG_LIBC_EXTERN] #{lib_name}.#{fun_name} params=[#{param_names}] return=#{get_type_name_from_ref(return_type)}"
      end

      # Register the external function
      @module.add_extern_function(ExternFunction.new(
        name: fun_name,
        real_name: real_name,
        lib_name: lib_name,
        param_types: param_types,
        return_type: return_type,
        varargs: node.varargs
      ))

      if env_get("DEBUG_LIB_REG") && lib_name == "LibUnwind" && fun_name == "raise_exception"
        STDERR.puts "[LIB_REG] extern lib=#{lib_name} fun=#{fun_name} real=#{real_name}"
      end
    end

    private def register_extern_global(lib_name : String, var_name : String, type_name : String, real_name : String? = nil)
      real_name ||= var_name
      old_class = @current_class
      @current_class = lib_name
      type_ref = type_ref_for_c_type(type_name)
      @current_class = old_class
      @module.add_extern_global(ExternGlobal.new(
        name: var_name,
        real_name: real_name,
        lib_name: lib_name,
        type: type_ref
      ))
    end

    # Convert Crystal type notation to C-compatible TypeRef
    private def type_ref_for_c_type(type_name : String) : TypeRef
      type_name = type_name.strip

      if type_name.ends_with?('*')
        base_name = type_name
        star_count = 0
        while base_name.ends_with?('*')
          base_name = base_name[0...-1]
          star_count += 1
        end
        base_name = base_name.strip
        base_ref = type_ref_for_c_type(base_name)
        pointer_name = get_type_name_from_ref(base_ref)
        star_count.times { pointer_name = "Pointer(#{pointer_name})" }
        return type_ref_for_name(pointer_name)
      end

      if type_name.starts_with?("Pointer(")
        return type_ref_for_name(type_name)
      end

      case type_name
      when "Void"
        TypeRef::VOID
      when "Int8", "SChar"
        TypeRef::INT8
      when "UInt8", "Char", "UChar"
        TypeRef::UINT8
      when "Int16", "Short"
        TypeRef::INT16
      when "UInt16", "UShort"
        TypeRef::UINT16
      when "Int32", "Int"
        TypeRef::INT32
      when "UInt32", "UInt"
        TypeRef::UINT32
      when "Int64", "Long", "LongLong", "SSizeT", "OffT", "PtrDiffT"
        TypeRef::INT64
      when "UInt64", "ULong", "ULongLong", "SizeT"
        TypeRef::UINT64
      when "Float32", "Float"
        TypeRef::FLOAT32
      when "Float64", "Double"
        TypeRef::FLOAT64
      when "Bool"
        TypeRef::BOOL
      when "NoReturn"
        TypeRef::VOID # NoReturn functions still have void return in LLVM
      when "Pointer"
        TypeRef::POINTER
      else
        resolved = type_ref_for_name(type_name)
        resolved == TypeRef::VOID ? TypeRef::POINTER : resolved
      end
    end

    # ═══════════════════════════════════════════════════════════════════════
    # MACRO EXPANSION
    # ═══════════════════════════════════════════════════════════════════════

    # Compile-time flags for platform detection
    COMPILE_FLAGS = Set{
      # Platform
      "darwin", "unix", "linux", "freebsd", "openbsd", "netbsd", "dragonfly",
      "win32", "windows", "android", "wasi",
      # Architecture
      "x86_64", "aarch64", "arm64", "i386", "arm",
      # Build config
      "release", "debug",
      # Crystal-specific
      "preview_mt",
    }

    # Evaluate a macro flag condition at compile time
    private def evaluate_macro_flag(flag_name : String) : Bool
      # Remove leading/trailing quotes and colons
      clean_name = flag_name.strip.gsub(/^[:"']|["']$/, "")
      # Check against known compile flags - use macOS defaults for now
      case clean_name
      when "darwin", "unix"
        true # macOS is darwin and unix
      when "kqueue"
        true # macOS uses kqueue for event loop
      when "linux", "win32", "windows", "android", "wasi", "epoll", "libevent", "openbsd", "freebsd", "netbsd", "dragonfly"
        false # Not linux/windows/android/bsd
      when "x86_64", "aarch64", "arm64"
        # Assume arm64 for modern Macs
        clean_name == "aarch64" || clean_name == "arm64"
      when "release"
        true # Assume release build
      when "execution_context", "preview_mt"
        false # Not using execution context by default
      else
        # Check using macro-style syntax flag?("evloop=kqueue")
        if clean_name.starts_with?("evloop=")
          clean_name == "evloop=kqueue" # macOS uses kqueue
        else
          COMPILE_FLAGS.includes?(clean_name)
        end
      end
    end

    # Evaluate LibC.has_constant?(:NAME) or similar
    private def evaluate_has_constant(lib_name : String, const_name : String) : Bool
      # Remove leading colon if present
      clean_name = const_name.lstrip(':')

      # First check if it's defined in @constant_defs (parsed from lib declarations)
      full_name = "#{lib_name}::#{clean_name}"
      return true if @constant_defs.includes?(full_name)

      # Platform-specific constants for LibC
      if lib_name == "LibC"
        is_darwin = evaluate_macro_flag("darwin")
        is_linux = evaluate_macro_flag("linux")
        is_bsd = evaluate_macro_flag("freebsd") || evaluate_macro_flag("openbsd") || evaluate_macro_flag("netbsd") || evaluate_macro_flag("dragonfly")

        case clean_name
        # kqueue constants (Darwin, BSD)
        when "EVFILT_USER", "NOTE_TRIGGER", "EV_UDATA_SPECIFIC"
          is_darwin || is_bsd
        when "EVFILT_READ", "EVFILT_WRITE", "EVFILT_TIMER", "EV_ADD", "EV_DELETE", "EV_CLEAR", "EV_EOF", "EV_ERROR"
          is_darwin || is_bsd
          # epoll constants (Linux)
        when "EPOLL_CTL_ADD", "EPOLL_CTL_DEL", "EPOLL_CTL_MOD", "EPOLLIN", "EPOLLOUT", "EPOLLERR", "EPOLLHUP"
          is_linux
          # io_uring constants (Linux 5.1+)
        when "IOURING_SETUP_SQPOLL", "IORING_ENTER_GETEVENTS"
          is_linux
          # Common POSIX constants
        when "CLOCK_MONOTONIC", "TIOCGWINSZ", "TIOCSCTTY", "O_CLOEXEC", "O_DIRECTORY", "O_NONBLOCK"
          is_darwin || is_linux || is_bsd
        else
          false
        end
      else
        false
      end
    end

    private def evaluate_has_method(type_name : String, method_name : String) : Bool
      # Check extern functions registered from lib declarations
      if @module.get_extern_function(type_name, method_name)
        return true
      end

      # Check extern globals (C global variables accessed as methods)
      if @module.get_extern_global(type_name, method_name)
        return true
      end

      false
    end

    private def merge_macro_or(left : Bool?, right : Bool?) : Bool?
      return true if left == true || right == true
      return false if left == false && right == false
      nil
    end

    private def merge_macro_and(left : Bool?, right : Bool?) : Bool?
      return false if left == false || right == false
      return true if left == true && right == true
      nil
    end

    # Try to evaluate a macro condition expression at compile time
    # Returns true/false if evaluable, nil if not
    private def try_evaluate_macro_condition(condition_id : ExprId) : Bool?
      cond_node = @arena[condition_id]
      case cond_node
      when CrystalV2::Compiler::Frontend::BoolNode
        return cond_node.value
      when CrystalV2::Compiler::Frontend::NilNode
        return false
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        return try_evaluate_macro_condition(cond_node.expression)
      when CrystalV2::Compiler::Frontend::GroupingNode
        return try_evaluate_macro_condition(cond_node.expression)
      when CrystalV2::Compiler::Frontend::CallNode
        # Check for flag?(:name) or flag?("name")
        callee = @arena[cond_node.callee]
        if callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          callee_name = String.new(callee.name)
          if callee_name == "flag?"
            if cond_node.args.size >= 1
              arg_node = @arena[cond_node.args[0]]
              flag_name = case arg_node
                          when CrystalV2::Compiler::Frontend::SymbolNode
                            String.new(arg_node.name)
                          when CrystalV2::Compiler::Frontend::StringNode
                            String.new(arg_node.value)
                          else
                            nil
                          end
              if flag_name
                return evaluate_macro_flag(flag_name)
              end
            end
          end
        elsif callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          # Check for LibC.has_constant?(:name) or Type.has_constant?(:name)
          member_name = String.new(callee.member)
          if member_name == "has_constant?" || member_name == "has_method?"
            obj_node = @arena[callee.object]
            lib_name = case obj_node
                       when CrystalV2::Compiler::Frontend::ConstantNode
                         String.new(obj_node.name)
                       when CrystalV2::Compiler::Frontend::IdentifierNode
                         String.new(obj_node.name)
                       when CrystalV2::Compiler::Frontend::PathNode
                         collect_path_string(obj_node)
                       else
                         nil
                       end
            if lib_name && cond_node.args.size >= 1
              arg_node = @arena[cond_node.args[0]]
              name_arg = case arg_node
                         when CrystalV2::Compiler::Frontend::SymbolNode
                           String.new(arg_node.name)
                         when CrystalV2::Compiler::Frontend::StringNode
                           String.new(arg_node.value)
                         else
                           nil
                         end
              if name_arg
                if member_name == "has_constant?"
                  return evaluate_has_constant(lib_name, name_arg)
                else
                  return evaluate_has_method(lib_name, name_arg)
                end
              end
            end
          end
        end
      when CrystalV2::Compiler::Frontend::UnaryNode
        # Handle !flag?(:name)
        op_str = String.new(cond_node.operator)
        if op_str == "!"
          inner = try_evaluate_macro_condition(cond_node.operand)
          return inner.nil? ? nil : !inner
        end
      when CrystalV2::Compiler::Frontend::BinaryNode
        # Handle flag?(:a) || flag?(:b) or flag?(:a) && flag?(:b)
        left = try_evaluate_macro_condition(cond_node.left)
        right = try_evaluate_macro_condition(cond_node.right)
        op_str = String.new(cond_node.operator)
        case op_str
        when "||"
          return merge_macro_or(left, right)
        when "&&"
          return merge_macro_and(left, right)
        when "==", "!="
          # Handle type parameter comparison: {% if F == Float32 %}
          left_type = macro_condition_type_name(cond_node.left)
          right_type = macro_condition_type_name(cond_node.right)
          if env_has?("DEBUG_MACRO_TYPE_CMP")
            method_name = @current_method || "(unknown)"
            if @current_class.try(&.includes?("Slice")) && method_name.includes?("hash")
              STDERR.puts "[MACRO_TYPE_CMP_SLICE] class=#{@current_class} method=#{method_name} left=#{left_type.inspect}, right=#{right_type.inspect}, op=#{op_str}, type_param_map=#{@type_param_map}"
            end
            STDERR.puts "[MACRO_TYPE_CMP] class=#{@current_class} method=#{@current_method} left=#{left_type.inspect}, right=#{right_type.inspect}, op=#{op_str}, type_param_map=#{@type_param_map}"
          end
          if left_type && right_type
            are_equal = left_type == right_type
            return op_str == "==" ? are_equal : !are_equal
          end
        when "<"
          # Handle subtype check: {% if K < Number::Primitive %}
          left_type = macro_condition_type_name(cond_node.left)
          right_type = macro_condition_type_name(cond_node.right)
          if left_type && right_type
            return macro_is_subtype(left_type, right_type)
          end
        end
      end
      nil # Can't evaluate
    end

    # Extract type name from macro condition expression, with type param substitution.
    # Used for evaluating {% if F == Float32 %} where F is a type parameter.
    private def macro_condition_type_name(expr_id : ExprId) : String?
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        macro_condition_type_name(node.expression)
      when CrystalV2::Compiler::Frontend::ConstantNode
        name = String.new(node.name)
        # Substitute type parameter if present
        @type_param_map[name]? || name
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(node.name)
        @type_param_map[name]? || name
      when CrystalV2::Compiler::Frontend::PathNode
        name = collect_path_string(node)
        # Check if any part is a type param
        @type_param_map[name]? || substitute_type_params_in_type_name(name)
      when CrystalV2::Compiler::Frontend::GenericNode
        base_name = macro_condition_type_name(node.base_type)
        return nil unless base_name
        type_arg_names = [] of String
        node.type_args.each do |arg_id|
          arg_name = macro_condition_type_name(arg_id)
          return nil unless arg_name
          type_arg_names << arg_name
        end
        "#{base_name}(#{type_arg_names.join(", ")})"
      else
        nil
      end
    end

    # Check if left_type is a subtype of right_type for macro {% if K < SomeType %}.
    # Walks class hierarchy via @class_info and @module.class_parents,
    # with hardcoded fallback for Crystal's core type hierarchy.
    private def macro_is_subtype(left_type : String, right_type : String) : Bool
      # Same type is not a strict subtype
      return false if left_type == right_type

      # Walk the class parent chain
      current = left_type
      visited = Set(String).new
      visited.add(current)
      100.times do
        parent = @class_info[current]?.try(&.parent_name) || @module.class_parents[current]?
        break unless parent
        break if visited.includes?(parent)
        return true if parent == right_type
        visited.add(parent)
        current = parent
      end

      # Hardcoded fallback for Crystal's core type hierarchy
      # (class_info may not have all types registered at macro evaluation time)
      number_primitives = {"Int8", "Int16", "Int32", "Int64", "Int128",
                           "UInt8", "UInt16", "UInt32", "UInt64", "UInt128",
                           "Float32", "Float64"}
      case right_type
      when "Number::Primitive"
        return number_primitives.includes?(left_type)
      when "Number"
        return number_primitives.includes?(left_type) ||
               left_type == "Number::Primitive" ||
               left_type == "BigInt" || left_type == "BigFloat" ||
               left_type == "BigDecimal" || left_type == "BigRational"
      when "Int"
        return {"Int8", "Int16", "Int32", "Int64", "Int128",
                "UInt8", "UInt16", "UInt32", "UInt64", "UInt128"}.includes?(left_type)
      when "Float"
        return left_type == "Float32" || left_type == "Float64"
      when "Enum"
        # Check if the type is registered as an enum in class_info
        if info = @class_info[left_type]?
          return info.parent_name == "Enum"
        end
        return false
      when "Value"
        return number_primitives.includes?(left_type) ||
               left_type == "Bool" || left_type == "Char" || left_type == "Symbol" ||
               left_type == "Nil" || left_type == "Pointer" || left_type == "StaticArray"
      when "Struct"
        return number_primitives.includes?(left_type) ||
               left_type == "Bool" || left_type == "Char" || left_type == "Symbol"
      when "Reference", "Object"
        return left_type == "String" || left_type == "Array" || left_type == "Hash" ||
               @class_info[left_type]?.try { |info|
                 p = info.parent_name
                 p && p != "Struct" && p != "Value" && p != "Enum"
               } || false
      end

      false
    end

    private def macro_for_iterable_values(iterable_id : ExprId) : Array(CrystalV2::Compiler::Semantic::MacroValue)?
      node = @arena[iterable_id]
      if node.is_a?(CrystalV2::Compiler::Frontend::MacroExpressionNode)
        return macro_for_iterable_values(node.expression)
      end

      if words = macro_word_list_from_source(node, 'w')
        return words.map { |word| CrystalV2::Compiler::Semantic::MacroStringValue.new(word).as(CrystalV2::Compiler::Semantic::MacroValue) }
      end
      if words = macro_word_list_from_source(node, 'i')
        return words.map { |word| CrystalV2::Compiler::Semantic::MacroSymbolValue.new(word).as(CrystalV2::Compiler::Semantic::MacroValue) }
      end

      case node
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        values = [] of CrystalV2::Compiler::Semantic::MacroValue
        node.elements.each do |elem_id|
          value = macro_value_for_expr(elem_id)
          return nil unless value
          values << value
        end
        values
      when CrystalV2::Compiler::Frontend::HashLiteralNode
        values = [] of CrystalV2::Compiler::Semantic::MacroValue
        node.entries.each do |entry|
          key_val = macro_value_for_expr(entry.key)
          value_val = macro_value_for_expr(entry.value)
          return nil unless key_val && value_val
          values << CrystalV2::Compiler::Semantic::MacroTupleValue.new([key_val, value_val])
        end
        values
      when CrystalV2::Compiler::Frontend::RangeNode
        start_val = macro_int_literal_for_expr(node.begin_expr)
        end_val = macro_int_literal_for_expr(node.end_expr)
        return nil unless start_val && end_val
        limit = CrystalV2::Compiler::Semantic::MacroExpander::MAX_RANGE_SIZE
        last_val = node.exclusive ? end_val - 1 : end_val
        count = last_val - start_val + 1
        return nil if count < 0 || count > limit
        values = [] of CrystalV2::Compiler::Semantic::MacroValue
        current = start_val
        while current <= last_val
          values << CrystalV2::Compiler::Semantic::MacroNumberValue.new(current)
          current += 1
        end
        values
      else
        nil
      end
    end

    private def assign_macro_iter_vars(
      vars : Hash(String, CrystalV2::Compiler::Semantic::MacroValue),
      iter_vars : Array(String),
      value : CrystalV2::Compiler::Semantic::MacroValue,
      idx : Int32,
    ) : Nil
      if iter_vars.size >= 2
        case value
        when CrystalV2::Compiler::Semantic::MacroTupleValue,
             CrystalV2::Compiler::Semantic::MacroArrayValue
          elements = value.elements
          iter_vars.each_with_index do |name, index|
            break if index >= elements.size
            vars[name] = elements[index]
          end
          return
        end
      end

      vars[iter_vars[0]] = value
      if idx_name = iter_vars[1]?
        vars[idx_name] = CrystalV2::Compiler::Semantic::MacroNumberValue.new(idx.to_i64)
      end
    end

    private def macro_word_list_from_source(
      node : CrystalV2::Compiler::Frontend::Node,
      kind : Char,
    ) : Array(String)?
      source = @sources_by_arena[@arena]?
      return nil unless source
      span = node.span
      length = span.end_offset - span.start_offset
      return nil if length <= 0 || span.start_offset < 0 || span.start_offset >= source.bytesize
      if span.start_offset + length > source.bytesize
        length = source.bytesize - span.start_offset
      end
      text = source.byte_slice(span.start_offset, length).strip
      if env_get("DEBUG_MACRO_WORD_LIST") && (text.includes?("%w") || text.includes?("%i"))
        STDERR.puts "[MACRO_WORD_LIST] text=#{text.inspect} span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column}"
      end
      return nil unless text.starts_with?("%#{kind}") && text.size >= 4
      open_delim = text[2]
      close_delim = macro_word_list_closer(open_delim)
      return nil unless close_delim
      return nil unless text.ends_with?(close_delim.to_s)
      inner = text[3, text.size - 4]
      inner.split(/\s+/).reject(&.empty?)
    end

    private def macro_word_list_closer(open_delim : Char) : Char?
      case open_delim
      when '(' then ')'
      when '[' then ']'
      when '{' then '}'
      when '<' then '>'
      when '|' then '|'
      else
        nil
      end
    end

    private def macro_value_for_expr(expr_id : ExprId) : CrystalV2::Compiler::Semantic::MacroValue?
      expr_node = @arena[expr_id]
      case expr_node
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        macro_value_for_expr(expr_node.expression)
      when CrystalV2::Compiler::Frontend::BoolNode
        CrystalV2::Compiler::Semantic::MacroBoolValue.new(expr_node.value)
      when CrystalV2::Compiler::Frontend::StringNode
        CrystalV2::Compiler::Semantic::MacroStringValue.new(String.new(expr_node.value))
      when CrystalV2::Compiler::Frontend::SymbolNode
        CrystalV2::Compiler::Semantic::MacroSymbolValue.new(String.new(expr_node.name))
      when CrystalV2::Compiler::Frontend::NumberNode
        num_str = strip_numeric_suffix(String.new(expr_node.value)).gsub("_", "")
        if expr_node.kind.in?(
             CrystalV2::Compiler::Frontend::NumberKind::F32,
             CrystalV2::Compiler::Frontend::NumberKind::F64
           )
          if value = num_str.to_f64?
            CrystalV2::Compiler::Semantic::MacroNumberValue.new(value)
          else
            nil
          end
        else
          if value = num_str.to_i64?(prefix: true)
            CrystalV2::Compiler::Semantic::MacroNumberValue.new(value)
          else
            nil
          end
        end
      when CrystalV2::Compiler::Frontend::TernaryNode
        cond_val = macro_value_for_expr(expr_node.condition)
        branch = cond_val && cond_val.truthy? ? expr_node.true_branch : expr_node.false_branch
        macro_value_for_expr(branch)
      when CrystalV2::Compiler::Frontend::IfNode
        cond_val = macro_value_for_expr(expr_node.condition)
        if cond_val && cond_val.truthy?
          if expr_id = tail_expr_id_for_body(expr_node.then_body)
            return macro_value_for_expr(expr_id)
          end
        else
          if elsifs = expr_node.elsifs
            elsifs.each do |elsif_branch|
              branch_val = macro_value_for_expr(elsif_branch.condition)
              if branch_val && branch_val.truthy?
                if expr_id = tail_expr_id_for_body(elsif_branch.body)
                  return macro_value_for_expr(expr_id)
                end
              end
            end
          end
          if else_body = expr_node.else_body
            if expr_id = tail_expr_id_for_body(else_body)
              return macro_value_for_expr(expr_id)
            end
          end
        end
        nil
      when CrystalV2::Compiler::Frontend::UnaryNode
        op = String.new(expr_node.operator)
        inner = macro_value_for_expr(expr_node.operand)
        if inner && inner.is_a?(CrystalV2::Compiler::Semantic::MacroNumberValue)
          case op
          when "-"
            raw = inner.value
            negated = raw.is_a?(Int64) ? -raw : -(raw.as(Float64))
            CrystalV2::Compiler::Semantic::MacroNumberValue.new(negated)
          when "~"
            raw = inner.value
            if raw.is_a?(Int64)
              CrystalV2::Compiler::Semantic::MacroNumberValue.new(~raw)
            else
              nil
            end
          when "+"
            inner
          else
            nil
          end
        elsif inner && inner.is_a?(CrystalV2::Compiler::Semantic::MacroBoolValue) && op == "!"
          CrystalV2::Compiler::Semantic::MacroBoolValue.new(!inner.value)
        else
          nil
        end
      when CrystalV2::Compiler::Frontend::ConstantNode
        raw_name = String.new(expr_node.name)
        resolved = resolve_constant_name_in_context(raw_name) || raw_name
        if literal = @constant_literal_values[resolved]?
          literal
        else
          CrystalV2::Compiler::Semantic::MacroIdValue.new(raw_name)
        end
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(expr_node.name)
        if name[0]?.try(&.uppercase?)
          if resolved = resolve_constant_name_in_context(name)
            if literal = @constant_literal_values[resolved]?
              return literal
            end
          end
        end
        CrystalV2::Compiler::Semantic::MacroIdValue.new(name)
      when CrystalV2::Compiler::Frontend::PathNode
        path = collect_path_string(expr_node)
        if resolved = resolve_constant_name_in_context(path)
          if literal = @constant_literal_values[resolved]?
            return literal
          end
        end
        CrystalV2::Compiler::Semantic::MacroIdValue.new(path)
      when CrystalV2::Compiler::Frontend::OffsetofNode
        if expr_node.args.size >= 2
          type_node = @arena[expr_node.args[0]]
          type_name = case type_node
                      when CrystalV2::Compiler::Frontend::IdentifierNode
                        String.new(type_node.name)
                      when CrystalV2::Compiler::Frontend::ConstantNode
                        String.new(type_node.name)
                      else
                        nil
                      end
          field_node = @arena[expr_node.args[1]]
          field_name = case field_node
                       when CrystalV2::Compiler::Frontend::InstanceVarNode
                         String.new(field_node.name)
                       when CrystalV2::Compiler::Frontend::IdentifierNode
                         "@#{String.new(field_node.name)}"
                       else
                         nil
                       end
          if type_name && field_name
            ci = @class_info[type_name]?
            unless ci
              if current = @current_class
                ci = @class_info["#{current}::#{type_name}"]?
                ci ||= @class_info["#{current.split("::").first}::#{type_name}"]? if current.includes?("::")
              end
            end
            if ci
              ci.ivars.each do |ivar|
                if ivar.name == field_name
                  return CrystalV2::Compiler::Semantic::MacroNumberValue.new(ivar.offset.to_i64)
                end
              end
              # Field not explicitly registered — it's at the end of the struct
              # (e.g. String's @c : UInt8 is the first byte after the header fields)
              if !ci.ivars.empty?
                return CrystalV2::Compiler::Semantic::MacroNumberValue.new(ci.size.to_i64)
              end
            end
          end
        end
        nil
      else
        nil
      end
    end

    private def macro_value_for_type_name(type_name : String) : CrystalV2::Compiler::Semantic::MacroValue
      resolved = resolve_type_alias_chain(resolve_type_name_in_context(type_name))
      type_vars = nil
      if info = split_generic_base_and_args(resolved)
        type_vars = split_generic_type_args(info[:args]).map(&.strip)
      end
      type_ref = type_ref_for_name(resolved)
      desc = type_ref == TypeRef::VOID ? nil : @module.get_type_descriptor(type_ref)
      is_struct = desc ? desc.kind == TypeKind::Struct : false
      is_module = desc ? desc.kind == TypeKind::Module : false
      CrystalV2::Compiler::Semantic::MacroTypeValue.new(
        resolved,
        nil,
        is_struct,
        is_module,
        false,
        nil,
        type_vars
      )
    end

    private def macro_vars_for_current_context(ctx : LoweringContext) : Hash(String, CrystalV2::Compiler::Semantic::MacroValue)
      vars = {} of String => CrystalV2::Compiler::Semantic::MacroValue
      @type_param_map.each do |param, actual|
        next if actual.empty?
        vars[param] = macro_value_for_type_name(actual)
      end

      if tuple_list = @type_param_map["T__tuple"]?
        args = split_generic_type_args(tuple_list).map(&.strip)
        unless args.empty?
          elems = [] of CrystalV2::Compiler::Semantic::MacroValue
          args.each do |arg|
            elems << macro_value_for_type_name(arg)
          end
          vars["T"] = CrystalV2::Compiler::Semantic::MacroTupleValue.new(elems)
        end
      end

      if self_id = ctx.lookup_local("self")
        if desc = @module.get_type_descriptor(ctx.type_of(self_id))
          if desc.kind == TypeKind::Tuple || desc.name.starts_with?("Tuple(")
            args = desc.type_params.reject { |t| t == TypeRef::VOID }.map { |ref| get_type_name_from_ref(ref) }
            if args.empty?
              if info = split_generic_base_and_args(desc.name)
                args = split_generic_type_args(info[:args]).map(&.strip)
              end
            end
            unless args.empty?
              elems = [] of CrystalV2::Compiler::Semantic::MacroValue
              args.each do |arg|
                elems << macro_value_for_type_name(arg)
              end
              vars["T"] = CrystalV2::Compiler::Semantic::MacroTupleValue.new(elems)
            end
          end
        end
      end

      if current = @current_class
        if info = split_generic_base_and_args(current)
          base = info[:base]
          args = split_generic_type_args(info[:args]).map(&.strip)
          if base == "Tuple" && !args.empty? && !vars.has_key?("T")
            elems = [] of CrystalV2::Compiler::Semantic::MacroValue
            args.each do |arg|
              elems << macro_value_for_type_name(arg)
            end
            vars["T"] = CrystalV2::Compiler::Semantic::MacroTupleValue.new(elems)
          elsif template = @generic_templates[base]?
            template.type_params.each_with_index do |param, idx|
              next if vars.has_key?(param)
              if arg = args[idx]?
                vars[param] = macro_value_for_type_name(arg)
              end
            end
          end
        end
      end

      vars
    end

    private def macro_int_literal_for_expr_with_context(
      expr_id : ExprId,
      vars : Hash(String, CrystalV2::Compiler::Semantic::MacroValue),
      owner_type : CrystalV2::Compiler::Semantic::ClassSymbol?,
      expander : CrystalV2::Compiler::Semantic::MacroExpander,
    ) : Int64?
      expr_node = @arena[expr_id]
      case expr_node
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        macro_int_literal_for_expr_with_context(expr_node.expression, vars, owner_type, expander)
      when CrystalV2::Compiler::Frontend::NumberNode
        num_str = strip_numeric_suffix(String.new(expr_node.value)).gsub("_", "")
        num_str.to_i64?
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        member = String.new(expr_node.member)
        if member == "size"
          obj_node = @arena[expr_node.object]
          if obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            name = String.new(obj_node.name)
            if name == "T"
              if tuple_val = vars["T"]?.try(&.as?(CrystalV2::Compiler::Semantic::MacroTupleValue))
                return tuple_val.elements.size.to_i64
              end
            end
          end
        end
        nil
      when CrystalV2::Compiler::Frontend::CallNode
        callee = @arena[expr_node.callee]
        if callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) && expr_node.args.empty?
          member = String.new(callee.member)
          if member == "size"
            obj_node = @arena[callee.object]
            if obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
              name = String.new(obj_node.name)
              if name == "T"
                if tuple_val = vars["T"]?.try(&.as?(CrystalV2::Compiler::Semantic::MacroTupleValue))
                  return tuple_val.elements.size.to_i64
                end
              end
            end
          end
        end
        nil
      else
        output = expander.expand_expression(expr_id, variables: vars, owner_type: owner_type).strip
        return nil if output.empty?
        num_str = strip_numeric_suffix(output).gsub("_", "")
        num_str.to_i64?
      end
    end

    private def macro_for_iterable_values_with_context(
      iterable_id : ExprId,
      vars : Hash(String, CrystalV2::Compiler::Semantic::MacroValue),
      owner_type : CrystalV2::Compiler::Semantic::ClassSymbol?,
      expander : CrystalV2::Compiler::Semantic::MacroExpander,
    ) : Array(CrystalV2::Compiler::Semantic::MacroValue)?
      node = @arena[iterable_id]
      if node.is_a?(CrystalV2::Compiler::Frontend::MacroExpressionNode)
        return macro_for_iterable_values_with_context(node.expression, vars, owner_type, expander)
      end

      case node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = CrystalV2::Compiler::Frontend.node_literal_string(node)
        if name && (val = vars[name]?)
          if val.is_a?(CrystalV2::Compiler::Semantic::MacroArrayValue)
            return val.elements
          elsif val.is_a?(CrystalV2::Compiler::Semantic::MacroTupleValue)
            return val.elements
          end
        end
      when CrystalV2::Compiler::Frontend::HashLiteralNode
        values = [] of CrystalV2::Compiler::Semantic::MacroValue
        node.entries.each do |entry|
          key_val = macro_value_for_expr(entry.key)
          value_val = macro_value_for_expr(entry.value)
          return nil unless key_val && value_val
          values << CrystalV2::Compiler::Semantic::MacroTupleValue.new([key_val, value_val])
        end
        return values
      when CrystalV2::Compiler::Frontend::RangeNode
        start_val = macro_int_literal_for_expr_with_context(node.begin_expr, vars, owner_type, expander)
        end_val = macro_int_literal_for_expr_with_context(node.end_expr, vars, owner_type, expander)
        if end_val.nil?
          end_node = @arena[node.end_expr]
          callee_node = if end_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
                          end_node.args.empty? ? @arena[end_node.callee] : nil
                        else
                          end_node
                        end
          if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
            member = String.new(callee_node.member)
            if member == "size"
              obj_node = @arena[callee_node.object]
              if obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
                name = String.new(obj_node.name)
                if name == "T"
                  if tuple_val = vars["T"]?.try(&.as?(CrystalV2::Compiler::Semantic::MacroTupleValue))
                    end_val = tuple_val.elements.size.to_i64
                  end
                end
              end
            end
          end
        end
        return nil unless start_val && end_val
        limit = CrystalV2::Compiler::Semantic::MacroExpander::MAX_RANGE_SIZE
        last_val = node.exclusive ? end_val - 1 : end_val
        count = last_val - start_val + 1
        return nil if count < 0 || count > limit
        values = [] of CrystalV2::Compiler::Semantic::MacroValue
        current = start_val
        while current <= last_val
          values << CrystalV2::Compiler::Semantic::MacroNumberValue.new(current)
          current += 1
        end
        return values
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        values = [] of CrystalV2::Compiler::Semantic::MacroValue
        node.elements.each do |elem_id|
          if value = macro_value_for_expr(elem_id)
            values << value
          else
            return nil
          end
        end
        return values
      end

      nil
    end

    private def strip_numeric_suffix(literal : String) : String
      literal.sub(/_?(i8|i16|i32|i64|i128|u8|u16|u32|u64|u128|f32|f64)\z/i, "")
    end

    private def macro_int_literal_for_expr(expr_id : ExprId) : Int64?
      expr_node = @arena[expr_id]
      case expr_node
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        macro_int_literal_for_expr(expr_node.expression)
      when CrystalV2::Compiler::Frontend::NumberNode
        num_str = String.new(expr_node.value).gsub("_", "")
        num_str.to_i64?
      else
        nil
      end
    end

    private def macro_expression_class_name(expr_id : ExprId) : String?
      value = macro_value_for_expr(expr_id)
      return nil unless value
      raw = value.to_macro_output
      return nil if raw.empty?
      resolved = resolve_type_name_in_context(raw)
      resolved = resolve_type_alias_chain(resolved)
      if @module.is_lib?(resolved) || type_name_exists?(resolved) || @module_defs.has_key?(resolved) || @generic_templates.has_key?(resolved)
        return resolved
      end
      if @module.is_lib?(raw) || type_name_exists?(raw) || @module_defs.has_key?(raw) || @generic_templates.has_key?(raw)
        return raw
      end
      nil
    end

    # Lower macro if/elsif/else at compile time
    private def lower_macro_if(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::MacroIfNode) : ValueId
      # Try to evaluate condition at compile time
      result = try_evaluate_macro_condition(node.condition)
      if env_has?("DEBUG_MACRO_IF")
        STDERR.puts "[MACRO_IF] condition_id=#{node.condition}, result=#{result.inspect}"
      end
      if env_has?("DEBUG_MACRO_IF_SLICE") && (@current_class.try(&.includes?("Slice")) || ctx.function.name.includes?("Slice"))
        STDERR.puts "[MACRO_IF_SLICE] func=#{ctx.function.name} class=#{@current_class} method=#{@current_method} result=#{result.inspect} type_param_map=#{@type_param_map}"
      end

      if result == true
        # Condition is true - lower the then branch
        lower_macro_body(ctx, node.then_body)
      elsif result == false
        # Condition is false - check else branch
        if else_node = node.else_body
          else_ast = @arena[else_node]
          case else_ast
          when CrystalV2::Compiler::Frontend::MacroIfNode
            # elsif - recursive evaluation
            lower_macro_if(ctx, else_ast)
          else
            # else branch (MacroLiteralNode containing body)
            lower_macro_body(ctx, else_node)
          end
        else
          # No else - return nil
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(nil_lit)
          nil_lit.id
        end
      else
        # Can't evaluate at compile time - return nil with warning
        # STDERR.puts "[WARN] Cannot evaluate macro condition at compile time"
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      end
    end

    private def macro_expander_for_current_context : CrystalV2::Compiler::Semantic::MacroExpander
      source = @sources_by_arena[@arena]?
      program = CrystalV2::Compiler::Frontend::Program.new(@arena, [] of ExprId)
      CrystalV2::Compiler::Semantic::MacroExpander.new(
        program,
        @arena,
        CrystalV2::Runtime.target_flags,
        recovery_mode: true,
        macro_source: source,
        source_provider: ->(block_id : CrystalV2::Compiler::Frontend::ExprId) { macro_block_text(block_id) }
      )
    end

    private def macro_block_text(block_id : CrystalV2::Compiler::Frontend::ExprId) : String?
      block_node = @arena[block_id]
      return nil unless block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
      body = block_node.body
      return nil if body.empty?

      spans = body.map { |expr_id| @arena[expr_id].span }
      span = CrystalV2::Compiler::Frontend::Span.cover_all(spans)
      source = @sources_by_arena[@arena]?
      return nil unless source

      start = span.start_offset
      finish = span.end_offset
      return nil if start < 0 || finish <= start || start >= source.bytesize
      length = finish - start
      length = source.bytesize - start if start + length > source.bytesize
      source.byte_slice(start, length)
    end

    private def lower_macro_expression(
      ctx : LoweringContext,
      node : CrystalV2::Compiler::Frontend::MacroExpressionNode,
    ) : ValueId
      vars = macro_vars_for_current_context(ctx)
      owner_type = @current_class ? macro_owner_type_for(@current_class.not_nil!) : nil
      expander = macro_expander_for_current_context
      output = expander.expand_expression(node.expression, variables: vars, owner_type: owner_type)
      if !output.empty?
        if parsed = parse_macro_literal_for_context(output)
          return lower_parsed_macro_body(ctx, parsed)
        end
        if value = lower_expanded_macro_code(ctx, output)
          return value
        end
      end
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_macro_for(
      ctx : LoweringContext,
      node : CrystalV2::Compiler::Frontend::MacroForNode,
    ) : ValueId
      iter_vars = node.iter_vars.map { |name| String.new(name) }
      if iter_vars.empty?
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      vars = macro_vars_for_current_context(ctx)
      owner_type = @current_class ? macro_owner_type_for(@current_class.not_nil!) : nil
      expander = macro_expander_for_current_context
      values = macro_for_iterable_values(node.iterable)
      if values.nil?
        values = macro_for_iterable_values_with_context(node.iterable, vars, owner_type, expander)
      end
      unless values
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      expanded = String.build do |io|
        values.each_with_index do |value, idx|
          loop_vars = vars.dup
          assign_macro_iter_vars(loop_vars, iter_vars, value, idx)
          if body_output = expander.expand_literal(node.body, variables: loop_vars, owner_type: owner_type)
            io << body_output
            io << "\n"
          end
        end
      end

      if expanded.strip.empty?
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      if parsed = parse_macro_literal_for_context(expanded)
        return lower_parsed_macro_body(ctx, parsed)
      end
      if value = lower_expanded_macro_code(ctx, expanded)
        return value
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Lower the body of a macro branch (MacroLiteralNode or expression)
    private def lower_macro_body(ctx : LoweringContext, body_id : ExprId) : ValueId
      body_node = @arena[body_id]
      case body_node
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        if raw_text = macro_literal_raw_text(body_node)
          if parsed = parse_macro_literal_for_context(raw_text)
            return lower_parsed_macro_body(ctx, parsed)
          elsif raw_text.includes?("{%")
            if expanded = expand_flag_macro_text(raw_text)
              if parsed = parse_macro_literal_for_context(expanded)
                return lower_parsed_macro_body(ctx, parsed)
              end
            end
          end
          # If raw_text contains {{ expressions }}, expand them and re-parse
          if raw_text.includes?("{{")
            if expanded = expand_macro_literal_expressions(body_node, ctx)
              if parsed = parse_macro_literal_for_context(expanded)
                return lower_parsed_macro_body(ctx, parsed)
              end
            end
          end
        end

        # Macro literal contains pieces (text and expressions)
        last_value : ValueId? = nil
        if pieces = body_node.pieces
          pieces.each do |piece|
            case piece.kind
            when CrystalV2::Compiler::Frontend::MacroPiece::Kind::Expression
              # Expression piece - lower the expression
              if expr_id = piece.expr
                last_value = lower_expr(ctx, expr_id)
              end
            when CrystalV2::Compiler::Frontend::MacroPiece::Kind::Text
              # Text piece - skip (just literal text, not code)
              nil
            else
              # Other control pieces - skip
              nil
            end
          end
        end
        last_value || begin
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(nil_lit)
          nil_lit.id
        end
      else
        # Direct expression
        lower_expr(ctx, body_id)
      end
    end

    private def parse_macro_literal_for_context(code : String) : Tuple(CrystalV2::Compiler::Frontend::Program, Array(ExprId))?
      if @current_method
        if parsed = parse_macro_literal_method_body(code)
          return parsed
        end
      end

      if current = @current_class
        if @module.is_lib?(current)
          if parsed = parse_macro_literal_lib_body(code)
            return parsed
          end
        end
        if parsed = parse_macro_literal_class_body(code)
          return parsed
        end
      end

      if program = parse_macro_literal_program(code)
        return {program, program.roots}
      end

      nil
    end

    private def lower_parsed_macro_body(
      ctx : LoweringContext,
      parsed : Tuple(CrystalV2::Compiler::Frontend::Program, Array(ExprId)),
    ) : ValueId
      program, body = parsed
      parsed_value : ValueId? = nil
      with_arena(program.arena) do
        body.each do |expr_id|
          parsed_value = lower_expr(ctx, expr_id)
        end
      end
      parsed_value || begin
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      end
    end

    # Lower a MacroLiteralNode that may contain text with {% if flag?() %} patterns
    private def lower_macro_literal(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::MacroLiteralNode) : ValueId
      # Prefer raw source text (includes control tags and whitespace).
      if raw_text = macro_literal_raw_text(node)
        if expanded = expand_flag_macro_text(raw_text)
          # Parse and lower the expanded code
          result = lower_expanded_macro_code(ctx, expanded)
          return result if result
        end
      else
        # Fallback to piece text when source is unavailable.
        node.pieces.each do |piece|
          next unless piece.kind == CrystalV2::Compiler::Frontend::MacroPiece::Kind::Text
          if text = piece.text
            expanded = expand_flag_macro_text(text)
            if expanded
              result = lower_expanded_macro_code(ctx, expanded)
              return result if result
            end
          end
        end
      end

      # Fall back to expression pieces only.
      node.pieces.each do |piece|
        next unless piece.kind == CrystalV2::Compiler::Frontend::MacroPiece::Kind::Expression
        if expr_id = piece.expr
          return lower_expr(ctx, expr_id)
        end
      end

      # No expansion possible - return nil
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Expand {% if flag?(:name) %} ... {% else %} ... {% end %} patterns in text
    private def expand_flag_macro_text(text : String) : String?
      trimmed = strip_macro_leading_comments(text)
      if parsed = parse_flag_macro_branches(trimmed)
        branches, else_body = parsed
        branches.each do |(cond, body)|
          verdict = evaluate_flag_condition_string(cond)
          return nil if verdict.nil?
          next unless verdict
          chosen = body.strip
          return nil if chosen.empty?
          return expand_flag_macro_text(chosen) || chosen
        end
        if else_body
          chosen = else_body.strip
          return nil if chosen.empty?
          return expand_flag_macro_text(chosen) || chosen
        end
        return nil
      end

      nil
    end

    private def parse_flag_macro_branches(text : String) : Tuple(Array(Tuple(String, String)), String?)?
      return nil unless text.includes?("{%")
      tag_re = /\{%\s*(if|elsif|else|end|unless)\b(.*?)%\}/m
      first = tag_re.match(text)
      return nil unless first
      return nil unless text[0, first.begin].strip.empty?
      tag = first[1]? || ""
      return nil unless tag == "if" || tag == "unless"

      cond = (first[2]? || "").strip
      cond = "!#{cond}" if tag == "unless"

      branches = [] of Tuple(String, String)
      depth = 0
      pos = first.end
      current_start = pos
      current_cond = cond
      else_body : String? = nil

      while match = tag_re.match(text, pos)
        tag = match[1]? || ""
        case tag
        when "if", "unless"
          depth += 1
        when "end"
          if depth == 0
            body = text[current_start, match.begin - current_start]
            if else_body
              else_body = body
            else
              branches << {current_cond, body}
            end
            return {branches, else_body}
          end
          depth -= 1
        when "elsif"
          if depth == 0 && else_body.nil?
            body = text[current_start, match.begin - current_start]
            branches << {current_cond, body}
            current_cond = (match[2]? || "").strip
            current_start = match.end
          end
        when "else"
          if depth == 0 && else_body.nil?
            body = text[current_start, match.begin - current_start]
            branches << {current_cond, body}
            else_body = ""
            current_start = match.end
          end
        end
        pos = match.end
      end
      nil
    end

    private def evaluate_flag_condition_string(cond : String) : Bool?
      cleaned = cond.strip
      return nil if cleaned.empty?
      if cleaned.starts_with?('!')
        inner = evaluate_flag_condition_string(cleaned[1..])
        return inner.nil? ? nil : !inner
      end
      if cleaned.includes?("||")
        parts = cleaned.split("||")
        results = [] of Bool?
        parts.each do |part|
          results << evaluate_flag_condition_string(part)
        end
        return nil if results.any?(&.nil?)
        return results.any? { |res| res == true }
      end
      if cleaned.includes?("&&")
        parts = cleaned.split("&&")
        results = [] of Bool?
        parts.each do |part|
          results << evaluate_flag_condition_string(part)
        end
        return nil if results.any?(&.nil?)
        return results.all? { |res| res == true }
      end
      if match = cleaned.match(/flag\?\s*\(\s*(?::([A-Za-z0-9_]+)|"([^"]+)"|'([^']+)')\s*\)/)
        flag_name = match[1]? || match[2]? || match[3]? || ""
        return evaluate_macro_flag(flag_name)
      end
      nil
    end

    private def flag_name_from_match(match : Regex::MatchData) : String
      match[1]? || match[2]? || match[3]? || ""
    end

    private def strip_macro_leading_comments(text : String) : String
      idx = 0
      while idx < text.size
        while idx < text.size && text[idx].ascii_whitespace?
          idx += 1
        end
        break unless idx < text.size && text.byte_at(idx) == '#'.ord
        newline = text.index('\n', idx) || text.size
        idx = newline + 1
      end
      text[idx, text.size - idx]
    end

    # Expand {{ expression }} pieces in a MacroLiteralNode to produce fully-expanded text.
    # This handles cases like {% begin %} bodies containing {{@type}} etc.
    private def expand_macro_literal_expressions(node : CrystalV2::Compiler::Frontend::MacroLiteralNode, ctx : LoweringContext) : String?
      pieces = node.pieces
      return nil if pieces.empty?

      vars = macro_vars_for_current_context(ctx)
      owner_type = @current_class ? macro_owner_type_for(@current_class.not_nil!) : nil
      expander = macro_expander_for_current_context

      source = @sources_by_arena[@arena]?
      bytesize = source ? source.bytesize : 0
      builder = String::Builder.new

      pieces.each do |piece|
        case piece.kind
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::Text
          if source && (span = piece.span)
            start = span.start_offset
            length = span.end_offset - span.start_offset
            next if length <= 0 || start < 0 || start >= bytesize
            length = bytesize - start if start + length > bytesize
            builder << source.byte_slice(start, length)
          elsif text = piece.text
            builder << text
          end
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::Expression
          if expr_id = piece.expr
            output = expander.expand_expression(expr_id, variables: vars, owner_type: owner_type)
            builder << output
          end
        end
      end

      text = builder.to_s.strip
      text.empty? ? nil : text
    end

    private def macro_literal_raw_text(node : CrystalV2::Compiler::Frontend::MacroLiteralNode) : String?
      return nil if node.pieces.empty?

      source = @sources_by_arena[@arena]?
      bytesize = source ? source.bytesize : 0
      builder = String::Builder.new

      node.pieces.each do |piece|
        if source && (span = piece.span)
          start = span.start_offset
          length = span.end_offset - span.start_offset
          next if length <= 0
          next if start < 0 || start >= bytesize
          if start + length > bytesize
            length = bytesize - start
          end
          builder << source.byte_slice(start, length)
        elsif text = piece.text
          builder << text
        end
      end

      text = builder.to_s
      text.empty? ? nil : text
    end

    private def macro_if_raw_text(node : CrystalV2::Compiler::Frontend::MacroIfNode) : String?
      source = @sources_by_arena[@arena]?
      return nil unless source
      span = node.span
      start = span.start_offset
      length = span.end_offset - span.start_offset
      return nil if length <= 0
      return nil if start < 0 || start >= source.bytesize
      if start + length > source.bytesize
        length = source.bytesize - start
      end
      source.byte_slice(start, length)
    end

    private def parse_macro_literal_program(code : String) : CrystalV2::Compiler::Frontend::Program?
      trimmed = code.strip
      return nil if trimmed.empty?
      return nil if trimmed.includes?("{%") || trimmed.includes?("{{")

      lexer = CrystalV2::Compiler::Frontend::Lexer.new(trimmed)
      parser = CrystalV2::Compiler::Frontend::Parser.new(lexer, recovery_mode: true)
      program = parser.parse_program
      return nil if program.roots.empty?
      @sources_by_arena[program.arena] = trimmed
      program
    end

    private def parse_macro_literal_lib_body(code : String) : Tuple(CrystalV2::Compiler::Frontend::Program, Array(ExprId))?
      trimmed = code.strip
      return nil if trimmed.empty?
      return nil if trimmed.includes?("{%") || trimmed.includes?("{{")

      wrapped = "lib __MacroContext__\n#{trimmed}\nend\n"
      lexer = CrystalV2::Compiler::Frontend::Lexer.new(wrapped)
      parser = CrystalV2::Compiler::Frontend::Parser.new(lexer, recovery_mode: true)
      program = parser.parse_program
      return nil if program.roots.empty?
      @sources_by_arena[program.arena] = wrapped

      lib_node = program.roots.map { |id| program.arena[id] }
        .find(&.is_a?(CrystalV2::Compiler::Frontend::LibNode))
      return nil unless lib_node

      body = lib_node.as(CrystalV2::Compiler::Frontend::LibNode).body
      return nil unless body

      {program, body}
    end

    private def parse_macro_literal_class_body(code : String) : Tuple(CrystalV2::Compiler::Frontend::Program, Array(ExprId))?
      trimmed = code.strip
      return nil if trimmed.empty?
      return nil if trimmed.includes?("{%") || trimmed.includes?("{{")

      wrapped = "class __MacroContext__\n#{trimmed}\nend\n"
      lexer = CrystalV2::Compiler::Frontend::Lexer.new(wrapped)
      parser = CrystalV2::Compiler::Frontend::Parser.new(lexer, recovery_mode: true)
      program = parser.parse_program
      if env_get("DEBUG_MACRO_CLASS_PARSE") && parser.diagnostics.any?
        details = parser.diagnostics.map(&.message).join("; ")
        STDERR.puts "[MACRO_CLASS_PARSE] diagnostics=#{details}"
        STDERR.puts "[MACRO_CLASS_PARSE] code=#{wrapped.inspect}"
      end
      return nil if program.roots.empty?
      @sources_by_arena[program.arena] = wrapped

      class_node = program.roots.map { |id| program.arena[id] }
        .find(&.is_a?(CrystalV2::Compiler::Frontend::ClassNode))
      return nil unless class_node

      body = class_node.as(CrystalV2::Compiler::Frontend::ClassNode).body
      return nil unless body

      {program, body}
    end

    private def parse_macro_literal_method_body(code : String) : Tuple(CrystalV2::Compiler::Frontend::Program, Array(ExprId))?
      trimmed = code.strip
      return nil if trimmed.empty?
      return nil if trimmed.includes?("{%") || trimmed.includes?("{{")

      wrapped = "def __MacroContext__\n#{trimmed}\nend\n"
      lexer = CrystalV2::Compiler::Frontend::Lexer.new(wrapped)
      parser = CrystalV2::Compiler::Frontend::Parser.new(lexer, recovery_mode: true)
      program = parser.parse_program
      return nil if program.roots.empty?
      @sources_by_arena[program.arena] = wrapped

      def_node = program.roots.map { |id| program.arena[id] }
        .find(&.is_a?(CrystalV2::Compiler::Frontend::DefNode))
      return nil unless def_node

      body = def_node.as(CrystalV2::Compiler::Frontend::DefNode).body
      return nil unless body

      {program, body}
    end

    # Lower expanded macro code by parsing and lowering it
    private def lower_expanded_macro_code(ctx : LoweringContext, code : String) : ValueId?
      return nil if code.empty?

      # Create a mini-parser for simple Crystal expressions
      # Handle common patterns: Path.method, method_call, Path
      code = code.strip

      # Pattern: Namespace::Path.method_call (handles Crystal::Scheduler.event_loop)
      if match = code.match(/^([A-Z][A-Za-z0-9_]*(?:::[A-Z][A-Za-z0-9_]*)*)\.(\w+)$/)
        type_path = match[1]
        method_name = match[2]
        # Generate call to type.method()
        full_name = "#{type_path}.#{method_name}"
        lower_function_if_needed(full_name)
        if @module.has_function?(full_name)
          return_type = @function_base_return_types[full_name]? || TypeRef::VOID
          call = Call.new(ctx.next_id, return_type, nil, full_name, [] of ValueId)
          ctx.emit(call)
          return call.id
        end
      end

      # Pattern: Simple path reference (constant)
      if match = code.match(/^([A-Z][A-Za-z0-9_]*(?:::[A-Z][A-Za-z0-9_]*)*)$/)
        type_path = match[1]
        type_ref = type_ref_for_name(type_path)
        if type_ref != TypeRef::VOID
          lit = Literal.new(ctx.next_id, type_ref, nil)
          ctx.emit(lit)
          return lit.id
        end
      end

      nil
    end

    # ═══════════════════════════════════════════════════════════════════════
    # METAPROGRAMMING (typeof, sizeof, etc.)
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_typeof(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::TypeofNode) : ValueId
      # typeof(x) returns the type of x at compile time
      # At runtime, we evaluate the expressions for side effects and return a type placeholder
      # For now, just lower the args and return a nil (type info is compile-time only)
      node.args.each do |arg_id|
        lower_expr(ctx, arg_id)
      end
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_sizeof(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::SizeofNode) : ValueId
      # sizeof(T) returns the size of type T in bytes
      # For basic types, we can compute this at compile time
      size = 8_i64 # Default pointer size
      if node.args.size > 0
        type_node = @arena[node.args.first]
        size = compute_type_size(type_node)
      end
      lit = Literal.new(ctx.next_id, TypeRef::INT32, size)
      ctx.emit(lit)
      lit.id
    end

    private def lower_offsetof(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::OffsetofNode) : ValueId
      # offsetof(T, @field) returns the byte offset of a field
      offset = 0_i64 # Default

      if node.args.size >= 2
        # Extract type name from first arg
        type_node = @arena[node.args[0]]
        type_name = case type_node
                    when CrystalV2::Compiler::Frontend::IdentifierNode
                      String.new(type_node.name)
                    when CrystalV2::Compiler::Frontend::ConstantNode
                      String.new(type_node.name)
                    else
                      nil
                    end

        # Extract field name from second arg
        field_node = @arena[node.args[1]]
        field_name = case field_node
                     when CrystalV2::Compiler::Frontend::InstanceVarNode
                       String.new(field_node.name) # includes @ prefix
                     when CrystalV2::Compiler::Frontend::IdentifierNode
                       "@#{String.new(field_node.name)}"
                     else
                       nil
                     end

        if type_name && field_name
          # Look up class info - try exact name, then with current namespace
          ci = @class_info[type_name]?
          unless ci
            if current = @current_class
              ci = @class_info["#{current}::#{type_name}"]?
              ci ||= @class_info["#{current.split("::").first}::#{type_name}"]? if current.includes?("::")
            end
          end
          if ci
            found = false
            ci.ivars.each do |ivar|
              if ivar.name == field_name
                offset = ivar.offset.to_i64
                found = true
                break
              end
            end
            # Field not explicitly registered — it's at the end of the struct
            if !found && !ci.ivars.empty?
              offset = ci.size.to_i64
            end
          end
        end
      end

      lit = Literal.new(ctx.next_id, TypeRef::INT32, offset)
      ctx.emit(lit)
      lit.id
    end

    private def compute_type_size(type_node : CrystalV2::Compiler::Frontend::Node) : Int64
      case type_node
      when CrystalV2::Compiler::Frontend::SelfNode
        # sizeof(self) — resolve to current monomorphized class
        if current = @current_class
          return size_for_type_name(current)
        end
        8_i64
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(type_node.name)
        # Resolve type parameters if present
        name = @type_param_map[name]? || name
        # sizeof(self) can also appear as IdentifierNode("self")
        if name == "self"
          if current = @current_class
            return size_for_type_name(current)
          end
          return 8_i64
        end
        size_for_type_name(name)
      when CrystalV2::Compiler::Frontend::ConstantNode
        name = String.new(type_node.name)
        name = @type_param_map[name]? || name
        size_for_type_name(name)
      else
        8_i64 # Default pointer size
      end
    end

    private def size_for_type_name(name : String) : Int64
      case name
      when "Nil"                                then 0_i64
      when "Void", "Int8", "UInt8", "Bool"      then 1_i64
      when "Int16", "UInt16"                    then 2_i64
      when "Int32", "UInt32", "Float32", "Char" then 4_i64
      when "Int64", "UInt64", "Float64"         then 8_i64
      when "Int128", "UInt128"                  then 16_i64
      else                                           8_i64 # Pointer/reference size
      end
    end

    # Lower top-level method definition
    private def lower_top_level_def(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::DefNode) : ValueId
      # Top-level methods are global functions
      method_name = String.new(node.name)
      param_types = [] of TypeRef
      has_block = false
      if params = node.params
        params.each do |param|
          next if named_only_separator?(param)
          if param.is_block
            has_block = true
            next
          end
          param_type = if ta = param.type_annotation
                         type_ref_for_name(String.new(ta))
                       elsif param.is_double_splat
                         type_ref_for_name("NamedTuple")
                       else
                         TypeRef::VOID
                       end
          param_types << param_type
        end
      end

      full_name = function_full_name_for_def(method_name, param_types, node.params, has_block)
      register_pending_method_effects(full_name, param_types.size)
      if @function_defs.has_key?(full_name)
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      # Determine return type
      return_type = if rt = node.return_type
                      type_ref_for_name(String.new(rt))
                    elsif method_name.ends_with?('?')
                      TypeRef::BOOL
                    else
                      TypeRef::VOID
                    end

      register_function_type(full_name, return_type) unless @function_types[full_name]?
      register_function_type(method_name, return_type) unless @function_types[method_name]?

      @function_defs[full_name] = node
      @function_def_arenas[full_name] = @arena
      unless @function_defs.has_key?(method_name)
        @function_defs[method_name] = node
        @function_def_arenas[method_name] = @arena
      end

      # Method definitions don't produce a value
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Lower pointerof(x) to get address of a variable
    private def lower_pointerof(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::PointerofNode) : ValueId
      # pointerof takes one argument - the variable/expression to get address of
      if node.args.empty?
        # Return null pointer if no args
        nil_lit = Literal.new(ctx.next_id, TypeRef::POINTER, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      # For local variables and instance variables, get the storage location directly
      # instead of creating a Copy (which loads the value). This ensures that
      # multiple pointerof(x) calls return the same address.
      arg_node = @arena[node.args.first]
      operand_id = case arg_node
                   when CrystalV2::Compiler::Frontend::IdentifierNode
                     name = String.new(arg_node.name)
                     if local_id = ctx.lookup_local(name)
                       local_id # Use storage directly, not a copy
                     else
                       lower_expr(ctx, node.args.first)
                     end
                   when CrystalV2::Compiler::Frontend::InstanceVarNode
                     # For pointerof(@ivar), compute field address: self + ivar_offset
                     # Do NOT load the value — we need the address.
                     ivar_name = String.new(arg_node.name)
                     ivar_offset = 0
                     if class_name = @current_class
                       search_name : String? = class_name
                       found = false
                       while search_name
                         if class_info = @class_info[search_name]?
                           if found_ivar = class_info.ivars.find { |iv| iv.name == ivar_name }
                             ivar_offset = found_ivar.offset
                             found = true
                             break
                           end
                           search_name = class_info.parent_name
                         else
                           break
                         end
                       end
                       # Fallback: implicit field at end of known ivars (e.g. String's @c)
                       if !found && (ci = @class_info[@current_class]?) && !ci.ivars.empty?
                         ivar_offset = ci.size
                       end
                     end
                     self_id = emit_self(ctx)
                     offset_lit = Literal.new(ctx.next_id, TypeRef::INT64, ivar_offset.to_i64)
                     ctx.emit(offset_lit)
                     ctx.register_type(offset_lit.id, TypeRef::INT64)
                     ptr_add = PointerAdd.new(ctx.next_id, TypeRef::POINTER, self_id, offset_lit.id, TypeRef::INT8)
                     ctx.emit(ptr_add)
                     ctx.register_type(ptr_add.id, TypeRef::POINTER)
                     return ptr_add.id # Return field address directly, skip AddressOf
                   else
                     lower_expr(ctx, node.args.first)
                   end

      # Create AddressOf instruction
      addr_of = AddressOf.new(ctx.next_id, TypeRef::POINTER, operand_id)
      ctx.emit(addr_of)
      ctx.register_type(addr_of.id, TypeRef::POINTER)
      addr_of.id
    end

    # Emit a call to an external C function
    private def emit_extern_call(ctx : LoweringContext, extern_func : ExternFunction, arg_ids : Array(ValueId)) : ValueId
      # Emit an ExternCall instruction with the real C function name
      extern_call = ExternCall.new(
        ctx.next_id,
        extern_func.return_type,
        extern_func.real_name, # Use the real C name
        arg_ids,
        extern_func.varargs
      )
      ctx.emit(extern_call)
      ctx.register_type(extern_call.id, extern_func.return_type)
      extern_call.id
    end

    private def emit_mem_intrinsic(ctx : LoweringContext, method_name : String, arg_ids : Array(ValueId)) : ValueId
      if arg_ids.size < 4
        if env_get("DEBUG_MEM_INTRINSIC")
          STDERR.puts "[MEM_INTRINSIC] emit method=#{method_name} args=#{arg_ids.size} func=#{ctx.function.name}"
        end
        return emit_extern_call(ctx, ExternFunction.new(method_name, method_name, nil, Array(TypeRef).new, TypeRef::VOID), arg_ids)
      end

      len_id = arg_ids[2]
      len_type = ctx.type_of(len_id)
      use_i32 = len_type == TypeRef::UINT32 || len_type == TypeRef::INT32 ||
                len_type == TypeRef::UINT16 || len_type == TypeRef::INT16 ||
                len_type == TypeRef::UINT8 || len_type == TypeRef::INT8
      target_len_type = use_i32 ? TypeRef::UINT32 : TypeRef::UINT64

      if len_type != target_len_type && len_type != TypeRef::VOID
        cast = Cast.new(ctx.next_id, target_len_type, len_id, target_len_type)
        ctx.emit(cast)
        ctx.register_type(cast.id, target_len_type)
        len_id = cast.id
      end

      intrinsic_name = case method_name
                       when "memcpy"
                         use_i32 ? "llvm.memcpy.p0.p0.i32" : "llvm.memcpy.p0.p0.i64"
                       when "memmove"
                         use_i32 ? "llvm.memmove.p0.p0.i32" : "llvm.memmove.p0.p0.i64"
                       else
                         use_i32 ? "llvm.memset.p0.i32" : "llvm.memset.p0.i64"
                       end

      extern_call = ExternCall.new(
        ctx.next_id,
        TypeRef::VOID,
        intrinsic_name,
        [arg_ids[0], arg_ids[1], len_id, arg_ids[3]],
        false
      )
      ctx.emit(extern_call)
      ctx.register_type(extern_call.id, TypeRef::VOID)
      extern_call.id
    end

    private def lower_pointer_new_intrinsic(ctx : LoweringContext, arg_ids : Array(ValueId)) : ValueId?
      return nil unless arg_ids.size == 1

      addr_id = arg_ids[0]
      addr_type = ctx.type_of(addr_id)
      if addr_type == TypeRef::VOID
        addr_cast = Cast.new(ctx.next_id, TypeRef::UINT64, addr_id, TypeRef::UINT64)
        ctx.emit(addr_cast)
        ctx.register_type(addr_cast.id, TypeRef::UINT64)
        addr_id = addr_cast.id
        addr_type = TypeRef::UINT64
      end

      return addr_id if addr_type == TypeRef::POINTER

      if numeric_primitive?(addr_type)
        cast = Cast.new(ctx.next_id, TypeRef::POINTER, addr_id, TypeRef::POINTER)
        ctx.emit(cast)
        ctx.register_type(cast.id, TypeRef::POINTER)
        return cast.id
      end

      nil
    end

    # Resolve annotation name from ExprId to string
    private def resolve_annotation_name(name_expr : CrystalV2::Compiler::Frontend::ExprId) : String
      name_node = @arena[name_expr]
      case name_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        String.new(name_node.name)
      when CrystalV2::Compiler::Frontend::PathNode
        # For paths like JSON::Field, extract the last part
        resolve_annotation_name(name_node.right)
      else
        "Unknown"
      end
    end

    private def lower_string_interpolation(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::StringInterpolationNode) : ValueId
      # String interpolation "Hello #{x}!" becomes:
      # 1. Build string by concatenating parts
      # 2. For each Text piece: create string literal
      # 3. For each Expression piece: convert to string and concat
      #
      # For now, implement simple version that calls __crystal_v2_string_interpolate
      # with all parts as arguments

      parts = [] of ValueId

      node.pieces.each do |piece|
        case piece.kind
        when .text?
          # Simple text piece - create string literal
          text = piece.text || ""
          lit = Literal.new(ctx.next_id, TypeRef::STRING, text)
          ctx.emit(lit)
          parts << lit.id
        when .expression?
          # Expression piece - lower the expression
          if expr_id = piece.expr
            next if expr_id.invalid?
            val_id = lower_expr(ctx, expr_id)
            val_type = ctx.type_of(val_id)
            # Enum values have a user-defined TypeRef that the LLVM string
            # interpolation backend doesn't recognize → cast to the enum's
            # base integer type so they get converted to a number string.
            enum_name = @enum_value_types.try(&.[val_id]?)
            if enum_name.nil? && val_type.id >= TypeRef::FIRST_USER_TYPE
              type_name = get_type_name_from_ref(val_type)
              enum_name = type_name if @enum_info.try(&.has_key?(type_name))
            end
            if enum_name
              base = enum_base_type(enum_name)
              if val_type != base
                cast = Cast.new(ctx.next_id, base, val_id, base, safe: false)
                ctx.emit(cast)
                ctx.register_type(cast.id, base)
                val_id = cast.id
              end
            end
            parts << val_id
          end
        end
      end

      # For simple case with one text part, return it directly
      if parts.size == 1 && node.pieces.first?.try(&.kind.text?)
        return parts.first
      end

      # Create StringInterpolation HIR instruction
      interp = StringInterpolation.new(ctx.next_id, parts)
      ctx.emit(interp)
      interp.id
    end

    private def lower_char(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::CharNode) : ValueId
      # Convert Slice(UInt8) to Char - first char of the slice
      char_value = String.new(node.value)[0]? || '\0'
      lit = Literal.new(ctx.next_id, TypeRef::CHAR, char_value)
      ctx.emit(lit)
      lit.id
    end

    private def lower_bool(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::BoolNode) : ValueId
      lit = Literal.new(ctx.next_id, TypeRef::BOOL, node.value)
      ctx.emit(lit)
      lit.id
    end

    private def lower_nil(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::NilNode) : ValueId
      lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(lit)
      lit.id
    end

    private def lower_symbol(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::SymbolNode) : ValueId
      str = String.new(node.name)
      lit = Literal.new(ctx.next_id, TypeRef::SYMBOL, str)
      ctx.emit(lit)
      lit.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # VARIABLE LOWERING
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_identifier(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::IdentifierNode) : ValueId
      name = String.new(node.name)

      case name
      when "__FILE__"
        path = source_path_for(@arena) || ""
        lit = Literal.new(ctx.next_id, TypeRef::STRING, path)
        ctx.emit(lit)
        return lit.id
      when "__DIR__"
        path = source_path_for(@arena) || ""
        dir = path.empty? ? "" : File.dirname(path)
        lit = Literal.new(ctx.next_id, TypeRef::STRING, dir)
        ctx.emit(lit)
        return lit.id
      when "__LINE__"
        line = node.span.start_line
        lit = Literal.new(ctx.next_id, TypeRef::INT32, line.to_i64)
        ctx.emit(lit)
        return lit.id
      when "__END_LINE__"
        line = node.span.end_line
        lit = Literal.new(ctx.next_id, TypeRef::INT32, line.to_i64)
        ctx.emit(lit)
        return lit.id
      end

      # Check if it's a local variable first
      if local_id = ctx.lookup_local(name)
        # Return a copy/reference to the local
        copy = Copy.new(ctx.next_id, ctx.type_of(local_id), local_id)
        ctx.emit(copy)
        ctx.mark_type_literal(copy.id) if ctx.type_literal?(local_id)
        if enum_name = @enum_value_types.try(&.[local_id]?)
          enum_map = @enum_value_types ||= {} of ValueId => String
          enum_map[copy.id] = enum_name
        end
        # Propagate proc captures through copies
        if caps = @proc_captures_by_value[local_id]?
          @proc_captures_by_value[copy.id] = caps
        end
        return copy.id
      else
        # Local not found - try inline caller locals for block bodies
        if @inline_yield_block_body_depth > 0
          # Inline-yield block bodies should be able to see caller locals. When a
          # block references an outer local (e.g. kevent inside get? { ... }),
          # fall back to the inline caller locals instead of creating a new void local.
          if value_id = inline_caller_local_id(name)
            ctx.register_local(name, value_id)
            copy = Copy.new(ctx.next_id, ctx.type_of(value_id), value_id)
            ctx.emit(copy)
            ctx.mark_type_literal(copy.id) if ctx.type_literal?(value_id)
            if enum_name = @enum_value_types.try(&.[value_id]?)
              enum_map = @enum_value_types ||= {} of ValueId => String
              enum_map[copy.id] = enum_name
            end
            return copy.id
          end
        end
        # Debug statements - non-blocking
        if env_get("DEBUG_FORMAT_LOCAL") && name == "format"
          STDERR.puts "[FORMAT_LOCAL] missing name=#{name} scope=#{@current_class || "nil"}##{@current_method || "nil"}"
        elsif env_get("DEBUG_BLOCK_PARAMS") && name.starts_with?("__arg")
          STDERR.puts "[BLOCK_PARAMS] missing_local name=#{name} scope=#{ctx.current_scope}"
        end
      end

      if mapped = @type_param_map[name]?
        if literal = literal_for_type_param_value(mapped)
          lit = Literal.new(ctx.next_id, literal[0], literal[1])
          ctx.emit(lit)
          return lit.id
        end
      end

      if name[0].uppercase?
        resolved = resolve_type_name_in_context(name)
        resolved = resolve_type_alias_chain(resolved)
        if env_get("DEBUG_THREAD_NAME") && name == "Thread"
          STDERR.puts "[DEBUG_THREAD_NAME] name=#{name} resolved=#{resolved} current=#{@current_class || "nil"} ns_override=#{@current_namespace_override || "nil"} type_exists=#{type_name_exists?(resolved)}"
        end
        return lower_type_literal_from_name(ctx, resolved) if type_name_exists?(resolved)
      end

      if full_name = resolve_constant_name_in_context(name)
        return emit_constant_get(ctx, full_name)
      end

      if macro_lookup = lookup_macro_entry(name, @current_class)
        macro_entry, macro_key = macro_lookup
        macro_def, macro_arena = macro_entry
        return expand_macro(ctx, macro_def, macro_arena, [] of ExprId, nil, nil, macro_key)
      end

      # Inside a class: check if it's a method call on self (e.g., getter without parens)
      if current_class = @current_class
        if name == "ord" && current_class == "Char"
          self_id = emit_self(ctx)
          cast = Cast.new(ctx.next_id, TypeRef::INT32, self_id, TypeRef::INT32)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT32)
          return cast.id
        end

        if name == "unsafe_chr"
          case current_class
          when "Int8", "Int16", "Int32", "Int64", "Int128",
               "UInt8", "UInt16", "UInt32", "UInt64", "UInt128"
            self_id = emit_self(ctx)
            cast = Cast.new(ctx.next_id, TypeRef::CHAR, self_id, TypeRef::CHAR)
            ctx.emit(cast)
            ctx.register_type(cast.id, TypeRef::CHAR)
            return cast.id
          end
        end

        # Check if method exists in current class (with inheritance)
        class_method_base = resolve_method_with_inheritance(current_class, name)
        if class_method_base
          # This is a method call on self with no arguments
          self_id = emit_self(ctx)
          full_name = mangle_function_name(class_method_base, [] of TypeRef)
          return_type = @function_types[full_name]? || TypeRef::VOID
          lower_function_if_needed(full_name)
          if return_type == TypeRef::VOID
            return_type = get_function_return_type(full_name)
            if return_type == TypeRef::VOID && full_name != class_method_base
              return_type = get_function_return_type(class_method_base)
            end
          end
          call = Call.new(ctx.next_id, return_type, self_id, full_name, [] of ValueId)
          ctx.emit(call)
          ctx.register_type(call.id, return_type)
          if function_returns_type_literal?(full_name, class_method_base)
            ctx.mark_type_literal(call.id)
          end
          # Track enum return type for predicate method inlining
          if enum_name = enum_return_name_for(full_name)
            (@enum_value_types ||= {} of ValueId => String)[call.id] = enum_name
          end
          return call.id
        end

        # Module/class method call without parens (e.g., class_getter inside module)
        module_method_base = resolve_class_method_with_inheritance(current_class, name)
        if module_method_base.nil?
          if find_module_class_def(current_class, name, 0)
            module_method_base = "#{current_class}.#{name}"
          end
        end
        if module_method_base && (@function_types.has_key?(module_method_base) || has_function_base?(module_method_base) || @class_accessor_entries.has_key?(module_method_base))
          full_name = mangle_function_name(module_method_base, [] of TypeRef)
          return_type = @function_types[full_name]? || @function_types[module_method_base]? || TypeRef::VOID
          lower_function_if_needed(full_name)
          if return_type == TypeRef::VOID
            return_type = get_function_return_type(full_name)
            if return_type == TypeRef::VOID && full_name != module_method_base
              return_type = get_function_return_type(module_method_base)
            end
          end
          call = Call.new(ctx.next_id, return_type, nil, full_name, [] of ValueId)
          ctx.emit(call)
          ctx.register_type(call.id, return_type)
          if function_returns_type_literal?(full_name, module_method_base)
            ctx.mark_type_literal(call.id)
          end
          # Track enum return type for predicate method inlining
          if enum_name = enum_return_name_for(full_name)
            (@enum_value_types ||= {} of ValueId => String)[call.id] = enum_name
          end
          return call.id
        end
      end

      # Top-level: treat `main` as a function call when a top-level main is defined.
      if @current_class.nil? && name == "main" && @top_level_main_defined
        full_name = mangle_function_name(TOP_LEVEL_MAIN_BASE, [] of TypeRef)
        return_type = @function_types[full_name]? || TypeRef::VOID
        lower_function_if_needed(full_name)
        call = Call.new(ctx.next_id, return_type, nil, full_name, [] of ValueId)
        ctx.emit(call)
        ctx.register_type(call.id, return_type)
        return call.id
      end

      # Top-level function fallback: if no local/constant resolved, treat bare
      # identifier as a zero-arg call when a top-level function exists.
      if @function_defs.has_key?(name) || @function_types.has_key?(name) || has_function_base?(name)
        full_name = mangle_function_name(name, [] of TypeRef)
        return_type = @function_types[full_name]? || @function_types[name]? || TypeRef::VOID
        lower_function_if_needed(full_name)
        if return_type == TypeRef::VOID
          return_type = get_function_return_type(full_name)
          if return_type == TypeRef::VOID && full_name != name
            return_type = get_function_return_type(name)
          end
        end
        call = Call.new(ctx.next_id, return_type, nil, full_name, [] of ValueId)
        ctx.emit(call)
        ctx.register_type(call.id, return_type)
        if function_returns_type_literal?(full_name, name)
          ctx.mark_type_literal(call.id)
        end
        if enum_name = enum_return_name_for(full_name)
          (@enum_value_types ||= {} of ValueId => String)[call.id] = enum_name
        end
        return call.id
      end

      # Otherwise create a new local (first use)
      local = Local.new(ctx.next_id, TypeRef::VOID, name, ctx.current_scope)
      ctx.emit(local)
      ctx.register_local(name, local.id)
      local.id
    end

    private def lower_instance_var(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::InstanceVarNode) : ValueId
      name = String.new(node.name)

      # Get the type and offset of the instance variable from current class
      ivar_type = TypeRef::VOID
      ivar_offset = 0
      class_name = @current_class
      ivar_owner = class_name
      ivar_found = false
      debug_filter = env_get("DEBUG_IVAR")
      debug_trace = debug_filter ? [] of String : nil
      search_name = class_name
      while search_name
        if class_info = @class_info[search_name]?
          if debug_trace
            debug_trace << "#{search_name}(ivars=#{class_info.ivars.size})"
          end
          class_info.ivars.each do |ivar|
            if ivar.name == name
              ivar_found = true
              ivar_type = ivar.type
              ivar_offset = ivar.offset
              ivar_owner = search_name
              break
            end
          end
          break if ivar_found
          parent_name = class_info.parent_name
          parent_name ||= @module.class_parents[search_name]?
          search_name = parent_name
        else
          break
        end
      end
      # Search included modules when ivar not found in parent chain.
      # Module names may use aliases (e.g. Engine::MatchData → Regex::PCRE2::MatchData),
      # so resolve through type_alias_chain before class_info lookup.
      unless ivar_found
        if class_name
          if modules = @class_included_modules[class_name]?
            modules.each do |mod_name|
              resolved_mod = resolve_type_alias_chain(mod_name)
              candidates = [mod_name]
              candidates << resolved_mod unless resolved_mod == mod_name
              candidates.each do |candidate|
                if mod_info = @class_info[candidate]?
                  mod_info.ivars.each do |ivar|
                    if ivar.name == name
                      ivar_found = true
                      ivar_type = ivar.type
                      ivar_offset = ivar.offset
                      ivar_owner = candidate
                      break
                    end
                  end
                end
                break if ivar_found
              end
              break if ivar_found
            end
          end
        end
      end
      if debug_trace && class_name
        filter = debug_filter.not_nil!
        if filter.empty? || class_name.includes?(filter) || name == filter
          type_name = get_type_name_from_ref(ivar_type)
          owner_name = ivar_owner || "nil"
          ivar_names = @class_info[class_name]?.try(&.ivars.map(&.name).join(",")) || "none"
          modules = @class_included_modules[class_name]?.try(&.join(",")) || "none"
          # Find matching class_info entries for the module
          match_keys = @class_info.keys.select { |k| k.includes?("MatchData") && !k.starts_with?("Regex::MatchData") }.first(5).join(",")
          alias_val = resolve_type_alias_chain("Engine::MatchData")
          STDERR.puts "[IVAR] class=#{class_name} name=#{name} owner=#{owner_name} found=#{ivar_found} type=#{type_name} trace=#{debug_trace.join("->")} ivars=[#{ivar_names}] modules=[#{modules}] match_keys=[#{match_keys}] alias=#{alias_val}"
        end
      end

      # If ivar type is still VOID, try to find a getter method as fallback
      # This handles cases where ivars are defined implicitly (e.g., @ivar = value in initialize)
      if !ivar_found && ivar_type == TypeRef::VOID && (class_name = @current_class)
        # Try to find getter method: @bytesize -> bytesize()
        accessor_name = name.lchop('@')
        # IMPORTANT: Don't call getter if we're inside that getter method!
        # This prevents infinite recursion in `def x; @x; end`
        current_method_name = @current_method
        is_inside_getter = current_method_name && current_method_name == accessor_name

        unless is_inside_getter
          getter_base = resolve_method_with_inheritance(class_name, accessor_name)
          if getter_base
            # Found a getter method - emit as method call instead of field get
            self_id = emit_self(ctx)
            full_name = mangle_function_name(getter_base, [] of TypeRef)
            return_type = @function_types[full_name]? || TypeRef::VOID
            # Ensure the getter method is lowered
            remember_callsite_arg_types(full_name, [] of TypeRef)
            lower_function_if_needed(full_name)
            call = Call.new(ctx.next_id, return_type, self_id, full_name, [] of ValueId)
            ctx.emit(call)
            ctx.register_type(call.id, return_type)
            return call.id
          end
        end
      end

      # Instance var access is a field get on self
      self_id = emit_self(ctx)
      field_get = FieldGet.new(ctx.next_id, ivar_type, self_id, name, ivar_offset)
      ctx.emit(field_get)
      ctx.register_type(field_get.id, ivar_type) # Register type for is_a?/case checks
      if ivar_owner
        if enum_name = @enum_ivar_types.try(&.[ivar_owner]?).try(&.[name]?)
          (@enum_value_types ||= {} of ValueId => String)[field_get.id] = enum_name
        end
      end
      field_get.id
    end

    private def lower_class_var(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::ClassVarNode) : ValueId
      # Name includes @@ prefix, strip it
      raw_name = String.new(node.name)
      name = raw_name.lstrip('@')
      cvar_type = get_class_var_type(name)
      class_name = @current_class || ""
      if cvar_type == TypeRef::VOID
        if inferred = infer_class_var_type_from_owner(@current_class, name)
          cvar_type = inferred
        end
      end
      class_var_get = ClassVarGet.new(ctx.next_id, cvar_type, class_name, name)
      ctx.emit(class_var_get)
      ctx.register_type(class_var_get.id, cvar_type)
      if enum_name = @enum_cvar_types.try(&.[class_name]?).try(&.[name]?)
        (@enum_value_types ||= {} of ValueId => String)[class_var_get.id] = enum_name
      end
      class_var_get.id
    end

    private def lower_self(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::SelfNode) : ValueId
      emit_self(ctx)
    end

    # Lower implicit object (like .foo syntax) - treated as self
    private def lower_self_implicit(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::ImplicitObjNode) : ValueId
      emit_self(ctx)
    end

    # Lower super call - calls parent class method with same name
    private def lower_super(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::SuperNode) : ValueId
      class_name = @current_class
      method_name = @current_method

      unless class_name && method_name
        # Fallback: return void
        void_lit = Literal.new(ctx.next_id, TypeRef::VOID, 0_i64)
        ctx.emit(void_lit)
        return void_lit.id
      end

      # Find parent class
      class_info = @class_info[class_name]?
      if class_info.nil?
        class_base = strip_generic_args(class_name)
        class_info = @class_info[class_base]?
      end
      parent_name = class_info.try(&.parent_name)

      # Lower arguments first to get their types
      args = if node_args = node.args
               node_args.reject(&.invalid?).map { |arg| lower_expr(ctx, arg) }
             else
               # If no args, forward current method's parameters
               # Get them from the function context (skip 'self' param at index 0)
               ctx.function.params[1..].map(&.id)
             end

      # Get argument types for mangling
      arg_types = args.map { |arg| ctx.type_of(arg) }

      previous_base = "#{class_name}##{method_name}_previous"
      if entry = lookup_function_def_for_call(previous_base, args.size, false, arg_types)
        actual_prev_name, actual_prev_def = entry
        if params = actual_prev_def.params
          param_count = params.count { |p| !p.is_block && !named_only_separator?(p) }
          if param_count > args.size
            param_idx = 0
            params.each do |param|
              next if param.is_block || named_only_separator?(param)
              if param_idx >= args.size
                if default_val = param.default_value
                  default_id = lower_expr(ctx, default_val)
                  args << default_id
                else
                  nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                  ctx.emit(nil_lit)
                  ctx.register_type(nil_lit.id, TypeRef::NIL)
                  args << nil_lit.id
                end
              end
              param_idx += 1
            end
          end
        end
        arg_types = args.map { |arg| ctx.type_of(arg) }
        remember_callsite_arg_types(actual_prev_name, arg_types, nil, nil, false)
        lower_function_if_needed(actual_prev_name)
        return_type = @function_types[actual_prev_name]? || TypeRef::VOID
        self_id = emit_self(ctx)
        call = Call.new(ctx.next_id, return_type, self_id, actual_prev_name, args)
        ctx.emit(call)
        ctx.register_type(call.id, return_type)
        return call.id
      end

      if class_info
        class_lookup = class_name
        class_base = strip_generic_args(class_name)
        included = @class_included_modules[class_lookup]? || @class_included_modules[class_base]?
        if included
          included.to_a.sort.each do |module_name|
            module_base = strip_generic_args(resolve_module_alias_for_include(module_name))
            # Skip the module that provided the current _super body to avoid infinite recursion.
            # E.g., IO::FileDescriptor includes IO::Buffered; IO::Buffered#write_byte calls super
            # → should skip IO::Buffered and go to parent class IO, not back to IO::Buffered.
            if skip_mod = @current_super_source_module
              next if module_base == skip_mod || module_name == skip_mod
            end
            visited = Set(String).new
            if found = find_module_def_recursive(module_base, method_name, args.size, visited)
              actual_func_def = found[0]
              def_arena = found[1]
              if params = actual_func_def.params
                param_count = params.count { |p| !p.is_block && !named_only_separator?(p) }
                if param_count > args.size
                  param_idx = 0
                  params.each do |param|
                    next if param.is_block || named_only_separator?(param)
                    if param_idx >= args.size
                      if default_val = param.default_value
                        default_id = lower_expr(ctx, default_val)
                        args << default_id
                      else
                        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                        ctx.emit(nil_lit)
                        ctx.register_type(nil_lit.id, TypeRef::NIL)
                        args << nil_lit.id
                      end
                    end
                    param_idx += 1
                  end
                end
              end
              arg_types = args.map { |arg| ctx.type_of(arg) }
              super_base = "#{class_name}##{method_name}_super"
              super_name = mangle_function_name(super_base, arg_types)
              unless @module.has_function?(super_name)
                receiver_map = type_param_map_for_receiver_name("#{class_name}##{method_name}")
                old_super_source = @current_super_source_module
                @current_super_source_module = module_base
                with_arena(def_arena) do
                  with_type_param_map(receiver_map) do
                    lower_method(class_name, class_info, actual_func_def, arg_types, nil, nil, super_name, force_class_method: @current_method_is_class)
                  end
                end
                @current_super_source_module = old_super_source
              end
              return_type = @function_types[super_name]? || TypeRef::VOID
              self_id = emit_self(ctx)
              call = Call.new(ctx.next_id, return_type, self_id, super_name, args)
              ctx.emit(call)
              ctx.register_type(call.id, return_type)
              return call.id
            end
          end
        end
      end

      unless parent_name
        # No parent - return void
        void_lit = Literal.new(ctx.next_id, TypeRef::VOID, 0_i64)
        ctx.emit(void_lit)
        return void_lit.id
      end

      # Find the method in parent class with proper mangling
      base_method_name = "#{parent_name}##{method_name}"
      super_method_name = mangle_function_name(base_method_name, arg_types)

      # Try to find the actual function definition - it might have more parameters with defaults
      actual_func_name = super_method_name
      actual_func_def : CrystalV2::Compiler::Frontend::DefNode? = nil

      # First try exact match
      if func_def = @function_defs[super_method_name]?
        actual_func_def = func_def
      elsif entry = lookup_function_def_for_call(base_method_name, args.size, false, arg_types)
        actual_func_name, actual_func_def = entry
        if actual_func_name != super_method_name
          super_method_name = actual_func_name
        end
      elsif func_def = @function_defs[base_method_name]?
        actual_func_def = func_def
        actual_func_name = base_method_name
      else
        # No matching overload found; keep default mangled name.
      end

      # If we found a method with more parameters, fill in defaults for missing args
      if actual_func_def && actual_func_name != super_method_name
        if params = actual_func_def.params
          # Count non-block, non-separator parameters
          param_count = params.count { |p| !p.is_block && !named_only_separator?(p) }

          if param_count > args.size
            # Need to fill in default values for missing arguments
            param_idx = 0
            params.each do |param|
              next if param.is_block || named_only_separator?(param)
              if param_idx >= args.size
                # This parameter needs a default value
                if default_val = param.default_value
                  default_id = lower_expr(ctx, default_val)
                  args << default_id
                else
                  # No default - use nil
                  nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                  ctx.emit(nil_lit)
                  ctx.register_type(nil_lit.id, TypeRef::NIL)
                  args << nil_lit.id
                end
              end
              param_idx += 1
            end
          end
        end
        super_method_name = actual_func_name
      end

      # Get return type from mangled name
      return_type = @function_types[super_method_name]? || TypeRef::VOID

      # Get self for the call
      self_id = emit_self(ctx)

      # Ensure parent method is lowered
      if env_has?("DEBUG_SUPER")
        STDERR.puts "[DEBUG_SUPER] lower_super: class=#{class_name} method=#{method_name}"
        STDERR.puts "[DEBUG_SUPER]   parent=#{parent_name}"
        STDERR.puts "[DEBUG_SUPER]   base_method_name=#{base_method_name}"
        STDERR.puts "[DEBUG_SUPER]   super_method_name=#{super_method_name}"
        STDERR.puts "[DEBUG_SUPER]   function_defs.has_key?(super)=#{@function_defs.has_key?(super_method_name)}"
        STDERR.puts "[DEBUG_SUPER]   function_defs.has_key?(base)=#{@function_defs.has_key?(base_method_name)}"
      end
      lower_function_if_needed(super_method_name)

      # Call parent method
      call = Call.new(ctx.next_id, return_type, self_id, super_method_name, args)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      call.id
    end

    private def lower_previous_def(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::PreviousDefNode) : ValueId
      # previous_def calls the previous definition of the current method
      # This is used when reopening classes/methods
      class_name = @current_class
      method_name = @current_method

      unless class_name && method_name
        # No current method context - return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      # Lower arguments first to get their types
      args = if node_args = node.args
               node_args.reject(&.invalid?).map { |arg| lower_expr(ctx, arg) }
             else
               # If no args, forward current method's parameters
               # Get them from the function context (skip 'self' param at index 0)
               ctx.function.params[1..].map(&.id)
             end

      # Get argument types for mangling
      arg_types = args.map { |arg| ctx.type_of(arg) }

      # For previous_def, we call the same method with a _previous suffix
      # The actual linking will resolve this (or fail if no previous def exists)
      base_method_name = "#{class_name}##{method_name}_previous"
      previous_method_name = mangle_function_name(base_method_name, arg_types)

      # Get return type (fallback to VOID if unknown)
      return_type = @function_types[previous_method_name]? || TypeRef::VOID

      if return_type == TypeRef::VOID && method_name == "value"
        enum_owner = class_name == "Enum" ? "Enum" : (class_name ? resolve_enum_name(class_name) : nil)
        if enum_owner
          self_id = emit_self(ctx)
          desired = ctx.function.return_type
          if desired != ctx.type_of(self_id)
            cast = Cast.new(ctx.next_id, desired, self_id, desired)
            ctx.emit(cast)
            ctx.register_type(cast.id, desired)
            return cast.id
          end
          return self_id
        end
      end

      # Get self for the call
      self_id = emit_self(ctx)

      # Call previous method definition
      call = Call.new(ctx.next_id, return_type, self_id, previous_method_name, args)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      call.id
    end

    private def path_is_absolute?(node : CrystalV2::Compiler::Frontend::PathNode) : Bool
      source = @sources_by_arena[@arena]?
      if source
        span = node.span
        if span.start_offset >= 0 && span.start_offset + 1 < source.bytesize
          return true if source.byte_slice(span.start_offset, 2) == "::"
        end
        if span.start_offset >= 2
          return true if source.byte_slice(span.start_offset - 2, 2) == "::"
        end
      end

      left_id = node.left
      return true unless left_id

      left_node = @arena[left_id]
      if left_node.is_a?(CrystalV2::Compiler::Frontend::PathNode)
        return path_is_absolute?(left_node)
      end

      if source.nil? &&
         (left_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) ||
         left_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode))
        gap = left_node.span.start_offset - node.span.start_offset
        return true if gap >= 2
      end

      !(left_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) ||
        left_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode))
    end

    # Collect full path string from PathNode (e.g., Foo::Bar::Baz -> "Foo::Bar::Baz")
    private def collect_path_string(node : CrystalV2::Compiler::Frontend::PathNode) : String
      parts = [] of String
      absolute = path_is_absolute?(node)

      # Get left part recursively
      if left_id = node.left
        left_node = @arena[left_id]
        case left_node
        when CrystalV2::Compiler::Frontend::PathNode
          # Recursively collect left path
          left_path = collect_path_string(left_node)
          if left_path.starts_with?("::")
            absolute = true
            left_path = left_path.size > 2 ? left_path[2..] : ""
          end
          parts << left_path unless left_path.empty?
        when CrystalV2::Compiler::Frontend::IdentifierNode
          parts << String.new(left_node.name)
        when CrystalV2::Compiler::Frontend::ConstantNode
          parts << String.new(left_node.name)
        else
          # Unexpected left node: treat as absolute path to avoid namespace capture.
          absolute = true
        end
      else
        # A PathNode without a left part represents an absolute path (::Foo::Bar).
        absolute = true
      end

      # Get right part
      right_node = @arena[node.right]
      case right_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        parts << String.new(right_node.name)
      when CrystalV2::Compiler::Frontend::ConstantNode
        parts << String.new(right_node.name)
      when CrystalV2::Compiler::Frontend::PathNode
        right_path = collect_path_string(right_node)
        if right_path.starts_with?("::")
          absolute = true
          right_path = right_path.size > 2 ? right_path[2..] : ""
        end
        parts << right_path unless right_path.empty?
      end

      path = parts.join("::")
      absolute ? "::#{path}" : path
    end

    # Lower path expression (e.g., Color::Green for enums, or Module::Constant)
    private def lower_path(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::PathNode) : ValueId
      # Extract left and right parts
      # For Color::Green: left = Color (IdentifierNode), right = Green (IdentifierNode)
      left_name : String? = nil
      if left_id = node.left
        left_node = @arena[left_id]
        left_name = case left_node
                    when CrystalV2::Compiler::Frontend::IdentifierNode
                      String.new(left_node.name)
                    when CrystalV2::Compiler::Frontend::ConstantNode
                      String.new(left_node.name)
                    when CrystalV2::Compiler::Frontend::PathNode
                      collect_path_string(left_node)
                    else
                      nil
                    end
      end

      right_node = @arena[node.right]
      right_name = case right_node
                   when CrystalV2::Compiler::Frontend::IdentifierNode
                     String.new(right_node.name)
                   when CrystalV2::Compiler::Frontend::ConstantNode
                     String.new(right_node.name)
                   else
                     nil
                   end

      raw_path = collect_path_string(node)

      # Check if this is an enum value access
      if left_name && right_name
        resolved_left = resolve_path_string_in_context(left_name)
        if enum_info = @enum_info
          if members = enum_info[resolved_left]?
            if right_name[0]?.try(&.uppercase?)
              value = members[right_name]? || 0_i64
              # Found enum value - emit as base literal but remember enum type.
              enum_type = enum_base_type(resolved_left)
              lit = Literal.new(ctx.next_id, enum_type, value)
              ctx.emit(lit)
              (@enum_value_types ||= {} of ValueId => String)[lit.id] = resolved_left
              return lit.id
            end
          end
        end
      end
      # Fallback: resolve enum value by full path prefix (handles nested paths).
      if right_name && raw_path.includes?("::")
        if idx = raw_path.rindex("::")
          prefix = raw_path[0, idx]
          prefix = prefix.starts_with?("::") ? (prefix.size > 2 ? prefix[2..] : "") : prefix
          resolved_prefix = resolve_path_string_in_context(prefix)
          if enum_info = @enum_info
            if members = enum_info[resolved_prefix]?
              if right_name[0]?.try(&.uppercase?)
                value = members[right_name]? || 0_i64
                enum_type = enum_base_type(resolved_prefix)
                lit = Literal.new(ctx.next_id, enum_type, value)
                ctx.emit(lit)
                (@enum_value_types ||= {} of ValueId => String)[lit.id] = resolved_prefix
                return lit.id
              end
            end
          end
        end
      end

      # Substitute type params in path prefix (e.g., D::CACHE -> ImplInfo_Float32::CACHE)
      substituted_path = substitute_type_params_in_type_name(raw_path)
      full_path = resolve_path_string_in_context(substituted_path)
      if mapped = @type_param_map[full_path]?
        if literal = literal_for_type_param_value(mapped)
          lit = Literal.new(ctx.next_id, literal[0], literal[1])
          ctx.emit(lit)
          return lit.id
        end
      end
      if type_name_exists?(full_path) || @type_aliases.has_key?(full_path) || @generic_templates.has_key?(full_path)
        return lower_type_literal_from_name(ctx, full_path)
      end

      if full_name = resolve_constant_name_in_context(full_path)
        return emit_constant_get(ctx, full_name)
      end

      # If we're inside a function that returns a type literal, treat unresolved
      # constant paths as type literals to avoid falling back to Int32.
      if right_name && right_name[0]?.try(&.uppercase?)
        if current_method = @current_method
          if current_class = @current_class
            sep = @current_method_is_class ? "." : "#"
            base_name = "#{current_class}#{sep}#{current_method}"
            if @function_return_type_literals.includes?(base_name)
              return lower_type_literal_from_name(ctx, full_path)
            end
          end
        end
      end

      # Fallback: treat as constant or module access (for future expansion)
      # For now, just return 0
      if full_path.includes?("Kqueue") || full_path.includes?("EventLoop")
        STDERR.puts "[PATH_FALLBACK] full_path=#{full_path} raw_path=#{raw_path} exists=#{type_name_exists?(full_path)} class_info=#{@class_info.has_key?(full_path)} func=#{ctx.function.name} class=#{@current_class} method=#{@current_method}"
      end
      lit = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(lit)
      lit.id
    end

    private def lower_global(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::GlobalNode) : ValueId
      name = String.new(node.name)
      # Global variables are like class vars at top level
      class_var_get = ClassVarGet.new(ctx.next_id, TypeRef::VOID, "$", name)
      class_var_get.lifetime = LifetimeTag::GlobalEscape
      ctx.emit(class_var_get)
      class_var_get.id
    end

    private def emit_self(ctx : LoweringContext) : ValueId
      # Check if we have a 'self' local
      if self_id = ctx.lookup_local("self")
        return self_id
      end
      param = ctx.function.params.find { |p| p.name == "self" }
      if param.nil? && ctx.function.name.includes?('#')
        param = ctx.function.params.first?
      end
      if param
        ctx.register_local("self", param.id)
        ctx.register_type(param.id, param.type)
        return param.id
      end

      # Create implicit self parameter
      local_type = TypeRef::VOID
      if @current_method_is_class
        if current = @current_class
          resolved = resolve_type_alias_chain(substitute_type_params_in_type_name(current))
          inferred = type_ref_for_name(resolved)
          local_type = inferred unless inferred == TypeRef::VOID
        end
      end
      local = Local.new(ctx.next_id, local_type, "self", ctx.current_scope, mutable: false)
      ctx.emit(local)
      ctx.register_local("self", local.id)
      if local_type != TypeRef::VOID
        ctx.register_type(local.id, local_type)
        ctx.mark_type_literal(local.id) if @current_method_is_class
      end
      local.id
    end

    # Lower a generic type reference like Array(Int32), Hash(String, Int32)
    # This is used when calling static methods like Array(Int32).new
    private def lower_generic_type_ref(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::GenericNode) : ValueId
      # Extract base type name
      base_name = resolve_path_like_name(node.base_type) || "Unknown"
      base_name = resolve_type_name_in_context(base_name)
      base_name = resolve_type_alias_chain(base_name)

      # Extract type arguments, substituting any type parameters
      normalize_typeof_name = ->(type_name : String) : String {
        # Keep unions in generic args (e.g. `Slice(Int32 | Pointer(UInt8))`),
        # otherwise we lose specialization and end up with `Pointer(Void)`-based
        # instantiations like `Indexable::ItemIterator(Pointer(Void), Pointer(Void))`.
        if type_name == "Void" || type_name == "Unknown"
          "Pointer(Void)"
        else
          type_name
        end
      }

      type_args = node.type_args.map do |arg_id|
        arg_node = @arena[arg_id]
        arg_name = case arg_node
                   when CrystalV2::Compiler::Frontend::TypeofNode
                     inner = arg_node.args.first?
                     resolved = inner ? resolve_typeof_expr(inner) : nil
                     if (resolved.nil? || resolved == "Pointer(Void)") && inner
                       inner_node = @arena[inner]
                       if inner_node.is_a?(CrystalV2::Compiler::Frontend::YieldNode)
                         # typeof(yield ...) — try the inline block return stack
                         if @inline_yield_block_return_stack.size > 0
                           if block_ret = @inline_yield_block_return_stack.last?
                             resolved = block_ret unless block_ret.nil? || block_ret.empty? || block_ret == "Void"
                           end
                         end
                         if (resolved.nil? || resolved == "Pointer(Void)")
                           # Try the type parameter T from block signature (& : T ->)
                           if @type_param_map["T"]?
                             resolved = @type_param_map["T"]
                           end
                         end
                       end
                     end
                     resolved || "Pointer(Void)"
                   else
                     stringify_type_expr(arg_id) || "Unknown"
                   end
        arg_name = resolve_typeof_in_type_string(arg_name)
        # If typeof(yield ...) resolved to Pointer(Void), try __block_return__
        # from function_type_param_maps (set by callers with known block types).
        if arg_name == "Pointer(Void)" || arg_name.empty?
          raw = if arg_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
                  String.new(arg_node.name)
                else
                  ""
                end
          if raw.includes?("typeof(yield")
            func_name = ctx.function.name
            base_func = func_name.sub(/\$.*$/, "") # strip suffix
            # 1. Check inline block return stack (available during inline expansion)
            if @inline_yield_block_return_stack.size > 0
              if br = @inline_yield_block_return_stack.last?
                arg_name = br unless br.empty? || br == "Void" || br == "Unknown"
              end
            end
            # 2. Check function_type_param_maps (set by callers before lowering)
            if arg_name == "Pointer(Void)" || arg_name.empty?
              if br = @function_type_param_maps.dig?(func_name, "__block_return__")
                arg_name = br
              elsif br = @function_type_param_maps.dig?(base_func, "__block_return__")
                arg_name = br
              elsif br = @type_param_map["__block_return__"]?
                arg_name = br unless br.empty? || br == "Void" || br == "Unknown"
              end
            end
          end
        end
        arg_name = normalize_typeof_name.call(arg_name)
        arg_name = resolve_type_name_in_context(arg_name)
        arg_name = substitute_type_params_in_type_name(arg_name)
        normalize_tuple_literal_type_name(arg_name)
      end

      # Create specialized class name like Array(Int32)
      class_name = "#{base_name}(#{type_args.join(", ")})"
      class_name = substitute_type_params_in_type_name(class_name)

      # Monomorphize if needed
      if !@monomorphized.includes?(class_name)
        monomorphize_generic_class(base_name, type_args, class_name)
      end

      # Return a type reference literal (for use as receiver in static calls)
      # We use a nil literal with special type tracking
      type_ref = @class_info[class_name]?.try(&.type_ref) || TypeRef::VOID
      if env_get("CRYSTAL_V2_TYPE_LITERAL_ALLOC")
        if class_info = @class_info[class_name]?
          generate_allocator(class_name, class_info)
        end
      end
      lit = Literal.new(ctx.next_id, type_ref, nil)
      ctx.emit(lit)
      ctx.register_type(lit.id, type_ref)
      ctx.mark_type_literal(lit.id)
      @type_literal_values.add(lit.id)
      lit.id
    end

    private def lower_type_literal_from_name(ctx : LoweringContext, type_name : String) : ValueId
      type_name = resolve_type_name_in_context(type_name)
      type_name = substitute_type_params_in_type_name(type_name)
      if info = split_generic_base_and_args(type_name)
        base_name = resolve_type_alias_chain(info[:base])
        type_args = split_generic_type_args(info[:args]).map do |arg|
          arg = substitute_type_params_in_type_name(arg)
          normalize_tuple_literal_type_name(arg)
        end
        type_name = "#{base_name}(#{type_args.join(", ")})"
        if base_name != "Proc" && !@monomorphized.includes?(type_name)
          monomorphize_generic_class(base_name, type_args, type_name)
        end
      else
        type_name = resolve_type_alias_chain(type_name)
      end
      if env_get("CRYSTAL_V2_TYPE_LITERAL_ALLOC")
        if class_info = @class_info[type_name]?
          generate_allocator(type_name, class_info)
        end
      end
      type_ref = type_ref_for_name(type_name)
      lit = Literal.new(ctx.next_id, type_ref, nil)
      ctx.emit(lit)
      ctx.register_type(lit.id, type_ref)
      ctx.mark_type_literal(lit.id)
      @type_literal_values.add(lit.id)
      lit.id
    end

    private def resolve_type_literal_class_name(type_name : String) : String?
      return nil unless type_name.ends_with?(".class") || type_name.ends_with?(".metaclass")
      cache_key = type_cache_key(type_name)
      if @type_literal_class_cache.has_key?(cache_key)
        return @type_literal_class_cache[cache_key]
      end

      base_name = type_name
      base_name = base_name.sub(/\.class$/, "")
      base_name = base_name.sub(/\.metaclass$/, "")
      if base_name.empty?
        @type_literal_class_cache[cache_key] = nil
        return nil
      end

      base_name = resolve_type_name_in_context(base_name)
      base_name = substitute_type_params_in_type_name(base_name)
      if info = split_generic_base_and_args(base_name)
        generic_base = resolve_type_alias_chain(info[:base])
        type_args = split_generic_type_args(info[:args]).map do |arg|
          arg = substitute_type_params_in_type_name(arg)
          normalize_tuple_literal_type_name(arg)
        end
        class_name = "#{generic_base}(#{type_args.join(", ")})"
        class_name = substitute_type_params_in_type_name(class_name)
        if generic_base != "Proc" && !@monomorphized.includes?(class_name)
          monomorphize_generic_class(generic_base, type_args, class_name)
        end
        @type_literal_class_cache[cache_key] = class_name
        return class_name
      end

      resolved = resolve_type_alias_chain(base_name)
      @type_literal_class_cache[cache_key] = resolved
      resolved
    end

    # ═══════════════════════════════════════════════════════════════════════
    # BINARY/UNARY OPERATIONS
    # ═══════════════════════════════════════════════════════════════════════

    private def is_comparison_op?(op : String) : Bool
      op == "<" || op == "<=" || op == ">" || op == ">=" || op == "==" || op == "!="
    end

    private def lower_binary(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::BinaryNode) : ValueId
      op_str = node.operator_string
      if op_str == "&&" || op_str == "||"
        return lower_short_circuit(ctx, node, op_str)
      end

      # Chained comparison: a <= b <= c → (a <= b) && (b <= c)
      # Detect when left operand is a BinaryNode with a comparison operator
      # and current operator is also a comparison.
      if is_comparison_op?(op_str)
        left_node = @arena[node.left]
        if left_node.is_a?(CrystalV2::Compiler::Frontend::BinaryNode) && is_comparison_op?(left_node.operator_string)
          # Lower left comparison: a op1 b
          left_comp_id = lower_binary(ctx, left_node)
          left_type = ctx.type_of(left_comp_id)
          cond_id = lower_truthy_check(ctx, left_comp_id, left_type)

          pre_branch_locals = ctx.save_locals

          then_block = ctx.create_block
          else_block = ctx.create_block
          merge_block = ctx.create_block

          ctx.terminate(Branch.new(cond_id, then_block, else_block))

          # Then block: evaluate right comparison (b op2 c)
          ctx.current_block = then_block
          ctx.restore_locals(pre_branch_locals)
          # Re-lower the middle expression (b) for the right comparison
          middle_id = lower_expr(ctx, left_node.right)
          right_id = lower_expr(ctx, node.right)

          # Emit the right comparison as inline binary op
          right_op = case op_str
                     when "<"  then BinaryOp::Lt
                     when "<=" then BinaryOp::Le
                     when ">"  then BinaryOp::Gt
                     when ">=" then BinaryOp::Ge
                     when "==" then BinaryOp::Eq
                     when "!=" then BinaryOp::Ne
                     else           BinaryOp::Eq
                     end
          right_comp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, right_op, middle_id, right_id)
          ctx.emit(right_comp)
          ctx.register_type(right_comp.id, TypeRef::BOOL)
          then_result = right_comp.id
          then_exit = ctx.current_block
          ctx.terminate(Jump.new(merge_block))

          # Else block: result is false
          ctx.current_block = else_block
          ctx.restore_locals(pre_branch_locals)
          false_lit = Literal.new(ctx.next_id, TypeRef::BOOL, 0_i64)
          ctx.emit(false_lit)
          ctx.register_type(false_lit.id, TypeRef::BOOL)
          else_result = false_lit.id
          else_exit = ctx.current_block
          ctx.terminate(Jump.new(merge_block))

          # Merge block: phi
          ctx.current_block = merge_block
          phi = Phi.new(ctx.next_id, TypeRef::BOOL,
            [{then_exit, then_result}, {else_exit, else_result}])
          ctx.emit(phi)
          ctx.register_type(phi.id, TypeRef::BOOL)
          return phi.id
        end
      end

      left_id = lower_expr(ctx, node.left)
      right_id = lower_expr(ctx, node.right)

      # Cast enum-typed operands to their base integer type.
      # Enum values from getters have a user-defined TypeRef (e.g., Color) that is
      # not recognized as numeric, causing == to dispatch to Object#== instead of icmp.
      # Detect by checking @enum_value_types or @enum_info for the type name.
      {% for side in ["left", "right"] %}
        %type = ctx.type_of({{side.id}}_id)
        %enum_name = @enum_value_types.try(&.[{{side.id}}_id]?)
        if %enum_name.nil? && %type.id >= TypeRef::FIRST_USER_TYPE
          %type_name = get_type_name_from_ref(%type)
          if @enum_info.try(&.has_key?(%type_name))
            %enum_name = %type_name
          end
        end
        if %enum_name
          %base = enum_base_type(%enum_name)
          if %type != %base
            %cast = Cast.new(ctx.next_id, %base, {{side.id}}_id, %base, safe: false)
            ctx.emit(%cast)
            ctx.register_type(%cast.id, %base)
            {{side.id}}_id = %cast.id
          end
        end
      {% end %}

      # Check for pointer arithmetic: ptr + n or ptr - n
      left_type = ctx.type_of(left_id)
      left_desc = @module.get_type_descriptor(left_type)
      is_pointer_type = left_type == TypeRef::POINTER || (left_desc && left_desc.kind == TypeKind::Pointer)
      right_type = ctx.type_of(right_id)
      right_desc = @module.get_type_descriptor(right_type)
      right_is_pointer = right_type == TypeRef::POINTER || (right_desc && right_desc.kind == TypeKind::Pointer)

      # Pointer difference: ptr - ptr -> element count
      if is_pointer_type && right_is_pointer && op_str == "-"
        element_type = if left_desc && left_desc.kind == TypeKind::Pointer
                         pointer_element_type(left_desc.name)
                       else
                         TypeRef::INT32
                       end
        element_size = type_size(element_type)
        element_size = 1 if element_size <= 0

        left_int = Cast.new(ctx.next_id, TypeRef::INT64, left_id, TypeRef::INT64)
        ctx.emit(left_int)
        ctx.register_type(left_int.id, TypeRef::INT64)
        right_int = Cast.new(ctx.next_id, TypeRef::INT64, right_id, TypeRef::INT64)
        ctx.emit(right_int)
        ctx.register_type(right_int.id, TypeRef::INT64)

        diff = BinaryOperation.new(ctx.next_id, TypeRef::INT64, BinaryOp::Sub, left_int.id, right_int.id)
        ctx.emit(diff)
        ctx.register_type(diff.id, TypeRef::INT64)
        return diff.id if element_size == 1

        size_lit = Literal.new(ctx.next_id, TypeRef::INT64, element_size.to_i64)
        ctx.emit(size_lit)
        ctx.register_type(size_lit.id, TypeRef::INT64)
        div = BinaryOperation.new(ctx.next_id, TypeRef::INT64, BinaryOp::Div, diff.id, size_lit.id)
        ctx.emit(div)
        ctx.register_type(div.id, TypeRef::INT64)
        return div.id
      end
      if is_pointer_type && (op_str == "+" || op_str == "-")
        offset_id = right_id
        # For subtraction, negate the offset
        if op_str == "-"
          neg_one = Literal.new(ctx.next_id, TypeRef::INT32, -1_i64)
          ctx.emit(neg_one)
          ctx.register_type(neg_one.id, TypeRef::INT32)
          neg_offset = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Mul, offset_id, neg_one.id)
          ctx.emit(neg_offset)
          ctx.register_type(neg_offset.id, TypeRef::INT32)
          offset_id = neg_offset.id
        end
        element_type = if left_desc && left_desc.kind == TypeKind::Pointer
                         pointer_element_type(left_desc.name)
                       else
                         TypeRef::INT32
                       end
        element_type = TypeRef::INT32 if element_type == TypeRef::VOID
        result_type = left_desc && left_desc.kind == TypeKind::Pointer ? left_type : TypeRef::POINTER
        add_node = PointerAdd.new(ctx.next_id, result_type, left_id, offset_id, element_type)
        ctx.emit(add_node)
        ctx.register_type(add_node.id, result_type)
        return add_node.id
      end

      # Check for string concatenation: String + String -> StringConcat
      left_type = ctx.type_of(left_id)
      if left_type == TypeRef::STRING && op_str == "+"
        # String concatenation - emit as StringInterpolation with two parts
        interp = StringInterpolation.new(ctx.next_id, [left_id, right_id])
        ctx.emit(interp)
        return interp.id
      end

      # Check for Array + Array → __crystal_v2_array_concat
      if op_str == "+"
        left_desc2 = @module.get_type_descriptor(left_type)
        if left_desc2 && left_desc2.kind == TypeKind::Array && left_desc2.name.starts_with?("Array(")
          # Determine element size from array element type
          elem_name = left_desc2.name[6...-1]  # Extract "Int32" from "Array(Int32)"
          elem_size = case elem_name
                      when "Bool", "Int8", "UInt8" then 1
                      when "Int16", "UInt16"       then 2
                      when "Int32", "UInt32", "Float32", "Char" then 4
                      else 8  # Int64, UInt64, Float64, String, ptr, class instances
                      end
          # Emit element size literal
          sz_lit = Literal.new(ctx.next_id, TypeRef::INT32, elem_size.to_i64)
          ctx.emit(sz_lit)
          ctx.register_type(sz_lit.id, TypeRef::INT32)
          # Call __crystal_v2_array_concat(left, right, elem_size) → ptr (Array)
          ext_call = ExternCall.new(ctx.next_id, left_type, "__crystal_v2_array_concat", [left_id, right_id, sz_lit.id])
          ctx.emit(ext_call)
          ctx.register_type(ext_call.id, left_type)
          return ext_call.id
        end
      end

      # Check for string repetition: String * Int -> __crystal_v2_string_repeat
      if (left_type == TypeRef::STRING || left_type == TypeRef::POINTER) && op_str == "*"
        # String repetition - emit as extern call (returns Crystal String ptr)
        ext_call = ExternCall.new(ctx.next_id, TypeRef::STRING, "__crystal_v2_string_repeat", [left_id, right_id])
        ctx.emit(ext_call)
        ctx.register_type(ext_call.id, TypeRef::STRING)
        return ext_call.id
      end

      # Check for shovel operator << on non-integer types (IO, Array, etc.)
      # If left operand is pointer or union type and operator is <<, emit as method call
      # This handles io << value and arr << elem, which are NOT bit-shift but append
      is_integer_type = (left_type.id >= TypeRef::INT8.id && left_type.id <= TypeRef::INT128.id) ||
                        (left_type.id >= TypeRef::UINT8.id && left_type.id <= TypeRef::UINT128.id)
      if !is_integer_type && op_str == "<<"
        if right_type == TypeRef::VOID && left_desc && left_desc.kind == TypeKind::Array
          if inferred = left_desc.type_params.first?
            if inferred != TypeRef::VOID
              right_type = inferred
              ctx.register_type(right_id, right_type)
            end
          end
        end
        # Emit as method call: left.<<(right)
        # The method is registered as "#<<" in the function_types
        ensure_monomorphized_type(left_type) unless left_type == TypeRef::VOID
        right_type = ctx.type_of(right_id)
        type_desc = @module.get_type_descriptor(left_type)
        class_name = type_desc.try(&.name) || ""
        class_name = normalize_method_owner_name(class_name)
        base_method_name = class_name.empty? ? "<<" : "#{class_name}#<<"
        primary_mangled_name = mangle_function_name(base_method_name, [right_type])
        # Debug: log the resolution attempt
        if env_has?("DEBUG_SHOVEL")
          type_desc = @module.get_type_descriptor(left_type)
          STDERR.puts "[SHOVEL] left_type=#{left_type.id}, type_desc=#{type_desc.try(&.name) || "nil"}, right_type=#{right_type.id}"
        end
        method_name = resolve_method_call(ctx, left_id, "<<", [right_type], false)
        if env_has?("DEBUG_SHOVEL")
          STDERR.puts "[SHOVEL] resolved to: #{method_name}"
        end
        # Convert .class type literal to String when used as << argument (e.g., io << self.class)
        # For static (monomorphized) methods, use compile-time class name string.
        # For dynamic dispatch (union types), will use __crystal_v2_type_name(type_id) in the future.
        if ctx.dot_class_literal?(right_id)
          dcl_class_name = get_type_name_from_ref(right_type)
          unless dcl_class_name.empty?
            str_lit = Literal.new(ctx.next_id, TypeRef::STRING, dcl_class_name)
            ctx.emit(str_lit)
            ctx.register_type(str_lit.id, TypeRef::STRING)
            right_id = str_lit.id
            right_type = TypeRef::STRING
            primary_mangled_name = mangle_function_name(base_method_name, [right_type])
            method_name = resolve_method_call(ctx, left_id, "<<", [right_type], false)
          end
        end

        remember_callsite_arg_types(primary_mangled_name, [right_type])
        if method_name != primary_mangled_name
          remember_callsite_arg_types(method_name, [right_type])
        end
        callsite_label = nil
        if DebugHooks::ENABLED
          span = node.span
          receiver_name = type_name_for_mangling(left_type)
          callsite_label = "func=#{ctx.function.name} method=<< full=#{method_name} class=#{@current_class || ""} recv=#{receiver_name} span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column}"
        end
        with_debug_callsite(callsite_label) do
          lower_function_if_needed(primary_mangled_name)
          if method_name != primary_mangled_name
            lower_function_if_needed(method_name)
          end
        end
        call = Call.new(ctx.next_id, left_type, left_id, method_name, [right_id])
        ctx.emit(call)
        ctx.register_type(call.id, left_type)
        return call.id
      end

      # String == / != must use content comparison, not pointer comparison.
      # Intercept here and emit a call to __crystal_v2_string_eq runtime helper.
      if left_type == TypeRef::STRING && (op_str == "==" || op_str == "!=")
        call = Call.new(ctx.next_id, TypeRef::BOOL, left_id, "__crystal_v2_string_eq", [right_id])
        ctx.emit(call)
        ctx.register_type(call.id, TypeRef::BOOL)
        if op_str == "!="
          # Negate the result for !=
          neg = UnaryOperation.new(ctx.next_id, TypeRef::BOOL, UnaryOp::Not, call.id)
          ctx.emit(neg)
          ctx.register_type(neg.id, TypeRef::BOOL)
          return neg.id
        end
        return call.id
      end

      # For non-primitive types (struct/class), arithmetic operators should be method calls.
      # This handles Slice#+, Time#-, etc.
      is_float_type = left_type == TypeRef::FLOAT32 || left_type == TypeRef::FLOAT64
      is_primitive = is_integer_type || is_float_type || is_pointer_type ||
                     left_type == TypeRef::BOOL || left_type == TypeRef::CHAR ||
                     left_type == TypeRef::STRING || left_type == TypeRef::NIL ||
                     left_type == TypeRef::VOID
      if !is_primitive && (op_str == "+" || op_str == "-" || op_str == "*" || op_str == "/" || op_str == "%" ||
                            op_str == "===" || op_str == "==" || op_str == "!=" ||
                            op_str == "<" || op_str == "<=" || op_str == ">" || op_str == ">=")
        return emit_binary_call(ctx, left_id, op_str, right_id)
      end

      op = case op_str
           when "+"  then BinaryOp::Add
           when "-"  then BinaryOp::Sub
           when "*"  then BinaryOp::Mul
           when "/"  then BinaryOp::Div
           when "//" then BinaryOp::Div # Floor division - use Div (truncation) for now
           when "%"  then BinaryOp::Mod
           when "&"  then BinaryOp::BitAnd
           when "|"  then BinaryOp::BitOr
           when "^"  then BinaryOp::BitXor
           when "<<" then BinaryOp::Shl
           when ">>" then BinaryOp::Shr
           when "==", "===" then BinaryOp::Eq
           when "!=" then BinaryOp::Ne
           when "<"  then BinaryOp::Lt
           when "<=" then BinaryOp::Le
           when ">"  then BinaryOp::Gt
           when ">=" then BinaryOp::Ge
             # Wrapping operators - map to same ops (LLVM integer ops already wrap)
           when "&+" then BinaryOp::Add
           when "&-" then BinaryOp::Sub
           when "&*" then BinaryOp::Mul
           else
             # Unknown operator - emit as method call
             return emit_binary_call(ctx, left_id, op_str, right_id)
           end

      result_type = if op.eq? || op.ne? || op.lt? || op.le? || op.gt? || op.ge? || op.and? || op.or?
                      TypeRef::BOOL
                    else
                      # For arithmetic ops, infer type from left operand
                      ctx.type_of(left_id)
                    end

      binop = BinaryOperation.new(ctx.next_id, result_type, op, left_id, right_id)
      ctx.emit(binop)
      binop.id
    end

    # Lower short-circuiting || and && with value semantics (returns last evaluated value).
    private def lower_short_circuit(
      ctx : LoweringContext,
      node : CrystalV2::Compiler::Frontend::BinaryNode,
      op_str : String,
    ) : ValueId
      left_id = lower_expr(ctx, node.left)
      left_type = ctx.type_of(left_id)

      cond_id = lower_truthy_check(ctx, left_id, left_type)

      pre_branch_locals = ctx.save_locals

      then_block = ctx.create_block
      else_block = ctx.create_block
      merge_block = ctx.create_block

      ctx.terminate(Branch.new(cond_id, then_block, else_block))

      # then: left is truthy
      ctx.current_block = then_block
      ctx.restore_locals(pre_branch_locals)
      then_value = if op_str == "||"
                     left_id
                   else
                     lower_expr(ctx, node.right)
                   end
      # In the then-branch, `left` is proven truthy by `cond_id`.
      # For common nilable unions (T | Nil), narrow to the non-nil payload so
      # `x || y` returns `T` (not `T | Nil`) and downstream overload selection
      # doesn't accidentally pick slice/Range paths (e.g. `arr[idx]`).
      if op_str == "||"
        then_type = ctx.type_of(then_value)
        then_value = unwrap_non_nil_to_block(ctx, ctx.current_block, then_value, then_type)
      end
      then_exit = ctx.current_block
      then_locals = ctx.save_locals
      then_block_data = ctx.get_block(ctx.current_block)
      then_has_noreturn = then_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
      then_flows_to_merge = then_block_data.terminator.is_a?(Unreachable) && !then_has_noreturn
      if then_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      # else: left is falsy
      ctx.current_block = else_block
      ctx.restore_locals(pre_branch_locals)
      else_value = if op_str == "||"
                     lower_expr(ctx, node.right)
                   else
                     left_id
                   end
      else_exit = ctx.current_block
      else_locals = ctx.save_locals
      else_block_data = ctx.get_block(ctx.current_block)
      else_has_noreturn = else_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
      else_flows_to_merge = else_block_data.terminator.is_a?(Unreachable) && !else_has_noreturn
      if else_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      if op_str == "||" && else_has_noreturn
        then_type = ctx.type_of(then_value)
        then_value = unwrap_non_nil_to_block(ctx, then_exit, then_value, then_type)
      end

      ctx.current_block = merge_block

      if then_flows_to_merge || else_flows_to_merge
        if then_flows_to_merge && else_flows_to_merge
          # Merge locals and result value
          merge_branch_locals(ctx, pre_branch_locals, then_locals, else_locals, then_exit, else_exit)

          then_type = ctx.type_of(then_value)
          else_type = ctx.type_of(else_value)
          phi_type = union_type_for_values(then_type, else_type)

          if phi_type == TypeRef::VOID || phi_type == TypeRef::NIL
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            return nil_lit.id
          end

          incoming = [{then_exit, then_value}, {else_exit, else_value}]
          coerced_incoming = incoming.map do |(blk, val)|
            val_type = ctx.type_of(val)
            if val_type == phi_type
              {blk, val}
            elsif is_union_type?(phi_type)
              variant_id = get_union_variant_id(phi_type, val_type)
              if variant_id >= 0
                wrap = UnionWrap.new(ctx.next_id, phi_type, val, variant_id)
                ctx.emit_to_block(blk, wrap)
                {blk, wrap.id}
              else
                {blk, val}
              end
            elsif numeric_primitive?(val_type) && numeric_primitive?(phi_type)
              cast = Cast.new(ctx.next_id, phi_type, val, phi_type, safe: false)
              ctx.emit_to_block(blk, cast)
              {blk, cast.id}
            else
              {blk, val}
            end
          end

          phi = Phi.new(ctx.next_id, phi_type)
          coerced_incoming.each do |exit_block, value|
            phi.add_incoming(exit_block, value)
          end
          ctx.emit(phi)
          ctx.register_type(phi.id, phi_type)
          return phi.id
        elsif then_flows_to_merge
          then_locals.each { |name, val| ctx.register_local(name, val) }
          return then_value
        else
          else_locals.each { |name, val| ctx.register_local(name, val) }
          return else_value
        end
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def truthy_narrowing_targets(condition_id : ExprId) : Array(String)
      return [] of String if condition_id.invalid?

      node = @arena[condition_id]
      case node
      when CrystalV2::Compiler::Frontend::GroupingNode
        truthy_narrowing_targets(node.expression)
      when CrystalV2::Compiler::Frontend::IdentifierNode
        [String.new(node.name)]
      when CrystalV2::Compiler::Frontend::AssignNode
        target = @arena[node.target]
        if target.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          [String.new(target.name)]
        else
          [] of String
        end
      when CrystalV2::Compiler::Frontend::BinaryNode
        op = String.new(node.operator)
        if op == "&&"
          left = truthy_narrowing_targets(node.left)
          right = truthy_narrowing_targets(node.right)
          right.each { |entry| left << entry }
          left
        else
          [] of String
        end
      else
        [] of String
      end
    end

    # Lower short-circuiting || and && for condition context (branches directly).
    private def lower_short_circuit_condition(
      ctx : LoweringContext,
      node : CrystalV2::Compiler::Frontend::BinaryNode,
      then_block : BlockId,
      else_block : BlockId,
    ) : Nil
      op_str = node.operator_string
      left_id = lower_expr(ctx, node.left)
      left_type = ctx.type_of(left_id)
      left_cond = lower_truthy_check(ctx, left_id, left_type)

      rhs_block = ctx.create_block
      static_left = static_truthy_value(ctx, left_cond)
      static_left = static_truthy_value(ctx, left_id) if static_left.nil?
      unless static_left.nil?
        if op_str == "&&"
          if static_left
            ctx.terminate(Jump.new(rhs_block))
            ctx.current_block = rhs_block
            lower_condition_branch(ctx, node.right, then_block, else_block)
          else
            ctx.terminate(Jump.new(else_block))
          end
        else
          if static_left
            ctx.terminate(Jump.new(then_block))
          else
            ctx.terminate(Jump.new(rhs_block))
            ctx.current_block = rhs_block
            lower_condition_branch(ctx, node.right, then_block, else_block)
          end
        end
        return
      end
      if op_str == "&&"
        ctx.terminate(Branch.new(left_cond, rhs_block, else_block))
        ctx.current_block = rhs_block
        lower_condition_branch(ctx, node.right, then_block, else_block)
      else
        ctx.terminate(Branch.new(left_cond, then_block, rhs_block))
        ctx.current_block = rhs_block
        lower_condition_branch(ctx, node.right, then_block, else_block)
      end
    end

    private def static_truthy_value(ctx : LoweringContext, value_id : ValueId) : Bool?
      if value = ctx.value_for(value_id)
        if value.is_a?(Literal)
          return false if value.type == TypeRef::NIL
          if value.type == TypeRef::BOOL
            return value.value.as(Bool)
          end
        end
      end

      value_type = ctx.type_of(value_id)
      return false if value_type == TypeRef::NIL
      nil
    end

    private def lower_condition_branch(
      ctx : LoweringContext,
      expr_id : ExprId,
      then_block : BlockId,
      else_block : BlockId,
    ) : Nil
      expr_node = @arena[expr_id]
      if expr_node.is_a?(CrystalV2::Compiler::Frontend::BinaryNode)
        op_str = expr_node.operator_string
        if op_str == "&&" || op_str == "||"
          lower_short_circuit_condition(ctx, expr_node, then_block, else_block)
          return
        end
      end

      cond_id = lower_expr(ctx, expr_id)
      cond_type = ctx.type_of(cond_id)
      cond_bool = lower_truthy_check(ctx, cond_id, cond_type)
      ctx.terminate(Branch.new(cond_bool, then_block, else_block))
    end

    private def static_is_a_condition_value(ctx : LoweringContext, condition_id : ExprId) : Bool?
      return nil if condition_id.invalid?

      node = @arena[condition_id]
      case node
      when CrystalV2::Compiler::Frontend::GroupingNode
        static_is_a_condition_value(ctx, node.expression)
      when CrystalV2::Compiler::Frontend::BinaryNode
        op = node.operator_string
        if op == "&&" || op == "||"
          left = static_is_a_condition_value(ctx, node.left)
          right = static_is_a_condition_value(ctx, node.right)
          return nil if left.nil? || right.nil?
          return op == "&&" ? (left && right) : (left || right)
        end
        nil
      when CrystalV2::Compiler::Frontend::UnaryNode
        op = String.new(node.operator)
        return nil unless op == "!"
        inner = static_is_a_condition_value(ctx, node.operand)
        inner.nil? ? nil : !inner
      when CrystalV2::Compiler::Frontend::IsANode
        expr_node = @arena[node.expression]
        return nil unless expr_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
        local_id = ctx.lookup_local(String.new(expr_node.name))
        return nil unless local_id
        value_type = ctx.type_of(local_id)
        target_name = resolve_typeof_in_type_string(String.new(node.target_type))
        target_type = type_ref_for_name(target_name)
        statically_is_a_type?(value_type, target_type)
      when CrystalV2::Compiler::Frontend::CallNode
        callee_node = @arena[node.callee]
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
           String.new(callee_node.member) == "is_a?" &&
           node.args.size == 1
          obj_node = @arena[callee_node.object]
          return nil unless obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          local_id = ctx.lookup_local(String.new(obj_node.name))
          return nil unless local_id
          value_type = ctx.type_of(local_id)
          if type_str = stringify_type_expr(node.args.first)
            type_str = resolve_typeof_in_type_string(type_str)
            target_type = type_ref_for_name(type_str)
            return statically_is_a_type?(value_type, target_type)
          end
        end
        nil
      else
        nil
      end
    end

    private def static_instance_var_type_ref(name : String) : TypeRef?
      search_name = @current_class
      while search_name
        if class_info = @class_info[search_name]?
          class_info.ivars.each do |ivar|
            return ivar.type if ivar.name == name
          end
          parent_name = class_info.parent_name
          parent_name ||= @module.class_parents[search_name]?
          search_name = parent_name
        else
          break
        end
      end
      nil
    end

    private def static_nil_condition_value(ctx : LoweringContext, condition_id : ExprId) : Bool?
      return nil if condition_id.invalid?

      node = @arena[condition_id]
      case node
      when CrystalV2::Compiler::Frontend::GroupingNode
        static_nil_condition_value(ctx, node.expression)
      when CrystalV2::Compiler::Frontend::BinaryNode
        op = node.operator_string
        if op == "&&" || op == "||"
          left = static_nil_condition_value(ctx, node.left)
          right = static_nil_condition_value(ctx, node.right)
          return nil if left.nil? || right.nil?
          return op == "&&" ? (left && right) : (left || right)
        end
        nil
      when CrystalV2::Compiler::Frontend::UnaryNode
        op = String.new(node.operator)
        return nil unless op == "!"
        inner = static_nil_condition_value(ctx, node.operand)
        inner.nil? ? nil : !inner
      when CrystalV2::Compiler::Frontend::CallNode
        callee_node = @arena[node.callee]
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
           String.new(callee_node.member) == "nil?" &&
           node.args.empty?
          recv_node = @arena[callee_node.object]
          recv_type : TypeRef? = nil
          case recv_node
          when CrystalV2::Compiler::Frontend::IdentifierNode
            if local_id = ctx.lookup_local(String.new(recv_node.name))
              recv_type = ctx.type_of(local_id)
            end
          when CrystalV2::Compiler::Frontend::InstanceVarNode
            recv_type = static_instance_var_type_ref(String.new(recv_node.name))
          end

          return nil unless recv_type
          return true if recv_type == TypeRef::NIL
          # Non-union, non-nil type => cannot be nil.
          unless is_union_type?(recv_type)
            return false
          end
          # Union without Nil variant => cannot be nil.
          return false if get_union_variant_id(recv_type, TypeRef::NIL) < 0
          # Nilable union => unknown at compile time.
          return nil
        end
        nil
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # Some nil? predicates are represented as bare member access nodes.
        return nil unless String.new(node.member) == "nil?"

        recv_node = @arena[node.object]
        recv_type2 : TypeRef? = nil
        case recv_node
        when CrystalV2::Compiler::Frontend::IdentifierNode
          if local_id = ctx.lookup_local(String.new(recv_node.name))
            recv_type2 = ctx.type_of(local_id)
          end
        when CrystalV2::Compiler::Frontend::InstanceVarNode
          recv_type2 = static_instance_var_type_ref(String.new(recv_node.name))
        end

        return nil unless recv_type2
        return true if recv_type2 == TypeRef::NIL
        unless is_union_type?(recv_type2)
          return false
        end
        return false if get_union_variant_id(recv_type2, TypeRef::NIL) < 0
        nil
      else
        nil
      end
    end

    private def is_a_narrowing_targets(condition_id : ExprId) : Array(Tuple(String, TypeRef))
      return [] of Tuple(String, TypeRef) if condition_id.invalid?

      node = @arena[condition_id]
      case node
      when CrystalV2::Compiler::Frontend::GroupingNode
        is_a_narrowing_targets(node.expression)
      when CrystalV2::Compiler::Frontend::BinaryNode
        op = String.new(node.operator)
        if op == "&&"
          left = is_a_narrowing_targets(node.left)
          right = is_a_narrowing_targets(node.right)
          right.each { |entry| left << entry }
          left
        else
          [] of Tuple(String, TypeRef)
        end
      when CrystalV2::Compiler::Frontend::IsANode
        target_name = resolve_typeof_in_type_string(String.new(node.target_type))
        target_type = type_ref_for_name(target_name)
        expr_node = @arena[node.expression]
        if expr_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          [{String.new(expr_node.name), target_type}]
        else
          [] of Tuple(String, TypeRef)
        end
      when CrystalV2::Compiler::Frontend::CallNode
        callee_node = @arena[node.callee]
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
           String.new(callee_node.member) == "is_a?" &&
           node.args.size == 1
          obj_node = @arena[callee_node.object]
          if obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            if type_str = stringify_type_expr(node.args.first)
              type_str = resolve_typeof_in_type_string(type_str)
              target_type = type_ref_for_name(type_str)
              return [{String.new(obj_node.name), target_type}]
            end
          end
        end
        [] of Tuple(String, TypeRef)
      else
        [] of Tuple(String, TypeRef)
      end
    end

    private def apply_truthy_narrowing(ctx : LoweringContext, targets : Array(String)) : Nil
      return if targets.empty?

      targets.each do |name|
        local_id = ctx.lookup_local(name)
        next unless local_id
        local_type = ctx.type_of(local_id)
        next unless is_union_or_nilable_type?(local_type)

        unwrapped = lower_not_nil_intrinsic(ctx, local_id, local_type)
        next if unwrapped == local_id

        ctx.register_local(name, unwrapped)
      end
    end

    private def apply_is_a_narrowing(ctx : LoweringContext, targets : Array(Tuple(String, TypeRef))) : Nil
      return if targets.empty?

      targets.each do |(name, target_type)|
        next if target_type == TypeRef::VOID
        local_id = ctx.lookup_local(name)
        next unless local_id
        local_type = ctx.type_of(local_id)
        next if local_type == target_type

        if is_union_type?(local_type)
          variant_id = get_union_variant_id(local_type, target_type)
          if variant_id >= 0
            unwrap = UnionUnwrap.new(ctx.next_id, target_type, local_id, variant_id, false)
            ctx.emit(unwrap)
            ctx.register_type(unwrap.id, target_type)
            ctx.register_local(name, unwrap.id)
            next
          end
        end

        cast = Cast.new(ctx.next_id, target_type, local_id, target_type, safe: false)
        ctx.emit(cast)
        ctx.register_type(cast.id, target_type)
        ctx.register_local(name, cast.id)
      end
    end

    private def emit_is_a_check(ctx : LoweringContext, value_id : ValueId, type_name : String) : ValueId
      resolved = resolve_typeof_in_type_string(type_name)
      if resolved.includes?('|')
        emit_is_a_check_for_type(ctx, value_id, type_ref_for_name(resolved))
      else
        resolved = resolve_type_name_in_context(resolved)
        resolved = resolve_type_alias_chain(resolved)
        # For primitive types, resolve is_a? against known abstract ancestors at compile time.
        # This avoids runtime type_id loads from value types (which crashes for i32/f64/etc.).
        value_type = ctx.type_of(value_id)
        if value_name = primitive_class_name(value_type)
          static_result = primitive_is_a_hierarchy?(value_name, resolved)
          unless static_result.nil?
            lit = Literal.new(ctx.next_id, TypeRef::BOOL, static_result)
            ctx.emit(lit)
            ctx.register_type(lit.id, TypeRef::BOOL)
            return lit.id
          end
        end
        emit_is_a_check_for_type(ctx, value_id, type_ref_for_name(resolved))
      end
    end

    # Statically resolve is_a? for primitive value types against known abstract ancestor types.
    # Returns true/false if deterministic, nil if unknown.
    private def primitive_is_a_hierarchy?(value_name : String, check_name : String) : Bool?
      return true if value_name == check_name
      signed_ints = {"Int8", "Int16", "Int32", "Int64", "Int128"}
      unsigned_ints = {"UInt8", "UInt16", "UInt32", "UInt64", "UInt128"}
      floats = {"Float32", "Float64"}
      is_signed = signed_ints.includes?(value_name)
      is_unsigned = unsigned_ints.includes?(value_name)
      is_float = floats.includes?(value_name)
      is_numeric = is_signed || is_unsigned || is_float
      return nil unless is_numeric
      case check_name
      when "Int::Signed"   then is_signed
      when "Int::Unsigned"  then is_unsigned
      when "Int::Primitive", "Int" then is_signed || is_unsigned
      when "Float::Primitive", "Float" then is_float
      when "Number::Primitive", "Number" then true
      when "Value", "Struct" then true
      when "Reference", "Object" then false
      else nil
      end
    end

    private def emit_is_a_check_for_type(ctx : LoweringContext, value_id : ValueId, check_type : TypeRef) : ValueId
      if is_union_type?(check_type)
        if type_desc = @module.get_type_descriptor(check_type)
          checks = type_desc.type_params.map { |variant| emit_is_a_check_for_type(ctx, value_id, variant) }
          return combine_boolean_checks(ctx, checks)
        end
      end

      value_type = ctx.type_of(value_id)
      if is_union_type?(value_type)
        variant_id = get_union_variant_id(value_type, check_type)
        if variant_id >= 0
          union_is = UnionIs.new(ctx.next_id, value_id, variant_id)
          ctx.emit(union_is)
          ctx.register_type(union_is.id, TypeRef::BOOL)
          return union_is.id
        end
      end

      static = statically_is_a_type?(value_type, check_type)
      unless static.nil?
        lit = Literal.new(ctx.next_id, TypeRef::BOOL, static)
        ctx.emit(lit)
        return lit.id
      end

      is_a = IsA.new(ctx.next_id, value_id, check_type)
      ctx.emit(is_a)
      is_a.id
    end

    private def statically_is_a_type?(value_type : TypeRef, check_type : TypeRef) : Bool?
      return true if value_type == check_type
      return nil if value_type == TypeRef::VOID || check_type == TypeRef::VOID

      if value_type == TypeRef::NIL
        return check_type == TypeRef::NIL
      end
      if check_type == TypeRef::NIL
        return false
      end

      if value_type.primitive? && check_type.primitive?
        return value_type == check_type
      end

      value_desc = @module.get_type_descriptor(value_type)
      check_desc = @module.get_type_descriptor(check_type)
      return nil unless value_desc && check_desc
      return nil if value_desc.kind == TypeKind::Union || check_desc.kind == TypeKind::Union
      return false if value_desc.kind == TypeKind::Primitive && check_desc.kind == TypeKind::Primitive

      value_name = value_desc.name
      check_name = check_desc.name
      return true if value_name == check_name

      # Walk UP from value_type: if check_type is an ancestor, return true
      current = @class_info[value_name]?
      while current
        parent = current.parent_name
        break unless parent
        return true if parent == check_name
        current = @class_info[parent]?
      end

      # Walk UP from check_type: if value_type is an ancestor of check_type,
      # then check_type is a subclass — can't determine statically (need runtime check)
      current = @class_info[check_name]?
      while current
        parent = current.parent_name
        break unless parent
        return nil if parent == value_name
        current = @class_info[parent]?
      end

      false
    end

    private def combine_boolean_checks(ctx : LoweringContext, checks : Array(ValueId)) : ValueId
      if checks.empty?
        lit = Literal.new(ctx.next_id, TypeRef::BOOL, false)
        ctx.emit(lit)
        return lit.id
      end

      result = checks.first
      checks[1..].each do |check_id|
        merged = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Or, result, check_id)
        ctx.emit(merged)
        ctx.register_type(merged.id, TypeRef::BOOL)
        result = merged.id
      end
      result
    end

    private def union_type_for_values(left_type : TypeRef, right_type : TypeRef) : TypeRef
      return left_type if left_type == right_type
      left_desc = @module.get_type_descriptor(left_type)
      right_desc = @module.get_type_descriptor(right_type)
      if left_desc && left_desc.kind == TypeKind::Union && right_desc && right_desc.kind == TypeKind::Union
        left_variants = split_union_type_name(left_desc.name)
        right_variants = split_union_type_name(right_desc.name)
        merged_names = merge_union_variant_names(left_variants + right_variants)
        return left_type if merged_names.size == left_variants.size && merged_names.size == right_variants.size
        return create_union_type(merged_names.join(" | "))
      end
      if left_desc && left_desc.kind == TypeKind::Union
        left_variants = split_union_type_name(left_desc.name)
        merged_names = merge_union_variant_names(left_variants + [get_type_name_from_ref(right_type)])
        return left_type if merged_names.size == left_variants.size
        return create_union_type(merged_names.join(" | "))
      end
      if right_desc && right_desc.kind == TypeKind::Union
        right_variants = split_union_type_name(right_desc.name)
        merged_names = merge_union_variant_names(right_variants + [get_type_name_from_ref(left_type)])
        return right_type if merged_names.size == right_variants.size
        return create_union_type(merged_names.join(" | "))
      end
      left_name = get_type_name_from_ref(left_type)
      right_name = get_type_name_from_ref(right_type)
      create_union_type("#{left_name} | #{right_name}")
    end

    private def merge_union_variant_names(variant_names : Array(String)) : Array(String)
      seen = Set(TypeRef).new
      merged = [] of String
      variant_names.each do |name|
        next if name.empty?
        ref = type_ref_for_name(name)
        next if seen.includes?(ref)
        seen << ref
        merged << get_type_name_from_ref(ref)
      end
      merged
    end

    private def lower_truthy_check(ctx : LoweringContext, value_id : ValueId, value_type : TypeRef) : ValueId
      if value_type == TypeRef::BOOL
        return value_id
      end

      if value_type == TypeRef::NIL || value_type == TypeRef::VOID
        lit = Literal.new(ctx.next_id, TypeRef::BOOL, false)
        ctx.emit(lit)
        return lit.id
      end

      if value_type == TypeRef::POINTER
        nil_val = Literal.new(ctx.next_id, TypeRef::POINTER, 0_i64)
        ctx.emit(nil_val)
        ne_check = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Ne, value_id, nil_val.id)
        ctx.emit(ne_check)
        return ne_check.id
      end

      # User-registered pointer types like Pointer(UInt8) also need null checks.
      # Our compiler heap-allocates structs, so these appear as user types, not TypeRef::POINTER.
      if value_type.id >= TypeRef::FIRST_USER_TYPE
        type_desc = @module.get_type_descriptor(value_type)
        if type_desc && type_desc.kind == TypeKind::Pointer
          nil_val = Literal.new(ctx.next_id, TypeRef::POINTER, 0_i64)
          ctx.emit(nil_val)
          ne_check = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Ne, value_id, nil_val.id)
          ctx.emit(ne_check)
          return ne_check.id
        end
      end

      if is_union_or_nilable_type?(value_type)
        is_nil = lower_nil_check_intrinsic(ctx, value_id, value_type)
        not_nil = UnaryOperation.new(ctx.next_id, TypeRef::BOOL, UnaryOp::Not, is_nil)
        ctx.emit(not_nil)
        ctx.register_type(not_nil.id, TypeRef::BOOL)
        return not_nil.id
      end

      # Non-nilable, non-bool types are always truthy.
      lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
      ctx.emit(lit)
      lit.id
    end

    private def emit_binary_call(ctx : LoweringContext, left : ValueId, op : String, right : ValueId) : ValueId
      # Qualify method name with receiver's class
      right_type = ctx.type_of(right)
      left_type = ctx.type_of(left)
      if env_get("DEBUG_COMPARE_OR_RAISE") && @current_method == "compare_or_raise"
        left_name = left_type == TypeRef::VOID ? "Void" : get_type_name_from_ref(left_type)
        right_name = right_type == TypeRef::VOID ? "Void" : get_type_name_from_ref(right_type)
        STDERR.puts "[COMPARE_OR_RAISE] op=#{op} left=#{left_name} right=#{right_name} current=#{@current_class || ""}##{@current_method || ""}"
      end
      # Special case: Object#<=> always returns nil (Object is not Comparable).
      # This matches the optimization in emit_call_expr.
      if op == "<=>"
        left_name = get_type_name_from_ref(left_type)
        if left_name == "Object" || left_name == "Unknown"
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(nil_lit)
          ctx.register_type(nil_lit.id, TypeRef::NIL)
          return nil_lit.id
        end
      end
      ensure_monomorphized_type(left_type) unless left_type == TypeRef::VOID
      type_desc = @module.get_type_descriptor(left_type)
      class_name = type_desc.try(&.name) || ""
      class_name = normalize_method_owner_name(class_name)
      base_method_name = class_name.empty? ? op : "#{class_name}##{op}"
      primary_mangled_name = mangle_function_name(base_method_name, [right_type])
      method_name = resolve_method_call(ctx, left, op, [right_type], false)
      remember_callsite_arg_types(primary_mangled_name, [right_type])
      if method_name != primary_mangled_name
        remember_callsite_arg_types(method_name, [right_type])
      end
      lower_function_if_needed(primary_mangled_name)
      if method_name != primary_mangled_name
        lower_function_if_needed(method_name)
      end
      # Infer return type: comparison ops return Bool, arithmetic ops return left type
      return_type = case op
                    when "==", "!=", "<", "<=", ">", ">=", "===", "<=>"
                      TypeRef::BOOL
                    else
                      left_type
                    end
      call = Call.new(ctx.next_id, return_type, left, method_name, [right])
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      call.id
    end

    private def lower_unary(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::UnaryNode) : ValueId
      operand_id = lower_expr(ctx, node.operand)

      op_str = String.new(node.operator)
      op = case op_str
           when "-" then UnaryOp::Neg
           when "!" then UnaryOp::Not
           when "~" then UnaryOp::BitNot
           else
             # Unknown unary op - emit as method call
             # Qualify method name with receiver's class
             operand_type = ctx.type_of(operand_id)
             ensure_monomorphized_type(operand_type) unless operand_type == TypeRef::VOID
             type_desc = @module.get_type_descriptor(operand_type)
             class_name = type_desc.try(&.name) || ""
             class_name = normalize_method_owner_name(class_name)
             base_method_name = class_name.empty? ? op_str : "#{class_name}##{op_str}"
             primary_mangled_name = mangle_function_name(base_method_name, [] of TypeRef)
             method_name = resolve_method_call(ctx, operand_id, op_str, [] of TypeRef, false)
             remember_callsite_arg_types(primary_mangled_name, [] of TypeRef)
             if method_name != primary_mangled_name
               remember_callsite_arg_types(method_name, [] of TypeRef)
             end
             lower_function_if_needed(primary_mangled_name)
             if method_name != primary_mangled_name
               lower_function_if_needed(method_name)
             end
             call = Call.new(ctx.next_id, TypeRef::VOID, operand_id, method_name, [] of ValueId)
             ctx.emit(call)
             return call.id
           end

      # Determine result type based on operation
      result_type = case op
                    when UnaryOp::Not
                      TypeRef::BOOL
                    when UnaryOp::Neg, UnaryOp::BitNot
                      # Negation and bitwise not preserve operand type
                      ctx.type_of(operand_id)
                    else
                      ctx.type_of(operand_id)
                    end
      unop = UnaryOperation.new(ctx.next_id, result_type, op, operand_id)
      ctx.emit(unop)
      unop.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # CONTROL FLOW
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_if(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::IfNode) : ValueId
      truthy_targets = truthy_narrowing_targets(node.condition)
      is_a_targets = is_a_narrowing_targets(node.condition)
      static_cond = static_is_a_condition_value(ctx, node.condition)
      static_cond = static_nil_condition_value(ctx, node.condition) if static_cond.nil?
      if !static_cond.nil? && (node.elsifs.nil? || node.elsifs.try(&.empty?))
        if static_cond
          ctx.push_scope(ScopeKind::Block)
          apply_truthy_narrowing(ctx, truthy_targets)
          apply_is_a_narrowing(ctx, is_a_targets)
          then_value = lower_body(ctx, node.then_body)
          ctx.pop_scope
          return then_value
        end

        ctx.push_scope(ScopeKind::Block)
        else_value = if else_body = node.else_body
                       if else_body.empty?
                         nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                         ctx.emit(nil_lit)
                         nil_lit.id
                       else
                         lower_body(ctx, else_body)
                       end
                     else
                       nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                       ctx.emit(nil_lit)
                       nil_lit.id
                     end
        ctx.pop_scope
        return else_value
      end

      merge_block = ctx.create_block

      # Collect all branches: (exit_block, value, locals, flows_to_merge)
      branches = [] of {BlockId, ValueId, Hash(String, ValueId), Bool}

      # Build the chain: if -> elsif1 -> elsif2 -> ... -> else
      # Each test that fails jumps to the next test block (or final else block)
      elsifs = node.elsifs
      has_elsifs = elsifs && !elsifs.empty?

      # Create blocks for the chain
      then_block = ctx.create_block
      next_test_block = if has_elsifs
                          ctx.create_block # First elsif test
                        else
                          ctx.create_block # Direct else block
                        end

      # Lower main condition and branch
      # NOTE: Condition must be evaluated BEFORE saving locals, because
      # 'out' parameters in the condition create new locals that must be
      # visible in both branches (e.g., `if func(out x) == -1 ... else ... x ...`)
      cond_node = @arena[node.condition]
      if cond_node.is_a?(CrystalV2::Compiler::Frontend::BinaryNode) &&
         (cond_node.operator_string == "&&" || cond_node.operator_string == "||")
        lower_short_circuit_condition(ctx, cond_node, then_block, next_test_block)
      else
        cond_id = lower_expr(ctx, node.condition)
        cond_type = ctx.type_of(cond_id)
        cond_bool = lower_truthy_check(ctx, cond_id, cond_type)
        # If the condition is constant, don't build both branches (this avoids
        # emitting unreachable code like beginless range iterators).
        static_val = static_truthy_value(ctx, cond_bool)
        if !has_elsifs && !static_val.nil?
          if static_val
            ctx.push_scope(ScopeKind::Block)
            apply_truthy_narrowing(ctx, truthy_targets)
            apply_is_a_narrowing(ctx, is_a_targets)
            then_value = lower_body(ctx, node.then_body)
            ctx.pop_scope
            return then_value
          end

          ctx.push_scope(ScopeKind::Block)
          else_value = if else_body = node.else_body
                         if else_body.empty?
                           nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                           ctx.emit(nil_lit)
                           nil_lit.id
                         else
                           lower_body(ctx, else_body)
                         end
                       else
                         nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                         ctx.emit(nil_lit)
                         nil_lit.id
                       end
          ctx.pop_scope
          return else_value
        end
        ctx.terminate(Branch.new(cond_bool, then_block, next_test_block))
      end

      # Save locals state AFTER condition evaluation to preserve 'out' parameters
      pre_branch_locals = ctx.save_locals

      # Process "then" branch
      ctx.current_block = then_block
      ctx.push_scope(ScopeKind::Block)
      apply_truthy_narrowing(ctx, truthy_targets)
      apply_is_a_narrowing(ctx, is_a_targets)
      then_value = lower_body(ctx, node.then_body)
      then_exit_block = ctx.current_block
      then_locals = ctx.save_locals
      ctx.pop_scope

      then_block_data = ctx.get_block(ctx.current_block)
      then_has_noreturn = then_block_data.instructions.any? { |inst| inst.is_a?(Raise) || inst.is_a?(Return) }
      then_flows_to_merge = then_block_data.terminator.is_a?(Unreachable) && !then_has_noreturn
      if then_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end
      branches << {then_exit_block, then_value, then_locals, then_flows_to_merge}

      # Process elsif branches
      if elsifs && !elsifs.empty?
        elsifs.each_with_index do |elsif_branch, idx|
          # Restore locals for this test (each elsif sees pre-branch state)
          ctx.restore_locals(pre_branch_locals)

          # We're now in the test block for this elsif
          ctx.current_block = next_test_block

          # Lower elsif condition
          elsif_truthy_targets = truthy_narrowing_targets(elsif_branch.condition)
          elsif_is_a_targets = is_a_narrowing_targets(elsif_branch.condition)
          elsif_cond_id = lower_expr(ctx, elsif_branch.condition)

          # Create body block and next block
          elsif_body_block = ctx.create_block
          is_last_elsif = (idx == elsifs.size - 1)
          next_test_block = if is_last_elsif
                              ctx.create_block # Final else block
                            else
                              ctx.create_block # Next elsif test
                            end

          ctx.terminate(Branch.new(elsif_cond_id, elsif_body_block, next_test_block))

          # Process elsif body
          ctx.current_block = elsif_body_block
          ctx.push_scope(ScopeKind::Block)
          apply_truthy_narrowing(ctx, elsif_truthy_targets)
          apply_is_a_narrowing(ctx, elsif_is_a_targets)
          elsif_value = lower_body(ctx, elsif_branch.body)
          elsif_exit_block = ctx.current_block
          elsif_locals = ctx.save_locals
          ctx.pop_scope

          elsif_block_data = ctx.get_block(ctx.current_block)
          elsif_has_noreturn = elsif_block_data.instructions.any? { |inst| inst.is_a?(Raise) || inst.is_a?(Return) }
          elsif_flows_to_merge = elsif_block_data.terminator.is_a?(Unreachable) && !elsif_has_noreturn
          if elsif_flows_to_merge
            ctx.terminate(Jump.new(merge_block))
          end
          branches << {elsif_exit_block, elsif_value, elsif_locals, elsif_flows_to_merge}
        end
      end

      # Process final else branch
      ctx.restore_locals(pre_branch_locals)
      ctx.current_block = next_test_block
      ctx.push_scope(ScopeKind::Block)
      else_value = if else_body = node.else_body
                     if else_body.empty?
                       nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                       ctx.emit(nil_lit)
                       nil_lit.id
                     else
                       lower_body(ctx, else_body)
                     end
                   else
                     # No else: produce nil
                     nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                     ctx.emit(nil_lit)
                     nil_lit.id
                   end
      else_exit_block = ctx.current_block
      else_locals = ctx.save_locals
      ctx.pop_scope

      else_block_data = ctx.get_block(ctx.current_block)
      else_has_noreturn = else_block_data.instructions.any? { |inst| inst.is_a?(Raise) || inst.is_a?(Return) }
      else_flows_to_merge = else_block_data.terminator.is_a?(Unreachable) && !else_has_noreturn
      if else_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end
      branches << {else_exit_block, else_value, else_locals, else_flows_to_merge}

      # Merge block
      ctx.current_block = merge_block

      # Count flowing branches
      flowing_branches = branches.select { |_, _, _, flows| flows }

      if flowing_branches.empty?
        # All branches return/raise - emit nil placeholder
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      elsif flowing_branches.size == 1
        # Only one branch flows - use its value and locals
        exit_block, value, locals, _ = flowing_branches.first
        locals.each { |name, val| ctx.register_local(name, val) }
        return value
      else
        # Multiple branches flow - create phi
        incoming = flowing_branches.map { |exit_block, value, _, _| {exit_block, value} }
        value_types = incoming.map { |(_, val)| ctx.type_of(val) }.reject { |t| t == TypeRef::VOID }.uniq
        phi_type = value_types.first? || TypeRef::VOID

        if value_types.size > 1 && !value_types.all? { |t| numeric_primitive?(t) }
          if union_ref = find_covering_union_type(value_types)
            phi_type = union_ref
          else
            union_name = value_types.map { |t| get_type_name_from_ref(t) }.uniq.join(" | ")
            phi_type = create_union_type(union_name)
          end
        end

        # Don't create phi for void/nil types — but STILL merge local variables!
        if phi_type == TypeRef::VOID || phi_type == TypeRef::NIL
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(nil_lit)
          # Must merge locals even when the if value itself is void/nil,
          # because variables may have been modified in the branches.
          flowing_branch_info = flowing_branches.map { |exit_block, _, locals, _| {exit_block, locals} }
          merge_if_branch_locals(ctx, pre_branch_locals, flowing_branch_info)
          return nil_lit.id
        end

        coerced_incoming = incoming.map do |(blk, val)|
          val_type = ctx.type_of(val)
          if val_type == phi_type
            {blk, val}
          elsif is_union_type?(phi_type)
            variant_id = get_union_variant_id(phi_type, val_type)
            if variant_id >= 0
              wrap = UnionWrap.new(ctx.next_id, phi_type, val, variant_id)
              ctx.emit_to_block(blk, wrap)
              {blk, wrap.id}
            else
              {blk, val}
            end
          elsif numeric_primitive?(val_type) && numeric_primitive?(phi_type)
            cast = Cast.new(ctx.next_id, phi_type, val, phi_type, safe: false)
            ctx.emit_to_block(blk, cast)
            {blk, cast.id}
          else
            {blk, val}
          end
        end

        phi = Phi.new(ctx.next_id, phi_type)
        coerced_incoming.each do |exit_block, value|
          phi.add_incoming(exit_block, value)
        end
        ctx.emit(phi)

        # Merge local variables from flowing branches.
        flowing_branch_info = flowing_branches.map { |exit_block, _, locals, _| {exit_block, locals} }
        merge_if_branch_locals(ctx, pre_branch_locals, flowing_branch_info)

        return phi.id
      end
    end

    # Merge locals from two branches, creating phi nodes where needed
    private def merge_branch_locals(ctx : LoweringContext,
                                    pre_locals : Hash(String, ValueId),
                                    then_locals : Hash(String, ValueId),
                                    else_locals : Hash(String, ValueId),
                                    then_block : BlockId,
                                    else_block : BlockId)
      # Find all variables that exist in either branch or existed before
      all_vars = (then_locals.keys + else_locals.keys + pre_locals.keys).uniq

      all_vars.each do |var_name|
        then_val = then_locals[var_name]?
        else_val = else_locals[var_name]?
        pre_val = pre_locals[var_name]?

        # Use pre-branch value if branch didn't define the variable
        then_val ||= pre_val
        else_val ||= pre_val

        # If variable is new in only one branch (not in pre_locals), use nil for other
        # Crystal semantics: variables assigned in one branch are nilable outside
        if then_val && !else_val
          # Create nil literal for else branch
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit_to_block(else_block, nil_lit)
          else_val = nil_lit.id
        elsif else_val && !then_val
          # Create nil literal for then branch
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit_to_block(then_block, nil_lit)
          then_val = nil_lit.id
        end

        # Skip if variable doesn't exist in either branch (and didn't exist before)
        next unless then_val && else_val

        # If both branches have the same value, no phi needed
        if then_val == else_val
          ctx.register_local(var_name, then_val)
          next
        end

        # Create phi to merge the values
        then_type = ctx.type_of(then_val)
        else_type = ctx.type_of(else_val)
        var_type = then_type
        if then_type != else_type
          var_type = union_type_for_values(then_type, else_type)
        end

        if var_type == TypeRef::VOID || var_type == TypeRef::NIL
          ctx.register_local(var_name, then_val)
          next
        end

        coerced_incoming = [{then_block, then_val}, {else_block, else_val}].map do |(blk, val)|
          val_type = ctx.type_of(val)
          if val_type == var_type
            {blk, val}
          elsif is_union_type?(var_type)
            variant_id = get_union_variant_id(var_type, val_type)
            if variant_id >= 0
              wrap = UnionWrap.new(ctx.next_id, var_type, val, variant_id)
              ctx.emit_to_block(blk, wrap)
              {blk, wrap.id}
            else
              {blk, val}
            end
          elsif numeric_primitive?(val_type) && numeric_primitive?(var_type)
            cast = Cast.new(ctx.next_id, var_type, val, var_type, safe: false)
            ctx.emit_to_block(blk, cast)
            {blk, cast.id}
          else
            {blk, val}
          end
        end

        merge_phi = Phi.new(ctx.next_id, var_type)
        coerced_incoming.each { |blk, val| merge_phi.add_incoming(blk, val) }
        ctx.emit(merge_phi)
        ctx.register_local(var_name, merge_phi.id)
      end
    end

    # Merge locals from N branches (for if/elsif/else), creating phi nodes where needed
    # Only merges variables that were actually modified in at least one branch.
    private def merge_if_branch_locals(ctx : LoweringContext,
                                       pre_locals : Hash(String, ValueId),
                                       branch_info : Array(Tuple(BlockId, Hash(String, ValueId))))
      return if branch_info.empty?

      # Collect all variable names across all branches (NOT pre_locals — only branch-modified)
      all_vars = Set(String).new
      branch_info.each do |(_, locals)|
        locals.keys.each { |k| all_vars << k }
      end

      all_vars.each do |var_name|
        pre_val = pre_locals[var_name]?

        # Check if any branch actually changed this variable
        any_modified = false
        branch_info.each do |(_, locals)|
          if val = locals[var_name]?
            if pre_val.nil? || val != pre_val
              any_modified = true
              break
            end
          end
        end
        next unless any_modified

        # Collect values from all branches
        branch_values = [] of Tuple(BlockId, ValueId)
        branch_info.each do |(block, locals)|
          if val = locals[var_name]?
            branch_values << {block, val}
          elsif pre_val
            branch_values << {block, pre_val}
          end
        end

        # Variable must exist in ALL branches (or have pre-value fallback)
        next if branch_values.size != branch_info.size

        # If all branches have the same value, no phi needed
        first_val = branch_values.first[1]
        if branch_values.all? { |(_, v)| v == first_val }
          ctx.register_local(var_name, first_val)
          next
        end

        # Determine merged type — filter VOID (unregistered type) to prevent
        # spurious X|Void unions that corrupt struct access (e.g. Slice|Void
        # makes Slice#size read the union type_id instead of actual size)
        var_types = branch_values.map { |(_, v)| ctx.type_of(v) }.uniq
        non_void_types = var_types.reject { |t| t == TypeRef::VOID }
        var_types = non_void_types unless non_void_types.empty?
        var_type = if var_types.size == 1
                     var_types.first
                   else
                     var_types.reduce { |acc, t| union_type_for_values(acc, t) }
                   end
        next if var_type == TypeRef::VOID

        # Coerce values to var_type and create phi
        coerced = branch_values.map do |(blk, val)|
          val_type = ctx.type_of(val)
          if val_type == var_type
            {blk, val}
          elsif is_union_type?(var_type)
            variant_id = get_union_variant_id(var_type, val_type)
            if variant_id >= 0
              wrap = UnionWrap.new(ctx.next_id, var_type, val, variant_id)
              ctx.emit_to_block(blk, wrap)
              {blk, wrap.id}
            else
              {blk, val}
            end
          elsif numeric_primitive?(val_type) && numeric_primitive?(var_type)
            cast = Cast.new(ctx.next_id, var_type, val, var_type, safe: false)
            ctx.emit_to_block(blk, cast)
            {blk, cast.id}
          else
            {blk, val}
          end
        end

        merge_phi = Phi.new(ctx.next_id, var_type)
        coerced.each { |(blk, val)| merge_phi.add_incoming(blk, val) }
        ctx.emit(merge_phi)
        ctx.register_local(var_name, merge_phi.id)
      end
    end

    # Safe version of merge_if_branch_locals that ONLY merges variables
    # already existing in pre_branch_locals. This avoids SSA domination errors
    # from variables first defined inside branches (e.g. in loops with if/else).
    private def merge_if_branch_locals_safe(ctx : LoweringContext,
                                            pre_locals : Hash(String, ValueId),
                                            branch_info : Array(Tuple(BlockId, Hash(String, ValueId))))
      return if branch_info.empty? || pre_locals.empty?

      pre_locals.each do |var_name, pre_val|
        # Check if any branch actually changed this variable
        any_modified = false
        branch_info.each do |(_, locals)|
          if val = locals[var_name]?
            if val != pre_val
              any_modified = true
              break
            end
          end
        end
        next unless any_modified

        # Collect values from all branches (use pre_val as fallback)
        branch_values = [] of Tuple(BlockId, ValueId)
        branch_info.each do |(block, locals)|
          val = locals[var_name]? || pre_val
          branch_values << {block, val}
        end

        next if branch_values.size != branch_info.size

        # If all branches have the same value, no phi needed
        first_val = branch_values.first[1]
        if branch_values.all? { |(_, v)| v == first_val }
          ctx.register_local(var_name, first_val)
          next
        end

        # Determine merged type — filter VOID (unregistered type) to prevent
        # spurious X|Void unions that corrupt struct access (e.g. Slice|Void
        # makes Slice#size read the union type_id instead of actual size)
        var_types = branch_values.map { |(_, v)| ctx.type_of(v) }.uniq
        non_void_types = var_types.reject { |t| t == TypeRef::VOID }
        var_types = non_void_types unless non_void_types.empty?
        var_type = if var_types.size == 1
                     var_types.first
                   else
                     var_types.reduce { |acc, t| union_type_for_values(acc, t) }
                   end
        next if var_type == TypeRef::VOID

        # Coerce values to var_type and create phi
        coerced = branch_values.map do |(blk, val)|
          val_type = ctx.type_of(val)
          if val_type == var_type
            {blk, val}
          elsif is_union_type?(var_type)
            variant_id = get_union_variant_id(var_type, val_type)
            if variant_id >= 0
              wrap = UnionWrap.new(ctx.next_id, var_type, val, variant_id)
              ctx.emit_to_block(blk, wrap)
              {blk, wrap.id}
            else
              {blk, val}
            end
          elsif numeric_primitive?(val_type) && numeric_primitive?(var_type)
            cast = Cast.new(ctx.next_id, var_type, val, var_type, safe: false)
            ctx.emit_to_block(blk, cast)
            {blk, cast.id}
          else
            {blk, val}
          end
        end

        merge_phi = Phi.new(ctx.next_id, var_type)
        coerced.each { |(blk, val)| merge_phi.add_incoming(blk, val) }
        ctx.emit(merge_phi)
        ctx.register_local(var_name, merge_phi.id)
      end
    end

    # Merge locals from N branches (for case expressions), creating phi nodes where needed
    # branch_info: Array of (BlockId, Hash(String, ValueId)) for each branch
    private def merge_case_locals(ctx : LoweringContext,
                                  pre_locals : Hash(String, ValueId),
                                  branch_info : Array(Tuple(BlockId, Hash(String, ValueId))))
      return if branch_info.empty?

      # Collect all variable names across all branches
      all_vars = Set(String).new
      branch_info.each do |(_, locals)|
        locals.keys.each { |entry| all_vars << entry }
      end

      all_vars.each do |var_name|
        pre_val = pre_locals[var_name]?

        # Collect values from all branches that have this variable
        branch_values = [] of Tuple(BlockId, ValueId)
        branch_info.each do |(block, locals)|
          if val = locals[var_name]?
            branch_values << {block, val}
          elsif pre_val
            # Branch didn't modify, use pre-case value
            branch_values << {block, pre_val}
          end
        end

        # Skip if variable doesn't exist in all branches and didn't exist before
        next if branch_values.size != branch_info.size

        # If all branches have the same value, no phi needed
        first_val = branch_values.first[1]
        if branch_values.all? { |(_, v)| v == first_val }
          ctx.register_local(var_name, first_val)
          next
        end

        # Create phi to merge values from all branches
        var_type = ctx.type_of(first_val)
        merge_phi = Phi.new(ctx.next_id, var_type)
        branch_values.each { |(blk, val)| merge_phi.add_incoming(blk, val) }
        ctx.emit(merge_phi)
        ctx.register_local(var_name, merge_phi.id)
      end
    end

    private def lower_unless(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::UnlessNode) : ValueId
      # Unless is just if with inverted condition
      cond_id = lower_expr(ctx, node.condition)

      # Save locals state before branching
      pre_branch_locals = ctx.save_locals
      truthy_targets = truthy_narrowing_targets(node.condition)
      is_a_targets = is_a_narrowing_targets(node.condition)

      # Negate condition
      neg_cond = UnaryOperation.new(ctx.next_id, TypeRef::BOOL, UnaryOp::Not, cond_id)
      ctx.emit(neg_cond)

      then_block = ctx.create_block
      else_block = ctx.create_block
      merge_block = ctx.create_block

      ctx.terminate(Branch.new(neg_cond.id, then_block, else_block))

      # Then (was unless body)
      ctx.current_block = then_block
      ctx.restore_locals(pre_branch_locals)
      ctx.push_scope(ScopeKind::Block)
      then_value = lower_body(ctx, node.then_branch)
      then_exit = ctx.current_block
      ctx.pop_scope
      then_locals = ctx.save_locals

      # Check if then branch flows to merge (not terminated by return/raise)
      then_block_data = ctx.get_block(ctx.current_block)
      then_has_noreturn = then_block_data.instructions.any? { |inst| inst.is_a?(Raise) || inst.is_a?(Return) }
      then_flows_to_merge = then_block_data.terminator.is_a?(Unreachable) && !then_has_noreturn
      if then_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      # Else branch (if any)
      ctx.current_block = else_block
      ctx.restore_locals(pre_branch_locals)
      ctx.push_scope(ScopeKind::Block)
      apply_truthy_narrowing(ctx, truthy_targets)
      apply_is_a_narrowing(ctx, is_a_targets)
      else_value = if else_branch = node.else_branch
                     lower_body(ctx, else_branch)
                   else
                     nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                     ctx.emit(nil_lit)
                     nil_lit.id
                   end
      else_exit = ctx.current_block
      else_locals = ctx.save_locals
      ctx.pop_scope

      # Check if else branch flows to merge
      else_block_data = ctx.get_block(ctx.current_block)
      else_has_noreturn = else_block_data.instructions.any? { |inst| inst.is_a?(Raise) || inst.is_a?(Return) }
      else_flows_to_merge = else_block_data.terminator.is_a?(Unreachable) && !else_has_noreturn
      if else_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      # Merge
      ctx.current_block = merge_block

      # Only create phi if at least one branch flows to merge
      if then_flows_to_merge || else_flows_to_merge
        if then_flows_to_merge && else_flows_to_merge
          # Merge locals from both branches
          merge_branch_locals(ctx, pre_branch_locals, then_locals, else_locals,
            then_exit, else_exit)

          phi_type = ctx.type_of(then_value)

          # Don't create phi for void types - LLVM doesn't allow phi void
          if phi_type == TypeRef::VOID || phi_type == TypeRef::NIL
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            return nil_lit.id
          end

          phi = Phi.new(ctx.next_id, phi_type)
          phi.add_incoming(then_exit, then_value)
          phi.add_incoming(else_exit, else_value)
          ctx.emit(phi)
          return phi.id
        elsif then_flows_to_merge
          # Only then flows - use then_value, then_locals
          then_locals.each { |name, val| ctx.register_local(name, val) }
          return then_value
        else
          # Only else flows - use else_value, else_locals
          else_locals.each { |name, val| ctx.register_local(name, val) }
          return else_value
        end
      end

      # Neither branch flows to merge - emit nil placeholder
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_while(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::WhileNode) : ValueId
      # Collect variables that might be assigned in the loop body
      # We need phi nodes at the loop header for these
      assigned_vars = collect_assigned_vars(node.body)
      inline_vars = Set(String).new

      # Save the initial values of variables before the loop
      pre_loop_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      assigned_var_types = {} of String => TypeRef
      old_body_context = @infer_body_context
      @infer_body_context = node.body
      begin
        assigned_vars.each do |var_name|
          if inferred = infer_local_type_from_body(node.body, var_name, @current_class)
            # Skip VOID: unioning with VOID corrupts phi types and breaks pointer arithmetic.
            assigned_var_types[var_name] = inferred unless inferred == TypeRef::VOID
          end
        end
      ensure
        @infer_body_context = old_body_context
      end

      cond_block = ctx.create_block
      body_block = ctx.create_block
      exit_block = ctx.create_block

      # Jump to condition check
      ctx.terminate(Jump.new(cond_block))

      # Condition block - create phi nodes for mutable variables
      ctx.current_block = cond_block
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          if var_type == TypeRef::VOID
            if value = ctx.value_for(initial_val)
              var_type = value.type unless value.type == TypeRef::VOID
            end
          end
          if var_type == TypeRef::VOID
            if locals = @current_typeof_locals
              if inferred_ref = locals[var_name]?
                var_type = inferred_ref unless inferred_ref == TypeRef::VOID
              end
            end
          end
          if var_type == TypeRef::VOID && env_get("DEBUG_LOOP_PHI")
            value_type = ctx.value_for(initial_val).try(&.type) || TypeRef::VOID
            local_type = @current_typeof_locals.try(&.[var_name]?) || TypeRef::VOID
            STDERR.puts "[LOOP_PHI] var=#{var_name} init=#{ctx.type_of(initial_val).id} value=#{value_type.id} local=#{local_type.id}"
          end
          if var_type == TypeRef::VOID
            if inferred = assigned_var_types[var_name]?
              var_type = inferred
            end
          end
          if inferred = assigned_var_types[var_name]?
            pointer_type = var_type == TypeRef::POINTER || @module.get_type_descriptor(var_type).try(&.kind) == TypeKind::Pointer
            # For compound assignments like `slice += n`, infer_local_type_from_body may
            # return the RHS type (Int32) instead of the method return type (Slice).
            # Avoid widening pointer or struct/class phis to unrelated primitive types.
            var_desc = @module.get_type_descriptor(var_type)
            struct_or_class = var_desc && (var_desc.kind == TypeKind::Struct || var_desc.kind == TypeKind::Class)
            var_type_name = get_type_name_from_ref(var_type)
            inferred_type_name = get_type_name_from_ref(inferred)
            enum_var = @enum_info.try(&.has_key?(var_type_name))
            enum_inferred = @enum_info.try(&.has_key?(inferred_type_name))
            # Enum + numeric or numeric + enum should not widen to union — keep Int32
            enum_numeric_mismatch = (enum_var && numeric_primitive?(inferred)) || (enum_inferred && numeric_primitive?(var_type))
            if ((pointer_type || struct_or_class) && numeric_primitive?(inferred)) || enum_numeric_mismatch
              # Avoid widening pointer/struct/enum phis to numeric types based on brittle inference.
              # Keep the Int32 type (enums are Int32 at runtime)
            else
              merged = union_type_for_values(var_type, inferred)
              if merged == TypeRef::VOID && env_get("DEBUG_LOOP_PHI")
                scope = "#{@current_class || ""}##{@current_method || ""}"
                STDERR.puts "[LOOP_PHI_MERGE] scope=#{scope} var=#{var_name} left=#{var_type.id} right=#{inferred.id}"
              end
              var_type = merged
            end
          end
          phi = Phi.new(ctx.next_id, var_type)
          # Add incoming from pre-loop block
          incoming = {pre_loop_block, initial_val}
          if var_type != ctx.type_of(initial_val)
            val_type = ctx.type_of(initial_val)
            if is_union_type?(var_type)
              if variant_id = get_union_variant_id(var_type, val_type)
                variant_id >= 0
                wrap = UnionWrap.new(ctx.next_id, var_type, initial_val, variant_id)
                ctx.emit_to_block(pre_loop_block, wrap)
                incoming = {pre_loop_block, wrap.id}
              end
            elsif numeric_primitive?(val_type) && numeric_primitive?(var_type)
              cast = Cast.new(ctx.next_id, var_type, initial_val, var_type, safe: false)
              ctx.emit_to_block(pre_loop_block, cast)
              incoming = {pre_loop_block, cast.id}
            end
          end
          phi.add_incoming(incoming[0], incoming[1])
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          # Update local to point to phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      cond_id = lower_expr(ctx, node.condition)
      # After lowering the condition, current_block may differ from cond_block
      # (e.g., method calls create new blocks). The Branch is in THIS block.
      cond_branch_block = ctx.current_block
      ctx.terminate(Branch.new(cond_id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Loop)
      @loop_exit_stack << exit_block
      @loop_cond_stack << cond_block
      @loop_phi_stack << phi_nodes
      @loop_break_info_stack << [] of {BlockId, Hash(String, ValueId)}
      @loop_break_value_stack << [] of {BlockId, ValueId}
      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      begin
        lower_body(ctx, node.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
        @loop_exit_stack.pop?
        @loop_cond_stack.pop?
        @loop_phi_stack.pop?
      end
      break_info = @loop_break_info_stack.pop
      break_values = @loop_break_value_stack.pop
      body_exit_block = ctx.current_block
      ctx.pop_scope

      # After body execution, get updated values and patch phi nodes
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            # Add incoming from body block (the updated value)
            incoming_val = updated_val
            phi_type = ctx.type_of(phi.id)
            if phi_type != ctx.type_of(updated_val)
              val_type = ctx.type_of(updated_val)
              if is_union_type?(phi_type)
                if variant_id = get_union_variant_id(phi_type, val_type)
                  variant_id >= 0
                  wrap = UnionWrap.new(ctx.next_id, phi_type, updated_val, variant_id)
                  ctx.emit_to_block(body_exit_block, wrap)
                  incoming_val = wrap.id
                end
              elsif numeric_primitive?(val_type) && numeric_primitive?(phi_type)
                cast = Cast.new(ctx.next_id, phi_type, updated_val, phi_type, safe: false)
                ctx.emit_to_block(body_exit_block, cast)
                incoming_val = cast.id
              end
            end
            if env_get("DEBUG_LOOP_PHI")
              STDERR.puts "[LOOP_PHI_BACKEDGE] var=#{var_name} phi=#{phi.id} updated_val=#{updated_val} incoming_val=#{incoming_val} body_exit=#{body_exit_block} phi_type=#{phi_type.id} val_type=#{ctx.type_of(updated_val).id} same_as_phi=#{updated_val == phi.id}"
            end
            phi.add_incoming(body_exit_block, incoming_val)
            # Reset local to point back to phi for next iteration
            ctx.register_local(var_name, phi.id)
          end
        end
      end

      if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
        ctx.terminate(Jump.new(cond_block)) # Loop back
      end

      # Exit block - create exit phis if any break occurred
      ctx.current_block = exit_block

      if break_info.empty?
        # No breaks — locals point to cond_block phi nodes (normal exit only)
        phi_nodes.each do |var_name, phi|
          ctx.register_local(var_name, phi.id)
        end
      else
        # Breaks occurred — create exit phi nodes that merge normal-exit + break paths
        # Use cond_branch_block (NOT cond_block) as the normal-exit predecessor,
        # because condition expression lowering may split cond_block into multiple blocks.
        phi_nodes.each do |var_name, cond_phi|
          exit_phi = Phi.new(ctx.next_id, cond_phi.type)
          # Normal exit path: from the block that has the Branch terminator
          exit_phi.add_incoming(cond_branch_block, cond_phi.id)
          # Break paths: use the variable value at each break point
          break_info.each do |break_block, break_locals|
            if break_val = break_locals[var_name]?
              exit_phi.add_incoming(break_block, break_val)
            else
              exit_phi.add_incoming(break_block, cond_phi.id)
            end
          end
          ctx.emit(exit_phi)
          ctx.register_local(var_name, exit_phi.id)
        end
      end

      # While expression result: nil for normal exit, break value for break exit
      if break_values.empty?
        # No break values — while always returns nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      else
        # Break values present — create phi merging nil (normal exit) + break values
        break_type = ctx.type_of(break_values.first[1])
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit_to_block(cond_branch_block, nil_lit)
        ctx.register_type(nil_lit.id, TypeRef::NIL)
        # Create union type for T | Nil if break type is not already nilable
        result_type = break_type
        if break_type != TypeRef::NIL
          result_type = union_type_for_values(break_type, TypeRef::NIL)
          result_type = break_type if result_type == TypeRef::VOID
        end
        result_phi = Phi.new(ctx.next_id, result_type)
        # Normal exit: nil
        if is_union_type?(result_type) && result_type != TypeRef::NIL
          nil_wrap = UnionWrap.new(ctx.next_id, result_type, nil_lit.id, 0)
          ctx.emit_to_block(cond_branch_block, nil_wrap)
          ctx.register_type(nil_wrap.id, result_type)
          result_phi.add_incoming(cond_branch_block, nil_wrap.id)
        else
          result_phi.add_incoming(cond_branch_block, nil_lit.id)
        end
        # Break exits: break value (may need union wrapping)
        break_values.each do |break_block, break_val|
          if is_union_type?(result_type) && ctx.type_of(break_val) != result_type
            val_type = ctx.type_of(break_val)
            variant_id = get_union_variant_id(result_type, val_type)
            if variant_id && variant_id >= 0
              wrap = UnionWrap.new(ctx.next_id, result_type, break_val, variant_id)
              ctx.emit_to_block(break_block, wrap)
              ctx.register_type(wrap.id, result_type)
              result_phi.add_incoming(break_block, wrap.id)
            else
              result_phi.add_incoming(break_block, break_val)
            end
          else
            result_phi.add_incoming(break_block, break_val)
          end
        end
        ctx.emit(result_phi)
        ctx.register_type(result_phi.id, result_type)
        result_phi.id
      end
    end

    # ═══════════════════════════════════════════════════════════════════════
    # LOOP (infinite loop) LOWERING
    # ═══════════════════════════════════════════════════════════════════════
    private def lower_loop(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::LoopNode) : ValueId
      # Collect variables that might be assigned in the loop body
      assigned_vars = collect_assigned_vars(node.body)
      inline_vars = Set(String).new

      # Save the initial values of variables before the loop
      pre_loop_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      assigned_var_types = {} of String => TypeRef
      old_body_context = @infer_body_context
      @infer_body_context = node.body
      begin
        assigned_vars.each do |var_name|
          if inferred = infer_local_type_from_body(node.body, var_name, @current_class)
            # Skip VOID: unioning with VOID corrupts phi types and breaks pointer arithmetic.
            assigned_var_types[var_name] = inferred unless inferred == TypeRef::VOID
          end
        end
      ensure
        @infer_body_context = old_body_context
      end

      # For infinite loop, we just need body and exit blocks
      body_block = ctx.create_block
      exit_block = ctx.create_block

      # Jump directly to body
      ctx.terminate(Jump.new(body_block))

      # Body block - create phi nodes for mutable variables
      ctx.current_block = body_block
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          if var_type == TypeRef::VOID
            if value = ctx.value_for(initial_val)
              var_type = value.type unless value.type == TypeRef::VOID
            end
          end
          if var_type == TypeRef::VOID
            if locals = @current_typeof_locals
              if inferred_ref = locals[var_name]?
                var_type = inferred_ref unless inferred_ref == TypeRef::VOID
              end
            end
          end
          if var_type == TypeRef::VOID
            if inferred = assigned_var_types[var_name]?
              var_type = inferred
            end
          end
          if inferred = assigned_var_types[var_name]?
            pointer_type = var_type == TypeRef::POINTER || @module.get_type_descriptor(var_type).try(&.kind) == TypeKind::Pointer
            var_desc_l = @module.get_type_descriptor(var_type)
            struct_or_class_l = var_desc_l && (var_desc_l.kind == TypeKind::Struct || var_desc_l.kind == TypeKind::Class)
            if (pointer_type || struct_or_class_l) && numeric_primitive?(inferred)
              # Avoid widening pointer/struct phis to numeric types based on brittle inference.
            else
              var_type = union_type_for_values(var_type, inferred)
            end
          end
          phi = Phi.new(ctx.next_id, var_type)
          incoming = {pre_loop_block, initial_val}
          if var_type != ctx.type_of(initial_val)
            val_type = ctx.type_of(initial_val)
            if is_union_type?(var_type)
              if variant_id = get_union_variant_id(var_type, val_type)
                variant_id >= 0
                wrap = UnionWrap.new(ctx.next_id, var_type, initial_val, variant_id)
                ctx.emit_to_block(pre_loop_block, wrap)
                incoming = {pre_loop_block, wrap.id}
              end
            elsif numeric_primitive?(val_type) && numeric_primitive?(var_type)
              cast = Cast.new(ctx.next_id, var_type, initial_val, var_type, safe: false)
              ctx.emit_to_block(pre_loop_block, cast)
              incoming = {pre_loop_block, cast.id}
            end
          end
          phi.add_incoming(incoming[0], incoming[1])
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      ctx.push_scope(ScopeKind::Loop)
      @loop_exit_stack << exit_block
      @loop_cond_stack << body_block  # for infinite loop, `next` jumps back to body start
      @loop_phi_stack << phi_nodes
      @loop_break_info_stack << [] of {BlockId, Hash(String, ValueId)}
      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      begin
        lower_body(ctx, node.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
        @loop_exit_stack.pop?
        @loop_cond_stack.pop?
        @loop_phi_stack.pop?
      end
      break_info_loop = @loop_break_info_stack.pop
      body_exit_block = ctx.current_block
      ctx.pop_scope

      # After body execution, update phi nodes for next iteration
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            incoming_val = updated_val
            phi_type = ctx.type_of(phi.id)
            if phi_type != ctx.type_of(updated_val)
              val_type = ctx.type_of(updated_val)
              if is_union_type?(phi_type)
                if variant_id = get_union_variant_id(phi_type, val_type)
                  variant_id >= 0
                  wrap = UnionWrap.new(ctx.next_id, phi_type, updated_val, variant_id)
                  ctx.emit_to_block(body_exit_block, wrap)
                  incoming_val = wrap.id
                end
              elsif numeric_primitive?(val_type) && numeric_primitive?(phi_type)
                cast = Cast.new(ctx.next_id, phi_type, updated_val, phi_type, safe: false)
                ctx.emit_to_block(body_exit_block, cast)
                incoming_val = cast.id
              end
            end
            phi.add_incoming(body_exit_block, incoming_val)
            ctx.register_local(var_name, phi.id)
          end
        end
      end

      # Loop back unconditionally (break will jump to exit_block)
      if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
        ctx.terminate(Jump.new(body_block))
      end

      # Exit block (reached via break only for infinite loops)
      ctx.current_block = exit_block

      if break_info_loop.empty?
        # No breaks — locals point to body phi nodes
        phi_nodes.each do |var_name, phi|
          ctx.register_local(var_name, phi.id)
        end
      else
        # Breaks occurred — create exit phi nodes merging break paths
        phi_nodes.each do |var_name, body_phi|
          if break_info_loop.size == 1
            # Single break — use break value directly (no phi needed)
            break_block, break_locals = break_info_loop[0]
            if break_val = break_locals[var_name]?
              ctx.register_local(var_name, break_val)
            else
              ctx.register_local(var_name, body_phi.id)
            end
          else
            exit_phi = Phi.new(ctx.next_id, body_phi.type)
            break_info_loop.each do |break_block, break_locals|
              if break_val = break_locals[var_name]?
                exit_phi.add_incoming(break_block, break_val)
              else
                exit_phi.add_incoming(break_block, body_phi.id)
              end
            end
            ctx.emit(exit_phi)
            ctx.register_local(var_name, exit_phi.id)
          end
        end
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Collect variable names that are assigned in a list of expressions
    private def collect_assigned_vars(body : Array(ExprId), visited_blocks : Set(UInt64)? = nil) : Array(String)
      visited_blocks ||= Set(UInt64).new
      vars = [] of String
      body.each do |expr_id|
        collect_assigned_vars_in_expr(expr_id, vars, visited_blocks)
      end
      vars.uniq
    end

    private def collect_assigned_vars_in_expr(expr_id : ExprId, vars : Array(String), visited_blocks : Set(UInt64))
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::AssignNode
        target = @arena[node.target]
        if target.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          vars << String.new(target.name)
        end
        # Also check the value side for nested assignments
        collect_assigned_vars_in_expr(node.value, vars, visited_blocks)
      when CrystalV2::Compiler::Frontend::MultipleAssignNode
        node.targets.each do |target_id|
          target = @arena[target_id]
          if target.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            vars << String.new(target.name)
          end
        end
        collect_assigned_vars_in_expr(node.value, vars, visited_blocks)
      when CrystalV2::Compiler::Frontend::TypeDeclarationNode
        vars << String.new(node.name)
        if value = node.value
          collect_assigned_vars_in_expr(value, vars, visited_blocks)
        end
      when CrystalV2::Compiler::Frontend::WhileNode
        # Nested while - check its body
        collect_assigned_vars(node.body, visited_blocks).each { |v| vars << v }
      when CrystalV2::Compiler::Frontend::LoopNode
        # Nested loop - check its body
        collect_assigned_vars(node.body, visited_blocks).each { |v| vars << v }
      when CrystalV2::Compiler::Frontend::IfNode
        # Check all branches
        collect_assigned_vars(node.then_body, visited_blocks).each { |v| vars << v }
        if else_body = node.else_body
          collect_assigned_vars(else_body, visited_blocks).each { |v| vars << v }
        end
      when CrystalV2::Compiler::Frontend::UnlessNode
        # Check all branches
        collect_assigned_vars(node.then_branch, visited_blocks).each { |v| vars << v }
        if else_body = node.else_branch
          collect_assigned_vars(else_body, visited_blocks).each { |v| vars << v }
        end
      when CrystalV2::Compiler::Frontend::CaseNode
        # Check all when branches and else
        node.when_branches.each do |when_branch|
          collect_assigned_vars(when_branch.body, visited_blocks).each { |v| vars << v }
        end
        if else_body = node.else_branch
          collect_assigned_vars(else_body, visited_blocks).each { |v| vars << v }
        end
      when CrystalV2::Compiler::Frontend::BinaryNode
        collect_assigned_vars_in_expr(node.left, vars, visited_blocks)
        collect_assigned_vars_in_expr(node.right, vars, visited_blocks)
      when CrystalV2::Compiler::Frontend::CallNode
        node.args.each { |arg| collect_assigned_vars_in_expr(arg, vars, visited_blocks) }
      when CrystalV2::Compiler::Frontend::GroupingNode
        collect_assigned_vars_in_expr(node.expression, vars, visited_blocks)
      when CrystalV2::Compiler::Frontend::YieldNode
        if inline_block = @inline_yield_block_stack.last?
          block_id = inline_block.object_id
          unless visited_blocks.includes?(block_id)
            visited_blocks.add(block_id)
            old_arena = @arena
            if block_arena = @inline_yield_block_arena_stack.last?
              @arena = block_arena
            end
            begin
              block_vars = collect_assigned_vars(inline_block.body, visited_blocks)
            ensure
              @arena = old_arena
            end
            if params = inline_block.params
              param_names = params.compact_map { |param| param.name ? String.new(param.name.not_nil!) : nil }
              block_vars.reject! { |name| param_names.includes?(name) }
            end
            block_vars.each { |v| vars << v }
          end
        end
      end
    end

    private def lookup_local_for_phi(ctx : LoweringContext, name : String, inline_vars : Set(String)) : ValueId?
      if val = ctx.lookup_local(name)
        return val
      end

      if caller_locals = @inline_caller_locals_stack.last?
        if val = caller_locals[name]?
          inline_vars.add(name)
          return val
        end
      end

      nil
    end

    private def inline_loop_vars_union : Set(String)?
      return nil if @inline_loop_vars_stack.empty?
      union = Set(String).new
      @inline_loop_vars_stack.each do |set|
        set.each { |name| union.add(name) }
      end
      union
    end

    private def lower_until(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::UntilNode) : ValueId
      # Until is while with inverted condition — needs phi nodes like lower_while
      assigned_vars = collect_assigned_vars(node.body)
      inline_vars = Set(String).new

      pre_loop_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      assigned_var_types = {} of String => TypeRef
      old_body_context = @infer_body_context
      @infer_body_context = node.body
      begin
        assigned_vars.each do |var_name|
          if inferred = infer_local_type_from_body(node.body, var_name, @current_class)
            assigned_var_types[var_name] = inferred unless inferred == TypeRef::VOID
          end
        end
      ensure
        @infer_body_context = old_body_context
      end

      cond_block = ctx.create_block
      body_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block - create phi nodes for mutable variables
      ctx.current_block = cond_block
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          if var_type == TypeRef::VOID
            if value = ctx.value_for(initial_val)
              var_type = value.type unless value.type == TypeRef::VOID
            end
          end
          if var_type == TypeRef::VOID
            if locals = @current_typeof_locals
              if inferred_ref = locals[var_name]?
                var_type = inferred_ref unless inferred_ref == TypeRef::VOID
              end
            end
          end
          if var_type == TypeRef::VOID
            if inferred = assigned_var_types[var_name]?
              var_type = inferred
            end
          end
          if inferred = assigned_var_types[var_name]?
            pointer_type = var_type == TypeRef::POINTER || @module.get_type_descriptor(var_type).try(&.kind) == TypeKind::Pointer
            var_desc_u = @module.get_type_descriptor(var_type)
            struct_or_class_u = var_desc_u && (var_desc_u.kind == TypeKind::Struct || var_desc_u.kind == TypeKind::Class)
            if (pointer_type || struct_or_class_u) && numeric_primitive?(inferred)
              # Avoid widening pointer/struct phis to numeric types based on brittle inference.
            else
              merged = union_type_for_values(var_type, inferred)
              var_type = merged
            end
          end
          phi = Phi.new(ctx.next_id, var_type)
          incoming = {pre_loop_block, initial_val}
          if var_type != ctx.type_of(initial_val)
            val_type = ctx.type_of(initial_val)
            if is_union_type?(var_type)
              if variant_id = get_union_variant_id(var_type, val_type)
                variant_id >= 0
                wrap = UnionWrap.new(ctx.next_id, var_type, initial_val, variant_id)
                ctx.emit_to_block(pre_loop_block, wrap)
                incoming = {pre_loop_block, wrap.id}
              end
            elsif numeric_primitive?(val_type) && numeric_primitive?(var_type)
              cast = Cast.new(ctx.next_id, var_type, initial_val, var_type, safe: false)
              ctx.emit_to_block(pre_loop_block, cast)
              incoming = {pre_loop_block, cast.id}
            end
          end
          phi.add_incoming(incoming[0], incoming[1])
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      cond_id = lower_expr(ctx, node.condition)
      # Negate condition (until = while NOT condition)
      neg_cond = UnaryOperation.new(ctx.next_id, TypeRef::BOOL, UnaryOp::Not, cond_id)
      ctx.emit(neg_cond)
      ctx.terminate(Branch.new(neg_cond.id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Loop)
      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      begin
        lower_body(ctx, node.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
      end
      body_exit_block = ctx.current_block
      ctx.pop_scope

      # Patch phi nodes with back-edge values
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            incoming_val = updated_val
            phi_type = ctx.type_of(phi.id)
            if phi_type != ctx.type_of(updated_val)
              val_type = ctx.type_of(updated_val)
              if is_union_type?(phi_type)
                if variant_id = get_union_variant_id(phi_type, val_type)
                  variant_id >= 0
                  wrap = UnionWrap.new(ctx.next_id, phi_type, updated_val, variant_id)
                  ctx.emit_to_block(body_exit_block, wrap)
                  incoming_val = wrap.id
                end
              elsif numeric_primitive?(val_type) && numeric_primitive?(phi_type)
                cast = Cast.new(ctx.next_id, phi_type, updated_val, phi_type, safe: false)
                ctx.emit_to_block(body_exit_block, cast)
                incoming_val = cast.id
              end
            end
            phi.add_incoming(body_exit_block, incoming_val)
            ctx.register_local(var_name, phi.id)
          end
        end
      end

      if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
        ctx.terminate(Jump.new(cond_block))
      end

      # Exit block
      ctx.current_block = exit_block
      phi_nodes.each do |var_name, phi|
        ctx.register_local(var_name, phi.id)
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_ternary(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::TernaryNode) : ValueId
      # Collect narrowing targets BEFORE lowering condition
      truthy_targets = truthy_narrowing_targets(node.condition)
      is_a_targets = is_a_narrowing_targets(node.condition)

      cond_id = lower_expr(ctx, node.condition)

      # Save locals before branching
      pre_branch_locals = ctx.save_locals

      then_block = ctx.create_block
      else_block = ctx.create_block
      merge_block = ctx.create_block

      ctx.terminate(Branch.new(cond_id, then_block, else_block))

      ctx.current_block = then_block
      ctx.restore_locals(pre_branch_locals)
      # Apply truthy narrowing in the then branch (e.g., entry ? entry.value : nil)
      apply_truthy_narrowing(ctx, truthy_targets)
      apply_is_a_narrowing(ctx, is_a_targets)
      then_value = lower_expr(ctx, node.true_branch)
      then_exit = ctx.current_block
      then_locals = ctx.save_locals

      # Check if then branch flows to merge
      then_block_data = ctx.get_block(ctx.current_block)
      then_has_noreturn = then_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
      then_flows_to_merge = then_block_data.terminator.is_a?(Unreachable) && !then_has_noreturn
      if then_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      ctx.current_block = else_block
      ctx.restore_locals(pre_branch_locals)
      else_value = lower_expr(ctx, node.false_branch)
      else_exit = ctx.current_block
      else_locals = ctx.save_locals

      # Check if else branch flows to merge
      else_block_data = ctx.get_block(ctx.current_block)
      else_has_noreturn = else_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
      else_flows_to_merge = else_block_data.terminator.is_a?(Unreachable) && !else_has_noreturn
      if else_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      ctx.current_block = merge_block

      # Only create phi if at least one branch flows to merge
      if then_flows_to_merge || else_flows_to_merge
        if then_flows_to_merge && else_flows_to_merge
          # Merge locals from both branches
          merge_branch_locals(ctx, pre_branch_locals, then_locals, else_locals,
            then_exit, else_exit)

          phi_type = ctx.type_of(then_value)

          # Don't create phi for void types - LLVM doesn't allow phi void
          if phi_type == TypeRef::VOID || phi_type == TypeRef::NIL
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            return nil_lit.id
          end

          phi = Phi.new(ctx.next_id, phi_type)
          phi.add_incoming(then_exit, then_value)
          phi.add_incoming(else_exit, else_value)
          ctx.emit(phi)
          return phi.id
        elsif then_flows_to_merge
          then_locals.each { |name, val| ctx.register_local(name, val) }
          return then_value
        else
          else_locals.each { |name, val| ctx.register_local(name, val) }
          return else_value
        end
      end

      # Neither branch flows - return nil placeholder
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Emit comparison for case/when using appropriate === semantics
    # Returns ValueId of boolean result
    private def emit_case_comparison(ctx : LoweringContext, subject_id : ValueId, cond_expr : ExprId) : ValueId
      cond_node = @arena[cond_expr]
      if env_get("DEBUG_ENUM_UNION_PREDICATE")
        node_type = cond_node.class.name.split("::").last
        member = case cond_node
                 when CrystalV2::Compiler::Frontend::MemberAccessNode
                   String.new(cond_node.member)
                 when CrystalV2::Compiler::Frontend::CallNode
                   callee = @arena[cond_node.callee]
                   if callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                     String.new(callee.member)
                   else
                     "?"
                   end
                 else
                   "?"
                 end
        if member == "kill?" || member == "hup?" || member == "quit?"
          STDERR.puts "[CASE_CMP] node_type=#{node_type} member=#{member} func=#{ctx.function.name}"
        end
      end

      case cond_node
      when CrystalV2::Compiler::Frontend::StringNode
        # String literals: use content comparison, not pointer comparison
        cond_val = lower_expr(ctx, cond_expr)
        subject_type = ctx.type_of(subject_id)
        if subject_type == TypeRef::STRING
          call = Call.new(ctx.next_id, TypeRef::BOOL, subject_id, "__crystal_v2_string_eq", [cond_val])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::BOOL)
          call.id
        else
          eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
          ctx.emit(eq)
          eq.id
        end
      when CrystalV2::Compiler::Frontend::NumberNode,
           CrystalV2::Compiler::Frontend::BoolNode,
           CrystalV2::Compiler::Frontend::NilNode,
           CrystalV2::Compiler::Frontend::CharNode
        # Primitive literals: direct equality comparison (optimized)
        cond_val = lower_expr(ctx, cond_expr)
        eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
        ctx.emit(eq)
        eq.id
      when CrystalV2::Compiler::Frontend::ConstantNode
        # Could be a type name (Int32, String) → is_a? check
        # Or a constant value → equality
        const_name = String.new(cond_node.name)
        if is_type_name?(const_name)
          # Type check: subject.is_a?(ConstName)
          check_type = type_ref_for_name(const_name)
          subject_type = ctx.type_of(subject_id)
          # If subject is union type, use UnionIs
          if is_union_type?(subject_type)
            variant_id = get_union_variant_id(subject_type, check_type)
            if variant_id >= 0
              union_is = UnionIs.new(ctx.next_id, subject_id, variant_id)
              ctx.emit(union_is)
              return union_is.id
            end
          end

          # Regular is_a? check
          is_a = IsA.new(ctx.next_id, subject_id, check_type)
          ctx.emit(is_a)
          is_a.id
        else
          # Constant value - equality
          cond_val = lower_expr(ctx, cond_expr)
          eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
          ctx.emit(eq)
          eq.id
        end
      when CrystalV2::Compiler::Frontend::RangeNode
        # Range: call Range#=== or Range#includes?
        # For now, expand to: subject >= begin && subject <= end (or < for exclusive)
        range_begin = lower_expr(ctx, cond_node.begin_expr)
        range_end = lower_expr(ctx, cond_node.end_expr)

        gte = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Ge, subject_id, range_begin)
        ctx.emit(gte)

        cmp_op = cond_node.exclusive ? BinaryOp::Lt : BinaryOp::Le
        lte = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, cmp_op, subject_id, range_end)
        ctx.emit(lte)

        and_op = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::And, gte.id, lte.id)
        ctx.emit(and_op)
        and_op.id
      when CrystalV2::Compiler::Frontend::IdentifierNode
        # Could be a type name (Int32, String) or variable
        ident_name = String.new(cond_node.name)
        if is_type_name?(ident_name)
          # Type check: subject.is_a?(IdentName)
          check_type = type_ref_for_name(ident_name)
          subject_type = ctx.type_of(subject_id)

          # If subject is union type, use UnionIs
          if is_union_type?(subject_type)
            variant_id = get_union_variant_id(subject_type, check_type)
            if variant_id >= 0
              union_is = UnionIs.new(ctx.next_id, subject_id, variant_id)
              ctx.emit(union_is)
              return union_is.id
            end
          end

          # Regular is_a? check
          is_a = IsA.new(ctx.next_id, subject_id, check_type)
          ctx.emit(is_a)
          is_a.id
        else
          # Variable - equality
          cond_val = lower_expr(ctx, cond_expr)
          eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
          ctx.emit(eq)
          eq.id
        end
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # Check for implicit receiver pattern: .method? → subject.method?
        obj_node = @arena[cond_node.object]
        member_name = String.new(cond_node.member)

        if obj_node.is_a?(CrystalV2::Compiler::Frontend::ImplicitObjNode)
          # Implicit receiver: .data1?, .block?, etc.
          # This is "subject.method?" - check if it's an enum predicate
          if member_name.ends_with?('?')
            # Try to find enum type from subject
            enum_name = @enum_value_types.try(&.[subject_id]?)

            # If not directly tracked, try to infer from type descriptor
            if enum_name.nil?
              subject_type = ctx.type_of(subject_id)
              if type_desc = @module.get_type_descriptor(subject_type)
                type_name = type_desc.name
                if @enum_info.try(&.has_key?(type_name))
                  enum_name = type_name
                end
                # For union types like "Signal | Nil", check if any variant is an enum
                if enum_name.nil? && type_desc.kind == TypeKind::Union
                  if env_get("DEBUG_ENUM_UNION_PREDICATE") && (member_name == "kill?" || member_name == "hup?" || member_name == "quit?")
                    STDERR.puts "[CASE_UNION] type_name=#{type_name} variants=#{split_union_type_name(type_name).join(",")}"
                  end
                  split_union_type_name(type_name).each do |variant_name|
                    if @enum_info.try(&.has_key?(variant_name))
                      if env_get("DEBUG_ENUM_UNION_PREDICATE") && (member_name == "kill?" || member_name == "hup?" || member_name == "quit?")
                        STDERR.puts "[CASE_UNION] found enum variant=#{variant_name}"
                      end
                      enum_name = variant_name
                      break
                    end
                  end
                end
              end
              # Also try direct lookup by type_ref id in enum_base_types
              # For primitive types that map to enums (e.g., UInt8 for Color : UInt8)
              if enum_name.nil? && @enum_base_types
                @enum_base_types.not_nil!.each do |name, base_type|
                  if base_type == subject_type
                    # Found an enum with matching base type - check if it has the member
                    if members = @enum_info.try(&.[name]?)
                      base_name = member_name[0...-1]
                      if members.keys.any? { |m| underscore_lower(m) == underscore_lower(base_name) }
                        enum_name = name
                        break
                      end
                    end
                  end
                end
              end
            end
            # Lazy-discover enum from stdlib if type descriptor is known but not in @enum_info
            if enum_name.nil?
              subject_type_check = ctx.type_of(subject_id)
              if td = @module.get_type_descriptor(subject_type_check)
                td_name = td.name
                if !td_name.empty? && !(@enum_info.try(&.has_key?(td_name)) || false)
                  if lazy_discover_enum_from_source(td_name)
                    enum_name = td_name
                  end
                end
              end
            end
            # As a fallback, search all enums for a matching member.
            # GUARD: Only do global enum search if subject type is unknown or is itself an enum.
            # Do NOT match when subject is a known non-enum type (Char, Int32, String, etc.)
            # to avoid false matches like `.ascii?` → `Unicode::CaseOptions::ASCII`.
            if enum_name.nil?
              subject_type_known_non_enum = false
              subject_type_check = ctx.type_of(subject_id)
              # Built-in primitive types are never enums
              if subject_type_check.id < TypeRef::FIRST_USER_TYPE
                subject_type_known_non_enum = true
              elsif td = @module.get_type_descriptor(subject_type_check)
                # If type has a name and that name is NOT in @enum_info, it's not an enum
                subject_type_known_non_enum = !(@enum_info.try(&.has_key?(td.name)) || false)
              end
              unless subject_type_known_non_enum
                base_name = member_name[0...-1]
                if enum_info = @enum_info
                  enum_info.each do |name, members|
                    if members.keys.any? { |m| underscore_lower(m) == underscore_lower(base_name) }
                      enum_name = name
                      break
                    end
                  end
                end
              end
            end

            if enum_name && (enum_info = @enum_info)
              if members = enum_info[enum_name]?
                # Try to match the predicate to an enum member
                # e.g., "data1?" -> "Data1", "block?" -> "Block"
                base_name = member_name[0...-1] # Remove trailing ?
                if env_get("DEBUG_ENUM_UNION_PREDICATE") && (member_name == "kill?" || member_name == "hup?" || member_name == "quit?")
                  STDERR.puts "[CASE_ENUM_PRED] member_name=#{member_name} base_name=#{base_name} enum_name=#{enum_name} members=#{members.keys.first(5).join(",")}"
                end
                member_match = members.keys.find { |m| underscore_lower(m) == underscore_lower(base_name) }
                if env_get("DEBUG_ENUM_UNION_PREDICATE") && (member_name == "kill?" || member_name == "hup?" || member_name == "quit?")
                  STDERR.puts "[CASE_ENUM_PRED] member_match=#{member_match || "nil"}"
                end
                if member_match
                  member_value = members[member_match]
                  # Emit: subject_id == member_value
                  enum_type = enum_base_type(enum_name)
                  lit = Literal.new(ctx.next_id, enum_type, member_value)
                  ctx.emit(lit)
                  ctx.register_type(lit.id, enum_type)
                  cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, lit.id)
                  ctx.emit(cmp)
                  ctx.register_type(cmp.id, TypeRef::BOOL)
                  return cmp.id
                end
              end
            end
          end

          # Fall through: call the method on subject and use boolean result
          call = Call.new(ctx.next_id, TypeRef::BOOL, subject_id, member_name, [] of ValueId)
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::BOOL)
          return call.id
        else
          # Non-implicit receiver: lower normally and compare
          cond_val = lower_expr(ctx, cond_expr)
          eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
          ctx.emit(eq)
          eq.id
        end
      when CrystalV2::Compiler::Frontend::CallNode
        # Check for implicit receiver pattern: .method?() → subject.method?()
        # CallNode.callee is a MemberAccessNode with ImplicitObjNode
        callee_node = @arena[cond_node.callee]
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          obj_node = @arena[callee_node.object]
          member_name = String.new(callee_node.member)

          # Check for implicit receiver OR explicit receiver that's an identifier or member access
          is_implicit = obj_node.is_a?(CrystalV2::Compiler::Frontend::ImplicitObjNode)
          is_identifier = obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          is_member_access = obj_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          if (is_implicit || is_identifier || is_member_access) && member_name.ends_with?('?')
            # Implicit receiver call OR explicit subject call: .data1?(), c.red?(), format.format.data1?()
            # The parser expands "when .data1?" to "subject.data1?()" so the callee's object
            # represents the SAME expression as the case subject. Use subject_id directly.
            #
            # For is_member_access: obj_node is a MemberAccessNode representing subject expression
            # This is the same expression that was already lowered to subject_id, so reuse it.
            actual_object_id = subject_id

            # Find enum type by matching predicate name against known enum members
            enum_name = nil.as(String?)
            base_name = member_name[0...-1] # Remove trailing ?

            # First try to identify enum type from type info (most reliable)
            obj_type = ctx.type_of(actual_object_id)
            if type_desc = @module.get_type_descriptor(obj_type)
              type_name = type_desc.name
              if @enum_info.try(&.has_key?(type_name))
                enum_name = type_name
              end
            end

            # Lazy-discover enum from stdlib if type descriptor is known but not in @enum_info
            if enum_name.nil?
              if (td2 = @module.get_type_descriptor(obj_type)) && !td2.name.empty?
                if lazy_discover_enum_from_source(td2.name)
                  enum_name = td2.name
                end
              end
            end

            # Fall back to enum_value_types tracking
            if enum_name.nil?
              enum_name = @enum_value_types.try(&.[actual_object_id]?)
            end

            # Last resort: global enum search, but ONLY if subject type is unknown or is an enum.
            # Do NOT match when subject is a known non-enum type (Char, Int32, String, etc.)
            # to avoid false matches like `.ascii?` → `Unicode::CaseOptions::ASCII`.
            if enum_name.nil?
              subject_type_known_non_enum = false
              # Built-in primitive types are never enums
              if obj_type.id < TypeRef::FIRST_USER_TYPE
                subject_type_known_non_enum = true
              elsif td = @module.get_type_descriptor(obj_type)
                subject_type_known_non_enum = !(@enum_info.try(&.has_key?(td.name)) || false)
              end
              unless subject_type_known_non_enum
                if enum_info = @enum_info
                  enum_info.each do |name, members|
                    if members.keys.any? { |m| underscore_lower(m) == underscore_lower(base_name) }
                      enum_name = name
                      break
                    end
                  end
                end
              end
            end

            if enum_name && (enum_info = @enum_info)
              if members = enum_info[enum_name]?
                base_name = member_name[0...-1] # Remove trailing ?
                member_match = members.keys.find { |m| underscore_lower(m) == underscore_lower(base_name) }
                if member_match
                  member_value = members[member_match]
                  enum_type = enum_base_type(enum_name)
                  lit = Literal.new(ctx.next_id, enum_type, member_value)
                  ctx.emit(lit)
                  ctx.register_type(lit.id, enum_type)
                  # Compare against actual_object_id (which may differ from subject_id for member access)
                  cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, actual_object_id, lit.id)
                  ctx.emit(cmp)
                  ctx.register_type(cmp.id, TypeRef::BOOL)
                  return cmp.id
                end
              end
            end

            # Fall through: call the method on actual object
            call = Call.new(ctx.next_id, TypeRef::BOOL, actual_object_id, member_name, [] of ValueId)
            ctx.emit(call)
            ctx.register_type(call.id, TypeRef::BOOL)
            return call.id
          end
        end

        # Default: lower the call expression and compare
        cond_val = lower_expr(ctx, cond_expr)
        eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
        ctx.emit(eq)
        eq.id
      when CrystalV2::Compiler::Frontend::GenericNode
        # Generic type like Tuple(X, Y), Array(Int32), etc.
        # In case/in this is a type check: subject.is_a?(GenericType)
        type_name = extract_type_name_from_node(cond_node)
        if type_name
          check_type = type_ref_for_name(type_name)
          subject_type = ctx.type_of(subject_id)

          # If subject is union type, use UnionIs
          if is_union_type?(subject_type)
            variant_id = get_union_variant_id(subject_type, check_type)
            if variant_id >= 0
              union_is = UnionIs.new(ctx.next_id, subject_id, variant_id)
              ctx.emit(union_is)
              return union_is.id
            end
          end

          # Regular is_a? check
          is_a = IsA.new(ctx.next_id, subject_id, check_type)
          ctx.emit(is_a)
          is_a.id
        else
          # Fallback: equality
          cond_val = lower_expr(ctx, cond_expr)
          eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
          ctx.emit(eq)
          eq.id
        end
      else
        # Default: call === method (when we have method calls working)
        # For now, fall back to equality
        cond_val = lower_expr(ctx, cond_expr)
        eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
        ctx.emit(eq)
        eq.id
      end
    end

    # Check if a name refers to a type (starts with uppercase)
    private def is_type_name?(name : String) : Bool
      return false if name.empty?
      first_char = name[0]
      first_char.uppercase? && @class_info.has_key?(name) ||
        ["Int32", "Int64", "String", "Bool", "Nil", "Float64"].includes?(name)
    end

    private def lower_case(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::CaseNode) : ValueId
      # Save locals state before case for proper phi merging
      pre_case_locals = ctx.save_locals

      # Lower case subject
      subject_id = if subj = node.value
                     lower_expr(ctx, subj)
                   else
                     nil
                   end

      merge_block = ctx.create_block
      incoming = [] of Tuple(BlockId, ValueId)
      branch_locals = [] of Tuple(BlockId, Hash(String, ValueId)) # Track locals for each branch

      # Combine when_branches and in_branches (case/in exhaustive matching)
      all_branches = node.when_branches.dup
      if in_branches = node.in_branches
        in_branches.each { |b| all_branches << b }
      end

      # Process each when/in branch
      all_branches.each_with_index do |when_branch, idx|
        when_block = ctx.create_block
        next_block = ctx.create_block

        # Build condition (any match)
        if subject_id
          # Match subject against when values using appropriate === semantics
          conds = when_branch.conditions.map do |cond_expr|
            emit_case_comparison(ctx, subject_id.not_nil!, cond_expr)
          end

          # Combine with OR
          combined = conds.reduce do |acc, c|
            or_op = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Or, acc, c)
            ctx.emit(or_op)
            or_op.id
          end

          ctx.terminate(Branch.new(combined, when_block, next_block))
        else
          # No subject: conditions are boolean
          cond_val = lower_expr(ctx, when_branch.conditions.first)
          ctx.terminate(Branch.new(cond_val, when_block, next_block))
        end

        # When body - restore locals before each branch
        ctx.current_block = when_block
        ctx.restore_locals(pre_case_locals)
        ctx.push_scope(ScopeKind::Block)
        result = lower_body(ctx, when_branch.body)
        exit_block = ctx.current_block
        ctx.pop_scope

        # Check if branch flows to merge
        when_block_data = ctx.get_block(ctx.current_block)
        when_has_noreturn = when_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
        when_flows_to_merge = when_block_data.terminator.is_a?(Unreachable) && !when_has_noreturn

        if when_flows_to_merge
          # Save branch locals before jumping to merge (only if flowing)
          branch_locals << {exit_block, ctx.save_locals}
          ctx.terminate(Jump.new(merge_block))
          incoming << {exit_block, result}
        end

        ctx.current_block = next_block
      end

      # Else branch - restore locals before else branch
      ctx.restore_locals(pre_case_locals)
      ctx.push_scope(ScopeKind::Block)
      else_result = if else_body = node.else_branch
                      if else_body.empty?
                        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                        ctx.emit(nil_lit)
                        nil_lit.id
                      else
                        lower_body(ctx, else_body)
                      end
                    else
                      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                      ctx.emit(nil_lit)
                      nil_lit.id
                    end
      else_exit = ctx.current_block
      ctx.pop_scope

      # Check if else branch flows to merge
      else_block_data = ctx.get_block(ctx.current_block)
      else_has_noreturn = else_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
      else_flows_to_merge = else_block_data.terminator.is_a?(Unreachable) && !else_has_noreturn

      if else_flows_to_merge
        # Save else branch locals (only if flowing)
        branch_locals << {else_exit, ctx.save_locals}
        ctx.terminate(Jump.new(merge_block))
        incoming << {else_exit, else_result}
      end

      # Merge
      ctx.current_block = merge_block

      # Only merge locals and create phi if at least one branch flows
      if incoming.empty?
        # No branches flow to merge - emit nil placeholder
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      # Merge locals from branches that flow to merge
      merge_case_locals(ctx, pre_case_locals, branch_locals)

      value_types = incoming.map { |(_, val)| ctx.type_of(val) }.reject { |t| t == TypeRef::VOID }.uniq
      phi_type = value_types.first? || TypeRef::VOID

      if env_get("DEBUG_UNION_PHI")
        debug_filter = env_get("DEBUG_UNION_PHI")
        should_log = debug_filter == "1" ||
                     (debug_filter && ctx.function.name.includes?(debug_filter))
        if should_log
          incoming.each do |(blk, val)|
            val_type = ctx.type_of(val)
            val_info = ctx.value_for(val)
            val_desc = val_info ? val_info.class.name.split("::").last : "unknown"
            val_name = val_info.is_a?(Call) ? " call=#{val_info.method_name}" : ""
            STDERR.puts "[UNION_PHI_IN] func=#{ctx.function.name} blk=#{blk} val=#{get_type_name_from_ref(val_type)} kind=#{val_desc}#{val_name}"
          end
        end
      end

      # If branch value types differ, prefer a union type that covers them.
      # This avoids invalid IR when merging mixed types (e.g., Bool/Float64/Int64),
      # and matches Crystal semantics (case expression returns a union).
      if value_types.size > 1 && !value_types.all? { |t| numeric_primitive?(t) }
        if union_ref = find_covering_union_type(value_types)
          phi_type = union_ref
        else
          union_name = value_types.map { |t| get_type_name_from_ref(t) }.uniq.join(" | ")
          phi_type = create_union_type(union_name)
        end
      end

      # Coerce incoming values to the chosen phi type when needed.
      #
      # NOTE: We must insert conversions into the predecessor blocks (not the merge block),
      # otherwise the SSA value won't dominate the phi edge.
      coerced_incoming = incoming.map do |(blk, val)|
        val_type = ctx.type_of(val)
        if val_type == phi_type
          {blk, val}
        elsif is_union_type?(phi_type)
          variant_id = get_union_variant_id(phi_type, val_type)
          if env_get("DEBUG_UNION_PHI")
            debug_filter = env_get("DEBUG_UNION_PHI")
            should_log = debug_filter == "1" ||
                         (debug_filter && ctx.function.name.includes?(debug_filter))
            if should_log
              val_info = ctx.value_for(val)
              val_desc = val_info ? val_info.class.name.split("::").last : "unknown"
              val_name = val_info.is_a?(Call) ? " call=#{val_info.method_name}" : ""
              STDERR.puts "[UNION_PHI] func=#{ctx.function.name} phi=#{get_type_name_from_ref(phi_type)} val=#{get_type_name_from_ref(val_type)} kind=#{val_desc}#{val_name} variant_id=#{variant_id}"
            end
          end
          if variant_id >= 0
            wrap = UnionWrap.new(ctx.next_id, phi_type, val, variant_id)
            ctx.emit_to_block(blk, wrap)
            {blk, wrap.id}
          else
            {blk, val}
          end
        elsif numeric_primitive?(val_type) && numeric_primitive?(phi_type)
          cast = Cast.new(ctx.next_id, phi_type, val, phi_type, safe: false)
          ctx.emit_to_block(blk, cast)
          {blk, cast.id}
        else
          {blk, val}
        end
      end

      # Don't create phi for void types - LLVM doesn't allow phi void
      if phi_type == TypeRef::VOID || phi_type == TypeRef::NIL
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      # If only one branch flows, no phi needed
      if coerced_incoming.size == 1
        return coerced_incoming.first[1]
      end

      phi = Phi.new(ctx.next_id, phi_type)
      coerced_incoming.each { |(blk, val)| phi.add_incoming(blk, val) }
      ctx.emit(phi)
      phi.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # FUNCTION-RELATED
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_return(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::ReturnNode) : ValueId
      value_id = if val = node.value
                   lower_expr(ctx, val)
                 else
                   nil
                 end

      # Returns inside a caller-provided block should return from the caller,
      # not from the inlined callee. When nested yield inlining is active,
      # route block-body returns to the next outer inline-return context.
      inline_return = nil
      if @inline_yield_proc_depth == 0
        if override = @inline_yield_return_override_stack.last?
          if override.active
            inline_return = override.context
          else
            inline_return = @inline_yield_return_stack.last?
          end
        else
          inline_return = @inline_yield_return_stack.last?
        end
      end
      if env_get("DEBUG_INLINE_RETURN")
        filter = env_get("DEBUG_INLINE_RETURN_FILTER")
        if filter.nil? || ctx.function.name.includes?(filter)
          stack_ids = @inline_yield_return_stack.map { |entry| "#{entry.function_id}:#{entry.exit_block}" }.join(",")
          override_targets = @inline_yield_return_override_stack.map { |entry| entry.active ? (entry.context ? "#{entry.context.not_nil!.function_id}:#{entry.context.not_nil!.exit_block}" : "nil") : "-" }.join(",")
          chosen = inline_return ? "#{inline_return.function_id}:#{inline_return.exit_block}" : "nil"
          STDERR.puts "[INLINE_RETURN] func=#{ctx.function.name} block_depth=#{@inline_yield_block_body_depth} stack=[#{stack_ids}] overrides=[#{override_targets}] chosen=#{chosen}"
        end
      end

      if inline_return
        if inline_return.function_id != ctx.function.id
          debug_hook("inline.return.skip", "func=#{ctx.function.name} inline=#{inline_return.function_id}")
        else
          if ctx.current_block >= ctx.function.blocks.size
            debug_hook("inline.return.block_oob", "func=#{ctx.function.name} block=#{ctx.current_block} size=#{ctx.function.blocks.size}")
          else
            if value_id.nil?
              nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
              ctx.emit(nil_lit)
              value_id = nil_lit.id
            end
            exit_block = inline_return.exit_block
            current_block = ctx.current_block
            ctx.terminate(Jump.new(exit_block))
            inline_return.incoming << {current_block, value_id.not_nil!}
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            return nil_lit.id
          end
        end
      end

      ctx.terminate(Return.new(value_id))

      # Return a dummy value (code after return is unreachable)
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def infer_yield_return_type(ctx : LoweringContext) : TypeRef?
      func_name = ctx.function.name
      if @inline_yield_block_body_depth > 0 && @current_class && @current_method
        sep = @current_method_is_class ? "." : "#"
        caller_name = "#{@current_class}#{sep}#{@current_method}"
        if env_get("DEBUG_YIELD_RETURN")
          base_candidate = strip_type_suffix(caller_name)
          STDERR.puts "[YIELD_RETURN] caller=#{caller_name} has_func=#{@function_defs.has_key?(caller_name)} has_base=#{@function_defs.has_key?(base_candidate)} ctx=#{ctx.function.name}"
        end
        func_name = caller_name
      end
      base_name = strip_type_suffix(func_name)

      func_def = @function_defs[func_name]? || @function_defs[base_name]?
      return nil unless func_def

      block_param = func_def.params.try(&.find(&.is_block))
      return nil unless block_param

      block_type = block_param.type_annotation
      return nil unless block_type

      ret_name = extract_proc_return_type_name(String.new(block_type))
      return nil unless ret_name

      param_map = @type_param_map.dup
      if registered = function_type_param_map_for(func_name, base_name)
        param_map = param_map.merge(registered)
      end

      resolved_name = if param_map.empty?
                        ret_name
                      else
                        substitute_type_params(ret_name, param_map)
                      end

      resolved_name = resolved_name.strip
      return nil if resolved_name.empty?
      if type_param_like?(resolved_name) && !param_map.has_key?(resolved_name)
        if env_get("DEBUG_YIELD_RETURN")
          STDERR.puts "[YIELD_RETURN] func=#{func_name} base=#{base_name} ret=#{resolved_name} map=missing"
        end
        return nil
      end
      if env_get("DEBUG_YIELD_RETURN")
        map_str = param_map.map { |k, v| "#{k}=#{v}" }.join(",")
        STDERR.puts "[YIELD_RETURN] func=#{func_name} base=#{base_name} ret=#{resolved_name} map=#{map_str}"
      end

      type_ref_for_name(resolved_name)
    end

    private def lower_yield(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::YieldNode) : ValueId
      args = if node_args = node.args
               node_args.reject(&.invalid?).map { |arg| lower_expr(ctx, arg) }
             else
               [] of ValueId
             end

      return_type = infer_yield_return_type(ctx) || TypeRef::VOID
      y = Yield.new(ctx.next_id, return_type, args)
      ctx.emit(y)
      y.id
    end

    private def lower_break(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::BreakNode) : ValueId
      # Lower the break value if present (e.g., `break x`)
      break_val_id : ValueId? = nil
      if val_expr = node.value
        break_val_id = lower_expr(ctx, val_expr)
      end

      if exit_block = @loop_exit_stack.last?
        # Track break value for while expression result
        if break_val_id && (break_vals = @loop_break_value_stack.last?)
          break_vals << {ctx.current_block, break_val_id}
        end

        # Capture current variable values at break point for exit phi construction
        if phi_nodes = @loop_phi_stack.last?
          if break_info = @loop_break_info_stack.last?
            break_locals = {} of String => ValueId
            phi_nodes.each_key do |var_name|
              if val = ctx.lookup_local(var_name)
                break_locals[var_name] = val
              end
            end
            break_info << {ctx.current_block, break_locals}
          end
        end
        ctx.terminate(Jump.new(exit_block))
      else
        ctx.terminate(Unreachable.new)
      end
      # Start a new unreachable block for any dead code after break
      dead_block = ctx.create_block
      ctx.switch_to_block(dead_block)
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_next(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::NextNode) : ValueId
      if cond_block = @loop_cond_stack.last?
        # Patch phi nodes with current variable values so the loop header
        # sees updated variables when we jump back from this block
        if phi_nodes = @loop_phi_stack.last?
          current_block = ctx.current_block
          phi_nodes.each do |var_name, phi|
            if updated_val = ctx.lookup_local(var_name)
              incoming_val = updated_val
              phi_type = ctx.type_of(phi.id)
              val_type = ctx.type_of(updated_val)
              if phi_type != val_type
                if is_union_type?(phi_type)
                  if variant_id = get_union_variant_id(phi_type, val_type)
                    wrap = UnionWrap.new(ctx.next_id, phi_type, updated_val, variant_id)
                    ctx.emit(wrap)
                    incoming_val = wrap.id
                  end
                elsif numeric_primitive?(val_type) && numeric_primitive?(phi_type)
                  cast = Cast.new(ctx.next_id, phi_type, updated_val, phi_type, safe: false)
                  ctx.emit(cast)
                  incoming_val = cast.id
                end
              end
              phi.add_incoming(current_block, incoming_val)
            end
          end
        end
        ctx.terminate(Jump.new(cond_block))
      else
        ctx.terminate(Unreachable.new)
      end
      # Start a new unreachable block for any dead code after next
      dead_block = ctx.create_block
      ctx.switch_to_block(dead_block)
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # EXCEPTION HANDLING
    # ═══════════════════════════════════════════════════════════════════════

    # Lower begin/rescue/ensure block
    # Structure:
    #   begin
    #     body...
    #   rescue ex : ExceptionType
    #     handler...
    #   else
    #     else_body...
    #   ensure
    #     cleanup...
    #   end
    private def lower_begin(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::BeginNode) : ValueId
      # Exception handling using setjmp/longjmp:
      # 1. Call TryBegin (setjmp) - returns 0 for normal, non-zero for exception
      # 2. Branch based on result
      # 3. Body path: execute body, call TryEnd
      # 4. Rescue path: execute rescue handlers, call TryEnd
      # 5. Ensure path: always executed

      has_rescue = !node.rescue_clauses.nil? && !node.rescue_clauses.not_nil!.empty?
      has_else = !node.else_body.nil? && !node.else_body.not_nil!.empty?
      has_ensure = !node.ensure_body.nil? && !node.ensure_body.not_nil!.empty?

      # Create blocks
      body_block = ctx.create_block
      rescue_block = ctx.create_block if has_rescue
      else_block = ctx.create_block if has_else
      ensure_block = ctx.create_block if has_ensure
      exit_block = ctx.create_block

      # Track locals for rescue merging (only when no else/ensure).
      pre_locals : Hash(String, ValueId)? = has_rescue ? ctx.save_locals : nil
      body_locals : Hash(String, ValueId)? = nil
      rescue_locals : Hash(String, ValueId)? = nil
      body_exit_block : BlockId? = nil
      rescue_exit_block : BlockId? = nil

      # If we have rescue clauses, set up exception handling
      if has_rescue
        # Call TryBegin - returns 0 for normal path, non-zero for exception
        try_begin = TryBegin.new(ctx.next_id)
        ctx.emit(try_begin)
        ctx.register_type(try_begin.id, TypeRef::INT32)

        # Compare with 0
        zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
        ctx.emit(zero)
        ctx.register_type(zero.id, TypeRef::INT32)

        cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, try_begin.id, zero.id)
        ctx.emit(cmp)
        ctx.register_type(cmp.id, TypeRef::BOOL)

        # Branch: if result == 0, normal path (body); else exception path (rescue)
        ctx.terminate(Branch.new(cmp.id, body_block, rescue_block.not_nil!))
      else
        # No rescue - just jump to body
        ctx.terminate(Jump.new(body_block))
      end

      ctx.switch_to_block(body_block)

      # Lower body
      result_id : ValueId = ctx.next_id
      node.body.each do |expr_id|
        result_id = lower_expr(ctx, expr_id)
      end

      # After body, call TryEnd if we have rescue handlers
      if has_rescue
        try_end = TryEnd.new(ctx.next_id)
        ctx.emit(try_end)
      end

      # Snapshot locals after body for rescue-merge.
      if has_rescue
        body_locals = ctx.save_locals
      end

      # After body, jump to else (if exists) or ensure (if exists) or exit
      after_body_target = else_block || ensure_block || exit_block
      ctx.terminate(Jump.new(after_body_target))
      body_exit_block = after_body_target

      # Lower rescue clauses if any
      if has_rescue
        rescue_clauses = node.rescue_clauses.not_nil!
        ctx.switch_to_block(rescue_block.not_nil!)

        # Pop exception handler FIRST — before rescue body executes.
        # This ensures that if the rescue body raises (re-raise), the
        # exception propagates to the OUTER handler, not back to this one.
        try_end_rescue = TryEnd.new(ctx.next_id)
        ctx.emit(try_end_rescue)

        # For now, just execute the first rescue clause's body
        # TODO: proper exception type matching
        rescue_result : ValueId = ctx.next_id
        rescue_clauses.each_with_index do |clause, idx|
          # If clause has variable name, create local for exception
          var_name = clause.variable_name
          if var_name.nil?
            if exc_type = clause.exception_type
              exc_name = String.new(exc_type)
              if !exc_name.empty? && exc_name[0].lowercase?
                var_name = exc_type
              end
            end
          end
          if var_name
            exc_type_name = clause.exception_type ? String.new(clause.exception_type.not_nil!) : ""
            if !exc_type_name.empty? && exc_type_name[0].lowercase?
              exc_type_name = ""
            end
            exc_type_ref = TypeRef::VOID
            if !exc_type_name.empty?
              exc_type_ref = type_ref_for_name(exc_type_name)
            end
            if exc_type_ref == TypeRef::VOID
              exc_type_ref = type_ref_for_name("Exception")
              exc_type_ref = TypeRef::POINTER if exc_type_ref == TypeRef::VOID
            end
            if env_get("DEBUG_RESCUE_TYPE")
              exc_name = exc_type_name.empty? ? "Exception" : exc_type_name
              STDERR.puts "[RESCUE_TYPE] var=#{String.new(var_name)} type_name=#{exc_name} resolved=#{get_type_name_from_ref(exc_type_ref)}"
            end

            exc_var = Local.new(ctx.next_id, exc_type_ref, String.new(var_name), ctx.current_scope, true)
            ctx.emit(exc_var)
            ctx.register_local(String.new(var_name), exc_var.id)
            ctx.register_type(exc_var.id, exc_type_ref)

            # Get exception value
            get_exc = GetException.new(ctx.next_id, exc_type_ref)
            ctx.emit(get_exc)
            ctx.register_type(get_exc.id, exc_type_ref)

            # Copy to variable
            copy = Copy.new(ctx.next_id, exc_type_ref, get_exc.id)
            ctx.emit(copy)
            ctx.register_type(copy.id, exc_type_ref)

            # Update local to point to the copy result (exception value),
            # not the Local alloca. Without this, phi merges and rescue body
            # code that references 'ex' would use the alloca pointer instead
            # of the actual exception.
            ctx.register_local(String.new(var_name), copy.id)
          end

          # Lower rescue body
          clause.body.each do |expr_id|
            rescue_result = lower_expr(ctx, expr_id)
          end

          # Only handle first clause for now
          break
        end

        # TryEnd already called at start of rescue block (before body).
        # No need to call again here — handler was already popped.

        # Snapshot locals after rescue for rescue-merge.
        rescue_locals = ctx.save_locals

        # After rescue, jump to ensure or exit
        after_rescue_target = ensure_block || exit_block
        ctx.terminate(Jump.new(after_rescue_target))
        rescue_exit_block = after_rescue_target
      end

      # Lower else block if any
      if has_else
        else_body = node.else_body.not_nil!
        ctx.switch_to_block(else_block.not_nil!)
        else_body.each do |expr_id|
          result_id = lower_expr(ctx, expr_id)
        end
        after_else_target = ensure_block || exit_block
        ctx.terminate(Jump.new(after_else_target))
      end

      # Lower ensure block if any
      if has_ensure
        ensure_body = node.ensure_body.not_nil!
        ctx.switch_to_block(ensure_block.not_nil!)
        ensure_body.each do |expr_id|
          lower_expr(ctx, expr_id) # ensure result is discarded
        end
        ctx.terminate(Jump.new(exit_block))
      end

      # Continue from exit block
      ctx.switch_to_block(exit_block)

      # Merge locals from body/rescue when both paths converge directly to exit
      if has_rescue && body_locals && rescue_locals &&
         body_exit_block == exit_block && rescue_exit_block == exit_block &&
         pre_locals
        merge_branch_locals(ctx, pre_locals, body_locals, rescue_locals, body_block, rescue_block.not_nil!)
      end

      result_id
    end

    # Lower raise statement
    private def lower_raise(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::RaiseNode) : ValueId
      exc_value : ValueId? = nil
      exc_message : String? = nil

      if val_id = node.value
        val_node = @arena[val_id]
        # Check if it's a string literal for simple raise "message"
        if val_node.is_a?(CrystalV2::Compiler::Frontend::StringNode)
          exc_message = String.new(val_node.value)
        else
          # Lower the exception value
          exc_value = lower_expr(ctx, val_id)
        end
      end

      # Emit raise instruction
      raise_inst = Raise.new(ctx.next_id, exc_value, exc_message)
      ctx.emit(raise_inst)

      # Raise is a terminator - nothing executes after
      ctx.terminate(Unreachable.new)

      raise_inst.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # CALLS
    # ═══════════════════════════════════════════════════════════════════════

    private def call_signature_for_base(base_name : String, arity : Int32, has_block : Bool) : CallSignature?
      return nil if base_name.empty?
      CallSignature.new(base_name, arity, has_block)
    end

    private def callsite_cache_key(
      receiver_type : TypeRef,
      method_name : String,
      arg_types : Array(TypeRef),
      has_block : Bool,
    ) : String
      String.build do |io|
        io << receiver_type.id
        io << '|'
        io << method_name
        io << '|'
        arg_types.each_with_index do |t, idx|
          io << ',' if idx > 0
          io << t.id
        end
        io << '|'
        io << (has_block ? 1 : 0)
      end
    end

    private def call_signature_for_call(name : String, arg_count : Int32, has_block : Bool) : CallSignature?
      base = base_callsite_key(name)
      call_signature_for_base(base, arg_count, has_block)
    end

    private def call_signature_for_def(
      func_def : CrystalV2::Compiler::Frontend::DefNode,
      name : String,
      target_name : String,
    ) : CallSignature?
      base = base_callsite_key(target_name.empty? ? name : target_name)
      return nil if base.empty?
      params = func_def.params
      return nil unless params

      has_block = params.any?(&.is_block)
      param_count = params.count { |p| !p.is_block && !named_only_separator?(p) }
      call_signature_for_base(base, param_count, has_block)
    end

    private def remember_callsite_arg_types(
      name : String,
      arg_types : Array(TypeRef),
      arg_literals : Array(Bool)? = nil,
      enum_names : Array(String?)? = nil,
      has_block : Bool = false,
    ) : Nil
      return if name.empty?
      base_key = base_callsite_key(name)
      # Avoid per-receiver callsite tracking for Object#in? (defined only on Object),
      # which otherwise causes massive monomorphization explosions.
      return if base_key.ends_with?("#in?")
      callsite = CallsiteArgs.new(
        arg_types.dup,
        arg_literals ? arg_literals.dup : nil,
        enum_names ? enum_names.dup : nil
      )
      @pending_arg_types[name] = callsite
      return if base_key.empty?
      literal_key = if arg_literals
                      arg_literals.map { |flag| flag ? '1' : '0' }.join
                    else
                      "-"
                    end
      seen_by_arity = @pending_arg_types_seen_by_arity[base_key]? || begin
        new_map = {} of Int32 => Set(String)
        @pending_arg_types_seen_by_arity[base_key] = new_map
        new_map
      end
      seen_bucket = seen_by_arity[arg_types.size]? || begin
        new_set = Set(String).new
        seen_by_arity[arg_types.size] = new_set
        new_set
      end
      callsite_key = "#{arg_types.map(&.id).join(",")}|#{literal_key}|#{has_block ? 1 : 0}"
      return if seen_bucket.includes?(callsite_key)
      seen_bucket.add(callsite_key)
      by_arity = @pending_arg_types_by_arity[base_key]? || begin
        new_map = {} of Int32 => Array(CallsiteArgs)
        @pending_arg_types_by_arity[base_key] = new_map
        new_map
      end
      bucket = by_arity[arg_types.size]? || [] of CallsiteArgs
      bucket << callsite
      by_arity[arg_types.size] = bucket
      if debug_hook_filter_match?(name)
        literal_payload = arg_literals ? arg_literals.join(",") : "nil"
        debug_hook(
          "callsite.args",
          "name=#{name} types=#{arg_types.map(&.id).join(",")} literals=#{literal_payload}"
        )
      end
      if debug_hook_filter_match?(name)
        literal_payload = arg_literals ? arg_literals.join(",") : "nil"
        debug_hook(
          "callsite.args",
          "name=#{name} types=#{arg_types.map(&.id).join(",")} literals=#{literal_payload}"
        )
      end
      if debug_hook_filter_match?(name)
        literal_payload = arg_literals ? arg_literals.join(",") : "nil"
        debug_hook(
          "callsite.args",
          "name=#{name} types=#{arg_types.map(&.id).join(",")} literals=#{literal_payload}"
        )
      end
      if env_get("DEBUG_FROM_IO_CALLSITE") && name.includes?("from_io")
        STDERR.puts "[FROM_IO_CALLSITE] name=#{name} types=#{arg_types.map(&.id).join(",")}"
      end
      if signature = call_signature_for_call(name, arg_types.size, has_block)
        sig_bucket = @pending_arg_types_by_signature[signature]? || [] of CallsiteArgs
        sig_bucket << callsite
        @pending_arg_types_by_signature[signature] = sig_bucket

        recorded_seen = @recorded_arg_types_seen_by_signature[signature]? || begin
          new_set = Set(String).new
          @recorded_arg_types_seen_by_signature[signature] = new_set
          new_set
        end
        unless recorded_seen.includes?(callsite_key)
          recorded_seen.add(callsite_key)
          recorded_bucket = @recorded_arg_types_by_signature[signature]? || [] of CallsiteArgs
          recorded_bucket << callsite
          @recorded_arg_types_by_signature[signature] = recorded_bucket
        end
      end
    end

    private def base_callsite_key(name : String) : String
      return "" if name.empty?
      base = strip_type_suffix(name)
      base = base.sub(/_(double_)?splat$/, "")
      base
    end

    private def pop_pending_callsite_args(name : String, target_name : String) : CallsiteArgs?
      candidates = [] of String
      {name, target_name}.each do |key|
        next if key.empty?
        candidates << key

        if key.ends_with?("_splat") || key.ends_with?("_double_splat")
          stripped = key.sub(/_(double_)?splat$/, "")
          candidates << stripped if stripped != key
        end

        base = strip_type_suffix(key)
        candidates << base if base != key
        if base.ends_with?("_splat") || base.ends_with?("_double_splat")
          stripped_base = base.sub(/_(double_)?splat$/, "")
          candidates << stripped_base if stripped_base != base
        end
      end

      candidates.uniq!
      candidates.each do |key|
        if callsite = @pending_arg_types[key]?
          @pending_arg_types.delete(key)
          base = base_callsite_key(key)
          remove_callsite_from_pending_maps(base, callsite.types, callsite.literals)
          return callsite
        end
      end

      nil
    end

    private def consume_callsite_args(base_key : String, entry : CallsiteArgs) : Nil
      remove_callsite_from_pending_maps(base_key, entry.types, entry.literals)
    end

    private def remove_callsite_from_pending_maps(
      base_key : String,
      types : Array(TypeRef),
      literals : Array(Bool)?,
    ) : Nil
      return if base_key.empty?

      if by_arity = @pending_arg_types_by_arity[base_key]?
        if bucket = by_arity[types.size]?
          idx = bucket.index do |candidate|
            candidate.types == types && (literals.nil? || candidate.literals == literals)
          end
          if idx
            bucket.delete_at(idx)
            by_arity.delete(types.size) if bucket.empty?
            @pending_arg_types_by_arity.delete(base_key) if by_arity.empty?
          end
        end
      end

      {true, false}.each do |has_block|
        if signature = call_signature_for_base(base_key, types.size, has_block)
          if sig_bucket = @pending_arg_types_by_signature[signature]?
            idx = sig_bucket.index do |candidate|
              candidate.types == types && (literals.nil? || candidate.literals == literals)
            end
            if idx
              sig_bucket.delete_at(idx)
              @pending_arg_types_by_signature.delete(signature) if sig_bucket.empty?
            end
          end
        end
      end
    end

    private def select_best_callsite_args(
      func_def : CrystalV2::Compiler::Frontend::DefNode,
      candidates : Array(CallsiteArgs),
      context : String?,
    ) : CallsiteArgs?
      if candidates.any? { |entry| entry.types.any? { |t| get_type_name_from_ref(t) == "block" } }
        without_block = candidates.select { |entry| entry.types.none? { |t| get_type_name_from_ref(t) == "block" } }
        candidates = without_block unless without_block.empty?
      end

      best : CallsiteArgs? = nil
      best_score = Int32::MIN
      candidates.each do |entry|
        call_types = entry.types
        next if call_types.all? { |t| t == TypeRef::VOID }
        next unless params_compatible_with_args?(func_def, call_types, context)
        score = params_match_score(func_def, call_types, context)
        if score > best_score
          best = entry
          best_score = score
        end
      end
      best
    end

    private def pending_callsite_args_for_def(
      func_def : CrystalV2::Compiler::Frontend::DefNode,
      name : String,
      target_name : String,
    ) : CallsiteArgs?
      base_key = base_callsite_key(target_name.empty? ? name : target_name)
      return nil if base_key.empty?
      by_arity = @pending_arg_types_by_arity[base_key]?

      params = func_def.params
      return nil unless params
      param_count = 0
      required_count = 0
      has_splat = false
      params.each do |param|
        next if named_only_separator?(param) || param.is_block || param.is_double_splat
        if param.is_splat
          has_splat = true
          param_count += 1
          next
        end
        param_count += 1
        required_count += 1 unless param.default_value
      end

      func_context = function_context_from_name(target_name.empty? ? name : target_name)
      if by_arity
        if bucket = by_arity[param_count]?
          if match = select_best_callsite_args(func_def, bucket, func_context) || bucket.first?
            consume_callsite_args(base_key, match)
            return match
          end
        end

        if signature = call_signature_for_def(func_def, name, target_name)
          if sig_bucket = @pending_arg_types_by_signature[signature]?
            if match = select_best_callsite_args(func_def, sig_bucket, func_context) || sig_bucket.first?
              consume_callsite_args(base_key, match)
              return match
            end
          end
        end

        fallback_key = if has_splat
                         by_arity.keys.select { |key| key >= required_count }.max?
                       else
                         by_arity.keys.select { |key| key >= required_count && key <= param_count }.max?
                       end
        if fallback_key
          if bucket = by_arity[fallback_key]?
            match = select_best_callsite_args(func_def, bucket, func_context) || bucket.first?
            if match
              consume_callsite_args(base_key, match)
              return match
            end
          end
        end
      end

      owner = function_context_from_name(base_key)
      parts = parse_method_name_compact(base_key)
      method = parts.method
      sep = parts.separator

      if owner && method && sep
        current = owner
        visited = Set(String).new
        while true
          break if visited.includes?(current)
          visited << current
          parent_name = @class_info[current]?.try(&.parent_name)
          parent_name ||= @module.class_parents[current]?
          break unless parent_name
          current = parent_name
          ancestor_key = "#{current}#{sep}#{method}"
          if ancestor_by_arity = @pending_arg_types_by_arity[ancestor_key]?
            if bucket = ancestor_by_arity[param_count]?
              if match = select_best_callsite_args(func_def, bucket, func_context) || bucket.first?
                return match
              end
            end

            fallback_key = if has_splat
                             ancestor_by_arity.keys.select { |key| key >= required_count }.max?
                           else
                             ancestor_by_arity.keys.select { |key| key >= required_count && key <= param_count }.max?
                           end
            if fallback_key
              if bucket = ancestor_by_arity[fallback_key]?
                match = select_best_callsite_args(func_def, bucket, func_context) || bucket.first?
                return match if match
              end
            end
          end
        end
      end

      if method
        unique : CallsiteArgs? = nil
        ambiguous = false
        @pending_arg_types_by_arity.each do |key, bucket_map|
          next unless key.ends_with?("##{method}") || key.ends_with?(".#{method}")
          bucket = bucket_map[param_count]?
          next unless bucket
          bucket.each do |candidate|
            next unless params_compatible_with_args?(func_def, candidate.types, func_context)
            if unique
              same_types = candidate.types == unique.types
              same_literals = unique.literals.nil? || candidate.literals.nil? || candidate.literals == unique.literals
              unless same_types && same_literals
                ambiguous = true
                break
              end
            else
              unique = candidate
            end
          end
          break if ambiguous
        end
        return unique if unique && !ambiguous
      end

      nil
    end

    # Search a generic template's body for a method definition by name.
    # Returns {DefNode, Arena} if found, nil otherwise.
    private def find_method_in_generic_template(
      template : GenericClassTemplate,
      method_name : String,
    ) : Tuple(CrystalV2::Compiler::Frontend::DefNode, CrystalV2::Compiler::Frontend::ArenaLike)?
      body = template.node.body
      return nil unless body

      body.each do |expr_id|
        member = template.arena[expr_id]
        # Unwrap visibility modifier using template's arena, not @arena
        while member.is_a?(CrystalV2::Compiler::Frontend::VisibilityModifierNode)
          member = template.arena[member.expression]
        end

        case member
        when CrystalV2::Compiler::Frontend::DefNode
          def_name = member.name.nil? ? "" : String.new(member.name.not_nil!)
          if def_name == method_name
            if env_get("DEBUG_FIND_TEMPLATE") && method_name == "internal_representation"
              STDERR.puts "[FIND_TEMPLATE] found #{template.name}##{method_name}"
            end
            return {member, template.arena}
          end
        end
      end

      nil
    end

    private def generic_owner_info(owner : String) : NamedTuple(base: String, owner: String, args: Array(String), map: Hash(String, String))?
      info = split_generic_base_and_args(owner)
      return nil unless info

      base = info[:base]
      raw_args = split_generic_type_args(info[:args]).map do |arg|
        normalize_tuple_literal_type_name(arg.strip)
      end

      param_names : Array(String)? = nil
      if template = @generic_templates[base]?
        param_names = template.type_params
      elsif mod_defs = @module_defs[base]?
        mod_defs.each do |mod_node, _|
          if type_params = mod_node.type_params
            candidate = type_params.map { |param| String.new(param) }
            if candidate.size == raw_args.size
              param_names = candidate
              break
            end
          end
        end
      end
      return nil unless param_names
      return nil unless raw_args.size == param_names.size

      substituted_args = raw_args.map { |arg| @type_param_map[arg]? || arg }
      map = {} of String => String
      param_names.each_with_index do |param, idx|
        map[param] = substituted_args[idx]
      end

      resolved_owner = "#{base}(#{substituted_args.join(", ")})"
      {base: base, owner: resolved_owner, args: substituted_args, map: map}
    end

    private def find_module_def_recursive(
      module_name : String,
      method_base : String,
      expected_param_count : Int32,
      visited : Set(String),
    ) : Tuple(CrystalV2::Compiler::Frontend::DefNode, CrystalV2::Compiler::Frontend::ArenaLike)?
      ensure_module_def_lookup_cache
      cache_key = "#{module_name}##{method_base}@#{expected_param_count}"
      if @module_def_lookup_cache.has_key?(cache_key)
        return @module_def_lookup_cache[cache_key]
      end
      return nil if visited.includes?(module_name)
      visited << module_name

      mod_defs = @module_defs[module_name]?
      # Resolve type aliases in module name path.
      # e.g., Engine::MatchData → PCRE2::MatchData → Regex::PCRE2::MatchData
      unless mod_defs
        resolved_mod = resolve_alias_in_module_path(module_name)
        if resolved_mod != module_name
          mod_defs = @module_defs[resolved_mod]?
          module_name = resolved_mod if mod_defs
        end
      end
      if env_has?("DEBUG_FIND_MODULE") && method_base == "byte_range"
        has_defs = !mod_defs.nil?
        STDERR.puts "[FIND_MODULE] module=#{module_name} method=#{method_base} has_defs=#{has_defs} num_defs=#{mod_defs.try(&.size) || 0}"
      end
      return nil unless mod_defs

      # Phase 1: Check direct DefNode definitions in this module FIRST.
      # This ensures that overrides (e.g., Indexable#empty? overriding Enumerable#empty?)
      # take priority over methods found through included modules.
      mod_defs.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          body = mod_node.body
          next unless body

          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            case member
            when CrystalV2::Compiler::Frontend::DefNode
              next if (recv = member.receiver) && String.new(recv) == "self"
              next if member.is_abstract
              member_name = String.new(member.name)
              next unless member_name == method_base

              actual_param_count = 0
              if params = member.params
                params.each do |param|
                  next if param.is_block || param.is_splat || param.is_double_splat || named_only_separator?(param)
                  actual_param_count += 1
                end
              end

              if expected_param_count == 0 || expected_param_count == actual_param_count
                result = {member, mod_arena}
                @module_def_lookup_cache[cache_key] = result
                return result
              end
            end
          end
        end
      end

      # Phase 2: If not found directly, search included modules recursively.
      mod_defs.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          body = mod_node.body
          next unless body

          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            case member
            when CrystalV2::Compiler::Frontend::IncludeNode
              include_name = resolve_path_like_name(member.target)
              next unless include_name
              if found = find_module_def_recursive(include_name, method_base, expected_param_count, visited)
                @module_def_lookup_cache[cache_key] = found
                return found
              end
            end
          end
        end
      end

      @module_def_lookup_cache[cache_key] = nil
      nil
    end

    # Resolve type aliases in a module path.
    # Mirrors the original Crystal compiler's AliasType.lookup_path_item() behavior:
    # the first path component is resolved through type aliases, then the remaining
    # components are appended and the full path is located in @module_defs.
    # e.g., Engine::MatchData → PCRE2::MatchData → Regex::PCRE2::MatchData
    private def resolve_alias_in_module_path(name : String) : String
      return name if name.empty?
      # Strategy 1: Direct alias resolution of the full name
      resolved = resolve_type_alias_chain(name)
      return resolved if resolved != name && @module_defs.has_key?(resolved)

      # Strategy 2: Resolve the FIRST path component through type aliases.
      # Only the first component can be an alias (like Crystal's lookup_path_item).
      # For "Engine::MatchData", resolve "Engine" → "PCRE2", yielding "PCRE2::MatchData".
      parts = name.split("::")
      first = parts.first
      rest = parts.size > 1 ? parts[1..].join("::") : nil
      # Find an alias whose short name matches the first component
      resolved_first : String? = nil
      @type_aliases.each do |alias_key, alias_target|
        if last_namespace_component(alias_key) == first
          resolved_first = alias_target
          break
        end
      end
      if resolved_first
        candidate = rest ? "#{resolved_first}::#{rest}" : resolved_first
        return candidate if @module_defs.has_key?(candidate)
        # The resolved name might need a parent namespace prefix.
        # Walk @module_defs for a suffix match (e.g., PCRE2::MatchData → Regex::PCRE2::MatchData).
        suffix = "::#{candidate}"
        @module_defs.each_key do |key|
          return key if key.ends_with?(suffix)
        end
      end

      # Strategy 3: Suffix match on original name (handles unqualified references)
      suffix = "::#{name}"
      @module_defs.each_key do |key|
        return key if key.ends_with?(suffix)
      end
      name
    end

    private def find_module_class_def(
      module_name : String,
      method_base : String,
      expected_param_count : Int32,
      call_arg_types : Array(TypeRef)? = nil,
    ) : Tuple(CrystalV2::Compiler::Frontend::DefNode, CrystalV2::Compiler::Frontend::ArenaLike)?
      is_math_min_debug = env_get("DEBUG_MATH_MIN") && module_name == "Math" && (method_base == "min" || method_base == "max")
      if is_math_min_debug
        arg_type_names = call_arg_types ? call_arg_types.map { |t| get_type_name_from_ref(t) }.join(",") : "nil"
        STDERR.puts "[MATH_MIN_FIND_DEF] module=#{module_name} method=#{method_base} param_count=#{expected_param_count} call_arg_types=#{arg_type_names}"
      end

      ensure_module_def_lookup_cache
      # Include arg types in cache key when available
      types_key = call_arg_types ? call_arg_types.map(&.id).join("_") : ""
      cache_key = "#{module_name}.#{method_base}@#{expected_param_count}@#{types_key}"
      if @module_class_def_lookup_cache.has_key?(cache_key)
        return @module_class_def_lookup_cache[cache_key]
      end

      entries = @module_defs[module_name]?
      return nil unless entries

      # Collect all matching candidates
      candidates = [] of {CrystalV2::Compiler::Frontend::DefNode, CrystalV2::Compiler::Frontend::ArenaLike, Int32}

      entries.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          body = mod_node.body
          next unless body

          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            next unless member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
            next if member.is_abstract
            recv = member.receiver
            next unless recv && String.new(recv) == "self"
            next unless String.new(member.name) == method_base

            actual_param_count = 0
            typed_param_count = 0
            if params = member.params
              params.each do |param|
                next if param.is_block || param.is_splat || param.is_double_splat || named_only_separator?(param)
                actual_param_count += 1
                typed_param_count += 1 if param.type_annotation
              end
            end

            if expected_param_count == 0 || expected_param_count == actual_param_count
              # Calculate score: prefer typed params that match call types, then untyped
              score = 0
              if call_arg_types && !call_arg_types.empty?
                # Check type compatibility
                compatible = true
                if params = member.params
                  param_idx = 0
                  params.each do |param|
                    next if param.is_block || param.is_splat || param.is_double_splat || named_only_separator?(param)
                    break if param_idx >= call_arg_types.size

                    call_type = call_arg_types[param_idx]
                    if ta = param.type_annotation
                      param_type_name = String.new(ta)
                      param_type = type_ref_for_name(param_type_name)
                      if param_type != TypeRef::VOID && call_type != TypeRef::VOID
                        if param_type == call_type
                          score += 10 # Exact match bonus
                        elsif numeric_compatible?(call_type, param_type)
                          score += 5 # Numeric compatible
                        else
                          compatible = false
                          break
                        end
                      end
                    else
                      # Untyped param - always compatible, small bonus
                      score += 1
                    end
                    param_idx += 1
                  end
                end
                next unless compatible
              else
                # No call types - prefer untyped overloads (generic)
                score = -typed_param_count
              end

              if is_math_min_debug
                param_type_names = if params = member.params
                                     params.map do |p|
                                       next "" if p.is_block
                                       if ta = p.type_annotation
                                         String.new(ta)
                                       else
                                         "(untyped)"
                                       end
                                     end
                                   else
                                     [] of String
                                   end
                STDERR.puts "[MATH_MIN_FIND_DEF]   candidate param_types=#{param_type_names.join(",")} score=#{score}"
              end
              candidates << {member, mod_arena, score}
            end
          end
        end
      end

      return nil if candidates.empty?

      # Sort by score descending and take the best
      best = candidates.max_by { |c| c[2] }
      if is_math_min_debug
        best_param_types = if params = best[0].params
                             params.map do |p|
                               next "" if p.is_block
                               if ta = p.type_annotation
                                 String.new(ta)
                               else
                                 "(untyped)"
                               end
                             end
                           else
                             [] of String
                           end
        STDERR.puts "[MATH_MIN_FIND_DEF]   SELECTED param_types=#{best_param_types.join(",")} score=#{best[2]}"
      end
      result = {best[0], best[1]}
      @module_class_def_lookup_cache[cache_key] = result
      result
    end

    # Eagerly infer return type for a function without fully lowering it.
    # This is used when a function is deferred during nested lowering,
    # but we need to know its return type for the caller.
    private def eager_infer_return_type(name : String) : Nil
      return if name.empty?
      dollar_idx = name.index('$')
      base_name = dollar_idx ? name[0, dollar_idx] : name

      # Skip if we already have a non-VOID return type cached
      if cached = @function_base_return_types[base_name]?
        return unless cached == TypeRef::VOID
      end

      # Try to find the function definition
      func_def = @function_defs[name]? || @function_defs[base_name]?
      return unless func_def

      # Get the arena for this function
      arena = @function_def_arenas[name]? || @function_def_arenas[base_name]?
      return unless arena

      # Switch to the function's arena temporarily
      old_arena = @arena
      @arena = arena

      begin
        # Extract self_type from name for context
        self_type = nil
        if hash_idx = base_name.rindex('#')
          self_type = base_name[0, hash_idx]
        elsif dot_idx = base_name.rindex('.')
          self_type = base_name[0, dot_idx]
        end

        # Try to infer return type from body
        # Wrap in rescue to handle arena mismatches gracefully
        begin
          if inferred = infer_concrete_return_type_from_body(func_def, self_type)
            # Cache the inferred return type
            if inferred != TypeRef::VOID
              @function_base_return_types[base_name] = inferred
            end
          end
        rescue ex
          # Arena mismatch or other error - just skip eager inference
          # The type will be inferred later when the function is fully lowered
        end
      ensure
        @arena = old_arena
      end
    end

    private def lower_function_if_needed(name : String) : Nil
      begin
        lower_function_if_needed_impl(name)
      rescue ex : KeyError
        STDERR.puts "[KEY_ERROR_TOP] name=#{name} error=#{ex.message}"
        STDERR.flush
        ex.backtrace.first(30).each do |line|
          STDERR.puts line
        end
        STDERR.flush
        raise ex
      end
    end

    # Force-lower a function immediately even if we're inside lowering.
    # Used when we need the return type of a callee that was deferred.
    # Returns true if the function was lowered, false if it couldn't be.
    private def force_lower_function_for_return_type(name : String) : Bool
      # Don't force if it would cause infinite recursion
      return false if function_state(name).in_progress?
      return false if @module.has_function?(name)
      return false if function_state(name).completed?
      # Prevent deep chaining: A needs ret type of B, B needs C, C needs D...
      max_force_depth = 32
      if @force_lower_return_type_depth >= max_force_depth
        STDERR.puts "[FORCE_LOWER_DEPTH_LIMIT] depth=#{@force_lower_return_type_depth} name=#{name}" if env_has?("DEBUG_FORCE_LOWER_DEPTH")
        return false
      end
      if env_has?("DEBUG_FORCE_LOWER_DEPTH") && @force_lower_return_type_depth > 5
        STDERR.puts "[FORCE_LOWER_CHAIN] depth=#{@force_lower_return_type_depth} name=#{name}"
      end

      # Clear pending state if set (we'll handle it now)
      if function_state(name).pending?
        @function_lowering_states.delete(name)
        @pending_function_queue.delete(name)
      end

      # Temporarily disable inside_lowering to allow immediate processing
      saved_depth = @lowering_depth
      @lowering_depth = 0
      @force_lower_return_type_depth += 1
      begin
        lower_function_if_needed_impl(name)
        true
      rescue ex
        STDERR.puts "[FORCE_LOWER_ERROR] name=#{name} error=#{ex.message}"
        if env_get("DEBUG_FORCE_LOWER")
          STDERR.flush
          ex.backtrace.first(30).each do |line|
            STDERR.puts line
          end
          STDERR.flush
        end
        false
      ensure
        @lowering_depth = saved_depth
        @force_lower_return_type_depth -= 1
      end
    end

    private def lower_function_if_needed_impl(name : String) : Nil
      return if name.empty?
      is_math_min_debug = env_get("DEBUG_MATH_MIN") && name.includes?("Math") && (name.includes?("min") || name.includes?("max"))
      if is_math_min_debug
        base = strip_type_suffix(name)
        has_def_name = @function_defs.has_key?(name)
        has_def_base = @function_defs.has_key?(base)
        overloads = function_def_overloads(base)
        STDERR.puts "[MATH_MIN_LOWER_FUNC] name=#{name} base=#{base} state=#{function_state(name)} has_func=#{@module.has_function?(name)} has_def_name=#{has_def_name} has_def_base=#{has_def_base} overloads=#{overloads.join(";")}"
      end
      debug_byte_at = env_get("DEBUG_BYTE_AT") && name.includes?("byte_at?") && name.includes?("String")
      if debug_byte_at
        base = strip_type_suffix(name)
        STDERR.puts "[LOWER_FUNC] name=#{name} base=#{base} state=#{function_state(name)} has_func=#{@module.has_function?(name)} has_def_full=#{@function_defs.has_key?(name)} has_def_base=#{@function_defs.has_key?(base)}"
      end
      debug_lookup_name = env_get("DEBUG_LOOKUP_NAME")
      if env_get("DEBUG_VDISPATCH_UNION") && name.includes?("next_power_of_two")
        STDERR.puts "[VDISPATCH_UNION_HIR] lower_function_if_needed name=#{name}"
      end
      if debug_env_filter_match?("DEBUG_FROM_CHARS", name)
        STDERR.puts "[DEBUG_FROM_CHARS] lower_function_if_needed name=#{name}"
      end
      if env_has?("DEBUG_YIELD_SKIP") && name.includes?("byte_range")
        is_yield = @yield_functions.includes?(name)
        STDERR.puts "[YIELD_SKIP] name=#{name} is_yield=#{is_yield}"
      end
      if function_state(name).in_progress?
        if debug_env_filter_match?("DEBUG_FROM_CHARS", name)
          STDERR.puts "[DEBUG_FROM_CHARS] skip already lowering name=#{name}"
        end
        if is_math_min_debug
          STDERR.puts "[MATH_MIN_LOWER_FUNC] EARLY_RETURN: in_progress name=#{name}"
        end
        return
      end
      if @module.has_function?(name)
        if is_math_min_debug
          STDERR.puts "[MATH_MIN_LOWER_FUNC] EARLY_RETURN: already_exists name=#{name}"
        end
        return
      end
      if function_state(name).completed?
        if is_math_min_debug
          STDERR.puts "[MATH_MIN_LOWER_FUNC] EARLY_RETURN: completed name=#{name}"
        end
        return
      end

      # WORK QUEUE: If we're already inside lowering, defer this function
      # to prevent stack overflow from deep recursive lowering chains.
      if inside_lowering?
        unless function_state(name).pending?
          @function_lowering_states[name] = FunctionLoweringState::Pending
          @pending_function_queue << name
          if env_get("DEBUG_PENDING_SOURCES")
            base = strip_type_suffix(name)
            stripped = strip_generic_receiver_from_base_name(base)
            @pending_source_counts[stripped] = (@pending_source_counts[stripped]? || 0) + 1
            if env_get("DEBUG_PENDING_SOURCES_SAMPLES")
              samples = @pending_source_samples[stripped]? || [] of String
              if samples.size < 3 && !samples.includes?(name)
                samples << name
                @pending_source_samples[stripped] = samples
              end
            end
          end
        end
        return
      end

      target_name = name
      # Parse name once at the start - reuse for all lookups
      name_parts = parse_method_name(name)
      base_name = name_parts.base
      primitive_template_map : Hash(String, String)? = nil
      debug_hook("function.lookup.start", name)
      if env_get("DEBUG_TRACE_FUNC") && name.includes?("trace")
        STDERR.puts "[TRACE_FUNC] lookup name=#{name}"
      end
      func_def = @function_defs[target_name]?
      arena = @function_def_arenas[target_name]?
      lookup_branch : String? = func_def ? "direct" : nil
      if env_get("DEBUG_ENTRY_MATCHES") && name.includes?("entry_matches")
        param_count = func_def.try { |fd| fd.params.try(&.size) || 0 } || -1
        STDERR.puts "[ENTRY_MATCHES_LOOKUP] name=#{name} target=#{target_name} base=#{base_name} direct_found=#{!!func_def} param_count=#{param_count}"
      end
      if is_math_min_debug
        STDERR.puts "[MATH_MIN_LOWER_FUNC] LOOKUP name=#{name} target=#{target_name} base=#{base_name} direct_found=#{!!func_def}"
      end
      if debug_lookup_name && name.includes?(debug_lookup_name) && func_def
        STDERR.puts "[DEBUG_LOOKUP_NAME] hit name=#{name} branch=#{lookup_branch} target=#{target_name}"
      end
      if func_def
        if sep = name_parts.separator
          owner = name_parts.owner
          method_part = name_parts.method
          if method_part && !owner.includes?('(') && (template = @generic_templates[owner]?)
            if found = find_method_in_generic_template(template, method_part)
              func_def = found[0]
              arena = found[1]
              target_name = name
              lookup_branch = "generic_template_prefer"
            elsif reopenings = @generic_reopenings[owner]?
              reopenings.each do |reopen_template|
                found_in_reopen = find_method_in_generic_template(reopen_template, method_part)
                next unless found_in_reopen
                func_def = found_in_reopen[0]
                arena = found_in_reopen[1]
                target_name = name
                lookup_branch = "generic_reopen_prefer"
                break
              end
            end
          end
        end
      end
      unless func_def
        if maybe_generate_class_accessor_for_name(name)
          debug_hook("function.lookup.generated", "name=#{name} kind=class_accessor")
          return
        end
        if maybe_generate_accessor_for_name(name)
          debug_hook("function.lookup.generated", "name=#{name} kind=ivar_accessor")
          return
        end
        if sep = name_parts.separator
          if sep == '.' && (owner = name_parts.owner) && (method_part = name_parts.method)
            if type_name_exists?(owner)
              resolved_class = resolve_class_method_with_inheritance(owner, method_part)
              resolved_class = nil unless resolved_class && class_method_defined?(resolved_class)
            end
            if type_name_exists?(owner) && resolved_class.nil?
              callsite = pop_pending_callsite_args(name, base_name)
              arg_types = callsite ? callsite.types : parse_types_from_suffix(name_parts.suffix || "")
              if wrapper = ensure_unbound_instance_method_wrapper(owner, method_part, arg_types)
                @function_lowering_states[wrapper] = FunctionLoweringState::Completed
                return
              end
              meta_owner = module_type_ref?(type_ref_for_name(owner)) ? "Module" : "Class"
              if wrapper = ensure_type_literal_class_method(owner, method_part, arg_types, meta_owner)
                @function_lowering_states[wrapper] = FunctionLoweringState::Completed
                return
              end
            end
          end
        end
        if !func_def
          if (suffix = name_parts.suffix) && suffix_has_block_flag?(suffix)
            block_base = "#{base_name}$block"
            if block_def = @function_defs[block_base]?
              func_def = block_def
              arena = @function_def_arenas[block_base]
              target_name = block_base
              lookup_branch = "block_base"
            else
              overloads = function_def_overloads(base_name)
              block_candidate = overloads.find do |cand|
                cand_suffix = method_suffix(cand)
                cand_suffix && suffix_has_block_flag?(cand_suffix) && strip_mangled_suffix_flags(cand_suffix).empty?
              end
              if block_candidate.nil?
                block_candidate = overloads.find do |cand|
                  cand_suffix = method_suffix(cand)
                  cand_suffix && suffix_has_block_flag?(cand_suffix)
                end
              end
              if block_candidate
                if cand_def = @function_defs[block_candidate]?
                  func_def = cand_def
                  arena = @function_def_arenas[block_candidate]
                  target_name = block_candidate
                  lookup_branch = "block_overload"
                end
              end
            end
          end
        end
        if base_name != name
          # When name has a $ suffix (e.g., clamp$Nil_Int32), don't blindly use base_name lookup
          # as it may return the wrong overload. Let the more sophisticated overload matching handle it.
          # Allow base_name fallback for block-suffixed calls (e.g., try$block) because defs
          # are usually registered at the base name.
          allow_base_fallback = !name.includes?('$')
          if !allow_base_fallback
            if suffix = name_parts.suffix
              allow_base_fallback = suffix == "block" || suffix.ends_with?("_block")
            end
          end
          if allow_base_fallback
            func_def = @function_defs[base_name]?
            arena = @function_def_arenas[base_name]? if func_def
            target_name = base_name if func_def
            lookup_branch = "base_name" if func_def
          end
        end
        # If still not found, try monomorphizing a generic owner and retry.
        unless func_def
          if sep = name_parts.separator
            owner = name_parts.owner
            method_part = name_parts.method
            if method_part && (info = generic_owner_info(owner))
              if !@monomorphized.includes?(info[:owner]) &&
                 concrete_type_args?(info[:args]) &&
                 !@suppress_monomorphization
                monomorphize_generic_class(info[:base], info[:args], info[:owner])
              end
              resolved_base = "#{info[:owner]}#{sep}#{method_part}"
              resolved_candidate = resolved_base
              if (suffix = name_parts.suffix)
                resolved_candidate = "#{resolved_base}$#{suffix}"
              end
              if resolved_def = @function_defs[resolved_candidate]?
                func_def = resolved_def
                arena = @function_def_arenas[resolved_candidate]
                target_name = resolved_candidate
                lookup_branch = "generic_owner"
              elsif resolved_def = @function_defs[resolved_base]?
                func_def = resolved_def
                arena = @function_def_arenas[resolved_base]
                target_name = resolved_base
                lookup_branch = "generic_owner_base"
              else
                template_base = "#{info[:base]}#{sep}#{method_part}"
                if candidate = @function_defs[template_base]?
                  func_def = candidate
                  arena = @function_def_arenas[template_base]
                  target_name = name
                  lookup_branch = "generic_owner_template"
                elsif (suffix = name_parts.suffix)
                  template_mangled = "#{template_base}$#{suffix}"
                  if candidate = @function_defs[template_mangled]?
                    func_def = candidate
                    arena = @function_def_arenas[template_mangled]
                    target_name = name
                    lookup_branch = "generic_owner_template_mangled"
                  else
                    mangled_prefix = "#{template_base}$"
                    function_def_overloads(template_base).each do |key|
                      next if key == template_base
                      next unless key.starts_with?(mangled_prefix)
                      func_def = @function_defs[key]
                      arena = @function_def_arenas[key]
                      target_name = name
                      lookup_branch = "generic_owner_template_prefix"
                      break
                    end
                  end
                end
                # Fallback: search the generic template's body for the method
                unless func_def
                  if template = @generic_templates[info[:base]]?
                    found_in_template = find_method_in_generic_template(template, method_part)
                    if found_in_template
                      func_def = found_in_template[0]
                      arena = found_in_template[1]
                      target_name = name
                      lookup_branch = "generic_template_body"
                    end
                    # Also search reopenings
                    unless func_def
                      if reopenings = @generic_reopenings[info[:base]]?
                        reopenings.each do |reopen_template|
                          found_in_reopen = find_method_in_generic_template(reopen_template, method_part)
                          if found_in_reopen
                            func_def = found_in_reopen[0]
                            arena = found_in_reopen[1]
                            target_name = name
                            lookup_branch = "generic_reopen_body"
                            break
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        # If still not found, search for any mangled variant of the base name
        # This handles methods with default parameters where call-site arg count < defined param count
        unless func_def
          if name.includes?('$')
            if callsite = @pending_arg_types[name]? || @pending_arg_types[target_name]?
              suffix = name_parts.suffix
              has_block = suffix == "block" || (suffix && suffix.ends_with?("_block")) || name.ends_with?("$block")
              call_has_splat = name.ends_with?("_splat") || name.ends_with?("_double_splat")
              if entry = lookup_function_def_for_call(base_name, callsite.types.size, has_block, callsite.types, call_has_splat)
                func_def = entry[1]
                arena = @function_def_arenas[entry[0]]
                target_name = name
                lookup_branch = "callsite_args"
              end
            end
          end
        end
        unless func_def
          if suffix = name_parts.suffix
            stripped = strip_mangled_suffix_flags(suffix)
            parsed_types = parse_types_from_suffix(stripped)
            unless parsed_types.empty?
              has_block = suffix == "block" || suffix.ends_with?("_block")
              call_has_splat = suffix.ends_with?("_splat") || suffix.ends_with?("_double_splat")
              if entry = lookup_function_def_for_call(base_name, parsed_types.size, has_block, parsed_types, call_has_splat)
                func_def = entry[1]
                arena = @function_def_arenas[entry[0]]
                target_name = name
                lookup_branch = "suffix_types"
              end
            end
          end
        end
        unless func_def
          mangled_prefix = "#{base_name}$"
          if env_has?("DEBUG_LOOKUP")
            STDERR.puts "[DEBUG_LOOKUP] Searching for prefix '#{mangled_prefix}' for name '#{name}'"
          end
          if debug_env_filter_match?("DEBUG_FROM_CHARS", name)
            STDERR.puts "[DEBUG_FROM_CHARS] scan_prefix start prefix=#{mangled_prefix} defs=#{@function_defs.size}"
          end
          overload_keys = function_def_overloads(base_name)
          callsite_by_arity = @pending_arg_types_by_arity[base_callsite_key(name)]?
          best_def : CrystalV2::Compiler::Frontend::DefNode? = nil
          best_name : String? = nil
          best_param_count = Int32::MAX
          best_score = Int32::MIN
          if callsite_by_arity && !callsite_by_arity.empty?
            overload_keys.each do |key|
              next unless key.starts_with?(mangled_prefix)
              def_node = @function_defs[key]?
              next unless def_node
              params = def_node.params
              next unless params

              param_count = params.count { |p| !p.is_block && !named_only_separator?(p) }
              has_splat = params.any? { |p| p.is_splat && !named_only_separator?(p) }
              has_double_splat = params.any? { |p| p.is_double_splat }
              required = params.count do |p|
                !p.is_block && !named_only_separator?(p) && p.default_value.nil? && !p.is_splat && !p.is_double_splat
              end
              block_penalty = params.any?(&.is_block) ? 1 : 0

              callsite_by_arity.each do |arity, call_entries|
                next if arity < required
                next if arity > param_count && !has_splat && !has_double_splat
                void_only = call_entries.all? { |entry| entry.types.all? { |t| t == TypeRef::VOID } }
                if void_only
                  score = param_count == arity ? 1 : 0
                  score -= 1 if has_splat || has_double_splat
                  score -= block_penalty
                  if param_count < best_param_count || (param_count == best_param_count && score > best_score)
                    best_def = def_node
                    best_name = key
                    best_param_count = param_count
                    best_score = score
                  end
                  next
                end
                call_entries.each do |entry|
                  call_arg_types = entry.types
                  next if call_arg_types.all? { |t| t == TypeRef::VOID }

                  func_context = function_context_from_name(key)
                  next unless params_compatible_with_args?(def_node, call_arg_types, func_context)
                  score = params_match_score(def_node, call_arg_types, func_context)
                  score -= 1 if has_splat || has_double_splat
                  score -= block_penalty

                  if param_count < best_param_count || (param_count == best_param_count && score > best_score)
                    best_def = def_node
                    best_name = key
                    best_param_count = param_count
                    best_score = score
                  end
                end
              end
            end
          end

          if best_def && best_name
            if env_has?("DEBUG_LOOKUP")
              STDERR.puts "[DEBUG_LOOKUP]   Found match: '#{best_name}' (typed)"
            end
            func_def = best_def
            arena = @function_def_arenas[best_name]
            has_untyped = false
            if params = best_def.params
              params.each do |param|
                next if named_only_separator?(param) || param.is_block
                if param.type_annotation.nil?
                  has_untyped = true
                  break
                end
              end
            end
            if has_untyped && name.includes?('$')
              target_name = name
              lookup_branch = "mangled_prefix_typed_untyped"
            else
              target_name = best_name
              lookup_branch = "mangled_prefix_typed"
            end
          else
            # Fallback: prefer untyped (generic) overloads over typed ones
            # because generics can handle any argument type, while typed overloads
            # may coerce arguments to wrong types (e.g., Math.min(Int32,Int32) -> Float32)
            best_untyped_key : String? = nil
            first_key : String? = nil
            overload_keys.each do |key|
              # Check keys that start with mangled_prefix OR the base name itself (generic)
              unless key.starts_with?(mangled_prefix) || key == base_name
                next
              end
              first_key ||= key
              def_node = @function_defs[key]?
              next unless def_node
              # Check if this overload has all untyped params
              has_all_untyped = true
              if params = def_node.params
                params.each do |param|
                  next if param.is_block || param.is_splat || param.is_double_splat || named_only_separator?(param)
                  if param.type_annotation
                    has_all_untyped = false
                    break
                  end
                end
              end
              if has_all_untyped
                best_untyped_key = key
                break # Found untyped, use it
              end
            end
            selected_key = best_untyped_key || first_key
            if selected_key
              if env_has?("DEBUG_LOOKUP")
                STDERR.puts "[DEBUG_LOOKUP]   Found match: '#{selected_key}' (untyped=#{!!best_untyped_key})"
              end
              func_def = @function_defs[selected_key]
              arena = @function_def_arenas[selected_key]
              # If we selected the generic base name, use the mangled name as target
              # so the function gets created with the call-site types
              target_name = (selected_key == base_name) ? name : selected_key
              lookup_branch = best_untyped_key ? "mangled_prefix_untyped" : "mangled_prefix"
            end
          end
          if env_has?("DEBUG_LOOKUP") && !func_def
            STDERR.puts "[DEBUG_LOOKUP]   No match found for '#{mangled_prefix}'"
            STDERR.puts "[DEBUG_LOOKUP]   overload_keys=#{overload_keys.join(", ")}"
          end
          # If no mangled overload found but base name exists and is the only overload,
          # use it directly. This handles methods with single overload where call-site
          # type inference adds a $ suffix (e.g., String#byte_at?$Int32 -> String#byte_at?).
          unless func_def
            if overload_keys.size == 1 && overload_keys.first == base_name
              if candidate = @function_defs[base_name]?
                func_def = candidate
                arena = @function_def_arenas[base_name]
                target_name = name # Keep the mangled name as target
                lookup_branch = "base_name_single_overload"
              end
            end
          end
        end

        # If still not found, try looking in included modules
        # e.g., IO::FileDescriptor#sync= -> IO::Buffered#sync=
        # NOTE: When name has a $ suffix (e.g., clamp$Nil_Int32), skip this simple lookup
        # and let the deferred module lookup handle it - that code properly considers
        # parameter count to select the right overload.
        unless func_def || name.includes?('$')
          if name_parts.is_instance
            owner = name_parts.owner
            method = name_parts.method
            if method
              owner_base = strip_generic_args(owner)
              included = Set(String).new
              if direct = @class_included_modules[owner]?
                direct.each { |m| included << m }
              end
              if owner_base != owner
                if base = @class_included_modules[owner_base]?
                  base.each { |m| included << m }
                end
              end
              included.each do |module_name|
                # Strip generic params: IO::Buffered(T) -> IO::Buffered
                base_module = strip_generic_args(module_name)
                module_method = "#{base_module}##{method}"
                if mod_func_def = @function_defs[module_method]?
                  func_def = mod_func_def
                  arena = @function_def_arenas[module_method]
                  # Keep target_name as class method name - will generate with class prefix
                  target_name = base_name
                  lookup_branch = "included_module"
                  break
                end
                # Also try mangled versions
                function_def_overloads(module_method).each do |key|
                  next if key == module_method
                  func_def = @function_defs[key]
                  arena = @function_def_arenas[key]
                  target_name = base_name
                  lookup_branch = "included_module_mangled"
                  break
                end
                break if func_def
              end
            end
          end
        end

        # DEFERRED MODULE LOOKUP: If still not found, look directly in @module_defs
        # This handles cases where module inclusion was processed before all module
        # reopenings were registered (e.g., BinaryFormat reopened across multiple files)
        deferred_lookup_used = false
        unless func_def
          if name_parts.is_instance
            owner = name_parts.owner
            method_part = name_parts.method
            if env_has?("DEBUG_YIELD_SKIP") && name.includes?("byte_range")
              STDERR.puts "[BYTE_RANGE_DEFERRED] owner=#{owner} method=#{method_part} suffix=#{name_parts.suffix} included=#{@class_included_modules[owner]? || "nil"}"
            end
            # Extract param signature from original name (includes $params)
            suffix = name_parts.suffix
            # Collect all included modules from owner and its parent classes
            # This handles cases like UInt64 which inherits Comparable from Number
            all_included = Set(String).new
            visited_classes = Set(String).new
            current_class = owner
            while current_class && !visited_classes.includes?(current_class)
              visited_classes << current_class
              if modules = @class_included_modules[current_class]?
                modules.each { |m| all_included << m }
              end
              current_base = strip_generic_args(current_class)
              if current_base != current_class
                if modules = @class_included_modules[current_base]?
                  modules.each { |m| all_included << m }
                end
              end
              # Get parent class
              parent = @class_info[current_class]?.try(&.parent_name) || @module.class_parents[current_class]?
              break unless parent
              current_class = parent
            end
            if method_part && !all_included.empty?
              included = all_included
              method_base = method_part
              expected_param_count = suffix ? suffix_param_count(suffix) : 0
              if expected_param_count == 0
                if callsite = @pending_arg_types[name]? || @pending_arg_types[target_name]?
                  expected_param_count = callsite.types.size
                end
              end
              included.each do |module_name|
                base_module = strip_generic_args(module_name)
                visited = Set(String).new
                if env_has?("DEBUG_YIELD_SKIP") && name.includes?("byte_range")
                  STDERR.puts "[BYTE_RANGE_FIND_MOD] module=#{base_module} method=#{method_base} expected_params=#{expected_param_count}"
                end
                if found = find_module_def_recursive(base_module, method_base, expected_param_count, visited)
                  func_def = found[0]
                  arena = found[1]
                  if env_has?("DEBUG_YIELD_SKIP") && name.includes?("byte_range")
                    STDERR.puts "[BYTE_RANGE_FIND_MOD_OK] func_def_found=true arena=#{arena.size}"
                  end
                  # Register type params from deferred module context (lazy registration)
                  register_deferred_module_type_params(owner, base_module, name, base_name)
                  # When the call site already carries a mangled name, preserve it so
                  # overloads don't collapse onto the base during deferred lookup.
                  target_name = name.includes?('$') ? name : base_name
                  deferred_lookup_used = true
                  lookup_branch = "deferred_module"
                  if debug_env_filter_match?("DEBUG_DEFERRED", method_base, base_name, target_name)
                    STDERR.puts "[DEFERRED_LOOKUP] Found #{method_base} in module #{base_module} for #{base_name} target=#{target_name} func_def=#{func_def.class} arena=#{arena.class}:#{arena.size}"
                  end
                  if debug_env_filter_match?("DEBUG_FROM_CHARS", method_part, method_base)
                    STDERR.puts "[DEFERRED_LOOKUP] Found #{method_base} in module #{base_module} for #{base_name}"
                  end
                  break
                elsif debug_env_filter_match?("DEBUG_FROM_CHARS", method_part, method_base)
                  STDERR.puts "[DEFERRED_LOOKUP] Skipping #{method_base} in module #{base_module} (no match)"
                end
                break if func_def
              end
            end
          end
        end

        # PARENT CLASS FALLBACK: use parent method bodies for subclasses.
        # This keeps method resolution working when a subclass doesn't redefine a method.
        # Uses cached index lookup (Option D) for O(1) amortized performance.
        unless func_def
          if result = lookup_parent_method(name, name_parts)
            func_def = result[0]
            arena = result[1]
            resolved_name = result[2]
            target_name = name_parts.suffix ? name : base_name
            lookup_branch = "parent_fallback_cached"
            # Store the parent method's arena so lower_method uses the correct arena
            # for AST node lookups. Without this, methods found via parent fallback
            # use the wrong arena, causing macro node resolution failures.
            @function_def_arenas[name] ||= arena
            @function_def_arenas[base_name] ||= arena
            # Extract matched parent from resolved name for namespace override
            resolved_parts = parse_method_name(resolved_name)
            matched_parent = resolved_parts.owner
            if matched_parent != name_parts.owner
              store_function_namespace_override(name, base_name, matched_parent)
            end
            if env_get("DEBUG_PARENT_FALLBACK") && name.includes?("FileDescriptor") && name.includes?("puts")
              STDERR.puts "[PARENT_FB] name=#{name} resolved=#{resolved_name} target=#{target_name} matched_parent=#{matched_parent}"
            end
            # Prevent monomorphization explosion for Object#in? by forcing the
            # parent method target name when a subclass doesn't override it.
            if resolved_parts.method == "in?"
              target_name = resolved_name
            end
            debug_hook("function.lookup.parent_fallback", "name=#{name} parent=#{matched_parent}")
          end
        end

        # DEFERRED MODULE LOOKUP (class methods): direct module/class method call (Module.method)
        unless func_def
          if name_parts.is_class
            owner = name_parts.owner
            method_part = name_parts.method
            # Parse arg types from suffix for better overload selection
            parsed_call_arg_types : Array(TypeRef)? = nil
            if method_part
              if (suffix = name_parts.suffix)
                if suffix == "block"
                  expected_param_count = 0
                else
                  parsed_call_arg_types = parse_types_from_suffix(suffix)
                  expected_param_count = parsed_call_arg_types.size
                end
              else
                expected_param_count = 0
              end
              if found = find_module_class_def(owner, method_part, expected_param_count, parsed_call_arg_types)
                func_def = found[0]
                arena = found[1]
                target_name = base_name
                deferred_lookup_used = true
                lookup_branch = "deferred_module_class"
              end
            end
          end
        end

        # PRIMITIVE TEMPLATE FALLBACK: use Int/Float method bodies for primitive receivers.
        unless func_def
          if name_parts.is_instance
            owner = name_parts.owner
            method_part = name_parts.method
            if method_part && (template_owner = primitive_template_owner(owner))
              template_base = "#{template_owner}##{method_part}"
              if env_get("DEBUG_PRIMITIVE_TEMPLATE_LOOKUP") && name.includes?("Int32#**")
                STDERR.puts "[PRIM_TEMPLATE] name=#{name} template=#{template_base}"
              end
              if (suffix = name_parts.suffix)
                template_mangled = "#{template_base}$#{suffix}"
                if env_get("DEBUG_PRIMITIVE_TEMPLATE_LOOKUP") && name.includes?("Int32#**")
                  has_mangled = @function_defs.has_key?(template_mangled)
                  STDERR.puts "[PRIM_TEMPLATE] suffix=#{suffix} mangled=#{template_mangled} found=#{has_mangled}"
                end
                if candidate = @function_defs[template_mangled]?
                  func_def = candidate
                  arena = @function_def_arenas[template_mangled]
                  target_name = name
                  primitive_template_map = primitive_template_type_map(template_owner, owner)
                  lookup_branch = "primitive_template_mangled"
                else
                  if mapped_suffix = map_suffix_for_primitive_template(suffix, template_owner)
                    mapped_mangled = "#{template_base}$#{mapped_suffix}"
                    if env_get("DEBUG_PRIMITIVE_TEMPLATE_LOOKUP") && name.includes?("Int32#**")
                      has_mapped = @function_defs.has_key?(mapped_mangled)
                      STDERR.puts "[PRIM_TEMPLATE] mapped=#{mapped_mangled} found=#{has_mapped}"
                    end
                    if candidate = @function_defs[mapped_mangled]?
                      func_def = candidate
                      arena = @function_def_arenas[mapped_mangled]
                      target_name = name
                      primitive_template_map = primitive_template_type_map(template_owner, owner)
                      lookup_branch = "primitive_template_mapped"
                    end
                  end
                end
              end
              if !func_def
                if candidate = @function_defs[template_base]?
                  func_def = candidate
                  arena = @function_def_arenas[template_base]
                  target_name = name.includes?('$') ? name : base_name
                  primitive_template_map = primitive_template_type_map(template_owner, owner)
                  lookup_branch = "primitive_template"
                end
              end
              unless func_def
                mangled_prefix = "#{template_base}$"
                function_def_overloads(template_base).each do |key|
                  next if key == template_base
                  next unless key.starts_with?(mangled_prefix)
                  func_def = @function_defs[key]
                  arena = @function_def_arenas[key]
                  target_name = name.includes?('$') ? name : base_name
                  primitive_template_map = primitive_template_type_map(template_owner, owner)
                  lookup_branch = "primitive_template_prefix"
                  break
                end
              end
            end
          end
        end

        # OBJECT FALLBACK: use Object method bodies when classes omit explicit parents.
        unless func_def
          if name_parts.is_instance
            owner = name_parts.owner
            method_part = name_parts.method
            if method_part && owner != "Object"
              method_short = method_part
              use_object_target = method_short == "in?"
              object_base = "Object##{method_part}"
              if candidate = @function_defs[object_base]?
                func_def = candidate
                arena = @function_def_arenas[object_base]
                target_name = use_object_target ? object_base : (name.includes?('$') ? name : base_name)
                lookup_branch = "object_fallback"
              elsif (suffix = name_parts.suffix)
                object_mangled = "#{object_base}$#{suffix}"
                if candidate = @function_defs[object_mangled]?
                  func_def = candidate
                  arena = @function_def_arenas[object_mangled]
                  target_name = use_object_target ? object_mangled : (name.includes?('$') ? name : base_name)
                  lookup_branch = "object_fallback_mangled"
                end
              end
              unless func_def
                mangled_prefix = "#{object_base}$"
                function_def_overloads(object_base).each do |key|
                  next if key == object_base
                  next unless key.starts_with?(mangled_prefix)
                  func_def = @function_defs[key]
                  arena = @function_def_arenas[key]
                  target_name = use_object_target ? key : (name.includes?('$') ? name : base_name)
                  lookup_branch = "object_fallback_prefix"
                  break
                end
              end
            end
          end
        end

        # PARENT FALLBACK (class methods): reuse parent class method defs for subclasses.
        unless func_def
          if name_parts.is_class
            owner = name_parts.owner
            method_part = name_parts.method
            visited_parents = Set(String).new
            parent = @class_info[owner]?.try(&.parent_name)
            while parent
              break if visited_parents.includes?(parent)
              visited_parents << parent
              parent_base = method_part ? "#{parent}.#{method_part}" : nil
              break unless parent_base
              if candidate = @function_defs[parent_base]?
                func_def = candidate
                arena = @function_def_arenas[parent_base]
                target_name = name
                lookup_branch = "parent_class_fallback"
                store_function_namespace_override(name, base_name, parent)
                break
              elsif (suffix = name_parts.suffix)
                parent_mangled = "#{parent_base}$#{suffix}"
                if candidate = @function_defs[parent_mangled]?
                  func_def = candidate
                  arena = @function_def_arenas[parent_mangled]
                  target_name = name
                  lookup_branch = "parent_class_fallback_mangled"
                  store_function_namespace_override(name, base_name, parent)
                  break
                end
              end
              unless func_def
                mangled_prefix = "#{parent_base}$"
                function_def_overloads(parent_base).each do |key|
                  next if key == parent_base
                  next unless key.starts_with?(mangled_prefix)
                  func_def = @function_defs[key]
                  arena = @function_def_arenas[key]
                  target_name = name
                  lookup_branch = "parent_class_fallback_prefix"
                  store_function_namespace_override(name, base_name, parent)
                  break
                end
              end
              break if func_def
              parent = @class_info[parent]?.try(&.parent_name)
            end
          end
        end

        # PRIMITIVE TEMPLATE FALLBACK (class methods): reuse Int/Float class methods for numeric primitives.
        unless func_def
          if name_parts.is_class
            owner = name_parts.owner
            method_part = name_parts.method
            if method_part && (template_owner = primitive_template_owner(owner))
              template_base = "#{template_owner}.#{method_part}"
              if candidate = @function_defs[template_base]?
                func_def = candidate
                arena = @function_def_arenas[template_base]
                target_name = name
                lookup_branch = "primitive_class_fallback"
              elsif (suffix = name_parts.suffix)
                template_mangled = "#{template_base}$#{suffix}"
                if candidate = @function_defs[template_mangled]?
                  func_def = candidate
                  arena = @function_def_arenas[template_mangled]
                  target_name = name
                  lookup_branch = "primitive_class_fallback_mangled"
                end
              end
              unless func_def
                mangled_prefix = "#{template_base}$"
                function_def_overloads(template_base).each do |key|
                  next if key == template_base
                  next unless key.starts_with?(mangled_prefix)
                  func_def = @function_defs[key]
                  arena = @function_def_arenas[key]
                  target_name = name
                  lookup_branch = "primitive_class_fallback_prefix"
                  break
                end
              end
            end
          end
        end

        # OBJECT FALLBACK (class methods): reuse Object's class methods for subclasses.
        # This ensures inherited class methods are lowered with the subclass context.
        unless func_def
          if name_parts.is_class
            owner = name_parts.owner
            method_part = name_parts.method
            if method_part && owner != "Object" && @class_info.has_key?(owner)
              object_base = "Object.#{method_part}"
              if candidate = @function_defs[object_base]?
                func_def = candidate
                arena = @function_def_arenas[object_base]
                target_name = name
                lookup_branch = "object_class_fallback"
              elsif (suffix = name_parts.suffix)
                object_mangled = "#{object_base}$#{suffix}"
                if candidate = @function_defs[object_mangled]?
                  func_def = candidate
                  arena = @function_def_arenas[object_mangled]
                  target_name = name
                  lookup_branch = "object_class_fallback_mangled"
                end
              end
              unless func_def
                mangled_prefix = "#{object_base}$"
                function_def_overloads(object_base).each do |key|
                  next if key == object_base
                  next unless key.starts_with?(mangled_prefix)
                  func_def = @function_defs[key]
                  arena = @function_def_arenas[key]
                  target_name = name
                  lookup_branch = "object_class_fallback_prefix"
                  break
                end
              end
            end
          end
        end
      end

      if !func_def && !name.includes?('#') && !name.includes?('.')
        if current = @current_class
          base = strip_type_suffix(name)
          qualified_base = "#{current}##{base}"
          if candidate = @function_defs[qualified_base]?
            func_def = candidate
            arena = @function_def_arenas[qualified_base]?
            if name.includes?('$')
              suffix = method_suffix(name) || ""
              target_name = "#{qualified_base}$#{suffix}"
            else
              target_name = qualified_base
            end
            name = target_name
            lookup_branch = "qualified_current"
          end
        end
      end

      if func_def
        data = "name=#{name} target=#{target_name} branch=#{lookup_branch || "unknown"}"
        if callsite = @debug_callsite
          data += " callsite=#{callsite}"
        end
        debug_hook("function.lookup.hit", data)
      else
        data = "name=#{name}"
        if callsite = @debug_callsite
          data += " callsite=#{callsite}"
        end
        debug_hook("function.lookup.miss", data)
      end
      if debug_env_filter_match?("DEBUG_FROM_CHARS", name, target_name)
        STDERR.puts "[DEBUG_FROM_CHARS] lookup_result branch=#{lookup_branch || "none"} target=#{target_name} func_def=#{!func_def.nil?}"
      end

      if debug_env_filter_match?("DEBUG_DEFERRED", name, target_name)
        STDERR.puts "[DEFERRED_FUNC] func_def=#{!func_def.nil?} name=#{name} target=#{target_name} lookup=#{lookup_branch || "none"}"
      end
      if func_def && debug_env_filter_match?("DEBUG_BYTEFORMAT_REGISTER", name, target_name)
        arena_for_log = arena || resolve_arena_for_def(func_def, @arena)
        loc = "#{func_def.span.start_line}:#{func_def.span.start_column}"
        STDERR.puts "[DEBUG_BYTEFORMAT_LOWER] name=#{name} target=#{target_name} arena=#{arena_for_log.class} loc=#{loc} branch=#{lookup_branch || "none"}"
      end
      if func_def.nil? && debug_byte_at
        STDERR.puts "[LOWER_FUNC_MISS] name=#{name} base=#{base_name} target=#{target_name}"
        overloads = function_def_overloads(base_name)
        STDERR.puts "[LOWER_FUNC_MISS] overloads=#{overloads.join(",")}"
      end
      return unless func_def
      if env_has?("DEBUG_YIELD_SKIP") && target_name.includes?("byte_range")
        STDERR.puts "[BYTE_RANGE_FOUND] target=#{target_name} state=#{function_state(target_name)} is_abstract=#{func_def.is_abstract} branch=#{lookup_branch || "nil"} deferred=#{deferred_lookup_used}"
      end
      is_lowering_target = function_state(target_name).in_progress?
      if debug_env_filter_match?("DEBUG_DEFERRED", name, target_name)
        STDERR.puts "[DEFERRED_CHECK] is_lowering=#{is_lowering_target}"
      end
      return if is_lowering_target
      if func_def.is_abstract
        @function_lowering_states[target_name] = FunctionLoweringState::InProgress
        return
      end

      if arena.nil?
        arena = resolve_arena_for_def(func_def, @arena)
        if debug_env_filter_match?("DEBUG_CALL_TRACE", name, target_name)
          STDERR.puts "[LOWER_TRACE] arena_fallback name=#{name} arena=#{arena.class}:#{arena.size}"
        end
      elsif body = func_def.body
        unless body.empty?
          max_index = body.max_of(&.index)
          if max_index >= arena.size || !span_fits_source?(arena, func_def.span)
            arena = resolve_arena_for_def(func_def, arena)
            if debug_env_filter_match?("DEBUG_CALL_TRACE", name, target_name)
              STDERR.puts "[LOWER_TRACE] arena_repair name=#{name} max=#{max_index} arena=#{arena.class}:#{arena.size}"
            end
          end
        end
      end
      if filter = env_get("DEBUG_FUNC_DEF")
        if filter == "*" || target_name.includes?(filter) || name.includes?(filter)
          arena_for_log = arena || @arena
          path = source_path_for(arena_for_log) || "(unknown)"
          span = func_def.span
          def_name = func_def.name ? String.new(func_def.name.not_nil!) : "(nil)"
          STDERR.puts "[DEBUG_FUNC_DEF] name=#{target_name} def_name=#{def_name} def_span=#{span.start_line}-#{span.end_line} file=#{path}"
        end
      end

      callsite_args = pop_pending_callsite_args(name, target_name)
      if callsite_args.nil? && func_def
        callsite_args = pending_callsite_args_for_def(func_def, name, target_name)
      end
      call_arg_types = callsite_args ? callsite_args.types : nil

      # Arity mismatch fix: when the found func_def has fewer params than the
      # callsite provides, the base name lookup picked the wrong overload
      # (e.g., 2-param entry_matches? instead of 3-param version).
      # Look for an arity-specific version that matches.
      if func_def && call_arg_types && call_arg_types.size > 0
        actual_arity = count_non_block_params(func_def)
        expected_arity = call_arg_types.size
        if expected_arity > actual_arity
          arity_key = "#{name_parts.base}$arity#{expected_arity}"
          if env_get("DEBUG_ENTRY_MATCHES") && name.includes?("entry_matches")
            STDERR.puts "[ARITY_FIX] name=#{name} base=#{name_parts.base} target=#{target_name} expected=#{expected_arity} actual=#{actual_arity} arity_key=#{arity_key} has_key=#{@function_defs.has_key?(arity_key)}"
          end
          if arity_def = @function_defs[arity_key]?
            func_def = arity_def
            arena = @function_def_arenas[arity_key]
            target_name = arity_key
          else
            # Also try generic template base (e.g., Hash(K,V)#method$arity3)
            if (sep = name_parts.separator) && (method_part = name_parts.method)
              owner = name_parts.owner
              if ginfo = generic_owner_info(owner)
                template_arity_key = "#{ginfo[:base]}#{sep}#{method_part}$arity#{expected_arity}"
                if arity_def = @function_defs[template_arity_key]?
                  func_def = arity_def
                  arena = @function_def_arenas[template_arity_key]
                  target_name = arity_key
                end
              end
            end
          end
        end
      end

      if is_math_min_debug
        types_str = call_arg_types ? call_arg_types.map { |t| get_type_name_from_ref(t) }.join(",") : "nil"
        # Get param annotations from func_def
        param_annotations = if params = func_def.params
                              params.map do |p|
                                next "" if p.is_block
                                if ta = p.type_annotation
                                  String.new(ta)
                                else
                                  "(untyped)"
                                end
                              end
                            else
                              [] of String
                            end
        STDERR.puts "[MATH_MIN_FUNC_DEF] name=#{name} target=#{target_name} lookup_branch=#{lookup_branch || "nil"} call_arg_types=#{types_str} param_annotations=#{param_annotations.join(",")}"
      end
      if env_get("DEBUG_MATH_MIN") && (name.includes?("$Dmin") || name.includes?("$Dmax")) && name.includes?("Math")
        types_str = call_arg_types ? call_arg_types.map { |t| get_type_name_from_ref(t) }.join(",") : "nil"
        STDERR.puts "[MATH_MIN_LOWER_ARGS] name=#{name} call_arg_types=#{types_str}"
      end
      if env_has?("DEBUG_RANGE_LOWER") && name.includes?("range_to_index_and_count")
        types_str = call_arg_types ? call_arg_types.map { |t| desc = @module.get_type_descriptor(t); desc ? "#{desc.name}(id=#{t.id})" : "T#{t.id}" }.join(", ") : "nil"
        STDERR.puts "[RANGE_LOWER_INDEX] name=#{name} target=#{target_name} call_arg_types=#{types_str} callsite_args_nil=#{callsite_args.nil?}"
      end
      # The mangled suffix encodes the concrete specialization for this function
      # variant. Callsite arg types may be stale (e.g. from an unspecialized
      # generic context). Prefer suffix types as ground truth.
      if name.includes?('$')
        suffix = method_suffix(name)
        if suffix && !suffix.empty?
          parsed_types = parse_types_from_suffix(suffix)
          unless parsed_types.empty?
            if call_arg_types.nil?
              # When suffix has fewer types than params, the suffix likely
              # encodes only annotated param types (unannotated params don't
              # contribute).  Align suffix types with annotated params to
              # avoid mis-assigning, e.g. read_bytes(type, format : IO::ByteFormat)
              # where suffix $$IO::ByteFormat should map to 'format', not 'type'.
              if params_for_align = func_def.params
                param_count = 0
                annotated_count = 0
                params_for_align.each do |p|
                  next if p.is_block || named_only_separator?(p)
                  param_count += 1
                  annotated_count += 1 if p.type_annotation
                end
                if parsed_types.size < param_count && parsed_types.size <= annotated_count && annotated_count > 0
                  aligned = Array(TypeRef).new(param_count, TypeRef::VOID)
                  suffix_idx = 0
                  param_idx = 0
                  params_for_align.each do |p|
                    next if p.is_block || named_only_separator?(p)
                    if p.type_annotation && suffix_idx < parsed_types.size
                      aligned[param_idx] = parsed_types[suffix_idx]
                      suffix_idx += 1
                    end
                    param_idx += 1
                  end
                  call_arg_types = aligned
                else
                  call_arg_types = parsed_types
                end
              else
                call_arg_types = parsed_types
              end
            elsif parsed_types.size == call_arg_types.size
              # Merge: suffix wins for non-VOID entries
              merged = call_arg_types.dup
              changed = false
              parsed_types.each_with_index do |parsed, idx|
                next if parsed == TypeRef::VOID
                if merged[idx] != parsed
                  merged[idx] = parsed
                  changed = true
                end
              end
              call_arg_types = merged if changed
            else
              # Size mismatch — callsite may have more args than suffix can
              # encode (e.g. untyped first param whose type was not mangled).
              # Keep callsite types; only fill in VOID slots positionally.
              if call_arg_types.size > parsed_types.size
                # nothing — callsite has more info
              else
                call_arg_types = parsed_types
              end
            end
          end
        end
      end
      # Skip lowering functions with bare generic types when no concrete type info is available
      # This prevents emitting functions like Indexable.range_to_index_and_count$Range_Int32 which call Range#begin on bare Range
      if call_arg_types
        params_for_bare : Array(CrystalV2::Compiler::Frontend::Parameter)? = nil
        splat_index : Int32? = nil
        has_double_splat_param = false
        if params = func_def.params
          params_for_bare = [] of CrystalV2::Compiler::Frontend::Parameter
          params.each do |param|
            next if named_only_separator?(param) || param.is_block
            params_for_bare << param
          end
          has_double_splat_param = params.any?(&.is_double_splat)
          if params_for_bare
            params_for_bare.each_with_index do |param, idx|
              if param.is_splat || param.is_double_splat
                splat_index = idx
                break
              end
            end
          end
        end
        has_bare_generic = false
        call_arg_types.each_with_index do |t, idx|
          desc = @module.get_type_descriptor(t)
          next unless desc
          # Bare generic: name without '(' but is a known generic type
          is_bare = !desc.name.includes?('(') && KNOWN_GENERIC_TYPES.includes?(desc.name)
          next unless is_bare
          if desc.name == "NamedTuple" && has_double_splat_param
            next
          end
          # Allow bare generic when def param is also bare of the same base (e.g., Array)
          if params_for_bare && !params_for_bare.empty?
            param_idx = splat_index && idx >= splat_index ? splat_index : idx
            if param_idx < params_for_bare.size
              param = params_for_bare[param_idx]
              if ta = param.type_annotation
                type_name = String.new(ta)
                if !type_name.includes?('(') && type_name == desc.name
                  next
                end
              elsif param.is_splat || param.is_double_splat
                # Untyped splat params accept bare generic args without requiring instantiation.
                next
              end
            end
          end
          if env_has?("DEBUG_RANGE_SKIP") && is_bare
            STDERR.puts "[RANGE_SKIP] name=#{name} bare_type=#{desc.name} skipping"
          end
          has_bare_generic = true
          break
        end
        if has_bare_generic
          if env_has?("DEBUG_YIELD_SKIP") && name.includes?("byte_range")
            STDERR.puts "[BYTE_RANGE_BARE_GENERIC] returning early name=#{name}"
          end
          return
        end
      end
      call_arg_literals = callsite_args ? callsite_args.literals : nil
      call_arg_enum_names = callsite_args ? callsite_args.enum_names : nil

      base_guard_name = strip_type_suffix(name)
      allow_untyped_base = base_guard_name.ends_with?("#initialize") || base_guard_name.ends_with?(".initialize")
      if env_has?("DEBUG_YIELD_SKIP") && name.includes?("byte_range")
        STDERR.puts "[BYTE_RANGE_GUARDS] name=#{name} target=#{target_name} has_$=#{name.includes?('$')} call_arg_types=#{call_arg_types.try(&.size) || "nil"} untyped=#{def_params_untyped?(func_def)}"
      end
      if !name.includes?('$') && def_params_untyped?(func_def) && !allow_untyped_base
        callsite_void = call_arg_types.nil? || call_arg_types.all? { |t| t == TypeRef::VOID }
        if callsite_void
          params = func_def.params
          requires_args = false
          if params
            params.each do |param|
              next if named_only_separator?(param) || param.is_block || param.is_double_splat
              next unless param.default_value.nil?
              requires_args = true
              break
            end
          end
          if requires_args
            overloads = function_def_overloads(base_guard_name)
            has_typed_overload = overloads.any? do |key|
              next false if key == base_guard_name
              if def_node = @function_defs[key]?
                !def_params_untyped?(def_node)
              else
                false
              end
            end
            if has_typed_overload
              debug_hook("function.lower.skip_untyped_base", "name=#{name}") if DebugHooks::ENABLED
              return
            end
          end
        end
      end

      extra_type_params : Hash(String, String)? = nil
      resolved_owner : String? = nil
      resolved_target_name = target_name
      # Parse target_name once - get all parts in single pass
      target_parts = parse_method_name(target_name)
      base_target_name = target_parts.base
      force_class_method = target_parts.is_class
      if sep = target_parts.separator
        owner = target_parts.owner
        method = target_parts.method
        if info = generic_owner_info(owner)
          resolved_owner = info[:owner]
          extra_type_params = info[:map]
          if resolved_owner != owner
            resolved_base = "#{resolved_owner}#{sep}#{method}"
            if suffix = target_parts.suffix
              resolved_target_name = "#{resolved_base}$#{suffix}"
            else
              resolved_target_name = resolved_base
            end
          end
          if !@class_info.has_key?(info[:owner]) && !@monomorphized.includes?(info[:owner]) && concrete_type_args?(info[:args])
            monomorphize_generic_class(info[:base], info[:args], info[:owner])
          end
        end
      end

      if registered_params = function_type_param_map_for(target_name, base_target_name, name)
        if debug_hook_filter_match?(base_target_name)
          params_str = registered_params.map { |k, v| "#{k}=#{v}" }.join(",")
          debug_hook("function.lower.type_params", "target=#{target_name} base=#{base_target_name} params=#{params_str}")
        end
        extra_type_params = extra_type_params ? extra_type_params.merge(registered_params) : registered_params.dup
      elsif debug_hook_filter_match?(base_target_name)
        debug_hook("function.lower.type_params", "target=#{target_name} base=#{base_target_name} params=")
      end

      if pending_params = consume_pending_type_param_map(name)
        if env_get("DEBUG_TUPLE_MAP") && base_target_name.starts_with?("Tuple#")
          params_str = pending_params.map { |k, v| "#{k}=#{v}" }.join(",")
          STDERR.puts "[TUPLE_MAP_USE] source=name target=#{target_name} params=#{params_str}"
        end
        if debug_hook_filter_match?(base_target_name)
          params_str = pending_params.map { |k, v| "#{k}=#{v}" }.join(",")
          debug_hook("function.lower.pending_params", "target=#{target_name} name=#{name} params=#{params_str}")
        end
        extra_type_params = extra_type_params ? extra_type_params.merge(pending_params) : pending_params.dup
      elsif pending_params = consume_pending_type_param_map(target_name)
        if env_get("DEBUG_TUPLE_MAP") && base_target_name.starts_with?("Tuple#")
          params_str = pending_params.map { |k, v| "#{k}=#{v}" }.join(",")
          STDERR.puts "[TUPLE_MAP_USE] source=target target=#{target_name} params=#{params_str}"
        end
        if debug_hook_filter_match?(base_target_name)
          params_str = pending_params.map { |k, v| "#{k}=#{v}" }.join(",")
          debug_hook("function.lower.pending_params", "target=#{target_name} name=#{target_name} params=#{params_str}")
        end
        extra_type_params = extra_type_params ? extra_type_params.merge(pending_params) : pending_params.dup
      elsif pending_params = consume_pending_type_param_map(base_target_name)
        if env_get("DEBUG_TUPLE_MAP") && base_target_name.starts_with?("Tuple#")
          params_str = pending_params.map { |k, v| "#{k}=#{v}" }.join(",")
          STDERR.puts "[TUPLE_MAP_USE] source=base target=#{target_name} params=#{params_str}"
        end
        if debug_hook_filter_match?(base_target_name)
          params_str = pending_params.map { |k, v| "#{k}=#{v}" }.join(",")
          debug_hook("function.lower.pending_params", "target=#{target_name} name=#{base_target_name} params=#{params_str}")
        end
        extra_type_params = extra_type_params ? extra_type_params.merge(pending_params) : pending_params.dup
      end

      if !@type_param_map.empty? && @current_class
        current = @current_class.not_nil!
        current_base = strip_generic_args(current)
        if base_target_name.starts_with?("#{current}#") ||
           base_target_name.starts_with?("#{current}.") ||
           base_target_name.starts_with?("#{current_base}::")
          extra_type_params = extra_type_params ? @type_param_map.merge(extra_type_params) : @type_param_map.dup
        end
      end

      # For Tuple specializations, derive T/T__tuple directly from the owner name
      # so macro loops like 0...T.size can expand without relying on callsite maps.
      if target_parts.separator
        if target_parts.owner.starts_with?("Tuple(")
          if info = split_generic_base_and_args(target_parts.owner)
            args = split_generic_type_args(info[:args]).map(&.strip).reject(&.empty?)
            unless args.empty?
              extra_type_params = (extra_type_params || {} of String => String)
              extra_type_params["T"] = args.join(" | ")
              extra_type_params["T__tuple"] = args.join(", ")
            end
          end
        end
      end

      # Tuple has implicit splat type param T; if we don't have a concrete mapping,
      # fall back to Pointer to avoid unresolved generic unions (Nil | T).
      if base_target_name.starts_with?("Tuple#")
        unless extra_type_params && extra_type_params.has_key?("T")
          extra_type_params = (extra_type_params || {} of String => String)
          extra_type_params["T"] = "Pointer"
        end
      end

      has_in_module = @module.has_function?(resolved_target_name)
      is_lowering_resolved = function_state(resolved_target_name).in_progress?
      if debug_env_filter_match?("DEBUG_DEFERRED", name, resolved_target_name)
        STDERR.puts "[DEFERRED_FINAL] resolved=#{resolved_target_name} has_in_module=#{has_in_module} is_lowering=#{is_lowering_resolved}"
      end
      return if has_in_module
      return if is_lowering_resolved

      target_name = resolved_target_name
      # Re-parse resolved target name once for use in the rest of this function
      resolved_parts = parse_method_name(target_name)
      @function_lowering_states[target_name] = FunctionLoweringState::InProgress

      # WORK QUEUE: Track that we're inside lowering to defer nested calls
      @lowering_depth += 1

      debug_hook("function.lower.start", "name=#{target_name} requested=#{name}")
      if debug_env_filter_match?("DEBUG_CLASS_MODULES", target_name, name)
        modules = @class_included_modules[resolved_parts.owner]?
        STDERR.puts "[CLASS_MODULES] target=#{target_name} owner=#{resolved_parts.owner} modules=#{modules ? modules.to_a.join(",") : "nil"}"
      end
      if debug_env_filter_match?("DEBUG_FROM_CHARS", target_name, name)
        STDERR.puts "[LOWERING] Starting lower for #{target_name}, arena=#{arena.class}"
      end
      time_filter = env_get("DEBUG_LOWER_METHOD_TIME")
      slow_threshold = env_get("DEBUG_LOWER_METHOD_SLOW_MS").try(&.to_f)
      slow_enabled = !slow_threshold.nil?
      time_match = time_filter && (time_filter == "1" || target_name.includes?(time_filter) || name.includes?(time_filter))
      start_time = nil
      if time_match || slow_enabled
        start_time = Time.instant
        @lower_method_time_stack << LowerMethodTiming.new(target_name, name, start_time, 0.0)
        if env_get("DEBUG_LOWER_METHOD_STATS")
          @lower_method_stats_stack << LowerMethodStats.new
        end
      end
      begin
        with_arena(arena || @arena) do
          if resolved_parts.is_instance
            owner = resolved_owner || resolved_parts.owner
            if env_has?("DEBUG_YIELD_SKIP") && target_name.includes?("byte_range")
              STDERR.puts "[BYTE_RANGE_LOWER] owner=#{owner} target=#{target_name} has_class_info=#{@class_info.has_key?(owner)} deferred=#{deferred_lookup_used}"
            end
            if class_info = @class_info[owner]?
              if DebugHooks::ENABLED && unresolved_generic_receiver?(owner)
                debug_hook(
                  "lower.class_receiver.unresolved",
                  "owner=#{owner} target=#{target_name} requested=#{name} map=#{type_param_map_debug_string}"
                )
              end
              old_class = @current_class
              @current_class = owner
              if debug_env_filter_match?("DEBUG_FROM_CHARS", target_name, name)
                STDERR.puts "[LOWERING] Calling lower_method for #{target_name}, deferred=#{deferred_lookup_used}"
              end
              # For deferred lookup, pass the caller's expected name (with mangled types) so the
              # generated function matches what the call site is looking for. This handles cases where
              # the def signature uses unresolved generic types (like ParseOptionsT(UC)) but the call
              # site uses concrete types (like Pointer).
              # The `name` variable contains the full mangled name from the call site.
              override = name
              # Avoid per-receiver monomorphization for Object#in? by forcing the
              # base method name even when the call site is mangled.
              if resolved_parts.method == "in?" && target_name.starts_with?("Object#")
                override = nil
              end
              namespace_override = function_namespace_override_for(target_name, base_target_name, name)
              # Add forall type param bindings for primitive templates and FastFloat methods.
              extra_params = primitive_template_map || {} of String => String
              if target_name.includes?("FastFloat")
                extra_params = extra_params.merge({"UC" => "UInt8", "T" => "Float64"})
              end
              merged_params = extra_type_params ? extra_params.merge(extra_type_params) : extra_params
              with_type_param_map(merged_params) do
                with_namespace_override_or_clear(namespace_override) do
                  begin
                    # Arity mismatch fix: if func_def has fewer params than
                    # call_arg_types, the base-name lookup found the wrong
                    # overload. Try to find the correct arity version.
                    if call_arg_types && call_arg_types.size > 0
                      actual_arity = count_non_block_params(func_def)
                      expected_arity = call_arg_types.size
                      if expected_arity > actual_arity
                        base_for_arity = strip_type_suffix(target_name)
                        arity_key = "#{base_for_arity}$arity#{expected_arity}"
                        if arity_def = @function_defs[arity_key]?
                          func_def = arity_def
                          arena_override = @function_def_arenas[arity_key]?
                        else
                          # Try generic template base
                          if (ginfo = generic_owner_info(owner))
                            sep = resolved_parts.separator || '#'
                            mpart = resolved_parts.method
                            if mpart
                              template_arity = "#{ginfo[:base]}#{sep}#{mpart}$arity#{expected_arity}"
                              if arity_def = @function_defs[template_arity]?
                                func_def = arity_def
                                arena_override = @function_def_arenas[template_arity]?
                              end
                            end
                          end
                        end
                      end
                    end
                    if env_get("DEBUG_ENTRY_MATCHES") && name.includes?("entry_matches")
                      param_count = func_def.params.try(&.size) || 0
                      STDERR.puts "[ENTRY_MATCHES_LOWER] name=#{name} target=#{target_name} owner=#{owner} override=#{override} param_count=#{param_count} call_arg_types=#{call_arg_types.try(&.map(&.id).join(",")) || "nil"} type_params=#{type_param_map_debug_string}"
                    end
                    lower_method(owner, class_info, func_def, call_arg_types, call_arg_literals, call_arg_enum_names, override, force_class_method: force_class_method)
                  rescue ex : KeyError
                    STDERR.puts "[KEY_ERROR_DEFERRED] target=#{target_name} owner=#{owner} override=#{override} call_arg_types=#{call_arg_types.try(&.map(&.id).join(",")) || "nil"}"
                    STDERR.puts ex.backtrace.first(20).join("\n")
                    raise ex
                  end
                end
              end
              @current_class = old_class
            elsif enum_info = @enum_info
              if enum_info.has_key?(owner)
                old_class = @current_class
                @current_class = owner
                dummy_info = ClassInfo.new(owner, TypeRef::INT32, [] of IVarInfo, [] of ClassVarInfo, 0, false, nil)
                lower_method(owner, dummy_info, func_def, call_arg_types, call_arg_literals, call_arg_enum_names, name, force_class_method: force_class_method)
                @current_class = old_class
              else
                # Modules don't have ClassInfo entries, but we still need to lower
                # their instance methods (e.g., IO::ByteFormat#decode).
                module_ref = type_ref_for_name(owner)
                if module_ref != TypeRef::VOID
                  if desc = @module.get_type_descriptor(module_ref)
                    if desc.kind == TypeKind::Module || module_like_type_name?(desc.name)
                      old_class = @current_class
                      @current_class = owner
                      dummy_info = ClassInfo.new(owner, module_ref, [] of IVarInfo, [] of ClassVarInfo, 0, false, nil)
                      lower_method(owner, dummy_info, func_def, call_arg_types, call_arg_literals, call_arg_enum_names, name, force_class_method: force_class_method)
                      @current_class = old_class
                      return
                    end
                  end
                end
                if debug_env_filter_match?("DEBUG_FROM_CHARS", target_name, name)
                  STDERR.puts "[LOWERING] No class_info for #{owner}"
                end
              end
            elsif debug_env_filter_match?("DEBUG_FROM_CHARS", target_name, name)
              STDERR.puts "[LOWERING] No class_info for #{owner}"
            end
          elsif resolved_parts.is_class
            owner = resolved_owner || resolved_parts.owner
            method = resolved_parts.method
            namespace_override = function_namespace_override_for(target_name, base_target_name, name)
            full_override = name != target_name ? name : nil
            target_for_lower = full_override || target_name
            # For .new on classes/structs, use generate_allocator (not lower_method)
            # This ensures correct init_params from the initialize method are used.
            # If an explicit new overload exists but does NOT match this callsite,
            # we still generate the allocator for the callsite types.
            if method == "new"
              if class_info = @class_info[owner]?
                base_new = "#{owner}.new"
                explicit_new = @function_defs.has_key?(base_new)
                unless explicit_new
                  explicit_new = function_def_overloads(base_new).any? { |key| key != base_new }
                end
                has_call_types = call_arg_types && call_arg_types.any? { |t| t != TypeRef::VOID }
                if owner == "File" && env_get("DBG_FILE_NEW")
                  arg_strs = call_arg_types.try(&.map { |t| t.id.to_s }) || [] of String
                  STDERR.puts "[FILE_NEW_RESOLVE] owner=File explicit_new=#{explicit_new} has_call_types=#{has_call_types} call_args=[#{arg_strs.join(",")}] allocator_ok=#{allocator_supported?(owner)}"
                  if explicit_new && has_call_types
                    matched_dbg = lookup_function_def_for_call(base_new, call_arg_types.not_nil!.size, false, call_arg_types)
                    STDERR.puts "[FILE_NEW_RESOLVE] matched=#{matched_dbg.nil? ? "nil" : matched_dbg[0]}"
                  end
                end
                if allocator_supported?(owner)
                  if explicit_new && has_call_types
                    matched = lookup_function_def_for_call(base_new, call_arg_types.not_nil!.size, false, call_arg_types)
                    unless matched
                      generate_allocator(owner, class_info, call_arg_types)
                      return
                    end
                  elsif !explicit_new
                    generate_allocator(owner, class_info, call_arg_types)
                    # The function was just generated (or already existed), return
                    return
                  end
                end
              end
            end
            if class_info = @class_info[owner]?
              old_class = @current_class
              @current_class = owner
              if extra_type_params
                with_type_param_map(extra_type_params) do
                  with_namespace_override_or_clear(namespace_override) do
                    lower_method(owner, class_info, func_def, call_arg_types, call_arg_literals, call_arg_enum_names, target_for_lower, force_class_method: force_class_method)
                  end
                end
              else
                with_namespace_override_or_clear(namespace_override) do
                  lower_method(owner, class_info, func_def, call_arg_types, call_arg_literals, call_arg_enum_names, target_for_lower, force_class_method: force_class_method)
                end
              end
              @current_class = old_class
            elsif enum_info = @enum_info
              if enum_info.has_key?(owner)
                old_class = @current_class
                @current_class = owner
                dummy_info = ClassInfo.new(owner, TypeRef::INT32, [] of IVarInfo, [] of ClassVarInfo, 0, false, nil)
                lower_method(owner, dummy_info, func_def, call_arg_types, call_arg_literals, call_arg_enum_names, target_for_lower)
                @current_class = old_class
              else
                # Apply type param map for generic module methods
                if extra_type_params && !extra_type_params.empty?
                  with_type_param_map(extra_type_params) do
                    lower_module_method(owner, func_def, call_arg_types, call_arg_literals, call_arg_enum_names, target_for_lower)
                  end
                else
                  lower_module_method(owner, func_def, call_arg_types, call_arg_literals, call_arg_enum_names, target_for_lower)
                end
              end
            else
              # Apply type param map for generic module methods
              if extra_type_params && !extra_type_params.empty?
                with_type_param_map(extra_type_params) do
                  lower_module_method(owner, func_def, call_arg_types, call_arg_literals, call_arg_enum_names, target_for_lower)
                end
              else
                lower_module_method(owner, func_def, call_arg_types, call_arg_literals, call_arg_enum_names, target_for_lower)
              end
            end
          else
            # Use the call-site mangled name so top-level defs match call signatures.
            lower_def(func_def, call_arg_types, call_arg_literals, call_arg_enum_names, name)
          end
        end
      ensure
        # WORK QUEUE: Restore previous inside_lowering state
        @lowering_depth -= 1
        @function_lowering_states[target_name] = FunctionLoweringState::Completed
        debug_hook("function.lower.done", "name=#{target_name}")
        if start_time
          elapsed_ms = (Time.instant - start_time).total_milliseconds
          entry = @lower_method_time_stack.pop?
          child_ms = entry ? entry.child_ms : 0.0
          self_ms = elapsed_ms - child_ms
          self_ms = 0.0 if self_ms < 0.0
          if parent = @lower_method_time_stack.last?
            parent.child_ms += elapsed_ms
          end
          should_log = time_match
          if slow_threshold
            should_log ||= elapsed_ms >= slow_threshold
          end
          if should_log
            source_path = nil
            if arena
              source_path = source_path_for(arena)
            elsif @arena
              source_path = source_path_for(@arena)
            end
            stats = @lower_method_stats_stack.pop?
            if stats
              suffix = source_path ? " file=#{source_path}" : ""
              STDERR.puts "[LOWER_METHOD_TIME] name=#{target_name} requested=#{name} total=#{elapsed_ms.round(1)}ms self=#{self_ms.round(1)}ms child=#{child_ms.round(1)}ms resolve=#{stats.resolve_ms.round(1)}ms/#{stats.resolve_calls} infer=#{stats.infer_ms.round(1)}ms/#{stats.infer_calls}#{suffix}"
            else
              suffix = source_path ? " file=#{source_path}" : ""
              STDERR.puts "[LOWER_METHOD_TIME] name=#{target_name} requested=#{name} total=#{elapsed_ms.round(1)}ms self=#{self_ms.round(1)}ms child=#{child_ms.round(1)}ms#{suffix}"
            end
          elsif env_get("DEBUG_LOWER_METHOD_STATS")
            @lower_method_stats_stack.pop?
          end
        end
      end
    end

    private def maybe_generate_accessor_for_name(name : String) : Bool
      base_name = strip_type_suffix(name)
      parts = parse_method_name(base_name)
      return false unless parts.is_instance

      owner = parts.owner
      method_name = parts.method || ""
      return false if owner.empty? || method_name.empty?
      if method_name.starts_with?('@') && !method_name.ends_with?('=')
        ivar_name = method_name
        if class_info = @class_info[owner]?
          if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
            expected_name = mangle_function_name(base_name, [] of TypeRef)
            return false if name.includes?('$') && expected_name != name
            generate_getter_method_for_ivar(owner, class_info, ivar_info, method_name)
            return true
          end
        end
        if resolved = resolve_module_typed_ivar(owner, ivar_name)
          class_info, ivar_info = resolved
          module_type = type_ref_for_name(owner)
          expected_name = mangle_function_name(base_name, [] of TypeRef)
          return false if name.includes?('$') && expected_name != name
          generate_getter_method_for_ivar(owner, class_info, ivar_info, method_name, module_type)
          return true
        end
      end

      if env_has?("DEBUG_RANGE_ACCESSOR") && owner.starts_with?("Range") && (method_name == "begin" || method_name == "end" || method_name == "excludes_end?")
        STDERR.puts "[RANGE_ACCESSOR] name=#{name} owner=#{owner} method=#{method_name}"
      end

      class_info = @class_info[owner]?
      if env_has?("DEBUG_RANGE_ACCESSOR") && owner.starts_with?("Range") && (method_name == "begin" || method_name == "end" || method_name == "excludes_end?")
        if class_info
          ivars_str = class_info.ivars.map { |iv| "#{iv.name}:#{get_type_name_from_ref(iv.type)}" }.join(", ")
          STDERR.puts "[RANGE_ACCESSOR] class_info found: ivars=#{ivars_str}"
        else
          STDERR.puts "[RANGE_ACCESSOR] class_info NOT found for owner=#{owner}"
        end
      end
      return false unless class_info

      if method_name.ends_with?('=')
        accessor = method_name[0, method_name.size - 1]
        ivar_name = "@#{accessor}"
        if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
          expected_name = mangle_function_name(base_name, [ivar_info.type])
          return false if name.includes?('$') && expected_name != name
          generate_setter_method_for_ivar(owner, class_info, ivar_info, !name.includes?('$'))
          return true
        elsif class_info.is_struct
          if ivar_info = class_info.ivars.find { |iv| iv.name == "@@#{accessor}" }
            expected_name = mangle_function_name(base_name, [ivar_info.type])
            return false if name.includes?('$') && expected_name != name
            generate_setter_method_for_ivar(owner, class_info, ivar_info, !name.includes?('$'))
            return true
          end
        end
      else
        accessor = method_name.ends_with?('?') ? method_name[0, method_name.size - 1] : method_name
        ivar_name = "@#{accessor}"
        if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
          expected_name = mangle_function_name(base_name, [] of TypeRef)
          return false if name.includes?('$') && expected_name != name
          generate_getter_method_for_ivar(owner, class_info, ivar_info, method_name)
          return true
        elsif class_info.is_struct
          if ivar_info = class_info.ivars.find { |iv| iv.name == "@@#{accessor}" }
            expected_name = mangle_function_name(base_name, [] of TypeRef)
            return false if name.includes?('$') && expected_name != name
            generate_getter_method_for_ivar(owner, class_info, ivar_info, method_name)
            return true
          end
        end
      end

      false
    end

    private def register_class_accessor_entry(
      owner_name : String,
      spec : CrystalV2::Compiler::Frontend::AccessorSpec,
      kind : Symbol,
    ) : Nil
      storage_name = accessor_storage_name(spec)
      method_name = accessor_method_name(spec)

      case kind
      when :getter
        return_type = if ta = spec.type_annotation
                        type_ref_for_name(String.new(ta))
                      elsif spec.predicate
                        TypeRef::BOOL
                      elsif default_value = spec.default_value
                        infer_type_from_expr(default_value, owner_name) || TypeRef::VOID
                      else
                        TypeRef::VOID
                      end
        base_name = "#{owner_name}.#{method_name}"
        full_name = mangle_function_name(base_name, [] of TypeRef)
        register_function_type(full_name, return_type)
        entry = ClassAccessorEntry.new(owner_name, spec, @arena, :getter)
        @class_accessor_entries[full_name] = entry
        @class_accessor_entries[base_name] = entry
      when :setter
        param_type = if ta = spec.type_annotation
                       type_ref_for_name(String.new(ta))
                     else
                       TypeRef::VOID
                     end
        base_name = "#{owner_name}.#{storage_name}="
        full_name = mangle_function_name(base_name, [param_type])
        register_function_type(full_name, param_type)
        entry = ClassAccessorEntry.new(owner_name, spec, @arena, :setter)
        @class_accessor_entries[full_name] = entry
        @class_accessor_entries[base_name] = entry
      end
    end

    private def maybe_generate_class_accessor_for_name(name : String) : Bool
      entry = @class_accessor_entries[name]?
      unless entry
        base_name = strip_type_suffix(name)
        entry = @class_accessor_entries[base_name]?
      end
      return false unless entry

      with_arena(entry.arena) do
        case entry.kind
        when :getter
          generate_class_getter_method(entry.owner, entry.spec, entry.arena)
        when :setter
          generate_class_setter_method(entry.owner, entry.spec)
        end
      end
      true
    end

    private def ensure_accessor_method(
      ctx : LoweringContext,
      receiver_id : ValueId,
      method_name : String,
    ) : Tuple(TypeRef, String)?
      receiver_type = ctx.type_of(receiver_id)
      class_name = get_type_name_from_ref(receiver_type)
      class_info = @class_info[class_name]?
      if class_info.nil? && module_like_type_name?(class_name)
        if preferred = preferred_module_typed_class_for(class_name)
          class_name = preferred
          class_info = @class_info[class_name]?
        end
      end
      if env_get("DEBUG_ACCESSOR")
        STDERR.puts "[ACCESSOR] method=#{method_name} recv=#{get_type_name_from_ref(receiver_type)} resolved=#{class_name} class_info=#{class_info ? "yes" : "no"}"
      end
      return nil unless class_info

      if method_name.ends_with?('=')
        accessor_name = method_name[0, method_name.size - 1]
        ivar_name = "@#{accessor_name}"
        if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
          func_name = mangle_function_name("#{class_name}##{accessor_name}=", [ivar_info.type])
          generate_setter_method_for_ivar(class_name, class_info, ivar_info) unless @module.has_function?(func_name)
          return {ivar_info.type, func_name}
        end
      else
        ivar_name = "@#{method_name}"
        if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
          func_name = mangle_function_name("#{class_name}##{method_name}", [] of TypeRef)
          generate_getter_method_for_ivar(class_name, class_info, ivar_info) unless @module.has_function?(func_name)
          return {ivar_info.type, func_name}
        end
      end

      nil
    end

    private def ivar_type_for_setter(
      ctx : LoweringContext,
      receiver_id : ValueId,
      method_name : String,
    ) : TypeRef?
      return nil unless method_name.ends_with?('=')
      receiver_type = ctx.type_of(receiver_id)
      class_name = get_type_name_from_ref(receiver_type)
      return nil if class_name.empty?

      if class_info = @class_info[class_name]?
        accessor_name = method_name[0, method_name.size - 1]
        ivar_name = "@#{accessor_name}"
        if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
          return ivar_info.type
        end
      end

      nil
    end

    private def lower_spawn(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::SpawnNode) : ValueId
      body_exprs = if body = node.body
                     body
                   elsif expr = node.expression
                     [expr] of CrystalV2::Compiler::Frontend::ExprId
                   else
                     [] of CrystalV2::Compiler::Frontend::ExprId
                   end

      block_node = CrystalV2::Compiler::Frontend::BlockNode.new(node.span, nil, body_exprs)
      block_id = @arena.add_typed(block_node)

      callee_id = @arena.add_typed(
        CrystalV2::Compiler::Frontend::IdentifierNode.new(node.span, "spawn".to_slice)
      )
      call_node = CrystalV2::Compiler::Frontend::CallNode.new(node.span, callee_id, [] of CrystalV2::Compiler::Frontend::ExprId, block_id)
      lower_call(ctx, call_node)
    end

    private def lower_call(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::CallNode) : ValueId
      if env_get("DEBUG_MISSING_SYMS")
        callee_node_dbg = @arena[node.callee]
        method_name_dbg2 = case callee_node_dbg
                           when CrystalV2::Compiler::Frontend::MemberAccessNode
                             String.new(callee_node_dbg.member)
                           when CrystalV2::Compiler::Frontend::IdentifierNode
                             String.new(callee_node_dbg.name)
                           else
                             nil
                           end
        if method_name_dbg2 == "leap_year?" || method_name_dbg2 == "month_week_date"
          obj_dbg = case callee_node_dbg
                    when CrystalV2::Compiler::Frontend::MemberAccessNode
                      obj_node_dbg = @arena[callee_node_dbg.object]
                      "#{obj_node_dbg.class.name}(#{obj_node_dbg.is_a?(CrystalV2::Compiler::Frontend::ConstantNode) ? String.new(obj_node_dbg.name) : "?"})"
                    else
                      "bare"
                    end
          STDERR.puts "[LOWER_CALL_ENTRY_DBG] method=#{method_name_dbg2} obj=#{obj_dbg} func=#{ctx.function.name} current_class=#{@current_class}"
        end
      end
      if env_get("DEBUG_UNION_CONV_ALL")
        callee_node = @arena[node.callee]
        method_name_dbg = case callee_node
                          when CrystalV2::Compiler::Frontend::MemberAccessNode
                            String.new(callee_node.member)
                          when CrystalV2::Compiler::Frontend::IdentifierNode
                            String.new(callee_node.name)
                          else
                            nil
                          end
        if method_name_dbg && (method_name_dbg == "to_i32!" || method_name_dbg == "to_u32!" || method_name_dbg == "to_u64!")
          STDERR.puts "[LOWER_CALL_ENTRY] method=#{method_name_dbg} func=#{ctx.function.name}"
        end
      end
      if env_get("DEBUG_ENUM_UNION_PREDICATE")
        callee_node = @arena[node.callee]
        callee_name = case callee_node
                      when CrystalV2::Compiler::Frontend::MemberAccessNode
                        String.new(callee_node.member)
                      else
                        nil
                      end
        if callee_name && (callee_name == "kill?" || callee_name == "hup?" || callee_name == "quit?")
          STDERR.puts "[LOWER_CALL_SIGNAL] method=#{callee_name} func=#{ctx.function.name}"
        end
      end
      if env_get("DEBUG_ALL_CALLS") || env_get("DEBUG_LOWER_CALL")
        callee_node = @arena[node.callee]
        callee_name = case callee_node
                      when CrystalV2::Compiler::Frontend::IdentifierNode
                        String.new(callee_node.name)
                      when CrystalV2::Compiler::Frontend::MemberAccessNode
                        String.new(callee_node.member)
                      else
                        "(other)"
                      end
        if env_get("DEBUG_ALL_CALLS") || callee_name == "byte_range"
          STDERR.puts "[LOWER_CALL] method=#{callee_name} callee_type=#{callee_node.class.name.split("::").last} current_class=#{@current_class || "nil"} block=#{node.block.nil? ? "no" : "yes"} func=#{ctx.function.name}"
        end
      end
      if env_get("DEBUG_INLINE_CRASH")
        if @inline_yield_name_stack.any? { |name| name.includes?("Char::Reader#decode_char_at") }
          stack = @inline_yield_name_stack.join(" -> ")
          if ctx.current_block >= ctx.function.blocks.size
            STDERR.puts "[INLINE_CRASH] block_oob call block=#{ctx.current_block} size=#{ctx.function.blocks.size} stack=#{stack}"
          end
          if source = @sources_by_arena[@arena]?
            span = node.span
            start = span.start_offset
            length = span.end_offset - span.start_offset
            if length > 0 && start >= 0 && start < source.bytesize
              slice_len = length > 80 ? 80 : length
              snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
              STDERR.puts "[INLINE_CRASH] lower_call span=#{start}..#{span.end_offset} stack=#{stack} \"#{snippet}\""
            else
              STDERR.puts "[INLINE_CRASH] lower_call span=#{start}..#{span.end_offset} stack=#{stack}"
            end
          else
            STDERR.puts "[INLINE_CRASH] lower_call span=#{node.span.start_offset}..#{node.span.end_offset} stack=#{stack}"
          end
        end
      end
      call_arena = @arena
      if @current_class && @current_method
        scope = "#{@current_class}##{@current_method}"
        if scope != @callsite_method_cache_scope
          @callsite_method_cache.clear
          @callsite_method_cache_scope = scope
        end
      elsif @callsite_method_cache_scope
        @callsite_method_cache.clear
        @callsite_method_cache_scope = nil
      end
      if type_like_call_expr?(node)
        base = resolve_path_like_name(node.callee) || stringify_type_expr(node.callee)
        if base
          args = node.args.compact_map { |arg| stringify_type_expr(arg) }
          if args.size == node.args.size
            type_name = "#{base}(#{args.join(", ")})"
            return lower_type_literal_from_name(ctx, type_name)
          end
        end
      end
      # CallNode has callee (ExprId) which can be:
      # - IdentifierNode: simple function call like foo() or ClassName.new()
      # - MemberAccessNode: method call like obj.method()
      # - Other: chained/complex calls

      callee_node = @arena[node.callee]
      if env_get("DEBUG_READ_ATTR_CALL")
        callee_name = case callee_node
                      when CrystalV2::Compiler::Frontend::IdentifierNode
                        String.new(callee_node.name)
                      when CrystalV2::Compiler::Frontend::MemberAccessNode
                        String.new(callee_node.member)
                      else
                        nil
                      end
        if callee_name == "read_attribute_value"
          snippet = nil
          if source = @sources_by_arena[@arena]?
            span = node.span
            start = span.start_offset
            length = span.end_offset - span.start_offset
            if length > 0 && start >= 0 && start < source.bytesize
              slice_len = length > 120 ? 120 : length
              snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
            end
          end
          snippet_label = snippet ? " \"#{snippet}\"" : ""
          STDERR.puts "[DEBUG_READ_ATTR_CALL] func=#{ctx.function.name} class=#{@current_class || "nil"} arena=#{@arena.class}:#{@arena.size}#{snippet_label}"
        end
      end

      # Intrinsic: obj.is_a?(Type) should lower to IsA/UnionIs without a runtime method call.
      if node.named_args.nil?
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
           String.new(callee_node.member) == "is_a?"
          if node.args.empty?
            debug_hook("is_a.missing_type", "receiver=#{stringify_type_expr(callee_node.object) || "unknown"}")
            lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
            ctx.emit(lit)
            return lit.id
          elsif type_str = stringify_type_expr(node.args.first)
            is_a_receiver_id = lower_expr(ctx, callee_node.object)
            return emit_is_a_check(ctx, is_a_receiver_id, type_str)
          end
        elsif callee_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
              String.new(callee_node.name) == "is_a?"
          if node.args.empty?
            debug_hook("is_a.missing_type", "receiver=self")
            lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
            ctx.emit(lit)
            return lit.id
          elsif type_str = stringify_type_expr(node.args.first)
            is_a_receiver_id = emit_self(ctx)
            return emit_is_a_check(ctx, is_a_receiver_id, type_str)
          end
        end
      end

      call_args = node.args
      block_expr = node.block
      block_pass_expr : ExprId? = nil

      if block_expr.nil? && !call_args.empty?
        last_id = call_args.last
        last_node = @arena[last_id]
        case last_node
        when CrystalV2::Compiler::Frontend::BlockNode
          block_expr = last_id
          call_args = call_args[0...-1]
        when CrystalV2::Compiler::Frontend::UnaryNode
          if String.new(last_node.operator) == "&"
            operand = last_node.operand
            operand_node = @arena[operand]
            if operand_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              block_expr = operand
            else
              block_pass_expr = operand
            end
            call_args = call_args[0...-1]
          end
        end
      end
      if block_expr
        block_node = @arena[block_expr]
        if block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
          @block_node_arenas[block_node.object_id] ||= @arena
        end
      end

      receiver_id : ValueId? = nil
      receiver_type : TypeRef = TypeRef::VOID
      method_name : String
      full_method_name : String? = nil
      static_class_name : String? = nil
      proc_return_type_name : String? = nil
      cached_callsite_key : String? = nil
      explicit_self_receiver = false

      case callee_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        # Simple function call: foo()
        method_name = String.new(callee_node.name)
        current_is_class = @current_method_is_class
        if !current_is_class
          current_is_class = class_method?(strip_type_suffix(ctx.function.name))
        end
        if !current_is_class
          if self_id = ctx.lookup_local("self")
            current_is_class = true if ctx.type_literal?(self_id)
          end
        end
        if current_is_class && (current = @current_class) && method_name == "new"
          full_method_name = "#{current}.#{method_name}"
          static_class_name = current
        end
        if @current_method == "new" && (current = @current_class) && method_name == "new"
          full_method_name = "#{current}.#{method_name}"
          static_class_name = current
        end
        # Handle qualified calls like Int32.to_s that may appear as IdentifierNodes
        # (e.g., from macro expansion or type-literal printing).
        if method_name.includes?('.')
          full_method_name = method_name
          if owner = method_owner(method_name)
            static_class_name = owner
            method_name = method_short_from_name(method_name) || method_name
          end
        end
        if method_name == "system_init" && @current_class == "File"
          lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(lit)
          return lit.id
        end
        if env_get("DEBUG_SET_CRYSTAL_TYPE_ID") && method_name == "set_crystal_type_id"
          STDERR.puts "[SET_CRYSTAL_TYPE_ID] current_class=#{@current_class || "nil"} current_method=#{@current_method || "nil"} class_method=#{@current_method_is_class} func=#{ctx.function.name}"
        end

        # Check if this is a macro call - expand inline instead of generating Call.
        # Skip spawn macro when lowering SpawnNode-generated calls (block + no args).
        unless method_name == "spawn" && block_expr && call_args.empty? && node.named_args.nil?
          if macro_lookup = lookup_macro_entry(method_name, @current_class)
            macro_entry, macro_key = macro_lookup
            macro_def, macro_arena = macro_entry
            return expand_macro(ctx, macro_def, macro_arena, call_args, node.named_args, block_expr, macro_key)
          end
        end

        # If inside a class/module, check if this is a method call on self or module
        if env_has?("DEBUG_CALL_PATH") && method_name == "byte_range"
          STDERR.puts "[CALL_PATH] IdentifierNode method=#{method_name} @current_class=#{@current_class || "nil"}"
        end
        if ctx.lookup_local("self").nil? && @inline_yield_block_body_depth > 0
          if value_id = inline_caller_local_id("self")
            ctx.register_local("self", value_id)
            ctx.register_type(value_id, ctx.type_of(value_id))
          end
        end
        if !current_is_class
          if self_id = ctx.lookup_local("self")
            self_type = ctx.type_of(self_id)
            if self_type != TypeRef::VOID
              self_name = if info = @class_info_by_type_id[self_type.id]?
                            info.name
                          elsif desc = @module.get_type_descriptor(self_type)
                            normalize_method_owner_name(desc.name)
                          else
                            ""
                          end
              if !self_name.empty?
                self_method_name = "#{self_name}##{method_name}"
                if @function_types.has_key?(self_method_name) ||
                   has_function_base?(self_method_name) ||
                   @function_defs.has_key?(self_method_name)
                  receiver_id = self_id
                  full_method_name = resolve_method_with_inheritance(self_name, method_name) || self_method_name
                end
                if receiver_id.nil?
                  # In instance methods, unqualified calls default to self even if the
                  # target method isn't registered yet (avoid class-method fallback).
                  # BUT: skip for puts/print — these are top-level output functions
                  # that must reach the direct STDOUT interception below, not become
                  # dead-code stubs like Foo#puts(String).
                  unless method_name == "puts" || method_name == "print" || method_name == "p" || method_name == "pp"
                    receiver_id = self_id
                    full_method_name = resolve_method_with_inheritance(self_name, method_name) || self_method_name
                  end
                end
              end
            end
          end
        end

        if receiver_id.nil? && (current = @current_class)
          # Debug: track when @current_class is a short name
          if env_has?("DEBUG_SHORT_NAMES") && !current.includes?("::") &&
             (current == "Seek" || current == "Section" || current == "LoadCommand" || current == "Sequence")
            STDERR.puts "[SHORT_CLASS] @current_class=#{current}, method=#{method_name}"
          end
          # Check if method exists in current class (instance method: Class#method)
          class_method_name = "#{current}##{method_name}"
          # O(1) lookup: check exact match or mangled version exists
          has_class_method = @function_types.has_key?(class_method_name) ||
                             has_function_base?(class_method_name) ||
                             !function_def_overloads(class_method_name).empty?
          if has_class_method || abstract_def?(class_method_name)
            # This is a method call on self - set receiver to self
            receiver_id = emit_self(ctx)
            full_method_name = class_method_name
          else
            # Check if method exists in included modules
            included_method_found = false
            if modules = @class_included_modules[current]?
              if env_has?("DEBUG_INCLUDED") && method_name == "byte_range"
                STDERR.puts "[INCLUDED] class=#{current} method=#{method_name} modules=#{modules.to_a.join(",")}"
              end
              modules.each do |mod_name|
                mod_method_name = "#{mod_name}##{method_name}"
                has_in_types = @function_types.has_key?(mod_method_name)
                has_in_base = has_function_base?(mod_method_name)
                if env_has?("DEBUG_INCLUDED") && method_name == "byte_range"
                  STDERR.puts "[INCLUDED_LOOKUP] mod_method=#{mod_method_name} has_in_types=#{has_in_types} has_in_base=#{has_in_base}"
                end
                if has_in_types || has_in_base || abstract_def?(mod_method_name)
                  receiver_id = emit_self(ctx)
                  full_method_name = mod_method_name
                  included_method_found = true
                  break
                end
                # If not found in function_types, try to find in module def AST
                # This handles instance methods (def foo) that aren't pre-registered
                unless included_method_found
                  base_module = strip_generic_args(mod_name)
                  visited = Set(String).new
                  if found = find_module_def_recursive(base_module, method_name, 0, visited)
                    if env_has?("DEBUG_INCLUDED") && method_name == "byte_range"
                      STDERR.puts "[INCLUDED_FOUND_IN_AST] mod=#{base_module} method=#{method_name}"
                    end
                    receiver_id = emit_self(ctx)
                    # Use class#method name for lowering (will use deferred lookup)
                    full_method_name = "#{current}##{method_name}"
                    included_method_found = true
                    break
                  end
                end
              end
            elsif env_has?("DEBUG_INCLUDED") && method_name == "byte_range"
              STDERR.puts "[INCLUDED] class=#{current} method=#{method_name} no_modules"
            end
            unless included_method_found
              # Check if method exists in parent classes (inheritance chain)
              parent_method_found = false
              parent_class = @class_info[current]?.try(&.parent_name) || @module.class_parents[current]?
              while parent_class && !parent_method_found
                parent_method_name = "#{parent_class}##{method_name}"
                if @function_types.has_key?(parent_method_name) ||
                   has_function_base?(parent_method_name) ||
                   !function_def_overloads(parent_method_name).empty? ||
                   abstract_def?(parent_method_name)
                  receiver_id = emit_self(ctx)
                  full_method_name = parent_method_name
                  parent_method_found = true
                  break
                end
                # Move to next parent
                parent_class = @class_info[parent_class]?.try(&.parent_name) || @module.class_parents[parent_class]?
              end

              unless parent_method_found
                # Only resolve class/module methods for implicit calls when we are in a class method.
                # In instance methods, implicit calls should remain instance dispatch (self), not
                # accidentally bind to Class.method and lose the receiver.
                if current_is_class
                  if class_method_base = resolve_class_method_with_inheritance(current, method_name)
                    # This is a module/class method call (no receiver)
                    receiver_id = nil
                    full_method_name = class_method_base
                  elsif find_module_class_def(current, method_name, call_args.size)
                    # Class method exists in AST but wasn't registered yet.
                    receiver_id = nil
                    full_method_name = "#{current}.#{method_name}"
                  else
                    receiver_id = nil
                  end
                else
                  receiver_id = nil
                end
              end
            end
          end
          # For abstract numeric types (Int, UInt, Float) calling primitive operations
          # without explicit receiver, use self as receiver so special lowering works.
          if receiver_id.nil? && full_method_name.nil? && !current_is_class
            is_abstract_numeric = current == "Int" || current == "UInt" || current == "Float" ||
                                  current == "Number" || current == "Comparable" ||
                                  current.starts_with?("Int(") || current.starts_with?("Comparable(")
            is_primitive_op = method_name == "unsafe_div" || method_name == "unsafe_mod" ||
                              method_name == "unsafe_shl" || method_name == "unsafe_shr"
            if is_abstract_numeric && is_primitive_op
              receiver_id = emit_self(ctx)
            end
          end
          if receiver_id.nil? && full_method_name.nil? && current_is_class
            top_level_exists = @function_defs.has_key?(method_name) ||
                               @function_types.has_key?(method_name) ||
                               has_function_base?(method_name)
            unless top_level_exists
              receiver_id = nil
              full_method_name = "#{current}.#{method_name}"
            end
          end
          if receiver_id.nil? && full_method_name.nil? && method_name == "set_crystal_type_id"
            receiver_id = nil
            full_method_name = "#{current}.#{method_name}"
          end
        else
          receiver_id = nil
        end
        if receiver_id.nil? && full_method_name.nil? && !current_is_class
          if current = @current_class
            if module_like_type_name?(current)
              receiver_id = emit_self(ctx)
              full_method_name = "#{current}##{method_name}"
            end
          end
        end
        if receiver_id.nil? && full_method_name.nil? && !current_is_class
          top_level_exists = @function_defs.has_key?(method_name) ||
                             @function_types.has_key?(method_name) ||
                             has_function_base?(method_name)
          unless top_level_exists
            object_owner = "Object"
            resolved = resolve_method_with_inheritance(object_owner, method_name)
            object_method_name = resolved || "#{object_owner}##{method_name}"
            if resolved || @function_types.has_key?(object_method_name) ||
               has_function_base?(object_method_name) || @function_defs.has_key?(object_method_name) ||
               !function_def_overloads(object_method_name).empty?
              receiver_id = emit_self(ctx)
              if receiver_id && ctx.type_of(receiver_id) == TypeRef::VOID
                object_ref = type_ref_for_name(object_owner)
                ctx.register_type(receiver_id, object_ref) if object_ref != TypeRef::VOID
              end
              full_method_name = object_method_name
            end
          end
        end
        if method_name == "new" && @current_method == "new" && (current = @current_class)
          full_method_name = "#{current}.#{method_name}"
          receiver_id = nil
          static_class_name = current
        end
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # Could be method call: obj.method() or class method: ClassName.new()
        obj_expr = callee_node.object
        obj_node = @arena[obj_expr]
        method_name = String.new(callee_node.member)
        explicit_self_receiver = obj_node.is_a?(CrystalV2::Compiler::Frontend::SelfNode) ||
                                 obj_node.is_a?(CrystalV2::Compiler::Frontend::ImplicitObjNode) ||
                                 (obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && String.new(obj_node.name) == "self")
        if debug_env_filter_match?("DEBUG_TPM_CALL", method_name)
          STDERR.puts "[TPM_CALL] method=#{method_name} current=#{@current_class || "nil"} map=#{type_param_map_debug_string}"
        end
        if env_get("DEBUG_EXE_PATH_CALL") && method_name == "executable_path"
          raw_obj = stringify_type_expr(obj_expr) || "(unknown)"
          obj_label = obj_node.class.name.split("::").last
          current_label = @current_class || "nil"
          override_label = @current_namespace_override || "nil"
          STDERR.puts "[DEBUG_EXE_PATH_CALL] early obj=#{obj_label} raw=#{raw_obj} current=#{current_label} override=#{override_label}"
        end
        if env_get("DEBUG_ENUM_PREDICATE") && method_name == "character_device?"
          STDERR.puts "[DEBUG_ENUM_CALL_PATH] lower_call method=#{method_name} callee=#{callee_node.class.name}"
        end
        if env_get("DEBUG_BYTEFORMAT_FORMAT") && method_name == "decode" &&
           obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
           String.new(obj_node.name) == "format"
          local_id = ctx.lookup_local("format")
          lit_flag = local_id ? ctx.type_literal?(local_id) : false
          local_type = local_id ? get_type_name_from_ref(ctx.type_of(local_id)) : "nil"
          module_flag = local_id ? module_type_ref?(ctx.type_of(local_id)) : false
          STDERR.puts "[BYTEFORMAT_FORMAT] lookup=#{local_id || "nil"} type=#{local_type} lit=#{lit_flag} module=#{module_flag} current=#{@current_class || "nil"}##{@current_method || "nil"} class_method=#{@current_method_is_class ? 1 : 0}"
        end
        if env_get("DEBUG_THREAD_RESOLVE") && method_name == "threads"
          STDERR.puts "[THREAD_RESOLVE_CALL] obj_node=#{obj_node.class.name} current=#{@current_class || "nil"} override=#{@current_namespace_override || "nil"}"
        end
        if env_get("DEBUG_POINTER_LIST") && method_name == "new"
          if obj_name = stringify_type_expr(obj_expr)
            if obj_name.includes?("PointerLinkedList")
              STDERR.puts "[POINTER_LIST_AST] obj=#{obj_name} method=#{method_name}"
            end
          end
        end

        # Intrinsic: unsafe_as(Type) should lower to a raw cast without a method call.
        if method_name == "unsafe_as" && node.named_args.nil? && block_expr.nil? && block_pass_expr.nil?
          if arg = call_args.first?
            if type_str = stringify_type_expr(arg)
              receiver_id = lower_expr(ctx, obj_expr)
              target_type = type_ref_for_name(type_str)
              if target_type != TypeRef::VOID
                cast = Cast.new(ctx.next_id, target_type, receiver_id, target_type, safe: false)
                ctx.emit(cast)
                ctx.register_type(cast.id, target_type)
                return cast.id
              end
            end
          end
        end

        # Proc#call intercept: lower receiver, check if Proc, emit direct Call
        # with individual args (NOT packed into splat tuple).
        if method_name == "call" && block_expr.nil? && block_pass_expr.nil?
          proc_recv_id = lower_expr(ctx, obj_expr)
          proc_recv_type = ctx.type_of(proc_recv_id)
          if proc_recv_desc = @module.get_type_descriptor(proc_recv_type)
            if proc_recv_desc.kind == TypeKind::Proc
              # Lower each arg individually
              proc_call_args = call_args.map { |arg_expr| lower_expr(ctx, arg_expr) }
              # Append captured values as hidden extra args
              if capture_ids = @proc_captures_by_value[proc_recv_id]?
                proc_call_args.concat(capture_ids)
              end
              # Extract return type from Proc type_params (last element)
              proc_call_return = TypeRef::VOID
              if proc_recv_desc.type_params.size > 0
                proc_ret = proc_recv_desc.type_params.last
                proc_call_return = proc_ret if proc_ret != TypeRef::VOID
              end
              proc_call = Call.new(ctx.next_id, proc_call_return, proc_recv_id, "Proc#call", proc_call_args)
              ctx.emit(proc_call)
              ctx.register_type(proc_call.id, proc_call_return)
              return proc_call.id
            end
          end
        end

        # Direct ivar access on another object: obj.@ivar
        # Lower as field get when no args/block are present.
        if method_name.starts_with?('@') && call_args.empty? && block_expr.nil? && block_pass_expr.nil?
          return lower_member_access(ctx, callee_node)
        end

        # String#to_i / to_i64 intercept (EARLY): must be before method resolution
        # to prevent stdlib to_i with 6 default args from being compiled.
        if (method_name == "to_i" || method_name == "to_i32" || method_name == "to_i64") &&
           call_args.empty? && block_expr.nil? && block_pass_expr.nil?
          recv_id = lower_expr(ctx, obj_expr)
          recv_type = ctx.type_of(recv_id)
          if recv_type == TypeRef::STRING || recv_type == TypeRef::POINTER
            if method_name == "to_i64"
              ext_call = ExternCall.new(ctx.next_id, TypeRef::INT64, "__crystal_v2_string_to_i64", [recv_id])
              ctx.emit(ext_call)
              ctx.register_type(ext_call.id, TypeRef::INT64)
              return ext_call.id
            else
              ext_call = ExternCall.new(ctx.next_id, TypeRef::INT32, "__crystal_v2_string_to_i", [recv_id])
              ctx.emit(ext_call)
              ctx.register_type(ext_call.id, TypeRef::INT32)
              return ext_call.id
            end
          end
        end

        # String#each_char { |ch| ... } (EARLY): intrinsic to avoid Char::Reader DWARF contamination
        # Iterates bytes as ASCII Chars (sufficient for bootstrap)
        if method_name == "each_char" && block_expr && call_args.empty?
          recv_id = lower_expr(ctx, obj_expr)
          recv_type = ctx.type_of(recv_id)
          if recv_type == TypeRef::STRING || recv_type == TypeRef::POINTER
            blk_node = @arena[block_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              return lower_string_each_char_intrinsic(ctx, recv_id, blk_node)
            end
          end
        end

        # Array#first / Array#last / Array#min / Array#max (EARLY): must be before method resolution
        # to prevent stdlib Enumerable method bodies (DWARF-contaminated) from being compiled.
        if (method_name == "first" || method_name == "last" || method_name == "min" || method_name == "max") &&
           call_args.empty? && block_expr.nil? && block_pass_expr.nil?
          recv_id = lower_expr(ctx, obj_expr)
          if array_intrinsic_receiver?(ctx, recv_id)
            case method_name
            when "first" then return lower_array_first_intrinsic(ctx, recv_id)
            when "last"  then return lower_array_last_intrinsic(ctx, recv_id)
            when "min"   then return lower_array_min_intrinsic(ctx, recv_id)
            when "max"   then return lower_array_max_intrinsic(ctx, recv_id)
            end
          end
        end

        # Array#join(separator) (EARLY): intercept before method resolution.
        if method_name == "join" && call_args.size == 1 && block_expr.nil? && block_pass_expr.nil?
          recv_id = lower_expr(ctx, obj_expr)
          if array_intrinsic_receiver?(ctx, recv_id)
            sep_id = with_arena(call_arena) { lower_expr(ctx, call_args[0]) }
            ext_call = ExternCall.new(ctx.next_id, TypeRef::STRING, "__crystal_v2_array_join_string", [recv_id, sep_id])
            ctx.emit(ext_call)
            ctx.register_type(ext_call.id, TypeRef::STRING)
            return ext_call.id
          end
        end

        # Array#count { |x| condition } (EARLY): same as above.
        if method_name == "count" && block_expr
          recv_id = lower_expr(ctx, obj_expr)
          if array_intrinsic_receiver?(ctx, recv_id)
            blk_node = @arena[block_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              return lower_array_count_dynamic(ctx, recv_id, blk_node)
            end
          end
        end

        # Intrinsic: `x.upto(y).each { ... }` / `x.downto(y).each { ... }`
        # Prefer lowering directly via the yield-based overload to avoid iterator types like
        # `UptoIterator(typeof(self), typeof(to))` which are not yet fully monomorphized in codegen.
        if method_name == "each"
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode) && obj_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
              inner_call = obj_node
              if inner_call.block.nil?
                inner_callee = @arena[inner_call.callee]
                if inner_callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                  inner_method = String.new(inner_callee.member)
                  if inner_method == "upto" || inner_method == "downto"
                    inner_receiver_id = lower_expr(ctx, inner_callee.object)
                    inner_args = if inner_call.named_args
                                   # Named args for upto/downto are not expected; fall back to positional.
                                   expand_splat_args(ctx, inner_call.args, call_arena)
                                 else
                                   expand_splat_args(ctx, inner_call.args, call_arena)
                                 end
                    receiver_base = yield_receiver_base_name(ctx.type_of(inner_receiver_id))
                    if yield_key = find_yield_method_fallback(inner_method, inner_args.size, receiver_base)
                      if func_def = @function_defs[yield_key]?
                        callee_arena = @function_def_arenas[yield_key]? || @arena
                        return inline_yield_function(ctx, func_def, yield_key, inner_receiver_id, inner_args, blk_node, nil, callee_arena)
                      end
                    end
                  end
                end
              end
            end
          end
        end

        # Check if it's a class/module method call (ClassName.new() or Module.method())
        # Can be ConstantNode, IdentifierNode starting with uppercase, GenericNode, or macro expression.
        class_name_str : String? = nil
        constant_receiver = false
        if env_get("DEBUG_CONST_RECV") && method_name == "unsafe_fetch"
          STDERR.puts "[CONST_RECV_EARLY] obj_node=#{obj_node.class.name.split("::").last} method=#{method_name} current=#{@current_class || ""}"
        end
        if obj_node.is_a?(CrystalV2::Compiler::Frontend::MacroExpressionNode)
          if resolved = macro_expression_class_name(obj_node.expression)
            class_name_str = resolved
            constant_receiver = true
          end
        end
        while obj_node.is_a?(CrystalV2::Compiler::Frontend::GroupingNode)
          obj_expr = obj_node.expression
          obj_node = @arena[obj_expr]
        end
        force_instance_receiver = false
        if !@current_method_is_class &&
           (obj_node.is_a?(CrystalV2::Compiler::Frontend::SelfNode) ||
           obj_node.is_a?(CrystalV2::Compiler::Frontend::ImplicitObjNode) ||
           (obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && String.new(obj_node.name) == "self"))
          force_instance_receiver = true
        end
        type_param_receiver_name : String? = nil
        if obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          name = String.new(obj_node.name)
          if name != "self"
            if local_id = ctx.lookup_local(name)
              force_instance_receiver = true
            elsif mapped = @type_param_map[name]?
              type_param_receiver_name = mapped
              force_instance_receiver = true
            elsif @type_param_map.empty?
              if inferred_map = fallback_type_param_map_for_current
                if mapped = inferred_map[name]?
                  type_param_receiver_name = mapped
                  force_instance_receiver = true
                end
              end
            end
          end
        end
        if env_get("DEBUG_FROM_IO_CALL") && method_name == "from_io"
          obj_kind = obj_node.class.name.split("::").last
          obj_name = obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) ? String.new(obj_node.name) : nil
          local_hit = obj_name ? ctx.lookup_local(obj_name) : nil
          STDERR.puts "[FROM_IO_CALL] obj=#{obj_kind} name=#{obj_name || "nil"} local=#{local_hit || "nil"} force_instance=#{force_instance_receiver}"
        end
        if type_param_receiver_name && class_name_str.nil?
          class_name_str = type_param_receiver_name
          force_instance_receiver = false
        end

        if @current_method_is_class &&
           (obj_node.is_a?(CrystalV2::Compiler::Frontend::SelfNode) ||
           obj_node.is_a?(CrystalV2::Compiler::Frontend::ImplicitObjNode))
          class_name_str = @current_class
        elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
          name = String.new(obj_node.name)
          substituted_name = substitute_type_params_in_type_name(name)
          substituted = substituted_name != name
          if substituted
            class_name_str = substituted_name
            force_instance_receiver = false
          elsif mapped = @type_param_map[name]?
            class_name_str = mapped
            force_instance_receiver = false
          elsif @type_param_map.empty?
            if inferred_map = fallback_type_param_map_for_current
              if mapped = inferred_map[name]?
                class_name_str = mapped
                force_instance_receiver = false
              end
            end
          end
          unless force_instance_receiver
            name = substituted_name if substituted
            if @module.is_lib?(name)
              class_name_str = name
            else
              resolved = if substituted && name.includes?("::")
                           name
                         else
                           resolve_class_name_in_context(name)
                         end
              resolved = resolve_type_alias_chain(resolved)
              if env_get("DEBUG_MISSING_SYMS") && (method_name == "leap_year?" || method_name == "month_week_date")
                STDERR.puts "[CONST_RESOLVE] name=#{name} resolved=#{resolved} current=#{@current_class} override=#{@current_namespace_override} class_name_str=#{class_name_str}"
              end
              # Prefer type/module resolution for constant receivers that are actually types.
              if class_name_str.nil? && @generic_templates.has_key?(resolved) && method_name == "new"
                if resolved == "Range" && call_args && call_args.size >= 2
                  left_name = infer_type_name_from_expr_id(call_args[0])
                  right_name = infer_type_name_from_expr_id(call_args[1])
                  if left_name && right_name
                    specialized_name = "#{resolved}(#{left_name}, #{right_name})"
                    if !@monomorphized.includes?(specialized_name)
                      monomorphize_generic_class(resolved, [left_name, right_name], specialized_name)
                    end
                    class_name_str = specialized_name
                  end
                else
                  inferred_type = infer_generic_type_arg(resolved, call_args, block_expr, ctx, node.named_args)
                  if inferred_type
                    specialized_name = "#{resolved}(#{inferred_type})"
                    if !@monomorphized.includes?(specialized_name)
                      monomorphize_generic_class(resolved, [inferred_type], specialized_name)
                    end
                    class_name_str = specialized_name
                  elsif resolved == "Array"
                    specialized_name = "Array(String)"
                    if !@monomorphized.includes?(specialized_name)
                      monomorphize_generic_class(resolved, ["String"], specialized_name)
                    end
                    class_name_str = specialized_name
                  end
                end
              end
              if class_name_str.nil?
                if fallback = class_method_fallback_from_module(resolved, method_name)
                  class_name_str = fallback
                end
              end
              if class_name_str.nil?
                if class_like_namespace?(resolved) || module_like_type_name?(resolved) ||
                   primitive_self_type(resolved) || @enum_info.try(&.has_key?(resolved))
                  class_name_str = resolved
                elsif is_module_method?(resolved, method_name)
                  class_name_str = resolved
                elsif resolve_constant_name_in_context(name)
                  constant_receiver = true
                end
              end
              if env_get("DEBUG_MISSING_SYMS") && (method_name == "leap_year?" || method_name == "month_week_date")
                STDERR.puts "[CONST_PATH_SET] class_name_str=#{class_name_str} resolved=#{resolved} name=#{name} current=#{@current_class}"
              end
            end
          end
        elsif !force_instance_receiver && obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          name = String.new(obj_node.name)
          if ctx.lookup_local(name).nil? || name[0]?.try(&.uppercase?)
            if @module.is_lib?(name)
              class_name_str = name
            else
              if @type_param_map.empty? && type_param_like?(name)
                if inferred_map = fallback_type_param_map_for_current
                  if mapped = inferred_map[name]?
                    name = mapped
                  end
                end
              end
              if type_name = lookup_typeof_local_name(name)
                if env_get("DEBUG_TYPE_CLASS") && type_name.ends_with?(".class")
                  STDERR.puts "[DEBUG_TYPE_CLASS] method=#{method_name} name=#{name} type_name=#{type_name}"
                end
                if class_literal = resolve_type_literal_class_name(type_name)
                  class_name_str = class_literal
                end
              end
              # CRITICAL: Substitute type params FIRST, before namespace resolution
              # e.g., ImplInfo -> ImplInfo_Float32 (or Float::Printer::Dragonbox::ImplInfo_Float32)
              # This must happen before resolve_class_name_in_context because the type param
              # substitution gives us the concrete type name to resolve.
              substituted_name = substitute_type_params_in_type_name(name)
              # If the substitution result already has a namespace (::), use it directly
              # to avoid double namespace like Float::Printer::Dragonbox::Float::Printer::Dragonbox::ImplInfo_Float32
              resolved_name = if substituted_name != name && substituted_name.includes?("::")
                                substituted_name
                              else
                                resolve_class_name_in_context(substituted_name)
                              end
              resolved_name = resolve_type_alias_chain(resolved_name)
              if env_get("DEBUG_THREAD_RESOLVE") && method_name == "threads"
                STDERR.puts "[THREAD_RESOLVE] name=#{name} resolved=#{resolved_name} current=#{@current_class || "nil"} override=#{@current_namespace_override || "nil"}"
              end
              if class_name_str.nil? && @generic_templates.has_key?(resolved_name) && method_name == "new"
                if resolved_name == "Range" && call_args && call_args.size >= 2
                  left_name = infer_type_name_from_expr_id(call_args[0])
                  right_name = infer_type_name_from_expr_id(call_args[1])
                  if left_name && right_name
                    specialized_name = "#{resolved_name}(#{left_name}, #{right_name})"
                    if !@monomorphized.includes?(specialized_name)
                      monomorphize_generic_class(resolved_name, [left_name, right_name], specialized_name)
                    end
                    class_name_str = specialized_name
                  end
                else
                  inferred_type = infer_generic_type_arg(resolved_name, call_args, block_expr, ctx, node.named_args)
                  if inferred_type
                    specialized_name = "#{resolved_name}(#{inferred_type})"
                    if !@monomorphized.includes?(specialized_name)
                      monomorphize_generic_class(resolved_name, [inferred_type], specialized_name)
                    end
                    class_name_str = specialized_name
                  elsif resolved_name == "Array"
                    specialized_name = "Array(String)"
                    if !@monomorphized.includes?(specialized_name)
                      monomorphize_generic_class(resolved_name, ["String"], specialized_name)
                    end
                    class_name_str = specialized_name
                  end
                end
              end
              # Prefer class/module resolution when the identifier maps to a known type.
              if class_name_str.nil?
                if class_like_namespace?(resolved_name) || module_like_type_name?(resolved_name) ||
                   @enum_info.try(&.has_key?(resolved_name)) || primitive_self_type(resolved_name)
                  class_name_str = resolved_name
                elsif is_module_method?(resolved_name, method_name)
                  class_name_str = resolved_name
                elsif resolve_constant_name_in_context(name)
                  constant_receiver = true
                end
              end
              if class_name_str.nil?
                if fallback = class_method_fallback_from_module(resolved_name, method_name)
                  class_name_str = fallback
                end
              end
              if class_name_str.nil? && !constant_receiver
                # Check if it's a class name (starts with uppercase and is known class)
                # OR a module name (check if Module.method exists in function_types)
                if class_name_str.nil? && resolved_name[0].uppercase?
                  # Prefer nested types in the current namespace over top-level types.
                  resolved_name = resolve_class_name_in_context(resolved_name) unless resolved_name.includes?("::")
                  if @class_info.has_key?(resolved_name) ||
                     @enum_info.try(&.has_key?(resolved_name))
                    class_name_str = resolved_name
                  elsif is_module_method?(resolved_name, method_name)
                    # It's a module method call
                    class_name_str = resolved_name
                  elsif @generic_templates.has_key?(resolved_name) && method_name == "new"
                    # Calling .new on a generic template (e.g., Array.new, Hash.new)
                    # Try to infer type argument from constructor arguments or block
                    inferred_type = infer_generic_type_arg(resolved_name, call_args, block_expr, ctx, node.named_args)
                    if inferred_type
                      specialized_name = "#{resolved_name}(#{inferred_type})"
                      # Monomorphize if not already done
                      if !@monomorphized.includes?(specialized_name)
                        monomorphize_generic_class(resolved_name, [inferred_type], specialized_name)
                      end
                      class_name_str = specialized_name
                    else
                      # Can't infer type - use fallback or report error
                      # For now, use String as default for Array (common case)
                      if resolved_name == "Array"
                        specialized_name = "Array(String)"
                        if !@monomorphized.includes?(specialized_name)
                          monomorphize_generic_class(resolved_name, ["String"], specialized_name)
                        end
                        class_name_str = specialized_name
                      end
                    end
                  else
                    # For primitive types and aliases not in class_info, use the resolved name directly.
                    # Avoid treating value constants (like STDERR) as type names.
                    if primitive_self_type(resolved_name)
                      class_name_str = resolved_name
                    elsif @type_aliases.has_key?(resolved_name) || LIBC_TYPE_ALIASES.has_key?(resolved_name)
                      class_name_str = resolved_name
                    end
                  end
                end
              end
            end
          end
        elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::GenericNode)
          # Generic type like Box(Int32).new()
          base_name = resolve_path_like_name(obj_node.base_type)
          if base_name
            base_name = resolve_type_name_in_context(base_name)
            base_name = resolve_type_alias_chain(base_name)
            normalize_typeof_name = ->(type_name : String) : String {
              # Keep unions in generic args (e.g. `Slice(Int32 | Pointer(UInt8))`)
              # so we don't degrade specialization to `Pointer(Void)`.
              if type_name == "Void" || type_name == "Unknown"
                "Pointer(Void)"
              else
                type_name
              end
            }

            type_args = obj_node.type_args.map do |arg_id|
              arg_node = @arena[arg_id]
              arg_name = case arg_node
                         when CrystalV2::Compiler::Frontend::TypeofNode
                           inner = arg_node.args.first?
                           inner ? resolve_typeof_expr(inner) : "Pointer(Void)"
                         else
                           stringify_type_expr(arg_id) || "Unknown"
                         end
              arg_name = resolve_typeof_in_type_string(arg_name)
              arg_name = normalize_typeof_name.call(arg_name)
              arg_name = resolve_type_name_in_context(arg_name)
              arg_name = substitute_type_params_in_type_name(arg_name)
              normalize_tuple_literal_type_name(arg_name)
            end

            # Create specialized class name like Box(Int32)
            class_name_str = "#{base_name}(#{type_args.join(", ")})"
            class_name_str = substitute_type_params_in_type_name(class_name_str)

            if base_name == "Proc"
              proc_return_type_name = class_name_str
              class_name_str = "Proc"
            else
              # Monomorphize generic class if not already done
              if !@monomorphized.includes?(class_name_str)
                monomorphize_generic_class(base_name, type_args, class_name_str)
              end
              # If not a class, try as a generic module
              if !@monomorphized.includes?(class_name_str) && @module_defs.has_key?(base_name)
                monomorphize_generic_module(base_name, type_args, class_name_str)
              end
            end
          end
        elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
          if type_name = stringify_type_expr(obj_expr)
            type_name = substitute_type_params_in_type_name(type_name)
            if type_name[0]?.try(&.uppercase?) || type_name.includes?("::")
              if info = split_generic_base_and_args(type_name)
                base_name = info[:base]
                base_name = resolve_type_name_in_context(base_name) unless base_name.includes?("::")
                base_name = resolve_type_alias_chain(base_name)
                type_args = split_generic_type_args(info[:args]).map do |arg|
                  arg = substitute_type_params_in_type_name(arg)
                  normalize_tuple_literal_type_name(arg)
                end
                class_name_str = "#{base_name}(#{type_args.join(", ")})"
                if base_name == "Proc"
                  proc_return_type_name = class_name_str
                  class_name_str = "Proc"
                else
                  if !@monomorphized.includes?(class_name_str)
                    monomorphize_generic_class(base_name, type_args, class_name_str)
                  end
                  if !@monomorphized.includes?(class_name_str) && @module_defs.has_key?(base_name)
                    monomorphize_generic_module(base_name, type_args, class_name_str)
                  end
                end
              else
                class_name_str = resolve_type_alias_chain(type_name)
              end
            end
          end
        elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::PathNode)
          # Path like Foo::Bar for nested classes/modules
          raw_path = collect_path_string(obj_node)
          if mapped = @type_param_map[raw_path]?
            type_param_receiver_name = mapped
            class_name_str = mapped
            force_instance_receiver = false
          elsif @type_param_map.empty?
            if inferred_map = fallback_type_param_map_for_current
              if mapped = inferred_map[raw_path]?
                type_param_receiver_name = mapped
                class_name_str = mapped
                force_instance_receiver = false
              end
            end
          end
          unless force_instance_receiver
            if @type_param_map.empty? && raw_path.includes?("::")
              prefix = first_namespace_component(raw_path)
              if type_param_like?(prefix)
                if inferred_map = fallback_type_param_map_for_current
                  if mapped = inferred_map[prefix]?
                    suffix = raw_path[(prefix.size + 2)..]?
                    raw_path = suffix ? "#{mapped}::#{suffix}" : mapped
                  end
                end
              end
            end
            if env_get("DEBUG_CONST_RECV") && method_name == "unsafe_fetch"
              STDERR.puts "[CONST_RECV_PATH] raw_path=#{raw_path} method=#{method_name}"
            end
            absolute_path = path_is_absolute?(obj_node)
            # Substitute type params FIRST, before resolving context (e.g., D::CACHE -> ImplInfo_Float32::CACHE)
            substituted_path = substitute_type_params_in_type_name(raw_path)
            full_path = if absolute_path
                          substituted_path.starts_with?("::") ? substituted_path[2..] : substituted_path
                        else
                          resolve_path_string_in_context(substituted_path)
                        end
            const_exists = constant_name_exists?(full_path)
            if env_get("DEBUG_CONST_RECV") && method_name == "unsafe_fetch"
              STDERR.puts "[CONST_RECV] full_path=#{full_path} const_exists=#{const_exists} method=#{method_name}"
            end
            if const_exists
              if @module.is_lib?(full_path)
                class_name_str = full_path
              else
                constant_receiver = true
              end
            else
              # Check if this path is a known class
              if @class_info.has_key?(full_path)
                class_name_str = full_path
              elsif @type_aliases.has_key?(full_path) || LIBC_TYPE_ALIASES.has_key?(full_path)
                # Resolve type alias with chain resolution
                resolved = @type_aliases[full_path]? || LIBC_TYPE_ALIASES[full_path]? || full_path
                # Chain resolve if needed (e.g., LibCrypto::ULong -> LibC::ULong -> UInt64) - max 10 iterations
                depth = 0
                while (next_resolved = @type_aliases[resolved]? || LIBC_TYPE_ALIASES[resolved]?) && next_resolved != resolved && depth < 10
                  resolved = next_resolved
                  depth += 1
                end
                class_name_str = substitute_type_params_in_type_name(resolved)
              else
                # Even if not in class_info, treat path as class name for class method calls
                # This handles nested classes/modules that may not be fully registered
                class_name_str = full_path
              end
            end
            if class_name_str && method_name == "new"
              resolved = resolve_type_alias_chain(class_name_str)
              if @generic_templates.has_key?(resolved) && !resolved.includes?('(')
                inferred_type = infer_generic_type_arg(resolved, call_args, block_expr, ctx, node.named_args)
                if inferred_type
                  specialized_name = "#{resolved}(#{inferred_type})"
                  if !@monomorphized.includes?(specialized_name)
                    monomorphize_generic_class(resolved, [inferred_type], specialized_name)
                  end
                  class_name_str = specialized_name
                end
              end
            end
          end
        end

        # Fast callsite cache for instance member calls when receiver and arg types are known.
        if class_name_str.nil? && receiver_id
          receiver_type = ctx.type_of(receiver_id)
          if receiver_type != TypeRef::VOID
            arg_types_for_cache = call_args.empty? ? [] of TypeRef : infer_arg_types_for_call(call_args, @current_class)
            cache_key = callsite_cache_key(receiver_type, method_name, arg_types_for_cache, !block_expr.nil? || !block_pass_expr.nil?)
            if cached = @callsite_method_cache[cache_key]?
              full_method_name = cached
            else
              cached_callsite_key = cache_key
            end
          end
        end

        if class_name_str.nil? && !constant_receiver && !force_instance_receiver
          if type_like_expr_id?(obj_expr)
            type_name = stringify_type_expr(obj_expr)
          else
            type_name = nil
          end
          if type_name
            type_name = substitute_type_params_in_type_name(type_name)
            if type_name[0]?.try(&.uppercase?) || type_name.includes?("::")
              if info = split_generic_base_and_args(type_name)
                base_name = resolve_type_alias_chain(info[:base])
                type_args = split_generic_type_args(info[:args]).map do |arg|
                  arg = substitute_type_params_in_type_name(arg)
                  normalize_tuple_literal_type_name(arg)
                end
                class_name_str = "#{base_name}(#{type_args.join(", ")})"
                if base_name == "Proc"
                  proc_return_type_name = class_name_str
                  class_name_str = "Proc"
                else
                  if !@monomorphized.includes?(class_name_str)
                    monomorphize_generic_class(base_name, type_args, class_name_str)
                  end
                end
              else
                class_name_str = resolve_type_alias_chain(type_name)
              end
            end
          end
        end

        if class_name_str.nil? && !force_instance_receiver
          raw_name = case obj_node
                     when CrystalV2::Compiler::Frontend::IdentifierNode
                       String.new(obj_node.name)
                     when CrystalV2::Compiler::Frontend::ConstantNode
                       String.new(obj_node.name)
                     when CrystalV2::Compiler::Frontend::PathNode
                       # Substitute type params in path (e.g., D::CACHE -> ImplInfo_Float32::CACHE)
                       substitute_type_params_in_type_name(collect_path_string(obj_node))
                     else
                       nil
                     end
          if raw_name && raw_name[0]?.try(&.uppercase?)
            resolved = resolve_class_name_in_context(raw_name)
            resolved = resolve_type_alias_chain(resolved)
            candidates = [] of String
            candidates << resolved
            candidates << raw_name if raw_name != resolved
            short_name = last_namespace_component(resolved)
            candidates << short_name unless short_name.empty? || candidates.includes?(short_name)
            candidates.each do |candidate|
              base = resolve_class_method_with_inheritance(candidate, method_name)
              if base
                class_name_str = method_owner(base)
                break
              end
              if class_method_overload_exists?("#{candidate}.#{method_name}") || @function_defs.has_key?("#{candidate}.#{method_name}")
                class_name_str = candidate
                break
              end
            end
          end
        end

        if receiver_id.nil? && type_param_receiver_name
          receiver_id = lower_type_literal_from_name(ctx, type_param_receiver_name)
          receiver_type = ctx.type_of(receiver_id)
        end

        if class_name_str.nil?
          if receiver_id.nil? && obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && ctx.lookup_local(String.new(obj_node.name)).nil?
            obj_name = String.new(obj_node.name)
            assigned_locals = @assigned_vars_stack.last?
            is_type_param = type_param_like?(obj_name) || @type_param_map.has_key?(obj_name)
            func_exists = @function_defs.has_key?(obj_name) ||
                          @function_types.has_key?(obj_name) ||
                          has_function_base?(obj_name)
            if obj_name == "caller" && env_get("DEBUG_CALLER_FALLBACK")
              assigned = assigned_locals ? assigned_locals.includes?(obj_name) : false
              STDERR.puts "[CALLER_FALLBACK] name=#{obj_name} func_exists=#{func_exists} assigned=#{assigned} func=#{ctx.function.name} method=#{method_name}"
            end
            if !is_type_param &&
               (assigned_locals.nil? || !assigned_locals.includes?(obj_name)) &&
               func_exists
              full_name = mangle_function_name(obj_name, [] of TypeRef)
              return_type = @function_types[full_name]? || @function_types[obj_name]? || TypeRef::VOID
              lower_function_if_needed(full_name)
              if return_type == TypeRef::VOID
                return_type = get_function_return_type(full_name)
                if return_type == TypeRef::VOID && full_name != obj_name
                  return_type = get_function_return_type(obj_name)
                end
              end
              call = Call.new(ctx.next_id, return_type, nil, full_name, [] of ValueId)
              ctx.emit(call)
              ctx.register_type(call.id, return_type)
              receiver_id = call.id
              receiver_type = return_type
            elsif obj_name == "caller" && !func_exists
              if current = @current_class
                if base = resolve_method_with_inheritance(current, obj_name) ||
                          resolve_method_with_inheritance("Object", obj_name)
                  self_id = emit_self(ctx)
                  full_name = mangle_function_name(base, [] of TypeRef)
                  return_type = @function_types[full_name]? || TypeRef::VOID
                  lower_function_if_needed(full_name)
                  call = Call.new(ctx.next_id, return_type, self_id, full_name, [] of ValueId)
                  ctx.emit(call)
                  ctx.register_type(call.id, return_type)
                  receiver_id = call.id
                  receiver_type = return_type
                end
              end
            end
          end
        end

        if class_name_str.nil? && receiver_id.nil?
          receiver_id = lower_expr(ctx, callee_node.object)
          receiver_type = ctx.type_of(receiver_id)
          if receiver_type.id >= TypeRef::FIRST_USER_TYPE
            if value = ctx.value_for(receiver_id)
              if value.is_a?(Literal) && value.value.is_a?(Nil)
                type_name = get_type_name_from_ref(receiver_type)
                class_name_str = resolve_type_alias_chain(type_name) unless type_name.empty?
              end
            end
          end
        end
        if env_get("DEBUG_SELF_TO_S") && method_name == "to_s"
          recv_id = receiver_id ? receiver_id.to_s : "nil"
          recv_lit = receiver_id ? ctx.type_literal?(receiver_id) : false
          STDERR.puts "[SELF_TO_S] explicit=#{explicit_self_receiver} force=#{force_instance_receiver} recv_id=#{recv_id} lit=#{recv_lit} class_name=#{class_name_str || "nil"} current=#{@current_class || "nil"}##{@current_method || "nil"} class_method=#{@current_method_is_class}"
        end

        if env_get("DEBUG_FIBER_CURRENT") && method_name == "current"
          obj_kind = obj_node.class.name.split("::").last
          STDERR.puts "[DEBUG_FIBER_CURRENT] obj=#{obj_kind} owner=#{class_name_str || "nil"} current_class=#{@current_class || "nil"}"
        end
        if class_name_str
          if env_get("DEBUG_FROM_IO_CALL") && method_name == "from_io"
            STDERR.puts "[FROM_IO_CLASS] owner=#{class_name_str} receiver_id=#{receiver_id || "nil"} force_instance=#{force_instance_receiver}"
          end
          if env_get("DEBUG_EXE_PATH_CALL") && method_name == "executable_path"
            raw_obj = stringify_type_expr(callee_node.object) || "(unknown)"
            STDERR.puts "[DEBUG_EXE_PATH_CALL] obj=#{obj_node.class.name.split("::").last} raw=#{raw_obj} resolved=#{class_name_str} current=#{@current_class || "nil"} override=#{@current_namespace_override || "nil"}"
          end
          if env_get("DEBUG_FIBER_CURRENT") && method_name == "current"
            STDERR.puts "[DEBUG_FIBER_CURRENT] owner=#{class_name_str} current_class=#{@current_class || "nil"}"
          end
          if !@class_info.has_key?(class_name_str) && @module_defs.has_key?(class_name_str)
            module_method_name = "#{class_name_str}.#{method_name}"
            unless @function_types.has_key?(module_method_name) || has_function_base?(module_method_name)
              short_name = last_namespace_component(class_name_str)
              if candidates = @short_type_index[short_name]?
                if candidates.size == 1
                  candidate = candidates.first
                  candidate_method = "#{candidate}.#{method_name}"
                  if @function_types.has_key?(candidate_method) || has_function_base?(candidate_method)
                    class_name_str = candidate
                  end
                end
              end
            end
          end
          if env_get("DEBUG_THREAD_CURRENT") &&
             class_name_str.includes?("Thread") &&
             method_name.starts_with?("current")
            STDERR.puts "[DEBUG_THREAD_CURRENT] owner=#{class_name_str} method=#{method_name} current_class=#{@current_class || "nil"} current_method=#{@current_method || "nil"}"
          end
          if DebugHooks::ENABLED && unresolved_generic_receiver?(class_name_str)
            debug_hook(
              "call.class_receiver.unresolved",
              "owner=#{class_name_str} method=#{method_name} current=#{@current_class || ""} current_method=#{@current_method || ""} class_method=#{@current_method_is_class} map=#{type_param_map_debug_string}"
            )
          end
          # Intrinsics.* macros lower to LibIntrinsics.* extern calls. In codegen
          # we bypass macro expansion and rewrite the target here to avoid missing symbols.
          if class_name_str == "Intrinsics"
            class_name_str = "LibIntrinsics"
          end
          if method_name == "[]"
            enum_name = resolve_enum_name(class_name_str)
            if enum_name.nil? && @enum_info.try(&.has_key?(class_name_str))
              enum_name = class_name_str
            end
            if enum_name
              if value_id = lower_enum_bracket_call(ctx, enum_name, call_args, call_arena)
                return value_id
              end
            end
          end
          if macro_lookup = lookup_macro_entry_with_inheritance(method_name, class_name_str)
            macro_entry, macro_key = macro_lookup
            macro_def, macro_arena = macro_entry
            return expand_macro(ctx, macro_def, macro_arena, call_args, node.named_args, block_expr, macro_key)
          end
          # Check if this is a lib function call (e.g., LibC.puts)
          extern_func = @module.get_extern_function(class_name_str, method_name)
          if env_get("DEBUG_EXTERN_CALL") && class_name_str == "LibUnwind"
            STDERR.puts "[EXTERN_CALL] lib=#{class_name_str} method=#{method_name} hit=#{!!extern_func}"
          end
          if extern_func
            # This is a call to an extern C function
            # Lower args and emit extern call with real C name
            has_splat = call_args.any? do |arg_expr|
              call_arena[arg_expr].is_a?(CrystalV2::Compiler::Frontend::SplatNode)
            end
            arg_ids = if has_splat
                        expand_splat_args(ctx, call_args, call_arena)
                      else
                        expand_extern_args(ctx, call_args, call_arena, extern_func)
                      end
            if env_get("DEBUG_MEM_INTRINSIC") && class_name_str == "LibIntrinsics"
              STDERR.puts "[MEM_INTRINSIC] extern method=#{method_name} call_args=#{call_args.size} lowered=#{arg_ids.size}"
            end
            call_result = emit_extern_call(ctx, extern_func, arg_ids)
            return call_result
          end
          # Fallback for LibIntrinsics mem* when lib macro branches aren't expanded.
          if class_name_str == "LibIntrinsics"
            if method_name == "memcpy" || method_name == "memmove" || method_name == "memset"
              if env_get("DEBUG_MEM_INTRINSIC")
                STDERR.puts "[MEM_INTRINSIC] call method=#{method_name} args=#{call_args.size} named=#{node.named_args.try(&.size) || 0} arena=#{call_arena.class}:#{call_arena.size}"
              end
              arg_ids = expand_splat_args(ctx, call_args, call_arena)
              return emit_mem_intrinsic(ctx, method_name, arg_ids)
            end
          end
          # File.read(String) / File.write(String, String) intercept:
          # bypass broken Crystal::System::File.open chain, use direct C I/O
          if class_name_str == "File" && method_name == "read" && call_args.size >= 1
            arg_id = with_arena(call_arena) { lower_expr(ctx, call_args[0]) }
            ext_call = ExternCall.new(ctx.next_id, TypeRef::STRING, "__crystal_v2_file_read", [arg_id])
            ctx.emit(ext_call)
            ctx.register_type(ext_call.id, TypeRef::STRING)
            return ext_call.id
          end
          if class_name_str == "File" && method_name == "write" && call_args.size >= 2
            path_id = with_arena(call_arena) { lower_expr(ctx, call_args[0]) }
            content_id = with_arena(call_arena) { lower_expr(ctx, call_args[1]) }
            ext_call = ExternCall.new(ctx.next_id, TypeRef::VOID, "__crystal_v2_file_write", [path_id, content_id])
            ctx.emit(ext_call)
            ctx.register_type(ext_call.id, TypeRef::VOID)
            return ext_call.id
          end
          # Math.pw2ceil(v) → v.next_power_of_two (inline to avoid union return type loss)
          if class_name_str == "Math" && method_name == "pw2ceil" && call_args.size == 1
            arg_id = with_arena(call_arena) { lower_expr(ctx, call_args[0]) }
            arg_type = ctx.type_of(arg_id)
            arg_class = primitive_class_name(arg_type)
            if arg_class
              npt_name = resolve_method_with_inheritance(arg_class, "next_power_of_two")
              if npt_name
                npt_mangled = mangle_function_name(npt_name, [] of TypeRef)
                lower_function_if_needed(npt_mangled)
                npt_call = Call.new(ctx.next_id, arg_type, arg_id, npt_mangled, [] of ValueId)
                ctx.emit(npt_call)
                ctx.register_type(npt_call.id, arg_type)
                return npt_call.id
              end
            end
          end
          # Class method call like Counter.new()
          if method_name == "new"
            full_method_name = "#{class_name_str}.#{method_name}"
            static_class_name = class_name_str
          else
            full_method_name = resolve_class_method_with_inheritance(class_name_str, method_name) || "#{class_name_str}.#{method_name}"
            static_class_name = method_owner(full_method_name)
          end
          if !@function_defs.has_key?(full_method_name) &&
             !class_method_overload_exists?(full_method_name) &&
             !(method_name == "new" && @class_info.has_key?(class_name_str.not_nil!))
            # Treat type literal receivers as Class/Module instance methods when available (e.g., T.to_s).
            original_full_name = full_method_name
            original_static_class = static_class_name
            literal_id = lower_type_literal_from_name(ctx, class_name_str)
            ctx.mark_type_literal(literal_id)
            receiver_id = literal_id
            receiver_type = ctx.type_of(literal_id)
            receiver_is_module = module_type_ref?(receiver_type)
            meta_owner = receiver_is_module ? "Module" : "Class"
            if meta_resolved = resolve_method_with_inheritance(meta_owner, method_name)
              full_method_name = meta_resolved
              static_class_name = nil
            else
              # Module/Class fallback also failed; keep original class method name for deferred resolution
              full_method_name = original_full_name
              static_class_name = original_static_class
              receiver_id = nil
            end
          end
          if full_method_name
            call_has_splat = call_args.any? { |arg_expr| call_arena[arg_expr].is_a?(CrystalV2::Compiler::Frontend::SplatNode) }
            call_has_named_args = node.named_args.try(&.empty?) == false
            has_block_call = !!block_expr || !!block_pass_expr
            call_arg_types = infer_arg_types_for_call(call_args, @current_class)
            if entry = lookup_function_def_for_call(full_method_name, call_arg_types.size, has_block_call, call_arg_types, call_has_splat, call_has_named_args)
              full_method_name = entry[0]
            end
          end
          receiver_id = nil if static_class_name # Static call, no receiver
          if method_name == "new"
            if class_info = @class_info[class_name_str]?
              call_arg_types = call_args.map do |arg|
                infer_type_from_expr(arg, @current_class) || TypeRef::VOID
              end
              generate_allocator(class_name_str, class_info, call_arg_types)
            end
          end
        else
          # Instance method call like c.increment()
          receiver_id ||= lower_expr(ctx, callee_node.object)
          receiver_type = ctx.type_of(receiver_id)
          if receiver_type == TypeRef::VOID
            if obj_node.is_a?(CrystalV2::Compiler::Frontend::SelfNode) ||
               obj_node.is_a?(CrystalV2::Compiler::Frontend::ImplicitObjNode) ||
               (obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && String.new(obj_node.name) == "self")
              if current = @current_class
                resolved_current = resolve_type_alias_chain(substitute_type_params_in_type_name(current))
                inferred_self = type_ref_for_name(resolved_current)
                if inferred_self != TypeRef::VOID
                  receiver_type = inferred_self
                  ctx.register_type(receiver_id, receiver_type)
                end
              end
            else
              if inferred = infer_type_from_expr(obj_expr, @current_class)
                receiver_type = inferred
                ctx.register_type(receiver_id, receiver_type)
              end
            end
          end
          if method_name == "system_init" && receiver_type != TypeRef::VOID
            if info = @class_info_by_type_id[receiver_type.id]?
              if info.name == "File"
                lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                ctx.emit(lit)
                return lit.id
              end
            end
          end
          if call_args.empty? && block_expr.nil? && block_pass_expr.nil?
            if predicate_id = lower_enum_predicate(ctx, receiver_id, method_name)
              return predicate_id
            end
            if enum_value_id = lower_enum_value_call(ctx, receiver_id, method_name)
              return enum_value_id
            end
          end
          receiver_is_module = module_type_ref?(receiver_type)
          if receiver_is_module && (obj_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode) ||
             obj_node.is_a?(CrystalV2::Compiler::Frontend::PathNode))
            ctx.mark_type_literal(receiver_id)
          end
          receiver_is_type_literal = ctx.type_literal?(receiver_id)
          # Explicit self/implicit receiver in instance methods must never be treated as type literals.
          if !@current_method_is_class &&
             (obj_node.is_a?(CrystalV2::Compiler::Frontend::SelfNode) ||
             obj_node.is_a?(CrystalV2::Compiler::Frontend::ImplicitObjNode) ||
             (obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && String.new(obj_node.name) == "self"))
            receiver_is_type_literal = false
          end
          if env_get("DEBUG_SELF_TO_S") && method_name == "to_s"
            recv_name = receiver_id ? get_type_name_from_ref(ctx.type_of(receiver_id)) : "nil"
            STDERR.puts "[SELF_TO_S_LIT] explicit=#{explicit_self_receiver} force=#{force_instance_receiver} lit=#{receiver_is_type_literal} recv_type=#{recv_name}"
          end
          # Fallback: when .new is called on a method that returns a type (e.g. backend_class.new),
          # resolve the method body to find the actual class and generate the allocator.
          if !receiver_is_type_literal && method_name == "new" &&
             obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            obj_name = String.new(obj_node.name)
            if obj_name != "self" && obj_name[0]?.try(&.lowercase?) && (current = @current_class)
              resolved_type = try_resolve_type_returning_method(current, obj_name)
              if resolved_type
                if ci = @class_info[resolved_type]?
                  call_arg_types = call_args.map { |a| infer_type_from_expr(a, @current_class) || TypeRef::VOID }
                  generate_allocator(resolved_type, ci, call_arg_types)
                  full_method_name = "#{resolved_type}.new"
                  static_class_name = resolved_type
                  receiver_is_type_literal = true
                  ctx.mark_type_literal(receiver_id.not_nil!)
                end
              end
            end
          end
          if !receiver_is_type_literal
            raw_name = case obj_node
                       when CrystalV2::Compiler::Frontend::IdentifierNode
                         String.new(obj_node.name)
                       when CrystalV2::Compiler::Frontend::ConstantNode
                         String.new(obj_node.name)
                       when CrystalV2::Compiler::Frontend::PathNode
                         collect_path_string(obj_node)
                       else
                         nil
                       end
            if raw_name && raw_name[0]?.try(&.uppercase?)
              candidate = resolve_class_name_in_context(raw_name)
              candidate = resolve_type_alias_chain(candidate)
              if env_get("DEBUG_THREAD_RESOLVE") && method_name == "threads"
                STDERR.puts "[THREAD_RESOLVE_LIT] raw=#{raw_name} candidate=#{candidate} type_exists=#{type_name_exists?(candidate)}"
              end
              if type_name_exists?(candidate)
                ctx.mark_type_literal(receiver_id)
                receiver_is_type_literal = true
              end
            end
          end
          if env_get("DEBUG_FROM_IO_CALL") && method_name == "from_io"
            recv_desc = @module.get_type_descriptor(receiver_type)
            recv_name = recv_desc ? recv_desc.name : "nil"
            STDERR.puts "[FROM_IO_RECV] type=#{recv_name} id=#{receiver_type.id} literal=#{receiver_is_type_literal}"
          end
          ensure_monomorphized_type(receiver_type) unless receiver_type == TypeRef::VOID
          if debug_env_filter_match?("DEBUG_EACH_RESOLVE", method_name)
            desc_name = @module.get_type_descriptor(receiver_type).try(&.name) || "nil"
            info_name = @class_info_by_type_id[receiver_type.id]?.try(&.name) || "nil"
            scope = "#{@current_class || ""}##{@current_method || ""}"
            STDERR.puts "[EACH_RESOLVE] recv_id=#{receiver_type.id} desc=#{desc_name} info=#{info_name} scope=#{scope}"
          end
          if receiver_type.id > 0
            # Look up class name from type, then resolve method with inheritance
            if info = @class_info_by_type_id[receiver_type.id]?
              name = info.name
              if env_get("DEBUG_CLASS_INFO_RESOLVE") && (method_name == "leap_year?" || method_name == "month_week_date" || method_name == "join" || method_name == "basename")
                desc2 = @module.get_type_descriptor(receiver_type)
                STDERR.puts "[CLASS_INFO_RESOLVE] name=#{name} desc=#{desc2.try(&.name)} kind=#{desc2.try(&.kind)} literal=#{receiver_is_type_literal} method=#{method_name} cls_info_has=#{@class_info.has_key?(name)}"
              end
              if receiver_is_type_literal
                if desc = @module.get_type_descriptor(receiver_type)
                  if desc.kind == TypeKind::Module && !desc.name.empty?
                    # Only override to module descriptor name when class_info name
                    # is not a real class/struct (avoid Crystal::System::Time overriding Time)
                    if !@class_info.has_key?(name) || name == desc.name
                      name = desc.name
                    end
                  end
                end
              end
              # Debug: track when short names are matched
              if env_has?("DEBUG_CLASS_MATCH") && !name.includes?("::")
                STDERR.puts "[CLASS_MATCH] method=#{method_name}, receiver_id=#{receiver_type.id}, name=#{name}"
              end
              if receiver_is_type_literal
                if method_name == "new"
                  full_method_name = "#{name}.#{method_name}"
                  static_class_name = name
                  receiver_id = nil
                else
                  if full_method_name.nil?
                    full_method_name = resolve_class_method_with_inheritance(name, method_name) || "#{name}.#{method_name}"
                    static_class_name = method_owner(full_method_name)
                    if !@function_defs.has_key?(full_method_name) &&
                       !class_method_overload_exists?(full_method_name)
                      # Fall back to Class/Module instance methods for type literals (e.g., T.to_s).
                      meta_owner = receiver_is_module ? "Module" : "Class"
                      if meta_method = resolve_method_with_inheritance(meta_owner, method_name)
                        full_method_name = meta_method
                        static_class_name = nil
                      else
                        # Module/Class fallback also failed; keep original class method name
                        full_method_name = "#{name}.#{method_name}"
                        static_class_name = name
                        receiver_id = nil
                      end
                    else
                      receiver_id = nil
                    end
                  end
                end
                if method_name == "new"
                  call_arg_types = call_args.map do |arg|
                    infer_type_from_expr(arg, @current_class) || TypeRef::VOID
                  end
                  generate_allocator(name, info, call_arg_types)
                end
              else
                # Use inheritance-aware method resolution
                # Check if the name is a union type and resolve to variant method
                if union_type_name?(name)
                  union_name = normalize_union_type_name(name)
                  # At this point arg_types aren't computed yet, so use empty array to just find any matching variant
                  if resolved = resolve_union_method_call(union_name, method_name, [] of TypeRef, false)
                    full_method_name = resolved
                    if env_get("DEBUG_UNION_CONV")
                      STDERR.puts "[UNION_CLASS_INFO] resolved union #{union_name}##{method_name} -> #{resolved}"
                    end
                  else
                    full_method_name = resolve_method_with_inheritance(name, method_name)
                    full_method_name ||= "#{name}##{method_name}"
                  end
                else
                  full_method_name = resolve_method_with_inheritance(name, method_name)
                  full_method_name ||= "#{name}##{method_name}"
                end
                generate_allocator(name, info) if method_name == "new"
              end
            end

            # Fallback: if not found in class_info, try type descriptor name
            # This handles records, generic structs, and module types
            unless full_method_name
              type_desc = @module.get_type_descriptor(receiver_type)
              type_name = type_desc ? normalize_method_owner_name(type_desc.name) : ""
              if type_name.empty?
                if primitive_name = primitive_class_name(receiver_type)
                  type_name = primitive_name unless primitive_name.starts_with?("Pointer(")
                end
              end
              if !type_name.empty?
                # DEBUG: Detect type name mismatches for any type that doesn't include ::
                if env_has?("DEBUG_TYPE_RESOLVE") && !type_name.includes?("::")
                  STDERR.puts "[DEBUG_TYPE] method=#{method_name}, receiver_type_id=#{receiver_type.id}, type_name=#{type_name}"
                end
                # DEBUG: Catch specifically problematic short names
                if env_has?("DEBUG_SHORT_NAMES") &&
                   (type_name == "Seek" || type_name == "Section" || type_name == "LoadCommand" || type_name == "Sequence")
                  STDERR.puts "[SHORT_NAME_FALLBACK] type=#{type_name}, method=#{method_name}, receiver_id=#{receiver_type.id}"
                end
                # When type_name is a module (e.g. Crystal::System::Time), resolve to
                # the actual class (e.g. Time) if the short name exists in class_info.
                if @module_defs.has_key?(type_name) && !@class_info.has_key?(type_name)
                  short = last_namespace_component(type_name)
                  if @class_info.has_key?(short)
                    type_name = short
                  end
                end
                if env_get("DEBUG_TYPEDESC_FALLBACK")
                  STDERR.puts "[TYPEDESC_FALLBACK] type_name=#{type_name} method=#{method_name} literal=#{receiver_is_type_literal} module=#{receiver_is_module}"
                end
                if receiver_is_type_literal
                  full_method_name = resolve_class_method_with_inheritance(type_name, method_name) || "#{type_name}.#{method_name}"
                  static_class_name = method_owner(full_method_name)
                  if !@function_defs.has_key?(full_method_name) &&
                     !class_method_overload_exists?(full_method_name)
                    meta_owner = receiver_is_module ? "Module" : "Class"
                    if meta_resolved = resolve_method_with_inheritance(meta_owner, method_name)
                      full_method_name = meta_resolved
                      static_class_name = nil
                    else
                      # Module/Class fallback also failed; keep original class method name
                      full_method_name = "#{type_name}.#{method_name}"
                      static_class_name = type_name
                      receiver_id = nil
                    end
                  else
                    receiver_id = nil
                  end
                  if method_name == "new"
                    if class_info = @class_info[type_name]?
                      generate_allocator(type_name, class_info)
                    end
                  end
                elsif type_desc && type_desc.kind == TypeKind::Module
                  # Module-typed receivers should use instance-style dispatch (#),
                  # so virtual dispatch can target concrete module implementations.
                  full_method_name = "#{type_name}##{method_name}"
                elsif type_desc && type_desc.kind == TypeKind::Union
                  # Union types: resolve method to a concrete variant's method
                  # This prevents generating calls to non-existent union methods like Int64|Int32#to_i32!
                  union_name = normalize_union_type_name(type_name)
                  # At this point arg_types aren't computed yet, so use empty array to just find any matching variant
                  if resolved = resolve_union_method_call(union_name, method_name, [] of TypeRef, false)
                    full_method_name = resolved
                  else
                    # Fallback: use union name with method (will be handled by virtual dispatch)
                    full_method_name = "#{union_name}##{method_name}"
                  end
                else
                  # Try to find method with this type name
                  test_method = "#{type_name}##{method_name}"
                  if @function_types.has_key?(test_method) || has_function_base?(test_method)
                    full_method_name = test_method
                  else
                    # Even if method not registered, use type name as prefix
                    # This ensures proper symbol naming
                    full_method_name = test_method
                  end
                  if method_name == "new"
                    if class_info = @class_info[type_name]?
                      generate_allocator(type_name, class_info)
                    end
                  end
                end
              end
            end

            if receiver_is_type_literal && full_method_name && full_method_name.includes?('#')
              receiver_type = receiver_id ? ctx.type_of(receiver_id) : TypeRef::VOID
              unless module_type_ref?(receiver_type)
                class_name = method_owner(full_method_name)
                literal_owner = class_name_str
                if literal_owner.nil? || literal_owner.empty?
                  if desc = @module.get_type_descriptor(receiver_type)
                    literal_owner = desc.name unless desc.name.empty?
                  elsif info = @class_info_by_type_id[receiver_type.id]?
                    literal_owner = info.name
                  end
                end
                # Only convert instance-method resolution to class-method call when the
                # owner matches the literal type (avoid rewriting Class#to_s to Class.to_s).
                if literal_owner && !literal_owner.empty? &&
                   normalize_method_owner_name(literal_owner) == normalize_method_owner_name(class_name)
                  full_method_name = "#{class_name}.#{method_name}"
                  receiver_id = nil
                  static_class_name = class_name
                  if method_name == "new"
                    if class_info = @class_info[class_name]?
                      generate_allocator(class_name, class_info)
                    end
                  end
                end
              end
            end

            # NOTE: Avoid call-site monomorphization here: it can explode compilation time by creating many
            # specialized types reachable only through transient receiver types. Prefer monomorphization from
            # explicit annotations (see `ensure_monomorphized_type`) and constructor calls.
          end
          # Prevent monomorphization explosion for Object#in? by forcing calls to the base
          # method when no concrete override exists on the receiver.
          if method_name == "in?"
            if full_method_name.nil? || (!full_method_name.starts_with?("Object#") &&
               !@function_defs.has_key?(full_method_name) &&
               !has_function_base?(full_method_name))
              if object_in = resolve_method_with_inheritance("Object", "in?")
                full_method_name = object_in
              end
            end
          end
          if env_get("DEBUG_DECODE_CALL") && method_name == "decode"
            recv_id = receiver_id ? receiver_id.to_s : "nil"
            recv_type = receiver_id ? get_type_name_from_ref(ctx.type_of(receiver_id)) : "nil"
            recv_lit = receiver_id ? ctx.type_literal?(receiver_id) : false
            cur_class = @current_class || "nil"
            cur_method = @current_method || "nil"
            cur_is_class = @current_method_is_class ? 1 : 0
            STDERR.puts "[DECODE_CALL] obj=#{obj_node.class.name} recv_id=#{recv_id} recv_type=#{recv_type} lit=#{recv_lit} class_name=#{class_name_str || "nil"} full=#{full_method_name || "nil"} current=#{cur_class}##{cur_method} class_method=#{cur_is_class}"
          end
        end
      else
        # Complex callee (e.g., another call result being called)
        # Lower callee as receiver and use "call" as synthetic method name
        receiver_id = lower_node(ctx, callee_node)
        method_name = "call"
      end
      # Normalize any fully-qualified method name that may have slipped into method_name.
      # This keeps method_name as the short identifier for later resolution.
      if method_name.includes?('.')
        method_name = method_short_from_name(method_name) || method_name
      end

      # Direct puts/print interception: for bare single-arg puts/print, bypass the splat
      # wrapper and directly call IO#puts/print(Type) on STDOUT. This avoids the problem
      # where puts$splat is compiled once for the first call's type and reused incorrectly
      # for different types in the same program.
      if receiver_id.nil? && (method_name == "puts" || method_name == "print") &&
         call_args.size == 1 && block_expr.nil? && block_pass_expr.nil? &&
         full_method_name.nil?
        arg_type = with_arena(call_arena) { infer_type_from_expr(call_args[0], @current_class) }
        # Fallback: if AST-level inference fails, try lowering context for local vars
        if (arg_type.nil? || arg_type == TypeRef::VOID) && call_arena
          arg_node = with_arena(call_arena) { @arena[call_args[0]] }
          if arg_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            var_name = String.new(arg_node.name)
            if vid = ctx.lookup_local(var_name)
              arg_type = ctx.type_of(vid)
            end
          end
        end
        # Fallback 2: for method calls (arr.sum, arr.size, etc.) lower eagerly and check type
        eager_arg_id : ValueId? = nil
        if (arg_type.nil? || arg_type == TypeRef::VOID) && call_arena
          eager_arg_id = with_arena(call_arena) { lower_expr(ctx, call_args[0]) }
          arg_type = ctx.type_of(eager_arg_id)
        end
        if arg_type && arg_type != TypeRef::VOID
          type_suffix = type_name_for_mangling(arg_type)
          if type_suffix != "Void" && type_suffix != "Unknown"
            is_union = type_suffix.includes?('|') || type_suffix.starts_with?("Union(")
            if is_union
              # Union types: emit x.to_s(STDOUT) via vdispatch + newline
              arg_id = eager_arg_id || with_arena(call_arena) { lower_expr(ctx, call_args[0]) }
              stdout_get = ClassVarGet.new(ctx.next_id, TypeRef::POINTER, "Object", "STDOUT")
              ctx.emit(stdout_get)
              ctx.register_type(stdout_get.id, TypeRef::POINTER)
              # Call x.to_s(STDOUT) via virtual dispatch on the union
              to_s_call = Call.new(ctx.next_id, TypeRef::NIL, arg_id, "Object#to_s$IO", [stdout_get.id], nil, true)
              ctx.emit(to_s_call)
              ctx.register_type(to_s_call.id, TypeRef::NIL)
              if method_name == "puts"
                # Write newline through Crystal IO (not raw write) to preserve buffer ordering
                newline_char = Literal.new(ctx.next_id, TypeRef::CHAR, 10_i64) # '\n'
                ctx.emit(newline_char)
                ctx.register_type(newline_char.id, TypeRef::CHAR)
                stdout_get2 = ClassVarGet.new(ctx.next_id, TypeRef::POINTER, "Object", "STDOUT")
                ctx.emit(stdout_get2)
                ctx.register_type(stdout_get2.id, TypeRef::POINTER)
                print_call = Call.new(ctx.next_id, TypeRef::NIL, stdout_get2.id, "IO#print$Char", [newline_char.id], nil, false)
                ctx.emit(print_call)
                ctx.register_type(print_call.id, TypeRef::NIL)
              end
              return to_s_call.id
            end
            # Lower the argument (reuse eagerly lowered result if available)
            arg_id = eager_arg_id || with_arena(call_arena) { lower_expr(ctx, call_args[0]) }

            # For Float32/Float64, use direct printf-based extern calls to avoid
            # broken Float::Printer.shortest (yield/block issues)
            float_extern = case arg_type
                           when TypeRef::FLOAT64
                             method_name == "puts" ? "__crystal_v2_print_float64_ln" : "__crystal_v2_print_float64"
                           when TypeRef::FLOAT32
                             method_name == "puts" ? "__crystal_v2_print_float32_ln" : "__crystal_v2_print_float32"
                           else
                             nil
                           end
            if float_extern
              extern_call = ExternCall.new(ctx.next_id, TypeRef::VOID, float_extern, [arg_id])
              ctx.emit(extern_call)
              ctx.register_type(extern_call.id, TypeRef::NIL)
              return extern_call.id
            end

            # Enum types: emit value→name lookup + puts on string
            # Skip if the expression is .value (user explicitly wants numeric value)
            is_dot_value = false
            if call_arena
              arg_node = with_arena(call_arena) { @arena[call_args[0]] }
              if arg_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                if String.new(arg_node.member) == "value"
                  is_dot_value = true
                end
              elsif arg_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
                callee_expr = with_arena(call_arena) { @arena[arg_node.callee] }
                if callee_expr.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                  if String.new(callee_expr.member) == "value"
                    is_dot_value = true
                  end
                end
              end
            end
            if !is_dot_value && (enum_info = @enum_info)
              # Check if arg_id is tracked as an enum value
              enum_name = @enum_value_types.try(&.[arg_id]?)
              # Also check the type name directly
              enum_name ||= begin
                tn = get_type_name_from_ref(arg_type)
                tn if enum_info.has_key?(tn)
              end
              if members = enum_info[enum_name]?
                # Build if-elsif chain: if val==0 then "Red" elsif val==1 then "Green" ...
                exit_block = ctx.create_block
                result_blocks = [] of {BlockId, ValueId} # {block_id, string_literal_id}

                sorted_members = members.to_a.sort_by { |_, v| v }
                remaining = sorted_members.size
                sorted_members.each_with_index do |(member_name, member_value), idx|
                  # Short member name: "Color::Green" → "Green"
                  short_name = member_name.includes?("::") ? member_name.split("::").last : member_name
                  cmp_lit = Literal.new(ctx.next_id, TypeRef::INT32, member_value)
                  ctx.emit(cmp_lit)
                  ctx.register_type(cmp_lit.id, TypeRef::INT32)
                  cmp_eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, arg_id, cmp_lit.id)
                  ctx.emit(cmp_eq)

                  match_block = ctx.create_block
                  next_block = if idx == sorted_members.size - 1
                                 # Last member: fallback also goes to match (use its name)
                                 match_block
                               else
                                 ctx.create_block
                               end
                  ctx.terminate(Branch.new(cmp_eq.id, match_block, next_block))

                  ctx.current_block = match_block
                  str_lit = Literal.new(ctx.next_id, TypeRef::STRING, short_name)
                  ctx.emit(str_lit)
                  ctx.register_type(str_lit.id, TypeRef::STRING)
                  result_blocks << {match_block, str_lit.id}
                  ctx.terminate(Jump.new(exit_block))

                  if idx < sorted_members.size - 1
                    ctx.current_block = next_block
                  end
                end

                # Exit block: phi to get the string
                ctx.current_block = exit_block
                str_phi = Phi.new(ctx.next_id, TypeRef::STRING)
                result_blocks.each do |block_id, str_id|
                  str_phi.add_incoming(block_id, str_id)
                end
                ctx.emit(str_phi)
                ctx.register_type(str_phi.id, TypeRef::STRING)

                # Now puts/print the string
                stdout_get = ClassVarGet.new(ctx.next_id, TypeRef::POINTER, "Object", "STDOUT")
                ctx.emit(stdout_get)
                ctx.register_type(stdout_get.id, TypeRef::POINTER)
                mangled = mangle_function_name("IO##{method_name}", [TypeRef::STRING])
                call_instr = Call.new(ctx.next_id, TypeRef::NIL, stdout_get.id, mangled, [str_phi.id], nil, true)
                ctx.emit(call_instr)
                ctx.register_type(call_instr.id, TypeRef::NIL)
                return call_instr.id
              end
            end

            # Load STDOUT from classvar
            stdout_get = ClassVarGet.new(ctx.next_id, TypeRef::POINTER, "Object", "STDOUT")
            ctx.emit(stdout_get)
            ctx.register_type(stdout_get.id, TypeRef::POINTER)
            # Build mangled method name: IO#puts$Int32, IO#print$String, etc.
            mangled = mangle_function_name("IO##{method_name}", [arg_type])
            # Emit virtual call: STDOUT.puts(arg) / STDOUT.print(arg)
            call_instr = Call.new(ctx.next_id, TypeRef::NIL, stdout_get.id, mangled, [arg_id], nil, true)
            ctx.emit(call_instr)
            ctx.register_type(call_instr.id, TypeRef::NIL)
            return call_instr.id
          end
        end
      end

      # Handle named arguments by reordering them to match parameter positions
      # Also expand splat arguments (*array -> individual elements)
      has_block_call = !!block_expr || !!block_pass_expr
      has_named_args = !node.named_args.nil?
      if env_get("DEBUG_SPLAT_TRACE")
        source = @sources_by_arena[call_arena]?
        span = node.span
        snippet = nil
        if source
          start = span.start_offset
          length = span.end_offset - span.start_offset
          if length > 0 && start >= 0 && start < source.bytesize
            max_len = 120
            slice_len = length > max_len ? max_len : length
            snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
          end
        end
        inline_stack = @inline_yield_name_stack.join(" -> ")
        @last_splat_context = "func=#{ctx.function.name} method=#{method_name} class=#{@current_class || ""} inline=#{inline_stack} arena=#{call_arena.class}:#{call_arena.size} span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column} snippet=\"#{snippet || ""}\""
      end
      has_splat = with_arena(call_arena) do
        call_args.any? { |arg_id| @arena[arg_id].is_a?(CrystalV2::Compiler::Frontend::SplatNode) }
      end
      args = with_arena(call_arena) do
        if DebugHooks::ENABLED && block_pass_expr
          kind = CrystalV2::Compiler::Frontend.node_kind(@arena[block_pass_expr])
          debug_hook("call.block_pass", "method=#{method_name} kind=#{kind}")
        end
        if env_get("DEBUG_SPLAT_TRACE")
          kinds = call_args.map do |arg_id|
            CrystalV2::Compiler::Frontend.node_kind(@arena[arg_id]).to_s
          end
          STDERR.puts "[SPLAT_TRACE_ARGS] #{@last_splat_context || "func=#{ctx.function.name}"} args=#{kinds.join(",")}"
        end
        args_result = if named_args = node.named_args
                        reorder_named_args(ctx, call_args, named_args, method_name, full_method_name, has_block_call, call_arena)
                      elsif has_splat
                        expand_splat_args(ctx, call_args, call_arena)
                      else
                        lower_args_with_expected_types(ctx, call_args, method_name, full_method_name, has_block_call, call_arena)
                      end
        if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, method_name, full_method_name || "")
          STDERR.puts "[CALL_TRACE] stage=with_arena_done method=#{method_name} args=#{args_result.size} receiver=#{!!receiver_id} full=#{full_method_name || ""}"
        end
        args_result
      end
      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, method_name, full_method_name || "")
        STDERR.puts "[CALL_TRACE] stage=after_args method=#{method_name} args=#{args.size} receiver=#{!!receiver_id} full=#{full_method_name || ""}"
      end
      args = apply_default_args(ctx, args, method_name, full_method_name, has_block_call, has_named_args, receiver_id)
      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, method_name, full_method_name || "")
        STDERR.puts "[CALL_TRACE] stage=after_defaults method=#{method_name} args=#{args.size} receiver=#{!!receiver_id} full=#{full_method_name || ""}"
      end
      prepack_arg_types = args.map { |arg_id| ctx.type_of(arg_id) }
      prepack_arg_literals = args.map { |arg_id| ctx.type_literal?(arg_id) }
      prepack_arg_enum_names = nil
      if enum_map = @enum_value_types
        names = args.map { |arg_id| enum_map[arg_id]? }
        prepack_arg_enum_names = names if names.any?
      end

      # Post-lowering puts/print interception for primitive types.
      # This catches cases where the AST-level inference failed (e.g., top-level locals,
      # enum .value calls, comparison results). For primitive types (int/float/bool),
      # puts$splat wraps the value as a pointer → crashes. Redirect to IO#puts$<Type> directly.
      if receiver_id.nil? && (method_name == "puts" || method_name == "print") &&
         prepack_arg_types.size == 1 && block_expr.nil? && block_pass_expr.nil? &&
         full_method_name.nil?
        _post_arg_type = prepack_arg_types[0]
        _post_is_primitive = signed_integer_type?(_post_arg_type) ||
                             unsigned_integer_type?(_post_arg_type) ||
                             _post_arg_type == TypeRef::BOOL ||
                             _post_arg_type == TypeRef::FLOAT32 ||
                             _post_arg_type == TypeRef::FLOAT64
        if _post_is_primitive
          _post_arg_id = args[0]
          # Float special handling
          _float_extern = case _post_arg_type
                          when TypeRef::FLOAT64
                            method_name == "puts" ? "__crystal_v2_print_float64_ln" : "__crystal_v2_print_float64"
                          when TypeRef::FLOAT32
                            method_name == "puts" ? "__crystal_v2_print_float32_ln" : "__crystal_v2_print_float32"
                          else
                            nil
                          end
          if _float_extern
            _ext_call = ExternCall.new(ctx.next_id, TypeRef::VOID, _float_extern, [_post_arg_id])
            ctx.emit(_ext_call)
            ctx.register_type(_ext_call.id, TypeRef::NIL)
            return _ext_call.id
          end
          _stdout_get = ClassVarGet.new(ctx.next_id, TypeRef::POINTER, "Object", "STDOUT")
          ctx.emit(_stdout_get)
          ctx.register_type(_stdout_get.id, TypeRef::POINTER)
          _mangled = mangle_function_name("IO##{method_name}", [_post_arg_type])
          _call_instr = Call.new(ctx.next_id, TypeRef::NIL, _stdout_get.id, _mangled, [_post_arg_id], nil, true)
          ctx.emit(_call_instr)
          ctx.register_type(_call_instr.id, TypeRef::NIL)
          return _call_instr.id
        end
      end

      # String#[](Int32, Int32) intercept: extract substring via runtime helper
      if method_name == "[]" && receiver_id && args.size == 2
        recv_type = ctx.type_of(receiver_id)
        if recv_type == TypeRef::STRING || recv_type == TypeRef::POINTER
          arg0_type = prepack_arg_types.size > 0 ? prepack_arg_types[0] : TypeRef::VOID
          arg1_type = prepack_arg_types.size > 1 ? prepack_arg_types[1] : TypeRef::VOID
          if numeric_primitive?(arg0_type) && numeric_primitive?(arg1_type)
            ext_call = ExternCall.new(ctx.next_id, TypeRef::STRING, "__crystal_v2_string_substring", [receiver_id, args[0], args[1]])
            ctx.emit(ext_call)
            ctx.register_type(ext_call.id, TypeRef::STRING)
            return ext_call.id
          end
        end
      end

      # String#to_i intercept: convert string to integer via runtime helper (strtol-based)
      # Crystal's to_i has many default args (base, whitespace, etc.) — match any args count
      if (method_name == "to_i" || method_name == "to_i32") && receiver_id
        recv_type = ctx.type_of(receiver_id)
        if recv_type == TypeRef::STRING || recv_type == TypeRef::POINTER
          ext_call = ExternCall.new(ctx.next_id, TypeRef::INT32, "__crystal_v2_string_to_i", [receiver_id])
          ctx.emit(ext_call)
          ctx.register_type(ext_call.id, TypeRef::INT32)
          return ext_call.id
        end
      end

      # String#to_i64 intercept
      if method_name == "to_i64" && receiver_id
        recv_type = ctx.type_of(receiver_id)
        if recv_type == TypeRef::STRING || recv_type == TypeRef::POINTER
          ext_call = ExternCall.new(ctx.next_id, TypeRef::INT64, "__crystal_v2_string_to_i64", [receiver_id])
          ctx.emit(ext_call)
          ctx.register_type(ext_call.id, TypeRef::INT64)
          return ext_call.id
        end
      end

      # String#split(String) intercept: bypass wrong overload resolution and call runtime helper
      if method_name == "split" && receiver_id && args.size == 1 &&
         prepack_arg_types.size == 1 && prepack_arg_types[0] == TypeRef::STRING
        recv_type = ctx.type_of(receiver_id)
        if recv_type == TypeRef::STRING || recv_type == TypeRef::POINTER
          arr_type = type_ref_for_name("Array(String)")
          arr_type = TypeRef::POINTER if arr_type == TypeRef::VOID
          ext_call = ExternCall.new(ctx.next_id, arr_type, "__crystal_v2_string_split_string", [receiver_id, args[0]])
          ctx.emit(ext_call)
          ctx.register_type(ext_call.id, arr_type)
          return ext_call.id
        end
      end

      # String#includes? intercept: when argument type is known, bypass the union-param
      # function and directly call the correct implementation.
      # String includes?(String) → strstr-based check via __crystal_v2_string_includes_string
      # String includes?(Char) → no intercept needed (works via index$Char)
      if method_name == "includes?" && receiver_id && args.size == 1 &&
         prepack_arg_types.size == 1 && prepack_arg_types[0] == TypeRef::STRING
        recv_type = ctx.type_of(receiver_id)
        if recv_type == TypeRef::STRING || recv_type == TypeRef::POINTER
          ext_call = ExternCall.new(ctx.next_id, TypeRef::BOOL, "__crystal_v2_string_includes_string", [receiver_id, args[0]])
          ctx.emit(ext_call)
          ctx.register_type(ext_call.id, TypeRef::BOOL)
          return ext_call.id
        end
      end

      # String#index(String) and String#index(Char) intercept
      # Returns i32 (-1 = not found) to avoid DWARF-contaminated stdlib bodies
      # Note: Crystal returns Int32? (nilable), but we return plain Int32 for now.
      # -1 means not found. Callers using `if idx` on Int32 will always be truthy.
      if method_name == "index" && receiver_id && (args.size == 1 || args.size == 2)
        recv_type = ctx.type_of(receiver_id)
        if recv_type == TypeRef::STRING || recv_type == TypeRef::POINTER
          arg_type = prepack_arg_types.size > 0 ? prepack_arg_types[0] : nil
          offset_id = if args.size >= 2
                        args[1]
                      else
                        zero_lit = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
                        ctx.emit(zero_lit)
                        ctx.register_type(zero_lit.id, TypeRef::INT32)
                        zero_lit.id
                      end
          helper_name = if arg_type == TypeRef::STRING
                          "__crystal_v2_string_index_string"
                        elsif arg_type && (arg_type == TypeRef::CHAR || arg_type.id == TypeRef::CHAR.id)
                          "__crystal_v2_string_index_char"
                        else
                          "__crystal_v2_string_index_string"
                        end
          raw_result = ExternCall.new(ctx.next_id, TypeRef::INT32, helper_name, [receiver_id, args[0], offset_id])
          ctx.emit(raw_result)
          ctx.register_type(raw_result.id, TypeRef::INT32)
          return raw_result.id
        end
      end

      # String#gsub(String, String) intercept → runtime helper
      if method_name == "gsub" && receiver_id && args.size == 2 && block_expr.nil?
        recv_type = ctx.type_of(receiver_id)
        if recv_type == TypeRef::STRING || recv_type == TypeRef::POINTER
          ext_call = ExternCall.new(ctx.next_id, TypeRef::STRING, "__crystal_v2_string_gsub", [receiver_id, args[0], args[1]])
          ctx.emit(ext_call)
          ctx.register_type(ext_call.id, TypeRef::STRING)
          return ext_call.id
        end
      end

      # String#sub(String, String) intercept → similar to gsub but only first occurrence
      # For now, route through gsub (will replace all — TODO: implement proper sub)

      pack_result = pack_splat_args_for_call(ctx, args, method_name, full_method_name, has_block_call, has_named_args, receiver_id, has_splat)
      args = pack_result[0]
      splat_packed = pack_result[1]
      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, method_name, full_method_name || "")
        STDERR.puts "[CALL_TRACE] stage=after_pack method=#{method_name} args=#{args.size} receiver=#{!!receiver_id} full=#{full_method_name || ""}"
      end
      args = ensure_double_splat_arg(ctx, args, method_name, full_method_name, has_block_call, has_named_args, receiver_id)
      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, method_name, full_method_name || "")
        STDERR.puts "[CALL_TRACE] stage=after_double_splat method=#{method_name} args=#{args.size} receiver=#{!!receiver_id} full=#{full_method_name || ""}"
      end

      # Array.new(size, value) intercept → runtime helper for filled array
      if method_name == "new" && args.size == 2
        owner = static_class_name || class_name_str
        if owner && owner.starts_with?("Array")
          size_id = args[0]
          value_id = args[1]
          value_type = ctx.type_of(value_id)
          helper_name = if value_type == TypeRef::BOOL
                          "__crystal_v2_array_new_filled_bool"
                        else
                          "__crystal_v2_array_new_filled_i32"
                        end
          # Determine the element type name for proper array type
          elem_name = if owner.includes?("(")
                        owner.split("(").last.rstrip(')')
                      else
                        get_type_name_from_ref(value_type)
                      end
          arr_type_name = "Array(#{elem_name})"
          arr_type = type_ref_for_name(arr_type_name) || TypeRef::POINTER
          ext_call = ExternCall.new(ctx.next_id, arr_type, helper_name, [size_id, value_id])
          ctx.emit(ext_call)
          ctx.register_type(ext_call.id, arr_type)
          return ext_call.id
        end
      end

      if method_name == "new"
        enum_owner = static_class_name || class_name_str
        enum_name = enum_owner ? resolve_enum_name(enum_owner) : nil
        if env_get("DEBUG_ENUM_NEW") && (enum_owner || enum_name)
          if enum_owner && (enum_owner.includes?("DWARF") || enum_owner.includes?("MachO") || enum_owner == "Errno" || enum_owner == "Signal")
            STDERR.puts "[ENUM_NEW] owner=#{enum_owner} enum=#{enum_name || "nil"} static=#{static_class_name || "nil"} args=#{args.size}"
          end
        end
        if enum_owner && enum_name
          enum_type = enum_base_type(enum_name)
          if args.size == 1
            value_id = args.first
            value_type = ctx.type_of(value_id)
            if value_type != enum_type
              cast = Cast.new(ctx.next_id, enum_type, value_id, enum_type, safe: false)
              ctx.emit(cast)
              ctx.register_type(cast.id, enum_type)
              (@enum_value_types ||= {} of ValueId => String)[cast.id] = enum_name
              return cast.id
            end
            (@enum_value_types ||= {} of ValueId => String)[value_id] = enum_name
            return value_id
          end
        end
      end

      # Special handling for Tuple#size - return compile-time constant based on type parameters
      if method_name == "size" && receiver_id && args.empty?
        if type_desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
          tuple_size = tuple_size_from_type_name(type_desc.name)
          if tuple_size.nil?
            base_name = type_desc.name.split("(").first
            tuple_size = type_desc.type_params.size if base_name == "Tuple" && !type_desc.type_params.empty?
          end
          if tuple_size
            lit = Literal.new(ctx.next_id, TypeRef::INT32, tuple_size.to_i64)
            ctx.emit(lit)
            ctx.register_type(lit.id, TypeRef::INT32)
            return lit.id
          end
        end
      end

      # Handle .times { |i| body } intrinsic BEFORE lowering block
      if method_name == "times" && receiver_id
        if blk_expr = block_expr
          blk_node = @arena[blk_expr]
          if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
            return lower_times_intrinsic(ctx, receiver_id, blk_node)
          end
        end
      end

      # Handle nil? intrinsic for union types (T | Nil)
      if method_name == "nil?" && receiver_id
        receiver_type = ctx.type_of(receiver_id)
        # Try to get declared type from local variable if receiver is a Load
        declared_type = receiver_type
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          obj = @arena[callee_node.object]
          if obj.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            var_name = String.new(obj.name)
            if local_id = ctx.lookup_local(var_name)
              local_type = ctx.type_of(local_id)
              if @module.get_type_descriptor(local_type)
                declared_type = local_type
              end
            end
          end
        end
        # Check if receiver is a union type (has variants) or nilable
        if is_union_or_nilable_type?(declared_type)
          return lower_nil_check_intrinsic(ctx, receiver_id, declared_type)
        end
        # Non-union nil? is a constant for primitives and Nil, and a pointer check for pointers.
        if declared_type == TypeRef::NIL
          lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
          ctx.emit(lit)
          return lit.id
        elsif declared_type == TypeRef::POINTER
          nil_val = Literal.new(ctx.next_id, TypeRef::POINTER, 0_i64)
          ctx.emit(nil_val)
          eq_check = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, receiver_id, nil_val.id)
          ctx.emit(eq_check)
          ctx.register_type(eq_check.id, TypeRef::BOOL)
          return eq_check.id
        else
          lit = Literal.new(ctx.next_id, TypeRef::BOOL, false)
          ctx.emit(lit)
          return lit.id
        end
      end

      # Handle not_nil! intrinsic for union types - extracts non-nil value
      if method_name == "not_nil!" && receiver_id
        receiver_type = ctx.type_of(receiver_id)
        # Try to get declared type from local variable if receiver is a Load
        declared_type = receiver_type
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          obj = @arena[callee_node.object]
          if obj.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            var_name = String.new(obj.name)
            if local_id = ctx.lookup_local(var_name)
              local_type = ctx.type_of(local_id)
              if type_desc = @module.get_type_descriptor(local_type)
                declared_type = local_type
              end
            end
          end
        end
        if is_union_or_nilable_type?(declared_type)
          return lower_not_nil_intrinsic(ctx, receiver_id, declared_type)
        end
        if declared_type == TypeRef::VOID
          ctx.register_type(receiver_id, TypeRef::POINTER)
          return receiver_id
        end
      end

      # Ensure try receivers have a concrete type when possible (block shorthand often
      # loses the receiver type and falls back to VOID).
      if method_name == "try" && receiver_id && ctx.type_of(receiver_id) == TypeRef::VOID
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          if inferred = infer_type_from_expr(callee_node.object, @current_class)
            ctx.register_type(receiver_id, inferred) if inferred != TypeRef::VOID
          end
        end
      end

      if env_get("DEBUG_TRY_CALL") && method_name == "try"
        recv_type = receiver_id ? ctx.type_of(receiver_id) : TypeRef::VOID
        recv_name = receiver_id ? get_type_name_from_ref(recv_type) : "nil"
        STDERR.puts "[TRY_CALL] receiver=#{recv_name} block=#{!block_expr.nil?} block_pass=#{!block_pass_expr.nil?}"
        if recv_type == TypeRef::VOID && callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          if source = @sources_by_arena[@arena]?
            receiver_snippet = slice_source_for_expr_in_arena(callee_node.object, @arena, source)
            STDERR.puts "[TRY_CALL] receiver_expr=#{receiver_snippet}" if receiver_snippet
            span = node.span
            start = span.start_offset
            length = span.end_offset - span.start_offset
            if length > 0 && start >= 0 && start < source.bytesize
              slice_len = length > 160 ? 160 : length
              call_snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
              STDERR.puts "[TRY_CALL] call=#{call_snippet}"
            end
          end
        end
      end

      # Handle Range#each { |i| body } and Array#each { |x| body } intrinsics
      if method_name == "each"
        # Check if callee is (range).each - MemberAccessNode on RangeNode
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          inner_obj = @arena[callee_node.object]
          # Unwrap GroupingNode: (1..3) creates GroupingNode around RangeNode
          if inner_obj.is_a?(CrystalV2::Compiler::Frontend::GroupingNode)
            inner_obj = @arena[inner_obj.expression]
          end
          if inner_obj.is_a?(CrystalV2::Compiler::Frontend::RangeNode)
            if blk_expr = block_expr
              blk_node = @arena[blk_expr]
              if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                return lower_range_each_intrinsic(ctx, inner_obj, blk_node)
              end
            end
          end
          # Array#each intrinsic - check if inner_obj is ArrayLiteralNode or identifier
          if inner_obj.is_a?(CrystalV2::Compiler::Frontend::ArrayLiteralNode)
            if blk_expr = block_expr
              blk_node = @arena[blk_expr]
              if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                # Lower array first, then call array_each
                array_id = lower_array_literal(ctx, inner_obj)
                return lower_array_each_intrinsic(ctx, array_id, inner_obj.elements.size, blk_node)
              end
            end
          end
        end
        # arr.each where arr is a variable (receiver_id set)
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                # For arrays, use dynamic size via ArraySize.
                return lower_array_each_dynamic(ctx, receiver_id, blk_node)
              end
              if hash_intrinsic_receiver?(ctx, receiver_id)
                return lower_hash_each_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Hash#keys / Hash#values intrinsic (from lower_call path)
      if (method_name == "keys" || method_name == "values") && receiver_id
        if hash_intrinsic_receiver?(ctx, receiver_id)
          return lower_hash_keys_or_values_intrinsic(ctx, receiver_id, method_name == "keys")
        end
      end

      # Handle Array#each_with_index { |elem, idx| ... } intrinsic
      if method_name == "each_with_index"
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              # Check direct type first, then fall back to original object type
              # (method resolution may retype receiver to module like Enumerable)
              is_array = array_intrinsic_receiver?(ctx, receiver_id)
              if !is_array && callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                is_array = check_and_fix_array_receiver_type(ctx, callee_node, receiver_id)
              end
              if is_array
                return lower_array_each_with_index_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Handle Array#map { |x| expr } intrinsic
      if method_name == "map"
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          inner_obj = @arena[callee_node.object]
          # Array literal: [1, 2, 3].map { |x| x * 2 }
          if inner_obj.is_a?(CrystalV2::Compiler::Frontend::ArrayLiteralNode)
            if blk_expr = block_expr
              blk_node = @arena[blk_expr]
              if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                array_id = lower_array_literal(ctx, inner_obj)
                return lower_array_map_intrinsic(ctx, array_id, inner_obj.elements.size, blk_node)
              end
            end
          end
        end
        # arr.map where arr is a variable (receiver_id set)
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                return lower_array_map_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Handle Array#select { |x| condition } intrinsic
      if method_name == "select"
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          inner_obj = @arena[callee_node.object]
          # Array literal: [1, 2, 3].select { |x| x > 1 }
          if inner_obj.is_a?(CrystalV2::Compiler::Frontend::ArrayLiteralNode)
            if blk_expr = block_expr
              blk_node = @arena[blk_expr]
              if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                # Pass element expressions for compile-time predicate evaluation
                return lower_array_select_intrinsic_with_ast(ctx, inner_obj, blk_node)
              end
            end
          end
        end
        # arr.select where arr is a variable (receiver_id set)
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                return lower_array_select_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Handle Array#reject { |x| condition } intrinsic
      if method_name == "reject"
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                return lower_array_reject_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Handle Array#includes?(value) intrinsic for non-String arrays
      if method_name == "includes?" && receiver_id && args.size == 1
        if array_intrinsic_receiver?(ctx, receiver_id)
          return lower_array_includes_dynamic(ctx, receiver_id, args[0])
        end
      end

      # Handle Array#index(value) intrinsic — returns Int32 (-1 = not found)
      if method_name == "index" && receiver_id && args.size >= 1 && block_expr.nil?
        if array_intrinsic_receiver?(ctx, receiver_id) ||
           (callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
            check_original_receiver_is_array?(ctx, callee_node))
          return lower_array_index_dynamic(ctx, receiver_id, args[0])
        end
      end

      # Handle Array#sort → dup + sort in-place via qsort
      if method_name == "sort" && receiver_id && args.empty?
        is_array = array_intrinsic_receiver?(ctx, receiver_id)
        if !is_array && callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          is_array = check_and_fix_array_receiver_type(ctx, callee_node, receiver_id)
        end
        if is_array
          return lower_array_sort_dynamic(ctx, receiver_id)
        end
      end

      # Handle Array#sort! → sort in-place via qsort
      if method_name == "sort!" && receiver_id && args.empty?
        is_array = array_intrinsic_receiver?(ctx, receiver_id)
        if !is_array && callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          is_array = check_and_fix_array_receiver_type(ctx, callee_node, receiver_id)
        end
        if is_array
          return lower_array_sort_bang_dynamic(ctx, receiver_id)
        end
      end

      # Handle Array#any? { |x| condition } intrinsic
      if method_name == "any?"
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                return lower_array_any_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Handle Array#all? { |x| condition } intrinsic
      if method_name == "all?"
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                return lower_array_all_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Handle Array#none? { |x| condition } intrinsic
      if method_name == "none?"
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                return lower_array_none_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Fallback: treat bare unsafe_* calls inside numeric primitives as self-calls.
      if receiver_id.nil? && (current_class = @current_class) && numeric_primitive_class_name?(current_class)
        if method_name == "unsafe_div" || method_name == "unsafe_mod" ||
           method_name == "unsafe_shl" || method_name == "unsafe_shr"
          receiver_id = emit_self(ctx)
          full_method_name = "#{current_class}##{method_name}"
        end
      end

      # Handle Array#reduce { |acc, elem| ... } intrinsic
      if method_name == "reduce"
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                return lower_array_reduce_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Handle Array#count { |x| condition } intrinsic
      if method_name == "count"
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                return lower_array_count_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Handle Array#first (no args, no block) intrinsic (fallback — primary intercept is EARLY)
      if method_name == "first" && args.empty? && block_expr.nil?
        if receiver_id && array_intrinsic_receiver?(ctx, receiver_id)
          return lower_array_first_intrinsic(ctx, receiver_id)
        end
      end

      # Handle Array#last (no args, no block) intrinsic
      if method_name == "last" && args.empty? && block_expr.nil?
        if receiver_id && array_intrinsic_receiver?(ctx, receiver_id)
          return lower_array_last_intrinsic(ctx, receiver_id)
        end
      end

      # Handle Array#min (no args, no block) intrinsic
      if method_name == "min" && args.empty? && block_expr.nil?
        if receiver_id && array_intrinsic_receiver?(ctx, receiver_id)
          # Only intercept for non-Math receivers (Math.min has args)
          return lower_array_min_intrinsic(ctx, receiver_id)
        end
      end

      # Handle Array#max (no args, no block) intrinsic
      if method_name == "max" && args.empty? && block_expr.nil?
        if receiver_id && array_intrinsic_receiver?(ctx, receiver_id)
          return lower_array_max_intrinsic(ctx, receiver_id)
        end
      end

      # Collect argument types for name mangling (overloading support)
      arg_types = args.map { |arg_id| ctx.type_of(arg_id) }
      if env_get("DEBUG_MATH_MIN") && (method_name == "min" || method_name == "max") && (full_method_name.try(&.includes?("Math")) || (static_class_name && static_class_name.includes?("Math")))
        arg_type_names = arg_types.map { |t| get_type_name_from_ref(t) }
        STDERR.puts "[MATH_MIN_MANGLE] method=#{method_name} arg_types_at_mangle=#{arg_type_names.join(",")} func=#{ctx.function.name} static=#{static_class_name || "nil"} full=#{full_method_name || "nil"}"
      end
      # Refine VOID arg types by tracing back to their source Call instructions
      # This handles cases where a call result is used before the called function is lowered
      arg_types = refine_void_args_from_source_calls(ctx, args, arg_types)
      # If we still have VOID args, try to infer from the original AST call args
      # (safe only when arg counts align and no named/splat reordering happened).
      if arg_types.any? { |t| t == TypeRef::VOID } && call_args.size == args.size &&
         node.named_args.nil? && !has_splat
        inferred_from_ast = with_arena(call_arena) do
          infer_arg_types_for_call(call_args, @current_class)
        end
        if inferred_from_ast.size == arg_types.size
          arg_types = arg_types.map_with_index do |t, idx|
            t == TypeRef::VOID ? inferred_from_ast[idx] : t
          end
        end
      end
      arg_literals = args.map { |arg_id| ctx.type_literal?(arg_id) }
      callsite_arg_types = splat_packed ? prepack_arg_types.dup : arg_types
      callsite_arg_literals = splat_packed ? prepack_arg_literals.dup : arg_literals
      callsite_arg_enum_names = nil
      if splat_packed
        callsite_arg_enum_names = prepack_arg_enum_names.try(&.dup)
      elsif enum_map = @enum_value_types
        names = args.map { |arg_id| enum_map[arg_id]? }
        callsite_arg_enum_names = names if names.any?
      end
      if splat_packed && args.size > prepack_arg_types.size
        extra_ids = args[prepack_arg_types.size..-1] || [] of ValueId
        extra_ids.each do |arg_id|
          callsite_arg_types << ctx.type_of(arg_id)
          callsite_arg_literals << ctx.type_literal?(arg_id)
        end
        if callsite_arg_enum_names && (enum_map = @enum_value_types)
          extra_ids.each { |arg_id| callsite_arg_enum_names << enum_map[arg_id]? }
        end
      end
      if callsite_arg_enum_names
        callsite_arg_enum_names.each_with_index do |enum_name, idx|
          next unless enum_name
          enum_ref = type_ref_for_name(enum_name)
          next if enum_ref == TypeRef::VOID
          if idx < arg_types.size
            arg_types[idx] = enum_ref
          end
          if idx < callsite_arg_types.size
            callsite_arg_types[idx] = enum_ref
          end
        end
      end
      if receiver_id && method_name.ends_with?('=') && args.size == 1 &&
         arg_types.all? { |t| t == TypeRef::VOID }
        if inferred = ivar_type_for_setter(ctx, receiver_id, method_name)
          arg_types = [inferred]
        end
      end
      if receiver_id.nil? && method_name == "new" && full_method_name == "Range.new" && arg_types.size >= 2
        begin_name = get_type_name_from_ref(arg_types[0])
        end_name = get_type_name_from_ref(arg_types[1])
        if begin_name != "Void" && end_name != "Void" &&
           !begin_name.includes?('|') && !end_name.includes?('|')
          range_name = "Range(#{begin_name}, #{end_name})"
          monomorphize_generic_class("Range", [begin_name, end_name], range_name)
          full_method_name = "#{range_name}.new"
          static_class_name = range_name
          if class_info = @class_info[range_name]?
            generate_allocator(range_name, class_info, arg_types)
          end
        end
      end
      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, method_name, full_method_name || "")
        type_ids = arg_types.map(&.id)
        STDERR.puts "[CALL_TRACE] stage=after_arg_types method=#{method_name} arg_types=#{type_ids.join(",")}"
      end

      # Refine class/module method resolution using concrete arg types once available.
      if receiver_id.nil? && full_method_name
        call_has_splat = call_args.any? { |arg_expr| call_arena[arg_expr].is_a?(CrystalV2::Compiler::Frontend::SplatNode) }
        call_has_named_args = node.named_args.try(&.empty?) == false
        has_block_call = !!block_expr || !!block_pass_expr
        if entry = lookup_function_def_for_call(full_method_name, arg_types.size, has_block_call, arg_types, call_has_splat, call_has_named_args)
          full_method_name = entry[0]
        end
      end
      # If a class-method call is unresolved but the owner is a type literal,
      # fall back to Class/Module instance methods (e.g., Int32.to_s → Class#to_s).
      if receiver_id.nil? && full_method_name && full_method_name.includes?('.') &&
         !@function_defs.has_key?(full_method_name) && !class_method_overload_exists?(full_method_name)
        owner = method_owner(full_method_name)
        if owner && !owner.empty? && type_name_exists?(owner)
          owner_ref = type_ref_for_name(owner)
          meta_owner = module_type_ref?(owner_ref) ? "Module" : "Class"
          if meta_method = resolve_method_with_inheritance(meta_owner, method_name)
            literal_id = lower_type_literal_from_name(ctx, owner)
            ctx.mark_type_literal(literal_id)
            receiver_id = literal_id
            full_method_name = meta_method
            static_class_name = nil
          end
        end
      end
      # If this was an explicit self receiver, never rewrite to class methods.
      if explicit_self_receiver && receiver_id.nil? && !@current_method_is_class
        if current = @current_class
          receiver_id = emit_self(ctx)
          full_method_name = resolve_method_with_inheritance(current, method_name) || "#{current}##{method_name}"
          static_class_name = nil
        end
      end

      # Compute mangled name based on base name + argument types
      # If no explicit receiver and we're inside a class, try class#method first
      if debug_env_filter_match?("DEBUG_BASE_METHOD", method_name, method_name, full_method_name || "")
        STDERR.puts "[BASE_METHOD] method=#{method_name} full_method_name=#{full_method_name || "nil"} receiver_id=#{receiver_id.nil? ? "nil" : receiver_id.to_s} @current_class=#{@current_class || "nil"}"
      end
      base_method_name = if full_method_name
                           full_method_name
                         elsif receiver_id.nil? && (current = @current_class)
                           # Bare calls inside a class/module resolve to self.<method> only
                           # when that method exists; otherwise fall back to top-level.
                           resolved = if @current_method_is_class
                                        resolve_class_method_with_inheritance(current, method_name)
                                      else
                                        resolve_method_with_inheritance(current, method_name)
                                      end
                           if resolved
                             resolved
                           else
                             class_method_fallback : String? = nil
                             if @current_method_is_class
                               candidate = "#{current}.#{method_name}"
                               if @function_defs.has_key?(candidate) ||
                                  @function_types.has_key?(candidate) ||
                                  @module.has_function?(candidate) ||
                                  has_function_base?(candidate)
                                 class_method_fallback = candidate
                               else
                                 top_level_exists = @function_defs.has_key?(method_name) ||
                                                    @function_types.has_key?(method_name) ||
                                                    has_function_base?(method_name)
                                 class_method_fallback = candidate unless top_level_exists
                               end
                             end
                             # Check if method exists in included modules (instance methods only).
                             included_candidate : String? = nil
                             if !@current_method_is_class
                               if modules = @class_included_modules[current]?
                                 if env_has?("DEBUG_INCLUDED_BASE") && method_name == "byte_range"
                                   STDERR.puts "[INCLUDED_BASE] class=#{current} modules=#{modules.to_a.join(",")}"
                                 end
                                 modules.each do |mod_name|
                                   mod_candidate = "#{mod_name}##{method_name}"
                                   if @function_types.has_key?(mod_candidate) || has_function_base?(mod_candidate)
                                     included_candidate = mod_candidate
                                     break
                                   end
                                 end
                               elsif env_has?("DEBUG_INCLUDED_BASE") && method_name == "byte_range"
                                 STDERR.puts "[INCLUDED_BASE] class=#{current} NO_MODULES"
                               end
                             end
                             class_method_fallback || included_candidate || method_name
                           end
                         else
                           # receiver_id might be set but full_method_name is nil
                           # Try to get type name from receiver's TypeRef if we have a receiver
                           if receiver_id
                             recv_type = ctx.type_of(receiver_id)
                             type_name = get_type_name_from_ref(recv_type)
                             if !type_name.empty? && type_name != "Unknown" && type_name != "Void"
                               "#{type_name}##{method_name}"
                             else
                               method_name
                             end
                           else
                             method_name
                           end
                         end
      # Late fallback: if this is an unresolved class-method call on a type literal,
      # use meta-instance methods (e.g., Int32.to_s -> Class#to_s).
      if receiver_id.nil? && base_method_name.includes?('.') &&
         !@function_defs.has_key?(base_method_name) && !class_method_overload_exists?(base_method_name)
        owner = method_owner(base_method_name)
        if owner && !owner.empty? && type_name_exists?(owner)
          owner_ref = type_ref_for_name(owner)
          meta_owner = module_type_ref?(owner_ref) ? "Module" : "Class"
          if meta_method = resolve_method_with_inheritance(meta_owner, method_name)
            literal_id = lower_type_literal_from_name(ctx, owner)
            ctx.mark_type_literal(literal_id)
            receiver_id = literal_id
            base_method_name = meta_method
            full_method_name = meta_method
            static_class_name = nil
          end
        end
      end
      if cached_callsite_key && receiver_id && base_method_name.includes?('#')
        @callsite_method_cache[cached_callsite_key] = base_method_name
      end
      if receiver_id.nil? && full_method_name.nil? && method_name == "main" && @top_level_main_defined
        base_method_name = TOP_LEVEL_MAIN_BASE
      end
      if receiver_id.nil? && base_method_name.includes?('#') && !@current_method_is_class
        receiver_id = emit_self(ctx)
      end

      # Refine VOID arg types by looking at overload parameter annotations
      arg_types = refine_void_args_from_overloads(base_method_name, arg_types)

      if receiver_id.nil? && method_name == "new"
        if class_name = static_class_name || full_method_name.try { |name| method_owner(name) }
          if arg_types.any? { |t| t != TypeRef::VOID }
            if init_base = resolve_method_with_inheritance(class_name, "initialize")
              remember_callsite_arg_types(init_base, arg_types)
              lower_function_if_needed(init_base)
            end
          end
        end
      end

      if receiver_id.nil? && method_name == "new"
        target_name = full_method_name || base_method_name
        if target_name == "Pointer.new" || target_name.starts_with?("Pointer(")
          if lowered = lower_pointer_new_intrinsic(ctx, args)
            return lowered
          end
        end
      end
      # Convert .class type literal args to String (compile-time class name).
      # Type literals (from .class calls) are nil pointers at runtime.
      # When used as call args (e.g., `io << self.class`), they must become
      # actual String values. Receivers (e.g., `self.class.new`) are unaffected.
      # For dynamic dispatch (union types), __crystal_v2_type_name(type_id) will be used.
      args.each_with_index do |arg_id, i|
        next unless ctx.dot_class_literal?(arg_id)
        class_name_for_lit = get_type_name_from_ref(arg_types[i])
        next if class_name_for_lit.empty?
        str_lit = Literal.new(ctx.next_id, TypeRef::STRING, class_name_for_lit)
        ctx.emit(str_lit)
        ctx.register_type(str_lit.id, TypeRef::STRING)
        args[i] = str_lit.id
        arg_types[i] = TypeRef::STRING
      end

      mangled_method_name = mangle_function_name(base_method_name, arg_types)
      if has_block_call
        mangled_with_block = mangle_function_name(base_method_name, arg_types, true)
        if @function_types.has_key?(mangled_with_block) || @yield_functions.includes?(mangled_with_block) || @module.has_function?(mangled_with_block)
          mangled_method_name = mangled_with_block
        end
      end

      if receiver_id && base_method_name.includes?('|') && base_method_name.includes?('#')
        union_name = method_owner(base_method_name)
        if resolved = resolve_union_method_call(union_name, method_name, arg_types, has_block_call, has_named_args)
          if resolved.includes?('$')
            mangled_method_name = resolved
            base_method_name = strip_type_suffix(resolved)
          else
            base_method_name = resolved
            mangled_method_name = mangle_function_name(base_method_name, arg_types, has_block_call)
          end
        end
      end

      lookup_name = full_method_name || base_method_name
      if entry = lookup_function_def_for_call(lookup_name, args.size, has_block_call, arg_types, has_splat, has_named_args)
        entry_name = entry[0]
        entry_def = entry[1]
        base_method_name = strip_type_suffix(entry_name)
        if entry_name.includes?('$')
          mangled_method_name = entry_name
        elsif !arg_types.empty?
          untyped_params = true
          if params = entry_def.params
            params.each do |param|
              next if param.is_block || named_only_separator?(param)
              if param.is_double_splat
                untyped_params = false
                break
              end
              if ta = param.type_annotation
                type_name = String.new(ta)
                if !type_param_like?(type_name) || @type_param_map.has_key?(type_name)
                  untyped_params = false
                  break
                end
              end
            end
          end
          # Even for untyped params, use mangled name if we have concrete arg types
          # This ensures the correct overload is called at call site
          if untyped_params && arg_types.any? { |t| t != TypeRef::VOID }
            mangled_method_name = mangle_function_name(entry_name, arg_types, has_block_call)
          else
            mangled_method_name = untyped_params ? entry_name : mangle_function_name(entry_name, arg_types, has_block_call)
          end
        else
          mangled_method_name = entry_name
        end
      end
      if receiver_id && debug_env_filter_match?("DEBUG_EACH_RESOLVE", method_name)
        recv_name = get_type_name_from_ref(ctx.type_of(receiver_id))
        STDERR.puts "[EACH_RESOLVE_CALL] recv=#{recv_name} lookup=#{lookup_name} base=#{base_method_name} mangled=#{mangled_method_name}"
      end
      if receiver_id
        # Preserve a callsite-mangled overload (typed args) to avoid collapsing
        # into base names like `IO#puts` that hide typed overloads.
        needs_resolve = !(@function_types.has_key?(mangled_method_name) ||
                          @function_defs.has_key?(mangled_method_name) ||
                          @module.has_function?(mangled_method_name)) ||
                        !mangled_method_name.includes?('$')
        if needs_resolve
          named_count = node.named_args ? node.named_args.not_nil!.size : 0
          resolved_name = resolve_method_call(ctx, receiver_id, method_name, arg_types, has_block_call, has_named_args, named_count)
          # Don't override a mangled name with suffix with a base name without suffix
          # when we have concrete argument types
          if resolved_name != mangled_method_name
            should_override = resolved_name.includes?('$') ||
                              @function_types.has_key?(resolved_name) ||
                              @function_defs.has_key?(resolved_name) ||
                              @module.has_function?(resolved_name)
            # Keep mangled name if it has suffix and resolved doesn't
            if mangled_method_name.includes?('$') && !resolved_name.includes?('$')
              should_override = false
            end
            if should_override
              mangled_method_name = resolved_name
              base_method_name = strip_type_suffix(resolved_name)
            end
          end
        end

        # When argument types are unknown (all VOID), try to select a single
        # overload by arity to avoid falling back to an unmangled base name.
        if !mangled_method_name.includes?('$') &&
           arg_types.all? { |t| t == TypeRef::VOID } &&
           node.named_args.nil? &&
           !node.args.any? { |arg_id| @arena[arg_id].is_a?(CrystalV2::Compiler::Frontend::SplatNode) }
          if resolved_untyped = resolve_untyped_overload(base_method_name, args.size, has_block_call, has_named_args)
            mangled_method_name = resolved_untyped
            base_method_name = strip_type_suffix(resolved_untyped)
          end
        end
      end
      if method_name == "new" && full_method_name
        if class_name = method_owner(full_method_name)
          if class_info = @class_info[class_name]?
            generate_allocator(class_name, class_info, arg_types)
          end
        end
        explicit_new = !!lookup_function_def_for_call(full_method_name, args.size, has_block_call, arg_types, false, has_named_args)
        if !explicit_new && @module.has_function?(full_method_name) && !@module.has_function?(mangled_method_name) &&
           arg_types.all? { |t| t == TypeRef::VOID }
          mangled_method_name = full_method_name
          base_method_name = full_method_name
        end
      end

      if receiver_id && callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
        # Module-typed dispatch is only for *value receivers* whose static type is a module-like type.
        # Do not apply it to implicit/self receivers, otherwise we can accidentally bind to a generic
        # template module (e.g. Impl(F, Info)) instead of the concrete generic instance.
        obj_node = @arena[callee_node.object]
        unless obj_node.is_a?(CrystalV2::Compiler::Frontend::SelfNode) ||
               obj_node.is_a?(CrystalV2::Compiler::Frontend::ImplicitObjNode)
          receiver_type = ctx.type_of(receiver_id)
          if type_desc = @module.get_type_descriptor(receiver_type)
            # LOWER_CALL_DEBUG disabled
            # Only treat non-type-literal receivers as "module-typed" dispatch
            # (i.e., resolve against includers). For type literals (including
            # concrete generic module instances), prefer direct Class/Module.method
            # resolution so we don't accidentally bind to the generic template.
            if (type_desc.kind == TypeKind::Module || module_like_type_name?(type_desc.name)) &&
               !ctx.type_literal?(receiver_id)
              # Try to get module type name from AST, fall back to type_desc.name
              # This handles cases where the receiver is a call result (e.g., event_loop().write())
              module_type_name = module_receiver_type_name(callee_node) || type_desc.name
              if resolved = resolve_module_typed_method(method_name, arg_types, module_type_name, has_block_call, @current_class)
                mangled_method_name = resolved
                base_method_name = strip_type_suffix(resolved)
              end
            end
          end
        end
      end
      if receiver_id
        if type_desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
          if type_desc.kind == TypeKind::Module || (type_desc.kind == TypeKind::Generic && module_like_type_name?(type_desc.name))
            # Prefer the fully-qualified (possibly generic) module name first.
            # Generic module instances (e.g. Impl(Float32, ImplInfo_Float32)) can
            # have specialized method bodies and type-param substitutions. Only
            # fall back to the stripped base module when no specialized method exists.
            module_full = type_desc.name
            used_full = false
            if module_full.includes?('(')
              ensure_method_index_built
              base_owner = strip_generic_args(module_full)
              if owner_methods = @method_index[base_owner]?
                if candidates = owner_methods[method_name]?
                  owner_prefix = "#{module_full}."
                  candidates.each do |cand|
                    if cand.starts_with?(owner_prefix)
                      module_method_full = "#{module_full}.#{method_name}"
                      base_method_name = module_method_full
                      mangled_method_name = mangle_function_name(module_method_full, arg_types, has_block_call)
                      used_full = true
                      break
                    end
                  end
                end
              end
            end
            unless used_full
              module_base = module_full
              if paren = module_base.index('(')
                module_base = module_base[0, paren]
              end
              module_method_base = "#{module_base}.#{method_name}"
              if has_function_base?(module_method_base) || @function_defs.has_key?(module_method_base)
                base_method_name = module_method_base
                mangled_method_name = mangle_function_name(module_method_base, arg_types, has_block_call)
              end
            end
          end
        end
      end
      if arg_types.any? { |t| t != TypeRef::VOID }
        desired_mangled = mangle_function_name(base_method_name, arg_types, has_block_call)
        if desired_mangled != mangled_method_name &&
           (@function_types.has_key?(desired_mangled) || @function_defs.has_key?(desired_mangled) || @module.has_function?(desired_mangled))
          mangled_method_name = desired_mangled
        end
        if mangled_method_name.includes?("$arity")
          mangled_method_name = desired_mangled
        end
      end
      # Final safety net: if we ended with a class-method call that has no definition,
      # fall back to Class/Module instance methods on the type literal.
      if receiver_id.nil? && mangled_method_name.includes?('.') &&
         !@function_defs.has_key?(mangled_method_name)
        owner = method_owner(mangled_method_name) || method_owner(base_method_name)
        if owner && !owner.empty? && type_name_exists?(owner)
          short_name = method_short_from_name(mangled_method_name) || method_name
          wrapper = ensure_unbound_instance_method_wrapper(owner, short_name, arg_types)
          if wrapper
            base_method_name = strip_type_suffix(wrapper)
            mangled_method_name = wrapper
            full_method_name = base_method_name
            static_class_name = owner
          else
            owner_ref = type_ref_for_name(owner)
            meta_owner = module_type_ref?(owner_ref) ? "Module" : "Class"
            short_method = method_short_from_name(mangled_method_name) || method_name
            if resolve_class_method_with_inheritance(owner, short_method).nil?
              if wrapper = ensure_type_literal_class_method(owner, short_method, arg_types, meta_owner)
                base_method_name = strip_type_suffix(wrapper)
                mangled_method_name = wrapper
                full_method_name = base_method_name
                static_class_name = owner
              end
            end
          end
        end
      end
      primary_mangled_name = mangled_method_name
      receiver_name = ""
      if receiver_id
        if desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
          receiver_name = desc.name
        end
      end
      arg_names = arg_types.map { |t| type_name_for_mangling(t) }
      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, base_method_name, mangled_method_name)
        STDERR.puts "[CALL_TRACE] stage=after_resolve method=#{method_name} base=#{base_method_name} mangled=#{mangled_method_name}"
      end
      debug_hook("call.resolve", "method=#{method_name} base=#{base_method_name} mangled=#{mangled_method_name} receiver=#{receiver_name} args=#{arg_names} current=#{@current_class || ""}")
      if debug_env_filter_match?("DEBUG_EACH_RESOLVE", method_name)
        recv = receiver_id ? get_type_name_from_ref(ctx.type_of(receiver_id)) : "nil"
        scope = "#{@current_class || ""}##{@current_method || ""}"
        STDERR.puts "[EACH_RESOLVE_FINAL] recv=#{recv} base=#{base_method_name} mangled=#{mangled_method_name} scope=#{scope} func=#{ctx.function.name}"
      end
      if debug_env_filter_match?("DEBUG_UNSAFE_FETCH", method_name, base_method_name, mangled_method_name)
        recv = receiver_id ? get_type_name_from_ref(ctx.type_of(receiver_id)) : "nil"
        current_scope = "#{@current_class || ""}##{@current_method || ""}"
        STDERR.puts "[UNSAFE_FETCH] recv=#{recv} base=#{base_method_name} mangled=#{mangled_method_name} current=#{current_scope} func=#{ctx.function.name}"
      end
      if debug_env_filter_match?("DEBUG_PUTS_CALLS", method_name, base_method_name, mangled_method_name)
        STDERR.puts "[DEBUG_PUTS_CALL] base=#{base_method_name} mangled=#{mangled_method_name} args=#{arg_names.join(",")}"
      end
      if debug_env_filter_match?("DEBUG_HIGH_CALL", method_name, base_method_name, mangled_method_name)
        recv = receiver_id ? get_type_name_from_ref(ctx.type_of(receiver_id)) : "nil"
        current_scope = "#{@current_class || ""}##{@current_method || ""}"
        STDERR.puts "[HIGH_CALL] recv=#{recv} base=#{base_method_name} mangled=#{mangled_method_name} current=#{current_scope} func=#{ctx.function.name}"
      end

      if receiver_id.nil? && method_name == "new" && args.size == 1
        if mangled_method_name.starts_with?("Pointer_") && mangled_method_name.ends_with?("__new")
          if lowered = lower_pointer_new_intrinsic(ctx, args)
            return lowered
          end
        end
      end

      # Handle yield-functions with inline expansion FIRST (before lowering block)
      # Must check with mangled name since that's how yield functions are registered.
      block_for_inline : CrystalV2::Compiler::Frontend::BlockNode? = nil
      proc_for_inline : CrystalV2::Compiler::Frontend::ProcLiteralNode? = nil
      block_param_types_inline : Array(TypeRef)? = nil
      if block_expr
        blk_node = @arena[block_expr]
        if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
          block_param_types_inline = block_param_types_for_call(mangled_method_name, base_method_name, receiver_id ? ctx.type_of(receiver_id) : nil)
          if method_name == "try" && receiver_id
            if non_nil = non_nil_type_for_union(ctx.type_of(receiver_id))
              block_param_types_inline = [non_nil]
            else
              block_param_types_inline = [ctx.type_of(receiver_id)]
            end
          end
          block_for_inline = blk_node
        elsif blk_node.is_a?(CrystalV2::Compiler::Frontend::ProcLiteralNode)
          proc_for_inline = blk_node
        end
      elsif block_pass_expr
        block_param_types_inline = block_param_types_for_call(mangled_method_name, base_method_name, receiver_id ? ctx.type_of(receiver_id) : nil)
        if method_name == "try" && receiver_id
          if non_nil = non_nil_type_for_union(ctx.type_of(receiver_id))
            block_param_types_inline = [non_nil]
          else
            block_param_types_inline = [ctx.type_of(receiver_id)]
          end
        end
        block_for_inline = build_block_from_block_pass(block_pass_expr, block_param_types_inline, node.span)
      end
      if block_param_types_inline.nil? && static_class_name && method_name == "new"
        block_param_types_inline = [type_ref_for_name(static_class_name)]
      end

      disable_inline_yield = env_has?("CRYSTAL_V2_DISABLE_INLINE_YIELD")
      if (block_for_inline || proc_for_inline) && !disable_inline_yield
        try_inline_allowed = env_has?("CRYSTAL_V2_INLINE_TRY") || !env_has?("CRYSTAL_V2_DISABLE_TRY_INLINE")
        if method_name == "try"
          if env_has?("CRYSTAL_V2_DISABLE_TRY_INLINE")
            try_inline_allowed = false
          elsif try_inline_allowed
            max_inline = (env_get("CRYSTAL_V2_TRY_INLINE_MAX").try(&.to_i?)) || 6
            if block_for_inline
              body_size = block_for_inline.body ? block_for_inline.body.not_nil!.size : 0
              try_inline_allowed = false if body_size > max_inline
            elsif proc_for_inline
              body_size = proc_for_inline.body ? proc_for_inline.body.not_nil!.size : 0
              try_inline_allowed = false if body_size > max_inline
            end
          end
        end
        if block_for_inline
          @block_node_arenas[block_for_inline.object_id] = @arena
        end
        if env_get("DEBUG_YIELD_TRACE") && (method_name == "char_at" || method_name == "fetch" || method_name == "upto" ||
           method_name == "byte_range" ||
           base_method_name.includes?("char_at") || base_method_name.includes?("fetch") || base_method_name.includes?("upto") ||
           mangled_method_name.includes?("char_at") || mangled_method_name.includes?("fetch") || mangled_method_name.includes?("upto"))
          STDERR.puts "[YIELD_TRACE] method=#{method_name} base=#{base_method_name} mangled=#{mangled_method_name} in_set=#{@yield_functions.includes?(mangled_method_name)} block=#{!!block_for_inline} current=#{@current_class || ""}"
        end
        # For Object#tap, inline directly when we have a receiver
        # tap yields self to the block then returns self
        if receiver_id && method_name == "tap"
          if block_for_inline
            return inline_tap_with_block(ctx, receiver_id, block_for_inline)
          elsif proc_for_inline
            return inline_tap_with_proc(ctx, receiver_id, proc_for_inline)
          end
        end
        if receiver_id && method_name == "try" && try_inline_allowed
          recv_type = ctx.type_of(receiver_id)
          if block_for_inline
            return inline_try_with_block(ctx, receiver_id, recv_type, block_for_inline)
          elsif proc_for_inline
            return inline_try_with_proc(ctx, receiver_id, recv_type, proc_for_inline)
          end
        end

        if block_for_inline
          block_cast = block_for_inline
          call_arg_values = args

          skip_inline = false
          # NOTE: We used to skip when block return type param wasn't in type_param_map.
          # However, this prevented valid inlining of methods like min_by { |x| x } where
          # the block's return type can be inferred from the actual block body.
          # The inline expansion can handle type inference from the concrete block.
          # Removed check:
          # if type_param_name = block_return_type_param_name(mangled_method_name, base_method_name)
          #   receiver_map = type_param_map_for_receiver_name(base_method_name)
          #   unless @type_param_map.has_key?(type_param_name) || receiver_map.has_key?(type_param_name)
          #     skip_inline = true
          #   end
          # end
          if block_pass_expr
            if type_param_name = block_return_type_param_name(mangled_method_name, base_method_name)
              receiver_map = type_param_map_for_receiver_name(base_method_name)
              unless @type_param_map.has_key?(type_param_name) || receiver_map.has_key?(type_param_name)
                skip_inline = true
              end
            end
          end
          # Avoid inlining Tuple#map/map_with_index until macro-expanded bodies are reliable.
          # Inline-yield with macro bodies can produce empty returns and drop to Nil.
          if receiver_id && (method_name == "map" || method_name == "map_with_index")
            if recv_desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
              if recv_desc.kind == TypeKind::Tuple || recv_desc.name.starts_with?("Tuple(")
                skip_inline = true
              end
            end
          end
          if !skip_inline && method_name == "try" && receiver_id
            if env_get("DEBUG_TRY_INLINE")
              recv_type = ctx.type_of(receiver_id)
              STDERR.puts "[TRY_INLINE] recv_type=#{get_type_name_from_ref(recv_type)} union=#{is_union_or_nilable_type?(recv_type)}"
            end
          end
          if method_name == "try" && !try_inline_allowed
            skip_inline = true
            debug_hook("call.inline.skip", "callee=#{mangled_method_name} reason=try_inline_limit")
          end
          if !skip_inline
            # If the method return type does not depend on the block, avoid expensive inline-yield.
            # This keeps correctness (fallback call emits a block) while reducing lowering cost.
            # However, do NOT skip for yield functions — they may use typeof(yield ...) internally
            # which requires inline expansion to resolve the block return type correctly.
            is_known_yield = @yield_functions.includes?(mangled_method_name) ||
                             @yield_functions.includes?(base_method_name)
            unless is_known_yield || yield_return_function_for_call(mangled_method_name, base_method_name)
              if block_return_type_param_name(mangled_method_name, base_method_name).nil?
                resolved_receiver_type = receiver_id ? ctx.type_of(receiver_id) : TypeRef::VOID
                receiver_hint = resolved_receiver_type == TypeRef::VOID ? nil : resolved_receiver_type
                if inferred = resolve_return_type_from_def(mangled_method_name, base_method_name, receiver_hint)
                  if inferred != TypeRef::VOID && inferred != TypeRef::NIL
                    skip_inline = true
                    debug_hook("call.inline.skip", "callee=#{mangled_method_name} reason=return_type_known")
                  end
                end
              end
            end
          end
          inline_required = yield_return_function_for_call(mangled_method_name, base_method_name) ||
                            !block_return_type_param_name(mangled_method_name, base_method_name).nil? ||
                            @yield_functions.includes?(mangled_method_name) ||
                            @yield_functions.includes?(base_method_name)
          if !skip_inline && !inline_required
            if block_param_types_inline
              skip_inline = true
              debug_hook("call.inline.skip", "callee=#{mangled_method_name} reason=block_types_known")
            end
          end
          if !skip_inline && !inline_required
            inline_body_limit = (env_get("INLINE_YIELD_BODY_LIMIT") || "120").to_i
            if func_def = @function_defs[mangled_method_name]?
              if body = func_def.body
                if body.size > inline_body_limit
                  skip_inline = true
                  debug_hook("call.inline.skip", "callee=#{mangled_method_name} reason=body_size limit=#{inline_body_limit}")
                end
              end
            end
          end

          if !skip_inline && @yield_functions.includes?(mangled_method_name)
            if receiver_id
              recv_name = get_type_name_from_ref(ctx.type_of(receiver_id))
              owner_part = strip_type_suffix(mangled_method_name)
              owner_name = method_owner(owner_part)
              if owner_name && owner_name.includes?('(') && recv_name.includes?('(')
                owner_base = split_generic_base_and_args(owner_name).try(&.[](:base)) || owner_name
                recv_base = split_generic_base_and_args(recv_name).try(&.[](:base)) || recv_name
                if owner_base == recv_base && owner_name != recv_name
                  # Only skip when we can't map generic params from the receiver type.
                  receiver_map = type_param_map_for_receiver_type(ctx.type_of(receiver_id))
                  skip_inline = true if receiver_map.empty?
                end
              end
            end
            if !skip_inline
              if func_def = @function_defs[mangled_method_name]?
                debug_hook("call.inline.yield", "callee=#{mangled_method_name} current=#{@current_class || ""}")
                callee_arena = @function_def_arenas[mangled_method_name]? || @arena
                return inline_yield_function(ctx, func_def, mangled_method_name, receiver_id, call_arg_values, block_cast, block_param_types_inline, callee_arena)
              end
            end
          end
          # Also try base method name (for functions without overloading)
          if env_has?("DEBUG_YIELD_INLINE") && (method_name == "trace" || mangled_method_name.includes?("trace"))
            STDERR.puts "[YIELD_INLINE]   base_in_yield_functions=#{@yield_functions.includes?(base_method_name)}"
            STDERR.puts "[YIELD_INLINE]   base_in_function_defs=#{@function_defs.has_key?(base_method_name)}"
          end
          if !skip_inline
            if yield_name = yield_function_name_for(base_method_name)
              if func_def = @function_defs[yield_name]?
                debug_hook("call.inline.yield", "callee=#{yield_name} current=#{@current_class || ""}")
                callee_arena = @function_def_arenas[yield_name]? || @arena
                return inline_yield_function(ctx, func_def, yield_name, receiver_id, call_arg_values, block_cast, block_param_types_inline, callee_arena)
              end
            end
          end

          # Fallback: resolve the def node by arity/signature and inline if it yields,
          # even if @yield_functions didn't capture the mangled name.
          receiver_base = nil
          if receiver_id
            receiver_desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
            receiver_base = yield_receiver_base_name(ctx.type_of(receiver_id)) unless receiver_desc && receiver_desc.name.includes?('(')
          end

          if env_has?("DEBUG_YIELD_INLINE") && (method_name == "trace" || mangled_method_name.includes?("trace"))
            overloads = function_def_overloads(base_method_name)
            STDERR.puts "[YIELD_INLINE]   overloads=#{overloads.size} base=#{base_method_name}"
            overloads.each { |o| STDERR.puts "[YIELD_INLINE]     - #{o}" }
            fb_entry = lookup_block_function_def_for_call(base_method_name, call_args.size, arg_types, receiver_base)
            STDERR.puts "[YIELD_INLINE]   lookup_block_entry=#{fb_entry ? fb_entry[0] : "nil"}"
          end
          if !skip_inline && (entry = lookup_block_function_def_for_call(base_method_name, call_args.size, arg_types, receiver_base))
            yield_name, yield_def = entry
            callee_arena = @function_def_arenas[yield_name]? || @arena
            # Check @yield_functions first - it was populated during registration when arena context was correct.
            # This is more reliable than re-analyzing the DefNode which may fail for stdlib arenas.
            callee_in_yield_set = @yield_functions.includes?(yield_name)
            callee_has_yield = callee_in_yield_set || def_contains_yield?(yield_def, callee_arena)
            callee_has_block_call = def_contains_block_call?(yield_def, callee_arena)
            if callee_has_yield || callee_has_block_call
              @yield_functions.add(yield_name) if callee_has_yield
              debug_hook("call.inline.yield", "callee=#{yield_name} current=#{@current_class || ""}")
              return inline_yield_function(ctx, yield_def, yield_name, receiver_id, call_arg_values, block_cast, block_param_types_inline, callee_arena)
            end
          end

          # Fallback: try to find yield method by name + arity.
          # This handles inherited methods like Object#tap called on any class.
          # Example: `fd.tap { |x| x.something }` where tap is defined in Object.
          if !skip_inline && receiver_id
            if yield_key = find_yield_method_fallback(method_name, call_args.size, receiver_base)
              if func_def = @function_defs[yield_key]?
                debug_hook("call.inline.yield", "callee=#{yield_key} current=#{@current_class || ""}")
                callee_arena = @function_def_arenas[yield_key]? || @arena
                return inline_yield_function(ctx, func_def, yield_key, receiver_id, call_arg_values, block_cast, block_param_types_inline, callee_arena)
              end
            end
          end
        end
      end

      # Handle String.build { |io| ... } intrinsic
      # This is a common pattern that builds a string using an IO-like builder
      if full_method_name == "String.build"
        if blk_expr = block_expr
          blk_node = @arena[blk_expr]
          if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
            return lower_string_build_intrinsic(ctx, blk_node, args.first?)
          end
        end
      end

      # Check for block (ExprId -> must lower to BlockNode) - for non-inline calls only
      # This is after yield function check so we don't emit dead block code
      block_id = if block_expr
                   blk_node = @arena[block_expr]
                   if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                     block_param_types = block_param_types_for_call(mangled_method_name, base_method_name, receiver_id ? ctx.type_of(receiver_id) : nil)
                     if method_name == "try" && receiver_id
                       if non_nil = non_nil_type_for_union(ctx.type_of(receiver_id))
                         block_param_types = [non_nil]
                       elsif block_param_types.nil?
                         block_param_types = [ctx.type_of(receiver_id)]
                       end
                     end
                     if debug_hook_filter_match?(method_name, base_method_name, mangled_method_name)
                       types_str = block_param_types ? block_param_types.map { |t| get_type_name_from_ref(t) }.join(",") : ""
                       debug_hook("block.param.result", "method=#{base_method_name} mangled=#{mangled_method_name} types=#{types_str}")
                     end
                     lower_block_to_block_id(ctx, blk_node, block_param_types)
                   else
                     # Block is some other expression - should not happen in well-formed AST
                     nil
                   end
                 elsif block_pass_expr
                   block_param_types = block_param_types_for_call(mangled_method_name, base_method_name, receiver_id ? ctx.type_of(receiver_id) : nil)
                   if method_name == "try" && receiver_id
                     if non_nil = non_nil_type_for_union(ctx.type_of(receiver_id))
                       block_param_types = [non_nil]
                     elsif block_param_types.nil?
                       block_param_types = [ctx.type_of(receiver_id)]
                     end
                   end
                   lower_block_pass_proc(ctx, block_pass_expr, block_param_types)
                 else
                   nil
                 end

      # Tuple has implicit splat type param T; map it from concrete tuple elements at the callsite.
      if receiver_id
        if recv_desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
          is_tuple = recv_desc.kind == TypeKind::Tuple || recv_desc.name.starts_with?("Tuple(")
          if env_get("DEBUG_TUPLE_MAP") && (is_tuple || recv_desc.name == "Tuple")
            params_str = recv_desc.type_params.map { |ref| get_type_name_from_ref(ref) }.join(",")
            STDERR.puts "[TUPLE_MAP_CANDIDATE] base=#{base_method_name} mangled=#{mangled_method_name} recv=#{recv_desc.name} kind=#{recv_desc.kind} params=#{params_str}"
          end
          if is_tuple
            if params = recv_desc.type_params
              union_parts = params.map { |ref| get_type_name_from_ref(ref) }.reject(&.empty?)
              if !union_parts.empty?
                tuple_union = union_parts.join(" | ")
                tuple_list = union_parts.join(", ")
                map = {"T" => tuple_union, "T__tuple" => tuple_list}
                record_pending_type_param_map(mangled_method_name, map)
                record_pending_type_param_map(base_method_name, map)
              end
            end
          end
        end
      end

      # Try to infer return type using mangled name first, fallback to base name
      # For non-overloaded functions, prefer base name since that's how they're registered in HIR module
      return_type = get_function_return_type(mangled_method_name)
      begin
        if def_node = lookup_function_def_for_return(mangled_method_name, base_method_name)
          if debug_env_filter_match?("DEBUG_RETURN_DEF", mangled_method_name, base_method_name)
            rt_name = def_node.return_type ? String.new(def_node.return_type.not_nil!) : "(nil)"
            STDERR.puts "[CALL_RETURN_DEF] name=#{mangled_method_name} base=#{base_method_name} rt=#{rt_name}"
          end
          if def_node.return_type
            if resolved = resolve_return_type_from_def(mangled_method_name, base_method_name, receiver_id ? ctx.type_of(receiver_id) : nil)
              if debug_env_filter_match?("DEBUG_RETURN_DEF", mangled_method_name, base_method_name)
                STDERR.puts "[CALL_RETURN_DEF] resolved=#{get_type_name_from_ref(resolved)}"
              end
              if resolved != TypeRef::VOID && resolved != TypeRef::NIL && resolved != return_type
                return_type = resolved
              end
            end
          end
        end
        unionish = false
        if return_type != TypeRef::VOID && return_type != TypeRef::NIL
          if ret_desc = @module.get_type_descriptor(return_type)
            unionish = ret_desc.kind == TypeKind::Union
          else
            unionish = get_type_name_from_ref(return_type).includes?('|')
          end
        end
        if return_type == TypeRef::VOID || return_type == TypeRef::NIL || unionish
          if def_node = lookup_function_def_for_return(mangled_method_name, base_method_name)
            owner_name = function_context_from_name(base_method_name)
            if inferred = infer_return_type_from_body_without_callsite(def_node, owner_name)
              if inferred != TypeRef::VOID && inferred != TypeRef::NIL
                inferred_desc = @module.get_type_descriptor(inferred)
                if return_type == TypeRef::VOID || return_type == TypeRef::NIL
                  return_type = inferred
                elsif inferred_desc.nil? || inferred_desc.kind != TypeKind::Union
                  return_type = inferred
                else
                  current_union_name = @module.get_type_descriptor(return_type).try(&.name) || get_type_name_from_ref(return_type)
                  if prefer_inferred_union_type?(current_union_name, inferred_desc.name)
                    return_type = inferred
                  end
                end
              end
            end
          end
        end
      end

      # If no concrete signature was registered for the mangled name, prefer
      # resolving the return type from the def in the owner's namespace.
      if !@function_types.has_key?(mangled_method_name)
        if inferred = resolve_return_type_from_def(mangled_method_name, base_method_name, receiver_id ? ctx.type_of(receiver_id) : nil)
          return_type = inferred unless inferred == TypeRef::VOID || inferred == TypeRef::NIL
        end
      end

      # For Proc#call, extract return type from Proc type_params (last element is return type)
      if return_type == TypeRef::VOID && method_name == "call" && receiver_id
        recv_type = ctx.type_of(receiver_id)
        if recv_desc = @module.get_type_descriptor(recv_type)
          if recv_desc.kind == TypeKind::Proc && recv_desc.type_params.size > 0
            proc_return = recv_desc.type_params.last
            return_type = proc_return unless proc_return == TypeRef::VOID
          end
        end
      end

      if filter = env_get("DEBUG_CALL_RETURN")
        if mangled_method_name.includes?(filter) || base_method_name.includes?(filter)
          rt_name = get_type_name_from_ref(return_type)
          STDERR.puts "[CALL_RETURN] name=#{mangled_method_name} base=#{base_method_name} type=#{rt_name}"
        end
      end
      if unresolved_generic_return_type?(return_type)
        def_node = @function_defs[mangled_method_name]? || @function_defs[base_method_name]?
        if def_node
          owner_name = receiver_id ? get_type_name_from_ref(ctx.type_of(receiver_id)) : @current_class
          if inferred = infer_return_type_from_callsite(def_node, owner_name, call_args, node.named_args, @current_class)
            if inferred != TypeRef::VOID && inferred != TypeRef::NIL
              return_type = inferred
              register_function_type(mangled_method_name, inferred)
              register_function_type(base_method_name, inferred) unless base_method_name == mangled_method_name
            end
          end
        end
      end
      debug_get_cache = env_get("DEBUG_GET_CACHE_TYPE") && method_name == "get_cache"
      if env_get("DEBUG_HIGH_METHOD") && method_name == "high"
        recv_type_name = receiver_id ? get_type_name_from_ref(ctx.type_of(receiver_id)) : "(nil)"
        STDERR.puts "[DEBUG_HIGH] method=high mangled=#{mangled_method_name} recv_type=#{recv_type_name} return=#{get_type_name_from_ref(return_type)} current_class=#{@current_class || "nil"}"
      end
      if debug_get_cache
        rt_name = get_type_name_from_ref(return_type)
        recv_type_name = receiver_id ? get_type_name_from_ref(ctx.type_of(receiver_id)) : "(nil)"
        STDERR.puts "[GET_CACHE_RT] 1. initial mangled=#{mangled_method_name} base=#{base_method_name} return=#{rt_name} recv_id=#{receiver_id || "nil"} recv_type=#{recv_type_name} current_class=#{@current_class || "nil"}"
      end

      has_typed_args = arg_types.any? { |t| t != TypeRef::VOID }
      if has_typed_args
        base_block_mangled = mangle_function_name(base_method_name, [] of TypeRef, has_block_call)
        if mangled_method_name == base_block_mangled
          mangled_method_name = mangle_function_name(base_method_name, arg_types, has_block_call)
        end
      end
      base_signature_exists = @function_types.has_key?(base_method_name)
      if base_signature_exists && !@function_types.has_key?(mangled_method_name) && mangled_method_name != base_method_name
        return_type = get_function_return_type(base_method_name)
        mangled_method_name = base_method_name unless has_typed_args
      end
      if method_name == "to_s" && arg_types.empty? &&
         (return_type == TypeRef::VOID || return_type == TypeRef::NIL)
        return_type = TypeRef::STRING
      end

      # Check if function exists in module by base name (for unqualified functions).
      base_func_exists = @module.has_function?(base_method_name)

      if base_func_exists && !base_method_name.includes?('#') && !base_method_name.includes?('.') && !has_typed_args
        # Function exists with base name - use that (no mangling needed for simple functions)
        return_type = get_function_return_type(base_method_name) if return_type == TypeRef::VOID
        mangled_method_name = base_method_name
      elsif return_type == TypeRef::VOID && mangled_method_name != base_method_name &&
            !base_method_name.includes?('#') && !base_method_name.includes?('.') && !has_typed_args
        # Try unmangled name as fallback for unqualified functions.
        return_type = get_function_return_type(base_method_name)
        if return_type != TypeRef::VOID
          mangled_method_name = base_method_name
        end
      end

      block_return_name = nil
      if block_id
        block_return_name = block_return_type_name(ctx, block_id)
      elsif block_for_inline
        block_return_name = inline_block_return_type_name(block_for_inline, block_param_types_inline, @current_class)
      end
      if block_return_name.nil? && block_for_inline
        block_return_name = inline_block_return_type_name(block_for_inline, block_param_types_inline, @current_class)
      end
      if block_return_name
        if type_param_name = block_return_type_param_name(mangled_method_name, base_method_name)
          record_pending_type_param_map(mangled_method_name, {type_param_name => block_return_name})
        end
        # Always record block return type for typeof(yield ...) resolution.
        # Use @function_type_param_maps (persistent) instead of pending
        # (consumed-once), since the function may be lowered before this
        # callsite records the params.  Merge to preserve existing params.
        {mangled_method_name, base_method_name}.each do |fn|
          next if fn.empty?
          if existing = @function_type_param_maps[fn]?
            @function_type_param_maps[fn] = existing.merge({"__block_return__" => block_return_name})
          else
            @function_type_param_maps[fn] = {"__block_return__" => block_return_name}
          end
        end
        if inferred = resolve_block_dependent_return_type(mangled_method_name, base_method_name, block_return_name)
          return_type = inferred
        end
        if receiver_id && (method_name == "map" || method_name == "map_with_index")
          if tuple_return = tuple_map_return_type(ctx.type_of(receiver_id), block_return_name)
            return_type = tuple_return
          end
        end
      end
      if env_get("DEBUG_BLOCK_RETURN") && (mangled_method_name.includes?("sort_by") || base_method_name.includes?("sort_by"))
        STDERR.puts "[BLOCK_RETURN] method=#{mangled_method_name} base=#{base_method_name} return=#{block_return_name || "nil"}"
      end

      if block_return_name && method_name == "try"
        inferred = type_ref_for_name(block_return_name)
        if receiver_id && is_union_or_nilable_type?(ctx.type_of(receiver_id))
          inferred = create_union_type_for_nullable(inferred)
        end
        return_type = inferred if inferred != TypeRef::VOID
      end

      if block_return_name
        if yield_return_function_for_call(mangled_method_name, base_method_name)
          inferred = type_ref_for_name(block_return_name)
          return_type = inferred if inferred != TypeRef::VOID
        end
      end

      if proc_return_type_name && method_name == "new"
        if proc_ref = proc_type_ref_for_name(proc_return_type_name.not_nil!)
          return_type = proc_ref
        end
      end

      if receiver_id
        if tuple_return = tuple_return_type_for_method(ctx.type_of(receiver_id), method_name)
          return_type = tuple_return
        end
      end

      if receiver_id && method_name.ends_with?('?')
        # For Hash#[]? and similar query methods, infer nilable return type.
        # Hash#[]? has an LLVM override that returns Nil | V union, so the call site
        # must also use the union type. Without this, `if val = h[key]?` treats val as
        # the raw value type (always truthy) instead of Nil | V (properly nilable).
        recv_type_for_infer = ctx.type_of(receiver_id)
        recv_desc_for_infer = @module.get_type_descriptor(recv_type_for_infer)
        # Only apply nilable inference for Hash receivers (which have LLVM override)
        # and when return type is not already nilable/bool
        is_hash_receiver = recv_desc_for_infer && recv_desc_for_infer.kind == TypeKind::Hash
        should_infer_nilable = if is_hash_receiver && method_name == "[]?"
                                 true
                               else
                                 (return_type == TypeRef::BOOL ||
                                  return_type == TypeRef::VOID ||
                                  return_type == TypeRef::NIL) &&
                                 NILABLE_QUERY_METHODS.includes?(method_name)
                               end
        if should_infer_nilable
          if inferred = infer_unannotated_query_return_type(method_name, recv_type_for_infer)
            return_type = inferred
          end
        end
      end
      if receiver_id && (method_name == "first" || method_name == "last" || method_name == "first?" || method_name == "last?")
        recv_type = ctx.type_of(receiver_id)
        recv_desc = @module.get_type_descriptor(recv_type)
        type_name = recv_desc ? recv_desc.name : get_type_name_from_ref(recv_type)
        if elem_name = element_type_for_type_name(type_name)
          elem_ref = type_ref_for_name(elem_name)
          if elem_ref != TypeRef::VOID
            return_type = method_name.ends_with?('?') ? create_union_type_for_nullable(elem_ref) : elem_ref
            if env_get("DEBUG_FIRST_LAST_RETURN")
              recv_name = get_type_name_from_ref(recv_type)
              ret_name = get_type_name_from_ref(return_type)
              STDERR.puts "[FIRST_LAST_RETURN] method=#{method_name} recv=#{recv_name} elem=#{elem_name} ret=#{ret_name}"
            end
          end
        end
      end

      if env_get("DEBUG_CALL_RETURN") && (mangled_method_name.includes?("PointerPairingHeap") || base_method_name.includes?("PointerPairingHeap"))
        STDERR.puts "[CALL_RETURN] before name=#{mangled_method_name} base=#{base_method_name} return=#{get_type_name_from_ref(return_type)}"
      end

      if return_type == TypeRef::VOID || return_type == TypeRef::NIL
        if inferred = resolve_return_type_from_def(mangled_method_name, base_method_name, receiver_id ? ctx.type_of(receiver_id) : nil)
          return_type = inferred unless inferred == TypeRef::VOID || inferred == TypeRef::NIL
          if debug_get_cache
            rt_name = get_type_name_from_ref(return_type)
            STDERR.puts "[GET_CACHE_RT] 2. after resolve_return_type_from_def return_type=#{rt_name}"
          end
        end
      end

      if def_node = @function_defs[mangled_method_name]? || @function_defs[base_method_name]?
        param_map = {} of String => String
        if params = def_node.params
          param_index = 0
          params.each do |param|
            next if named_only_separator?(param)
            next if param.is_block
            break if param_index >= callsite_arg_types.size
            param_name = param.name ? String.new(param.name.not_nil!) : ""
            literal_param = callsite_arg_literals && callsite_arg_literals[param_index]?
            if literal_param || param_name.ends_with?("_class") || param_name.ends_with?("int_class")
              type_name = get_type_name_from_ref(callsite_arg_types[param_index])
              if !param_name.empty? && !type_name.empty? && type_name != "Void" && type_name != "Unknown"
                param_map[param_name] = type_name
              end
            end
            param_index += 1 unless param.is_double_splat
          end
        end
        if !param_map.empty?
          return_name = get_type_name_from_ref(return_type)
          substituted = substitute_type_params(return_name, param_map)
          if substituted != return_name
            specialized = type_ref_for_name(substituted)
            return_type = specialized unless specialized == TypeRef::VOID
          end
        end
      end

      if env_get("DEBUG_CALL_RETURN") && (mangled_method_name.includes?("PointerPairingHeap") || base_method_name.includes?("PointerPairingHeap"))
        STDERR.puts "[CALL_RETURN] after name=#{mangled_method_name} base=#{base_method_name} return=#{get_type_name_from_ref(return_type)}"
      end

      # If still not found and receiver_id is set, try to find method in any class.
      # NOTE: Only do this when we couldn't resolve the receiver class; otherwise it can
      # incorrectly bind to a different specialization (e.g., Hash(Int32, Bool)#[]?).
      if return_type == TypeRef::VOID && receiver_id && full_method_name.nil?
        receiver_type = ctx.type_of(receiver_id)
        type_desc = @module.get_type_descriptor(receiver_type)
        if receiver_type == TypeRef::VOID || type_desc.nil?
          if candidates = @method_bases_by_name[method_name]?
            matches = [] of String
            candidates.each do |test_base|
              test_mangled = mangle_function_name(test_base, arg_types)
              if @function_types.has_key?(test_mangled)
                matches << test_mangled
              elsif @function_types.has_key?(test_base)
                matches << test_base
              end
            end
            if matches.size == 1
              resolved = matches.first
              return_type = @function_types[resolved]
              mangled_method_name = resolved
            end
          end
        end
      end

      # Ensure synthetic accessors exist for direct ivar access.
      if receiver_id
        missing_impl = mangled_method_name && !@module.has_function?(mangled_method_name)
        if return_type == TypeRef::VOID || missing_impl
          if accessor = ensure_accessor_method(ctx, receiver_id, method_name)
            return_type = accessor[0]
            mangled_method_name = accessor[1]
            if debug_get_cache
              rt_name = get_type_name_from_ref(return_type)
              STDERR.puts "[GET_CACHE_RT] 2d. ensure_accessor_method => return=#{rt_name} mangled=#{mangled_method_name}"
            end
          end
        end
      end

      # Check for primitive binary operator inlining
      # When calling methods like Int32#+ on primitive types, emit BinaryOperation instead of Call
      if receiver_id && args.size == 1
        receiver_type = ctx.type_of(receiver_id)
        # Also treat enum-typed receivers as numeric for binary ops (==, !=, <, etc.)
        is_enum_receiver = false
        if !numeric_primitive?(receiver_type)
          enum_name = @enum_value_types.try(&.[receiver_id]?)
          if enum_name.nil? && receiver_type.id >= TypeRef::FIRST_USER_TYPE
            type_name = get_type_name_from_ref(receiver_type)
            enum_name = type_name if @enum_info.try(&.has_key?(type_name))
          end
          if enum_name
            base = enum_base_type(enum_name)
            if receiver_type != base
              cast = Cast.new(ctx.next_id, base, receiver_id, base, safe: false)
              ctx.emit(cast)
              ctx.register_type(cast.id, base)
              receiver_id = cast.id
              receiver_type = base
            end
            is_enum_receiver = true
          end
        end
        if numeric_primitive?(receiver_type)
          if bin_op = binary_op_for_method(method_name)
            # Emit native binary operation instead of method call
            # Return type is same as receiver type for arithmetic, bool for comparisons
            result_type = case bin_op
                          when BinaryOp::Eq, BinaryOp::Ne, BinaryOp::Lt, BinaryOp::Le,
                               BinaryOp::Gt, BinaryOp::Ge, BinaryOp::And, BinaryOp::Or
                            TypeRef::BOOL
                          else
                            receiver_type
                          end
            bin_node = BinaryOperation.new(ctx.next_id, result_type, bin_op, receiver_id, args[0])
            ctx.emit(bin_node)
            return bin_node.id
          end
        end
      end

      if receiver_id && method_name == "ord" && args.empty?
        receiver_type = ctx.type_of(receiver_id)
        if receiver_type == TypeRef::CHAR
          cast = Cast.new(ctx.next_id, TypeRef::INT32, receiver_id, TypeRef::INT32)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT32)
          return cast.id
        end
      end

      if receiver_id && method_name == "unsafe_chr" && args.empty?
        receiver_type = ctx.type_of(receiver_id)
        if receiver_type == TypeRef::VOID
          # Assume numeric receiver when type info is missing.
          ctx.register_type(receiver_id, TypeRef::INT32)
          receiver_type = TypeRef::INT32
        end
        if is_union_or_nilable_type?(receiver_type)
          nil_variant_id = get_union_variant_id(receiver_type, TypeRef::NIL)
          if nil_variant_id >= 0
            unwrapped = lower_not_nil_intrinsic(ctx, receiver_id, receiver_type)
            unwrapped_type = ctx.type_of(unwrapped)
            if numeric_primitive?(unwrapped_type)
              cast = Cast.new(ctx.next_id, TypeRef::CHAR, unwrapped, TypeRef::CHAR)
              ctx.emit(cast)
              ctx.register_type(cast.id, TypeRef::CHAR)
              return cast.id
            elsif unwrapped_type == TypeRef::CHAR
              return unwrapped
            end
          elsif type_desc = @module.get_type_descriptor(receiver_type)
            variants = split_union_type_name(type_desc.name)
            idx = variants.index do |variant|
              next false if variant == "Nil"
              numeric_primitive?(type_ref_for_name(variant))
            end
            if idx
              unwrap_type = type_ref_for_name(variants[idx])
              unwrapped = UnionUnwrap.new(ctx.next_id, unwrap_type, receiver_id, idx, false)
              ctx.emit(unwrapped)
              ctx.register_type(unwrapped.id, unwrap_type)
              if numeric_primitive?(unwrap_type)
                cast = Cast.new(ctx.next_id, TypeRef::CHAR, unwrapped.id, TypeRef::CHAR)
                ctx.emit(cast)
                ctx.register_type(cast.id, TypeRef::CHAR)
                return cast.id
              end
            else
              idx = variants.index { |variant| variant == "Char" }
              if idx
                unwrap_type = TypeRef::CHAR
                unwrapped = UnionUnwrap.new(ctx.next_id, unwrap_type, receiver_id, idx, false)
                ctx.emit(unwrapped)
                ctx.register_type(unwrapped.id, unwrap_type)
                return unwrapped.id
              end
            end
          end
        end
        case receiver_type
        when TypeRef::CHAR
          return receiver_id
        when TypeRef::INT8, TypeRef::INT16, TypeRef::INT32, TypeRef::INT64, TypeRef::INT128,
             TypeRef::UINT8, TypeRef::UINT16, TypeRef::UINT32, TypeRef::UINT64, TypeRef::UINT128
          cast = Cast.new(ctx.next_id, TypeRef::CHAR, receiver_id, TypeRef::CHAR)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::CHAR)
          return cast.id
        end
        # Fallback: treat unsafe_chr as an unchecked numeric->Char conversion.
        cast = Cast.new(ctx.next_id, TypeRef::CHAR, receiver_id, TypeRef::CHAR)
        ctx.emit(cast)
        ctx.register_type(cast.id, TypeRef::CHAR)
        return cast.id
      end

      # Primitive numeric conversions (to_i*, to_u*, to_f*).
      if env_get("DEBUG_UNION_CONV") && method_name.starts_with?("to_") && (method_name.ends_with?('!') || method_name.includes?("32") || method_name.includes?("64"))
        STDERR.puts "[UNION_CONV_ENTRY] method=#{method_name} receiver_id=#{receiver_id} args=#{args.size}"
      end
      if receiver_id && args.empty?
        receiver_type = ctx.type_of(receiver_id)
        target_type = case method_name
                      when "to_i", "to_i32", "to_i32!"
                        TypeRef::INT32
                      when "to_i8", "to_i8!"
                        TypeRef::INT8
                      when "to_i16", "to_i16!"
                        TypeRef::INT16
                      when "to_i64", "to_i64!"
                        TypeRef::INT64
                      when "to_i128", "to_i128!"
                        TypeRef::INT128
                      when "to_u", "to_u32", "to_u32!"
                        TypeRef::UINT32
                      when "to_u8", "to_u8!"
                        TypeRef::UINT8
                      when "to_u16", "to_u16!"
                        TypeRef::UINT16
                      when "to_u64", "to_u64!"
                        TypeRef::UINT64
                      when "to_u128", "to_u128!"
                        TypeRef::UINT128
                      when "to_f", "to_f64", "to_f64!"
                        TypeRef::FLOAT64
                      when "to_f32", "to_f32!"
                        TypeRef::FLOAT32
                      else
                        nil
                      end
        if target_type
          if env_get("DEBUG_UNION_CONV") && (method_name == "to_i32!" || method_name == "to_u32!" || method_name == "to_u64!")
            desc_name = @module.get_type_descriptor(receiver_type).try(&.name) || "(nil)"
            is_union = is_union_or_nilable_type?(receiver_type)
            is_prim = numeric_primitive?(receiver_type)
            STDERR.puts "[UNION_CONV] method=#{method_name} receiver_type=#{receiver_type.id} desc=#{desc_name} is_union=#{is_union} is_prim=#{is_prim}"
          end
          if receiver_type == TypeRef::VOID
            # Treat unknown receivers as target type to avoid invalid pointer casts.
            # Call-site coercion will handle the actual conversion when needed.
            ctx.register_type(receiver_id, target_type)
            return receiver_id
          end
          if is_union_or_nilable_type?(receiver_type)
            type_name = nil.as(String?)
            variants = nil.as(Array(String)?)
            if type_desc = @module.get_type_descriptor(receiver_type)
              variants = split_union_type_name(type_desc.name)
            else
              type_name = get_type_name_from_ref(receiver_type)
              if type_name.includes?('|')
                variants = split_union_type_name(type_name)
              end
            end
            if variants
              idx = variants.index do |variant|
                next false if variant == "Nil"
                numeric_primitive?(type_ref_for_name(variant))
              end
              if idx
                unwrap_type = type_ref_for_name(variants[idx])
                unwrapped = UnionUnwrap.new(ctx.next_id, unwrap_type, receiver_id, idx, false)
                ctx.emit(unwrapped)
                ctx.register_type(unwrapped.id, unwrap_type)
                if numeric_primitive?(unwrap_type)
                  return unwrapped.id if unwrap_type == target_type
                  cast = Cast.new(ctx.next_id, target_type, unwrapped.id, target_type)
                  ctx.emit(cast)
                  ctx.register_type(cast.id, target_type)
                  return cast.id
                end
              end
            end
          end
          if numeric_primitive?(receiver_type)
            return receiver_id if receiver_type == target_type
            cast = Cast.new(ctx.next_id, target_type, receiver_id, target_type)
            ctx.emit(cast)
            ctx.register_type(cast.id, target_type)
            return cast.id
          end
        end
      end

      # Primitive numeric predicates and shifts.
      if receiver_id && numeric_primitive?(ctx.type_of(receiver_id))
        receiver_type = ctx.type_of(receiver_id)
        # Handle zero? and none? (flags enums use none? which is equivalent to zero?)
        if (method_name == "zero?" || method_name == "none?") && args.empty?
          zero = Literal.new(ctx.next_id, receiver_type, 0_i64)
          ctx.emit(zero)
          ctx.register_type(zero.id, receiver_type)
          cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, receiver_id, zero.id)
          ctx.emit(cmp)
          ctx.register_type(cmp.id, TypeRef::BOOL)
          return cmp.id
        end
        if receiver_type == TypeRef::UINT8 && method_name == "ascii?" && args.empty?
          limit = Literal.new(ctx.next_id, TypeRef::UINT8, 128_i64)
          ctx.emit(limit)
          ctx.register_type(limit.id, TypeRef::UINT8)
          cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, receiver_id, limit.id)
          ctx.emit(cmp)
          ctx.register_type(cmp.id, TypeRef::BOOL)
          return cmp.id
        end
        if receiver_type == TypeRef::UINT8 && method_name == "ord" && args.empty?
          cast = Cast.new(ctx.next_id, TypeRef::INT32, receiver_id, TypeRef::INT32)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT32)
          return cast.id
        end
        if (method_name == "unsafe_shl" || method_name == "unsafe_shr") && args.size == 1
          op = method_name == "unsafe_shl" ? BinaryOp::Shl : BinaryOp::Shr
          shift = BinaryOperation.new(ctx.next_id, receiver_type, op, receiver_id, args[0])
          ctx.emit(shift)
          ctx.register_type(shift.id, receiver_type)
          return shift.id
        end
        if method_name == "unsafe_div" && args.size == 1
          div = BinaryOperation.new(ctx.next_id, receiver_type, BinaryOp::Div, receiver_id, args[0])
          ctx.emit(div)
          ctx.register_type(div.id, receiver_type)
          return div.id
        end
        if method_name == "unsafe_mod" && args.size == 1
          rem = BinaryOperation.new(ctx.next_id, receiver_type, BinaryOp::Mod, receiver_id, args[0])
          ctx.emit(rem)
          ctx.register_type(rem.id, receiver_type)
          return rem.id
        end
      end

      # Pointer address conversions.
      if receiver_id && args.empty?
        receiver_type = ctx.type_of(receiver_id)
        recv_type_desc = @module.get_type_descriptor(receiver_type)
        is_pointer_type = receiver_type == TypeRef::POINTER ||
                          (recv_type_desc && recv_type_desc.name.starts_with?("Pointer"))
        if is_pointer_type
          case method_name
          when "address", "to_u64"
            cast = Cast.new(ctx.next_id, TypeRef::UINT64, receiver_id, TypeRef::UINT64)
            ctx.emit(cast)
            ctx.register_type(cast.id, TypeRef::UINT64)
            return cast.id
          when "null?"
            # Pointer#null? → ptrtoint self == 0
            addr = Cast.new(ctx.next_id, TypeRef::UINT64, receiver_id, TypeRef::UINT64)
            ctx.emit(addr)
            ctx.register_type(addr.id, TypeRef::UINT64)
            zero = Literal.new(ctx.next_id, TypeRef::UINT64, 0_i64)
            ctx.emit(zero)
            cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, addr.id, zero.id)
            ctx.emit(cmp)
            ctx.register_type(cmp.id, TypeRef::BOOL)
            return cmp.id
          when "to_i", "to_i64"
            cast = Cast.new(ctx.next_id, TypeRef::INT64, receiver_id, TypeRef::INT64)
            ctx.emit(cast)
            ctx.register_type(cast.id, TypeRef::INT64)
            return cast.id
          when "to_f64"
            int_cast = Cast.new(ctx.next_id, TypeRef::UINT64, receiver_id, TypeRef::UINT64)
            ctx.emit(int_cast)
            ctx.register_type(int_cast.id, TypeRef::UINT64)
            float_cast = Cast.new(ctx.next_id, TypeRef::FLOAT64, int_cast.id, TypeRef::FLOAT64)
            ctx.emit(float_cast)
            ctx.register_type(float_cast.id, TypeRef::FLOAT64)
            return float_cast.id
          end
        end
      end

      if receiver_id && method_name == "hash" && args.size == 1
        receiver_type = ctx.type_of(receiver_id)
        recv_type_desc = @module.get_type_descriptor(receiver_type)
        is_pointer_type = receiver_type == TypeRef::POINTER ||
                          (recv_type_desc && recv_type_desc.name.starts_with?("Pointer"))
        if is_pointer_type
          cast = Cast.new(ctx.next_id, TypeRef::UINT64, receiver_id, TypeRef::UINT64)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::UINT64)
          hasher_type = ctx.type_of(args[0])
          if hasher_type == TypeRef::VOID
            inferred = type_ref_for_name("Crystal::Hasher")
            hasher_type = inferred unless inferred == TypeRef::VOID
          end
          hasher_type = TypeRef::POINTER if hasher_type == TypeRef::VOID
          hash_name = mangle_function_name("UInt64#hash", [hasher_type])
          lower_function_if_needed(hash_name)
          call = Call.new(ctx.next_id, hasher_type, cast.id, hash_name, args)
          ctx.emit(call)
          ctx.register_type(call.id, hasher_type)
          return call.id
        end
      end

      # Check for pointer primitive operations
      # Pointer(T).malloc(count) -> PointerMalloc
      if full_method_name && full_method_name.starts_with?("Pointer(") && method_name == "malloc" && args.size == 1
        pointer_type_name = method_owner(full_method_name)
        pointer_type_ref = type_ref_for_name(pointer_type_name)
        element_type = pointer_element_type(full_method_name)
        result_type = pointer_type_ref == TypeRef::VOID ? TypeRef::POINTER : pointer_type_ref
        malloc_node = PointerMalloc.new(ctx.next_id, result_type, element_type, args[0])
        ctx.emit(malloc_node)
        ctx.register_type(malloc_node.id, result_type)
        return malloc_node.id
      end

      if full_method_name && (full_method_name == "Pointer.new" || full_method_name.starts_with?("Pointer(")) && method_name == "new" && args.size == 1
        if lowered = lower_pointer_new_intrinsic(ctx, args)
          if full_method_name.starts_with?("Pointer(")
            pointer_type_name = full_method_name.rchop(".new")
            pointer_type_ref = type_ref_for_name(pointer_type_name)
            ctx.register_type(lowered, pointer_type_ref) unless pointer_type_ref == TypeRef::VOID
          end
          return lowered
        end
      end

      if full_method_name && full_method_name.starts_with?("Pointer(") && method_name == "null" && args.empty?
        zero = Literal.new(ctx.next_id, TypeRef::INT64, 0_i64)
        ctx.emit(zero)
        ctx.register_type(zero.id, TypeRef::INT64)
        pointer_type_name = full_method_name.rchop(".null")
        pointer_type_ref = type_ref_for_name(pointer_type_name)
        result_type = pointer_type_ref == TypeRef::VOID ? TypeRef::POINTER : pointer_type_ref
        cast = Cast.new(ctx.next_id, result_type, zero.id, result_type)
        ctx.emit(cast)
        ctx.register_type(cast.id, result_type)
        return cast.id
      end

      # ptr.value or ptr[index] -> PointerLoad
      if receiver_id && (method_name == "value" || method_name == "[]")
        receiver_type = ctx.type_of(receiver_id)
        recv_type_desc = @module.get_type_descriptor(receiver_type)
        if recv_type_desc && recv_type_desc.kind == TypeKind::Union
          if unwrapped = unwrap_pointer_union(ctx, receiver_id, receiver_type)
            receiver_id, receiver_type = unwrapped
            recv_type_desc = @module.get_type_descriptor(receiver_type)
          end
        end
        is_pointer_type = receiver_type == TypeRef::POINTER ||
                          (recv_type_desc && recv_type_desc.kind == TypeKind::Pointer)
        if env_has?("DEBUG_PTR_VALUE")
          STDERR.puts "[DEBUG_PTR_VALUE] method=#{method_name} receiver_type.id=#{receiver_type.id} desc=#{recv_type_desc.try(&.name)} is_pointer=#{is_pointer_type}"
        end
        if is_pointer_type
          index_id = if method_name == "[]" && args.size == 1
                       args[0]
                     else
                       nil
                     end
          # Return the dereferenced type from Pointer(T) -> T
          deref_type = if recv_type_desc && recv_type_desc.name.starts_with?("Pointer(") && recv_type_desc.name.ends_with?(')')
                         element_type_name = recv_type_desc.name[8...-1]
                         type_ref_for_name(element_type_name)
                       else
                         TypeRef::UINT8 # Fallback for untyped pointers
                       end
          load_node = PointerLoad.new(ctx.next_id, deref_type, receiver_id, index_id)
          ctx.emit(load_node)
          ctx.register_type(load_node.id, deref_type)
          return load_node.id
        end
      end

      # ptr.value= or ptr[index]= -> PointerStore
      if receiver_id && (method_name == "value=" || method_name == "[]=")
        receiver_type = ctx.type_of(receiver_id)
        recv_type_desc = @module.get_type_descriptor(receiver_type)
        if recv_type_desc && recv_type_desc.kind == TypeKind::Union
          if value_type = args.first?
            if unwrapped = unwrap_pointer_union(ctx, receiver_id, receiver_type, ctx.type_of(value_type))
              receiver_id, receiver_type = unwrapped
              recv_type_desc = @module.get_type_descriptor(receiver_type)
            end
          end
        end
        is_pointer_type = receiver_type == TypeRef::POINTER ||
                          (recv_type_desc && recv_type_desc.kind == TypeKind::Pointer)
        if is_pointer_type
          if method_name == "value=" && args.size == 1
            store_node = PointerStore.new(ctx.next_id, TypeRef::VOID, receiver_id, args[0], nil)
            ctx.emit(store_node)
            return store_node.id
          elsif method_name == "[]=" && args.size == 2
            store_node = PointerStore.new(ctx.next_id, TypeRef::VOID, receiver_id, args[1], args[0])
            ctx.emit(store_node)
            return store_node.id
          end
        end
      end

      # ptr + offset or ptr - offset -> PointerAdd
      if receiver_id && (method_name == "+" || method_name == "-") && args.size == 1
        receiver_type = ctx.type_of(receiver_id)
        recv_type_desc = @module.get_type_descriptor(receiver_type)
        if recv_type_desc && recv_type_desc.kind == TypeKind::Union
          if unwrapped = unwrap_pointer_union(ctx, receiver_id, receiver_type)
            receiver_id, receiver_type = unwrapped
            recv_type_desc = @module.get_type_descriptor(receiver_type)
          end
        end
        is_pointer_type = receiver_type == TypeRef::POINTER ||
                          (recv_type_desc && recv_type_desc.kind == TypeKind::Pointer)
        if is_pointer_type
          offset_id = args[0]
          # For subtraction, negate the offset
          if method_name == "-"
            neg_one = Literal.new(ctx.next_id, TypeRef::INT32, -1_i64)
            ctx.emit(neg_one)
            ctx.register_type(neg_one.id, TypeRef::INT32)
            neg_offset = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Mul, offset_id, neg_one.id)
            ctx.emit(neg_offset)
            ctx.register_type(neg_offset.id, TypeRef::INT32)
            offset_id = neg_offset.id
          end
          element_type = if recv_type_desc && recv_type_desc.name.starts_with?("Pointer(")
                           pointer_element_type(recv_type_desc.name)
                         else
                           TypeRef::INT32
                         end
          result_type = receiver_type == TypeRef::VOID ? TypeRef::POINTER : receiver_type
          add_node = PointerAdd.new(ctx.next_id, result_type, receiver_id, offset_id, element_type)
          ctx.emit(add_node)
          ctx.register_type(add_node.id, result_type)
          return add_node.id
        end
      end

      # ptr.realloc(new_count) -> PointerRealloc
      if receiver_id && method_name == "realloc" && args.size == 1
        receiver_type = ctx.type_of(receiver_id)
        recv_type_desc = @module.get_type_descriptor(receiver_type)
        is_pointer_type = receiver_type == TypeRef::POINTER ||
                          (recv_type_desc && recv_type_desc.name.starts_with?("Pointer"))
        if is_pointer_type
          result_type = receiver_type == TypeRef::VOID ? TypeRef::POINTER : receiver_type
          realloc_node = PointerRealloc.new(ctx.next_id, result_type, receiver_id, args[0])
          ctx.emit(realloc_node)
          ctx.register_type(realloc_node.id, result_type)
          return realloc_node.id
        end
      end

      # ptr.copy_from(source, count) / ptr.copy_to(target, count) → runtime memcpy
      # ptr.move_from(source, count) / ptr.move_to(target, count) → runtime memmove
      # Crystal stdlib chains copy_from → copy_to → copy_from_impl which loses
      # the element type (resolves to Pointer(Void)), so we intercept at the top level.
      if receiver_id && (method_name == "copy_from" || method_name == "copy_to" ||
                         method_name == "move_from" || method_name == "move_to") && args.size >= 2
        receiver_type = ctx.type_of(receiver_id)
        recv_type_desc = @module.get_type_descriptor(receiver_type)
        is_pointer_type = receiver_type == TypeRef::POINTER ||
                          (recv_type_desc && (recv_type_desc.kind == TypeKind::Pointer ||
                           recv_type_desc.name.starts_with?("Pointer")))
        if is_pointer_type
          # Determine element size from pointer type
          recv_name = recv_type_desc.try(&.name) || "Pointer(Void)"
          elem_type = pointer_element_type(recv_name)
          elem_size = size_for_type_name(get_type_name_from_ref(elem_type))

          # For copy_from/move_from: dest=self, src=arg[0], count=arg[1]
          # For copy_to/move_to:     dest=arg[0], src=self, count=arg[1]
          is_copy = method_name == "copy_from" || method_name == "copy_to"
          is_from = method_name == "copy_from" || method_name == "move_from"
          helper = is_copy ? "__crystal_v2_ptr_copy" : "__crystal_v2_ptr_move"
          dest_id = is_from ? receiver_id : args[0]
          src_id = is_from ? args[0] : receiver_id
          count_id = args[1]

          elem_size_lit = Literal.new(ctx.next_id, TypeRef::INT32, elem_size)
          ctx.emit(elem_size_lit)
          ctx.register_type(elem_size_lit.id, TypeRef::INT32)

          copy_call = ExternCall.new(ctx.next_id, TypeRef::POINTER, helper,
                                     [dest_id, src_id, count_id, elem_size_lit.id] of ValueId)
          ctx.emit(copy_call)
          ctx.register_type(copy_call.id, receiver_type)
          return copy_call.id
        end
      end

      # For allocator calls (ClassName.new), ensure return type is the class type
      # This handles cases where the mangled name wasn't found in @function_types
      if method_name == "new" && full_method_name && return_type == TypeRef::VOID
        # Extract class name from "ClassName.new"
        class_name = full_method_name.rchop(".new")
        if class_info = @class_info[class_name]?
          return_type = class_info.type_ref
        else
          # Try resolving nested class names (e.g., "Crystal::Lexer" → check short name)
          short_name = class_name.includes?("::") ? class_name.split("::").last : nil
          found_via_short = false
          if short_name
            # Try progressively shorter qualified names
            parts = class_name.split("::")
            (parts.size - 1).downto(1) do |i|
              candidate = parts[i..].join("::")
              if ci = @class_info[candidate]?
                return_type = ci.type_ref
                found_via_short = true
                break
              end
            end
            # Also try full name with different namespace resolutions
            unless found_via_short
              @class_info.each_key do |k|
                if k.ends_with?(class_name) || k.ends_with?(short_name.not_nil!)
                  return_type = @class_info[k].type_ref
                  found_via_short = true
                  break
                end
              end
            end
          end
          unless found_via_short
            # Unknown class (probably from stdlib) - use pointer type as fallback
            # This ensures exception types like ArgumentError work correctly
            return_type = TypeRef::POINTER
          end
        end
      end

      # For method calls that return void but are likely returning the receiver or a value,
      # use pointer type as fallback to avoid void type errors in LLVM
      if return_type == TypeRef::VOID && receiver_id
        # Methods that typically return self or a collection (stdlib methods)
        methods_returning_self_or_value = ["to_a", "to_s", "map", "select", "reduce", "each",
                                           "first", "last", "dup", "clone", "cover",
                                           "compact", "flatten", "sort", "reverse", "uniq",
                                           "join", "split", "strip", "chomp", "chars",
                                           "keys", "values", "value", # 'value' is common getter
                                           "lines", "bytes", "codepoints", "graphemes",
                                           "rstrip", "lstrip", "downcase", "upcase", "capitalize",
                                           "gsub", "sub", "tr", "delete", "squeeze",
                                           "rjust", "ljust", "center", "each_line",
                                           "each_with_index", "map_with_index", "select_with_index",
                                           "index", "rindex", "find", "find_index", "count",
                                           "sum", "product", "min", "max", "minmax", "sample",
                                           "take", "drop", "take_while", "drop_while",
                                           "group_by", "partition", "zip", "transpose",
                                           "shuffle", "rotate", "pop", "shift", "slice",
                                           "to_slice", "to_unsafe", "to_h", "to_set", "copy_from"]
        if methods_returning_self_or_value.includes?(method_name)
          return_type = TypeRef::POINTER
          if debug_get_cache
            STDERR.puts "[GET_CACHE_RT] 2a. methods_returning_self_or_value => Pointer"
          end
        end
      end

      # Methods that return the same type as the receiver.
      # Handle this even if return_type is NIL (often incorrectly registered for abstract modules).
      methods_returning_receiver_type = ["tap", "itself", "clamp", "abs", "ceil", "floor", "round", "truncate",
                                         "remainder", "tdiv", "unsafe_mod", "unsafe_div", "gcd", "lcm"]
      if receiver_id && methods_returning_receiver_type.includes?(method_name)
        recv_type = ctx.type_of(receiver_id)
        # Only override if receiver is not Nil (these methods don't make sense on Nil)
        if recv_type != TypeRef::NIL && recv_type != TypeRef::VOID
          if env_has?("DEBUG_RECV_TYPE") && (method_name == "abs" || method_name == "remainder")
            STDERR.puts "[RECV_TYPE_CALL] method=#{method_name} recv_type=#{recv_type.id} old_return=#{return_type.id} current_class=#{@current_class || ""} current_method=#{@current_method || ""}"
          end
          return_type = recv_type
        elsif env_has?("DEBUG_RECV_TYPE") && (method_name == "abs" || method_name == "remainder")
          STDERR.puts "[RECV_TYPE_CALL_SKIP] method=#{method_name} recv_type=#{recv_type.id} return=#{return_type.id} current_class=#{@current_class || ""} current_method=#{@current_method || ""}"
        end
      end

      if receiver_id && method_name == "hash" && !arg_types.empty?
        first_arg = arg_types.first
        if first_arg != TypeRef::VOID && (return_type == TypeRef::VOID || return_type == TypeRef::POINTER || return_type == TypeRef::NIL)
          return_type = first_arg
        end
      end

      # For unqualified method calls (no class prefix in the call name),
      # if return type is still void, use pointer as fallback
      # This handles stdlib methods that aren't defined in the bootstrap sources
      if return_type == TypeRef::VOID && receiver_id && !mangled_method_name.includes?('#') && !mangled_method_name.includes?('.')
        return_type = TypeRef::POINTER
        if debug_get_cache
          STDERR.puts "[GET_CACHE_RT] 2b. unqualified_method => Pointer"
        end
      end

      # For class method calls (no receiver), handle common builder patterns
      # These methods return a new object (typically the class's instance type)
      if return_type == TypeRef::VOID && receiver_id.nil?
        class_methods_returning_value = ["build", "new", "create", "from", "parse", "load", "open"]
        if class_methods_returning_value.includes?(method_name)
          return_type = TypeRef::POINTER
          if debug_get_cache
            STDERR.puts "[GET_CACHE_RT] 2c. class_methods_returning_value => Pointer"
          end
        end
      end

      # For module method calls (within the same module), if return type is still void,
      # try to force-lower the function to get its return type, or use POINTER fallback
      # Module methods returning String/Array/etc. should not be void
      if return_type == TypeRef::VOID && receiver_id.nil? && @current_class
        # Check if it's a method that typically returns a value (not a side-effect only method)
        # Methods with "build_", "get_", "create_", "make_", "extract_", "format_" prefixes
        # typically return values
        if method_name.starts_with?("build_") || method_name.starts_with?("get_") ||
           method_name.starts_with?("create_") || method_name.starts_with?("make_") ||
           method_name.starts_with?("extract_") || method_name.starts_with?("format_") ||
           method_name.starts_with?("parse_") || method_name.starts_with?("to_") ||
           method_name.ends_with?("_lines") || method_name.ends_with?("_string") ||
           method_name.ends_with?("_snippet") || method_name.ends_with?("_range") ||
           method_name.ends_with?("_gutter") || method_name.ends_with?("_segment")
          # Try force-lowering to get actual return type before falling back to POINTER
          force_lowered = false
          [primary_mangled_name, mangled_method_name, base_method_name].uniq.each do |name|
            next if force_lowered
            # Always try force-lowering, regardless of pending status
            if force_lower_function_for_return_type(name)
              force_lowered = true
              return_type = get_function_return_type(name)
            end
          end
          # Fall back to POINTER if force-lower didn't help
          if return_type == TypeRef::VOID
            return_type = TypeRef::POINTER
          end
        end
      end

      # Inside module instance methods, unqualified calls can incorrectly resolve
      # to Module.method (no receiver). If the call targets the current module,
      # treat it as an instance dispatch on self (Module#method).
      if receiver_id.nil? && full_method_name && !@current_method_is_class && @current_class
        if full_method_name.includes?('.')
          owner = method_owner(full_method_name)
          if owner == @current_class && module_like_type_name?(owner)
            receiver_id = emit_self(ctx)
            mangled_method_name = mangled_method_name.sub(".", "#")
            primary_mangled_name = primary_mangled_name.sub(".", "#")
            base_method_name = base_method_name.sub(".", "#") if base_method_name.includes?('.')
          end
        end
      end

      if receiver_id && ctx.type_literal?(receiver_id) && mangled_method_name.includes?('#')
        receiver_type = ctx.type_of(receiver_id)
        if env_get("DEBUG_DECODE_CALL") && method_name == "decode"
          STDERR.puts "[DECODE_CALL_CONVERT] recv_type=#{get_type_name_from_ref(receiver_type)} module=#{module_type_ref?(receiver_type)}"
        end
        self_id = ctx.lookup_local("self")
        # Never rewrite explicit/implicit self in instance methods to class-method calls.
        unless (self_id && receiver_id == self_id && !@current_method_is_class)
          unless module_type_ref?(receiver_type)
            mangled_method_name = mangled_method_name.sub("#", ".")
            primary_mangled_name = primary_mangled_name.sub("#", ".")
            base_method_name = base_method_name.sub("#", ".") if base_method_name.includes?('#')
            receiver_id = nil
          end
        end
      elsif receiver_id && mangled_method_name.includes?('#') && env_get("DEBUG_TYPE_LITERAL_CALL")
        STDERR.puts "[TYPE_LITERAL_CALL] recv=#{receiver_id} type_literal=#{ctx.type_literal?(receiver_id)} name=#{mangled_method_name}"
      end
      if receiver_id && mangled_method_name.includes?('.')
        receiver_type = ctx.type_of(receiver_id)
        if type_desc = @module.get_type_descriptor(receiver_type)
          if (type_desc.kind == TypeKind::Module || module_like_type_name?(type_desc.name)) &&
             !ctx.type_literal?(receiver_id)
            module_base = type_desc.name
            if paren = module_base.index('(')
              module_base = module_base[0, paren]
            end
            module_method_base = "#{module_base}.#{method_name}"
            if !(has_function_base?(module_method_base) || @function_defs.has_key?(module_method_base))
              # Module-typed receivers should dispatch to instance-style (#) methods
              # only when no module class-method exists.
              mangled_method_name = mangled_method_name.sub(".", "#")
              primary_mangled_name = primary_mangled_name.sub(".", "#")
              base_method_name = base_method_name.sub(".", "#") if base_method_name.includes?('.')
            end
          end
        end
      end
      if env_get("DEBUG_POINTER_LIST") &&
         (mangled_method_name.includes?("PointerLinkedList") ||
         base_method_name.includes?("PointerLinkedList") ||
         full_method_name.try(&.includes?("PointerLinkedList")))
        STDERR.puts "[POINTER_LIST_CALL] recv=#{receiver_id || "nil"} type_literal=#{receiver_id && ctx.type_literal?(receiver_id)} name=#{mangled_method_name} base=#{base_method_name} full=#{full_method_name || "nil"} method=#{method_name}"
      end
      if env_get("DEBUG_BYTEFORMAT_STATIC") && mangled_method_name.starts_with?("IO::ByteFormat.decode")
        cur_class = @current_class || "nil"
        cur_method = @current_method || "nil"
        cur_is_class = @current_method_is_class ? 1 : 0
        STDERR.puts "[BYTEFORMAT_STATIC] name=#{mangled_method_name} recv=#{receiver_id || "nil"} current=#{cur_class}##{cur_method} class_method=#{cur_is_class}"
      end
      if env_get("DEBUG_NEW_CALLS") && method_name == "new"
        STDERR.puts "[NEW_CALL] recv=#{receiver_id || "nil"} name=#{mangled_method_name}"
      end

      call_virtual = false
      if receiver_id
        if type_desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
          call_virtual = type_desc.kind.in?(TypeKind::Union, TypeKind::Module)
          if !call_virtual && type_desc.kind == TypeKind::Generic
            call_virtual = module_like_type_name?(type_desc.name) || module_includers_match?(type_desc.name)
          end
          if !call_virtual && (module_like_type_name?(type_desc.name) || module_includers_match?(type_desc.name))
            call_virtual = true
          end
          if !call_virtual && type_desc.kind == TypeKind::Class
            call_virtual = class_has_subclasses?(type_desc.name) ||
                           abstract_def?(mangled_method_name) ||
                           (mangled_method_name != primary_mangled_name && abstract_def?(primary_mangled_name))
          end
        end
      end
      if !call_virtual && base_method_name
        if owner = method_owner(base_method_name)
          if @module_defs.has_key?(owner) || module_like_type_name?(owner) || module_includers_match?(owner)
            call_virtual = true
          end
        end
      end
      if !call_virtual
        owner = method_owner(mangled_method_name)
        if !owner.empty? && (module_like_type_name?(owner) || module_includers_match?(owner))
          call_virtual = true
        end
      end
      if !call_virtual && receiver_id
        if abstract_def?(mangled_method_name) ||
           abstract_def?(primary_mangled_name) ||
           (base_method_name && abstract_def?(base_method_name))
          call_virtual = true
        end
      end
      if !call_virtual && receiver_id
        if self_id = ctx.lookup_local("self") || emit_self(ctx)
          if receiver_id == self_id
            if current = @current_class
              module_key = strip_generic_args(current)
              if @module_defs.has_key?(module_key)
                call_virtual = true
              end
            else
              fn_parts = parse_method_name(ctx.function.name)
              if fn_parts.is_instance
                owner = strip_generic_args(fn_parts.owner)
                if @module_defs.has_key?(owner)
                  call_virtual = true
                end
              end
            end
          end
        end
      end
      if env_has?("DEBUG_VIRTUAL_CALLS") && receiver_id
        recv_type = ctx.type_of(receiver_id)
        recv_desc = @module.get_type_descriptor(recv_type)
        recv_name = recv_desc ? "#{recv_desc.name}(#{recv_desc.kind})" : recv_type.id.to_s
        STDERR.puts "[HIR_VIRTUAL_CALL] method=#{method_name} recv=#{recv_name} virtual=#{call_virtual}"
      end

      if return_type == TypeRef::VOID && receiver_id
        abstract_target = abstract_def?(mangled_method_name) ||
                          abstract_def?(primary_mangled_name) ||
                          (base_method_name && abstract_def?(base_method_name))
        if abstract_target || call_virtual
          owner = ""
          if base_method_name
            owner = method_owner(base_method_name)
          end
          if owner.empty?
            owner = method_owner(mangled_method_name)
          end
          if !owner.empty? && (module_like_type_name?(owner) || @module_includers.has_key?(strip_generic_args(owner)))
            if inferred = infer_return_type_from_includers(owner, method_name, arg_types, has_block_call)
              return_type = inferred
            end
          end
        end
      end

      # Ensure virtual dispatch targets are lowered so MIR can build vdispatch tables.
      if call_virtual && receiver_id
        if type_desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
          if type_desc.kind == TypeKind::Class
            ah = arg_types_hash(arg_types)
            vf = vdispatch_flags(has_block_call)
            key = {type_desc.name, method_name, ah, vf}
            unless @virtual_targets_lowered.includes?(key)
              @virtual_targets_lowered.add(key)
              record_virtual_target(type_desc.name, method_name, arg_types, has_block_call, has_splat)
              owners = [type_desc.name] + collect_subclasses_cached(type_desc.name)
              ensure_method_index_built
              owners.each do |owner|
                # Fast pre-filter: skip owners that don't have this method registered
                # (uses pre-built method_index for O(1) lookup, avoids string building + hash)
                base_owner = strip_generic_args(owner)
                unless @method_index[base_owner]?.try(&.has_key?(method_name))
                  next unless @class_info.has_key?(owner)
                end
                base_name = "#{owner}##{method_name}"
                if resolved = lookup_function_def_for_call(base_name, arg_types.size, has_block_call, arg_types, has_splat)
                  resolved_name = resolved[0]
                  lower_function_if_needed(resolved_name)
                  resolved_base = strip_type_suffix(resolved_name)
                  lower_function_if_needed(resolved_base) unless resolved_name == resolved_base
                else
                  candidate = mangle_function_name(base_name, arg_types, has_block_call)
                  lower_function_if_needed(candidate)
                  lower_function_if_needed(base_name) unless candidate == base_name
                end
              end
            end
          elsif type_desc.kind == TypeKind::Union
            union_name = normalize_union_type_name(type_desc.name)
            ah = arg_types_hash(arg_types)
            vf = vdispatch_flags(has_block_call, is_union: true)
            key = {union_name, method_name, ah, vf}
            unless @virtual_targets_lowered.includes?(key)
              @virtual_targets_lowered.add(key)
              split_union_type_name(union_name).each do |variant|
                next if variant == "Nil"
                resolved_variant = resolve_type_alias_chain(variant)
                expanded = [] of String
                [resolved_variant, variant].uniq.each do |owner|
                  if owner.includes?('|')
                    split_union_type_name(owner).each { |entry| expanded << entry }
                  else
                    expanded << owner
                  end
                end
                expanded.uniq.each do |owner|
                  owners = [owner]
                  if class_has_subclasses?(owner)
                    collect_subclasses_cached(owner).each { |entry| owners << entry }
                  end
                  record_virtual_target(owner, method_name, arg_types, has_block_call, has_splat)
                  owners.uniq.each do |resolved_owner|
                    base_name = "#{resolved_owner}##{method_name}"
                    if resolved = lookup_function_def_for_call(base_name, arg_types.size, has_block_call, arg_types, has_splat)
                      resolved_name = resolved[0]
                      lower_function_if_needed(resolved_name)
                      resolved_base = strip_type_suffix(resolved_name)
                      lower_function_if_needed(resolved_base) unless resolved_name == resolved_base
                    else
                      candidate = mangle_function_name(base_name, arg_types, has_block_call)
                      lower_function_if_needed(candidate)
                      lower_function_if_needed(base_name) unless candidate == base_name
                    end
                  end
                end
              end
            end
          elsif type_desc.kind == TypeKind::Module || (type_desc.kind == TypeKind::Generic &&
                (module_like_type_name?(type_desc.name) || module_includers_match?(type_desc.name)))
            module_base = type_desc.name
            if type_desc.kind == TypeKind::Generic
              module_base = strip_generic_args(module_base)
            end
            includers = @module_includers[module_base]?
            if includers.nil? || includers.empty?
              if matches = @module_includer_keys_by_suffix[module_base]?
                if matches.size == 1
                  module_base = matches.first
                  includers = @module_includers[module_base]?
                end
              end
            end
            if includers.nil? || includers.empty?
              short_name = last_namespace_component(module_base)
              if short_name != module_base
                includers = @module_includers[short_name]?
                if includers.nil? || includers.empty?
                  if matches = @module_includer_keys_by_suffix[short_name]?
                    if matches.size == 1
                      module_base = matches.first
                      includers = @module_includers[module_base]?
                    end
                  end
                end
              end
            end
            owners = includers ? includers.to_a : [] of String
            if module_like_type_name?(module_base) && !owners.includes?(module_base)
              owners << module_base
            end
            parent_keys = owners.dup
            namespaced_module = module_base.includes?("::")
            unless namespaced_module
              owners.each do |owner|
                short_owner = last_namespace_component(owner)
                parent_keys << short_owner unless parent_keys.includes?(short_owner)
              end
            end
            parent_keys.each do |pk|
              collect_subclasses_cached(pk).each { |entry| owners << entry }
            end
            owners.uniq!
            ensure_method_index_built
            owners.each do |owner|
              # Skip owners without registered class info or the method
              base_owner = strip_generic_args(owner)
              unless @method_index[base_owner]?.try(&.has_key?(method_name))
                next unless @class_info.has_key?(owner)
              end
              base_name = "#{owner}##{method_name}"
              if resolved = lookup_function_def_for_call(base_name, arg_types.size, has_block_call, arg_types, has_splat)
                resolved_name = resolved[0]
                lower_function_if_needed(resolved_name)
                resolved_base = strip_type_suffix(resolved_name)
                lower_function_if_needed(resolved_base) unless resolved_name == resolved_base
              else
                candidate = mangle_function_name(base_name, arg_types, has_block_call)
                lower_function_if_needed(candidate)
                lower_function_if_needed(base_name) unless candidate == base_name
              end
              module_base_name = "#{owner}.#{method_name}"
              if resolved = lookup_function_def_for_call(module_base_name, arg_types.size, has_block_call, arg_types, has_splat)
                resolved_name = resolved[0]
                lower_function_if_needed(resolved_name)
                resolved_base = strip_type_suffix(resolved_name)
                lower_function_if_needed(resolved_base) unless resolved_name == resolved_base
              else
                candidate = mangle_function_name(module_base_name, arg_types, has_block_call)
                lower_function_if_needed(candidate)
                lower_function_if_needed(module_base_name) unless candidate == module_base_name
              end
            end
          end
        end
      end

      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, base_method_name, mangled_method_name)
        STDERR.puts "[CALL_TRACE] stage=before_lower_function method=#{method_name} mangled=#{mangled_method_name} primary=#{primary_mangled_name} return=#{return_type.id}"
      end
      if receiver_id && args.empty? && (method_name == "inspect" || method_name == "to_s")
        base = base_method_name
        if has_function_base?(base)
          has_zero_arg = function_def_overloads(base).any? do |name|
            def_node = @function_defs[name]?
            next false unless def_node
            stats = function_param_stats(name, def_node)
            stats.param_count == 0 && stats.required == 0 && !stats.has_block
          end
          unless has_zero_arg
            object_base = "Object##{method_name}"
            if has_function_base?(object_base)
              mangled_method_name = object_base
              base_method_name = object_base
            end
          end
        end
      end
      # Lazily lower target function bodies (avoid full stdlib lowering).
      remember_callsite_arg_types(primary_mangled_name, callsite_arg_types, callsite_arg_literals, callsite_arg_enum_names, has_block_call)
      if mangled_method_name != primary_mangled_name
        remember_callsite_arg_types(mangled_method_name, callsite_arg_types, callsite_arg_literals, callsite_arg_enum_names, has_block_call)
      end
      if receiver_id
        receiver_type = ctx.type_of(receiver_id)
        if desc = @module.get_type_descriptor(receiver_type)
          if desc.kind == TypeKind::Tuple
            pending_map = type_param_map_for_receiver_type(receiver_type)
            unless pending_map.empty?
              record_pending_type_param_map(primary_mangled_name, pending_map)
              record_pending_type_param_map(base_method_name, pending_map) unless base_method_name.empty?
              if mangled_method_name != primary_mangled_name
                record_pending_type_param_map(mangled_method_name, pending_map)
              end
            end
          end
        end
      end
      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, base_method_name, mangled_method_name)
        STDERR.puts "[CALL_TRACE] stage=after_remember method=#{method_name} mangled=#{mangled_method_name} primary=#{primary_mangled_name}"
      end
      if debug_env_filter_match?("DEBUG_EACH_RESOLVE", method_name)
        STDERR.puts "[EACH_LOWER] primary=#{primary_mangled_name} mangled=#{mangled_method_name} func=#{ctx.function.name}"
      end
      callsite_label = nil
      if DebugHooks::ENABLED
        span = node.span
        receiver_type_name = receiver_id ? type_name_for_mangling(ctx.type_of(receiver_id)) : "nil"
        callsite_label = "func=#{ctx.function.name} method=#{method_name} full=#{full_method_name || ""} class=#{@current_class || ""} recv=#{receiver_type_name} span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column}"
      end
      # Debug disabled for performance
      # if mangled_method_name.includes?("from_chars") || mangled_method_name == "ec" || mangled_method_name == "ptr" || mangled_method_name == "current" || (method_name == "write" && base_method_name.includes?("FileDescriptor")) || mangled_method_name.includes?("Slice") && method_name == "new"
      #   arg_type_names = arg_types.map { |t| type_name_for_mangling(t) }
      #   STDERR.puts "[CALL_DEBUG] method=#{method_name}, base=#{base_method_name}, mangled=#{mangled_method_name}, primary=#{primary_mangled_name}, return_type=#{return_type}, arg_types=#{arg_type_names}, full=#{full_method_name}"
      # end
      with_debug_callsite(callsite_label) do
        lower_function_if_needed(primary_mangled_name)
        if mangled_method_name != primary_mangled_name
          lower_function_if_needed(mangled_method_name)
        end
      end
      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, base_method_name, mangled_method_name)
        STDERR.puts "[CALL_TRACE] stage=after_lower_function method=#{method_name} mangled=#{mangled_method_name} primary=#{primary_mangled_name}"
      end

      # After lowering, re-check return type if it was VOID
      # The lowered function may have registered its return type
      if debug_get_cache
        rt_name = get_type_name_from_ref(return_type)
        STDERR.puts "[GET_CACHE_RT] 3. before_re-check return_type=#{rt_name} mangled=#{mangled_method_name}"
      end
      if return_type == TypeRef::VOID
        return_type = get_function_return_type(mangled_method_name)
        if return_type == TypeRef::VOID && mangled_method_name != base_method_name
          return_type = get_function_return_type(base_method_name)
        end
      end
      if env_get("DEBUG_FORCE_LOWER") && method_name == "get_cache"
        rt_name = get_type_name_from_ref(return_type)
        STDERR.puts "[GET_CACHE_TRACE] after_re-check return_type=#{rt_name}"
      end

      # If return type is still VOID, the function may have been deferred due to inside_lowering?.
      # Force-lower it now to get the correct return type.
      if return_type == TypeRef::VOID
        force_lowered = false
        debug_force = env_get("DEBUG_FORCE_LOWER") && method_name == "get_cache"
        if debug_force
          STDERR.puts "[FORCE_LOWER] check method=#{method_name} mangled=#{mangled_method_name} primary=#{primary_mangled_name} base=#{base_method_name}"
          STDERR.puts "[FORCE_LOWER] pending=#{pending_functions.select { |n| n.includes?("get_cache") }.join(",")}"
        end
        # Try primary name first
        if function_state(primary_mangled_name).pending?
          if debug_force
            STDERR.puts "[FORCE_LOWER] trying primary_mangled=#{primary_mangled_name}"
          end
          if force_lower_function_for_return_type(primary_mangled_name)
            force_lowered = true
            return_type = get_function_return_type(primary_mangled_name)
            if debug_force
              rt_name = get_type_name_from_ref(return_type)
              STDERR.puts "[FORCE_LOWER] got return_type=#{rt_name} from primary"
            end
          end
        end
        # Try mangled name if different
        if return_type == TypeRef::VOID && mangled_method_name != primary_mangled_name
          if function_state(mangled_method_name).pending?
            if debug_force
              STDERR.puts "[FORCE_LOWER] trying mangled=#{mangled_method_name}"
            end
            if force_lower_function_for_return_type(mangled_method_name)
              force_lowered = true
              return_type = get_function_return_type(mangled_method_name)
              if debug_force
                rt_name = get_type_name_from_ref(return_type)
                STDERR.puts "[FORCE_LOWER] got return_type=#{rt_name} from mangled"
              end
            end
          end
        end
        # Try base name if still no result
        if return_type == TypeRef::VOID && base_method_name != mangled_method_name
          if function_state(base_method_name).pending?
            if debug_force
              STDERR.puts "[FORCE_LOWER] trying base=#{base_method_name}"
            end
            if force_lower_function_for_return_type(base_method_name)
              force_lowered = true
              return_type = get_function_return_type(base_method_name)
              if debug_force
                rt_name = get_type_name_from_ref(return_type)
                STDERR.puts "[FORCE_LOWER] got return_type=#{rt_name} from base"
              end
            end
          end
        end
        if debug_force
          rt_name = get_type_name_from_ref(return_type)
          STDERR.puts "[FORCE_LOWER] final return_type=#{rt_name} force_lowered=#{force_lowered}"
        end
      end

      # If we still have a fallback type, prefer a registered function type when available.
      # But don't override a concrete receiver-derived type with NIL.
      # Also don't override a nilable union type (from NILABLE_QUERY_METHODS like []?) with
      # the function's non-union return type — the function returns V but the CALL returns Nil | V.
      is_nilable_query = NILABLE_QUERY_METHODS.includes?(method_name)
      resolved_return_type = get_function_return_type(mangled_method_name)
      if resolved_return_type == TypeRef::VOID && mangled_method_name != base_method_name
        resolved_return_type = get_function_return_type(base_method_name)
      end
      if resolved_return_type != TypeRef::VOID && resolved_return_type != TypeRef::NIL && resolved_return_type != return_type
        if !(unresolved_generic_return_type?(resolved_return_type) && !unresolved_generic_return_type?(return_type))
          # Don't downgrade nilable union to non-union for nilable query methods
          unless is_nilable_query && is_union_or_nilable_type?(return_type)
            return_type = resolved_return_type
          end
        end
      end
      # Prefer the actual lowered function return type when available.
      if func = @module.function_by_name(mangled_method_name)
        func_rt = func.return_type
        if func_rt != TypeRef::VOID && func_rt != TypeRef::NIL && func_rt != return_type
          # Don't downgrade nilable union to non-union for nilable query methods
          unless is_nilable_query && is_union_or_nilable_type?(return_type)
            return_type = func_rt
          end
        end
      end

      # Coerce arguments to union types if needed
      # This handles cases like passing Int32 to a parameter of type Int32 | Nil
      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, base_method_name, mangled_method_name)
        STDERR.puts "[CALL_TRACE] stage=before_coerce method=#{method_name} mangled=#{mangled_method_name} args=#{args.size}"
      end
      coerced_args = coerce_args_to_param_types(ctx, args, mangled_method_name)
      args = coerced_args
      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, base_method_name, mangled_method_name)
        STDERR.puts "[CALL_TRACE] stage=after_coerce method=#{method_name} mangled=#{mangled_method_name} args=#{args.size}"
      end

      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, base_method_name, mangled_method_name)
        STDERR.puts "[CALL_TRACE] stage=before_emit method=#{method_name} mangled=#{mangled_method_name} return=#{return_type.id}"
      end
      if debug_env_filter_match?("DEBUG_DECODE_CALL", method_name, base_method_name, mangled_method_name)
        recv_id = receiver_id ? receiver_id.to_s : "nil"
        STDERR.puts "[DECODE_CALL_EMIT] name=#{mangled_method_name} recv_id=#{recv_id}"
      end
      if debug_env_filter_match?("DEBUG_FROM_CHARS", method_name, base_method_name, mangled_method_name)
        arg_names = args.map { |arg_id| get_type_name_from_ref(ctx.type_of(arg_id)) }
        STDERR.puts "[DEBUG_FROM_CHARS] base=#{base_method_name} mangled=#{mangled_method_name} args=#{arg_names.join(",")}"
      end
      if DebugHooks::ENABLED && env_get("CRYSTAL_V2_MISSING_TRACE")
        unless @module.has_function?(mangled_method_name) || @module.has_function?(primary_mangled_name)
          abstract_target = abstract_def?(mangled_method_name) ||
                            abstract_def?(primary_mangled_name) ||
                            (base_method_name != mangled_method_name && abstract_def?(base_method_name))
          trace_missing_symbol(ctx, node, mangled_method_name, base_method_name, method_name, receiver_id, arg_types, "unlowered", call_virtual, abstract_target)
        end
      end
      if env_get("DEBUG_MAP_CALL") && method_name == "map"
        recv_name = receiver_id ? get_type_name_from_ref(ctx.type_of(receiver_id)) : "nil"
        block_kind = block_id ? "block" : "none"
        STDERR.puts "[MAP_CALL] recv=#{recv_name} block_expr=#{!block_expr.nil?} block_pass=#{!block_pass_expr.nil?} block_id=#{block_kind} return=#{get_type_name_from_ref(return_type)} mangled=#{mangled_method_name}"
      end
      if env_get("DEBUG_BYTE_AT") && method_name == "byte_at?"
        ret_name = get_type_name_from_ref(return_type)
        recv_name = receiver_id ? get_type_name_from_ref(ctx.type_of(receiver_id)) : "nil"
        STDERR.puts "[BYTE_AT_CALL] return_type=#{ret_name} recv=#{recv_name} mangled=#{mangled_method_name} func=#{ctx.function.name}"
      end
      if env_get("DEBUG_MATH_MIN") && (method_name == "min" || method_name == "max") && (mangled_method_name.includes?("Math") || base_method_name.includes?("Math"))
        arg_type_names = args.map { |arg_id| get_type_name_from_ref(ctx.type_of(arg_id)) }
        ret_name = get_type_name_from_ref(return_type)
        STDERR.puts "[MATH_MIN_EMIT] method=#{method_name} mangled=#{mangled_method_name} base=#{base_method_name} args=#{arg_type_names.join(",")} return=#{ret_name} func=#{ctx.function.name}"
      end
      if env_get("DEBUG_MISSING_SYMS") && (method_name == "leap_year?" || method_name == "month_week_date" || method_name == "basename" || method_name == "high" || method_name == "zero" || method_name == "byte_range" || method_name == "from_io")
        STDERR.puts "[MISSING_SYM_EMIT] method=#{method_name} mangled=#{mangled_method_name} base=#{base_method_name} full=#{full_method_name || "nil"} recv=#{receiver_id.nil? ? "nil" : "set"} func=#{ctx.function.name}"
      end
      if env_get("DEBUG_SELF_TO_S") && method_name == "to_s"
        STDERR.puts "[SELF_TO_S_EMIT] mangled=#{mangled_method_name} base=#{base_method_name} full=#{full_method_name || "nil"} recv=#{receiver_id || "nil"} current=#{@current_class || "nil"}##{@current_method || "nil"}"
      end
      # When the receiver has VOID type and the method name has no class prefix
      # (no '#' or '.'), this is a metaclass dispatch that cannot be resolved in
      # the generic version of the enclosing function.  Crystal passes types as
      # values (e.g. `type.from_io(self, format)` in IO#read_bytes) which the
      # reference compiler handles via monomorphization.  If the concrete type is
      # unknown (VOID), the call target is undefined — emit nil instead.
      if receiver_id && !mangled_method_name.includes?('#') && !mangled_method_name.includes?('.')
        recv_type = ctx.type_of(receiver_id)
        if recv_type == TypeRef::VOID
          lit = Literal.new(ctx.next_id, return_type, nil)
          ctx.emit(lit)
          ctx.register_type(lit.id, return_type)
          return lit.id
        end
      end

      # Check if callee is a registered primitive — emit intrinsic instead of Call
      if prim_kind = @module.primitive_for(mangled_method_name) || @module.primitive_for(base_method_name)
        if prim_result = lower_primitive_call(ctx, prim_kind, method_name, receiver_id, args, return_type, mangled_method_name)
          return prim_result
        end
      end

      # Fallback: handle numeric conversion methods (to_u32!, to_i64!, etc.)
      # as Cast instructions even when not registered as primitives.
      # Primitives defined via macros in Crystal's primitives.cr may not be
      # registered because our macro expansion is incomplete.
      if env_get("DEBUG_TO_U32") && (method_name.includes?("to_u32") || method_name.includes?("to_u!"))
        STDERR.puts "[TO_U32_CALL_FB] method=#{method_name} receiver_id=#{receiver_id} is_conv=#{numeric_conversion_method_name?(method_name)} func=#{ctx.function.name}"
      end
      if receiver_id && numeric_conversion_method_name?(method_name)
        if target = type_ref_for_conversion_method(method_name)
          cast = Cast.new(ctx.next_id, target, receiver_id, target)
          ctx.emit(cast)
          ctx.register_type(cast.id, target)
          return cast.id
        end
      end

      # Intercept Array#sum() (no args, no block) on numeric arrays → runtime helper
      # Avoids infinite recursion from sum()/sum(initial) overload name collision
      if receiver_id && block_id.nil? &&
         (method_name == "sum" || mangled_method_name.ends_with?("#sum")) &&
         mangled_method_name.starts_with?("Array(")
        ext_call = ExternCall.new(ctx.next_id, TypeRef::INT32, "__crystal_v2_array_sum_int32", [receiver_id])
        ctx.emit(ext_call)
        ctx.register_type(ext_call.id, TypeRef::INT32)
        return ext_call.id
      end

      # Intercept Array(String)#join(String) → runtime helper
      if receiver_id && method_name == "join" && args.size == 1 &&
         mangled_method_name.starts_with?("Array(")
        if array_intrinsic_receiver?(ctx, receiver_id)
          ext_call = ExternCall.new(ctx.next_id, TypeRef::STRING, "__crystal_v2_array_join_string", [receiver_id, args[0]])
          ctx.emit(ext_call)
          ctx.register_type(ext_call.id, TypeRef::STRING)
          return ext_call.id
        end
      end

      call = Call.new(ctx.next_id, return_type, receiver_id, mangled_method_name, args, block_id, call_virtual)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      if function_returns_type_literal?(mangled_method_name, base_method_name)
        ctx.mark_type_literal(call.id)
      end
      if enum_name = enum_return_name_for(mangled_method_name)
        (@enum_value_types ||= {} of ValueId => String)[call.id] = enum_name
      end
      if debug_env_filter_match?("DEBUG_CALL_TRACE", method_name, base_method_name, mangled_method_name)
        STDERR.puts "[CALL_TRACE] stage=after_emit method=#{method_name} mangled=#{mangled_method_name}"
      end
      call.id
    end

    # Expand splat arguments in a call
    # *array becomes individual elements at compile time (if array is literal)
    private def out_alloc_type_for_param(param_type : TypeRef) : TypeRef
      if desc = @module.get_type_descriptor(param_type)
        if desc.kind == TypeKind::Pointer
          elem_type = pointer_element_type(desc.name)
          return elem_type unless elem_type == TypeRef::VOID
        end
      end
      param_type == TypeRef::POINTER ? TypeRef::POINTER : param_type
    end

    private def lower_out_arg(
      ctx : LoweringContext,
      node : CrystalV2::Compiler::Frontend::OutNode,
      param_type : TypeRef,
    ) : ValueId
      var_name = String.new(node.identifier)

      # For instance variables (@ivar), compute the field address directly from self.
      # This ensures the C function writes directly into the object's field,
      # instead of a temporary alloca that never gets copied back.
      if var_name.starts_with?('@')
        ivar_name = var_name[1..]
        self_id = ctx.lookup_local("self")
        if env_get("DEBUG_OUT_IVAR")
          STDERR.puts "[OUT_IVAR] var=#{var_name} ivar=#{ivar_name} self=#{self_id} class=#{@current_class} has_info=#{@current_class && @class_info[@current_class]?}"
          if (cn = @current_class) && (ci2 = @class_info[cn]?)
            STDERR.puts "[OUT_IVAR] ivars=#{ci2.ivars.map(&.name)}"
          end
        end
        if self_id && (class_name = @current_class) && (ci = @class_info[class_name]?)
          # Ivar names may be stored with or without @ prefix
          if ivar_info = ci.ivars.find { |iv| iv.name == ivar_name || iv.name == var_name }
            # Emit: self + ivar_offset (byte-level pointer arithmetic)
            offset_lit = Literal.new(ctx.next_id, TypeRef::INT64, ivar_info.offset.to_i64)
            ctx.emit(offset_lit)
            ctx.register_type(offset_lit.id, TypeRef::INT64)
            field_ptr = PointerAdd.new(ctx.next_id, TypeRef::POINTER, self_id, offset_lit.id, TypeRef::INT8)
            ctx.emit(field_ptr)
            ctx.register_type(field_ptr.id, TypeRef::POINTER)
            return field_ptr.id  # Already a pointer — no AddressOf needed
          end
        end
      end

      # Local variable: create temp alloca + AddressOf
      var_id = ctx.lookup_local(var_name)
      if var_id.nil?
        alloc_type = out_alloc_type_for_param(param_type)
        alloc = Allocate.new(ctx.next_id, alloc_type, [] of ValueId, true)
        ctx.emit(alloc)
        record_allocation_location(ctx, alloc.id, @arena, node)
        ctx.register_local(var_name, alloc.id)
        var_id = alloc.id
      end
      ptr = AddressOf.new(ctx.next_id, TypeRef::POINTER, var_id)
      ctx.emit(ptr)
      ptr.id
    end

    private def expand_extern_args(
      ctx : LoweringContext,
      arg_exprs : Array(ExprId),
      call_arena : CrystalV2::Compiler::Frontend::ArenaLike,
      extern_func : ExternFunction,
    ) : Array(ValueId)
      result = [] of ValueId
      param_types = extern_func.param_types
      old_arena = @arena
      begin
        arg_exprs.each_with_index do |arg_expr, idx|
          @arena = call_arena
          arg_node = @arena[arg_expr]
          if arg_node.is_a?(CrystalV2::Compiler::Frontend::OutNode)
            expected_type = param_types[idx]? || TypeRef::POINTER
            result << lower_out_arg(ctx, arg_node, expected_type)
          elsif arg_node.is_a?(CrystalV2::Compiler::Frontend::ProcLiteralNode)
            # Proc literal passed to C function — generate a standalone callback
            # function and pass its address as a raw function pointer.
            result << lower_proc_as_c_callback(ctx, arg_node, extern_func, idx)
          else
            arg_val = lower_expr(ctx, arg_expr)
            # Crystal implicitly calls to_unsafe when passing a class instance
            # to a C function. Check if the arg is `self` and the class has to_unsafe.
            arg_val = try_implicit_to_unsafe(ctx, arg_val, arg_node)
            result << arg_val
          end
        end
      ensure
        @arena = old_arena
      end

      result
    end

    # Crystal implicitly calls to_unsafe when passing a class instance to a C function.
    # For example, `LibC.pthread_mutex_lock(self)` where self is Thread::Mutex
    # becomes `LibC.pthread_mutex_lock(self.to_unsafe)`.
    # Also handles Slice/String/Array arguments: `LibC.write(fd, slice, size)`
    # becomes `LibC.write(fd, slice.to_unsafe, size)`.
    private def try_implicit_to_unsafe(
      ctx : LoweringContext,
      arg_val : ValueId,
      arg_node,
    ) : ValueId
      class_name : String? = nil
      case arg_node
      when CrystalV2::Compiler::Frontend::SelfNode
        class_name = @current_class
      else
        # For any other expression, try to determine the type from the value's TypeRef.
        # This handles VarNode (local/param refs), CallNode results, etc.
        type_ref = ctx.type_of(arg_val)
        if type_ref
          # Handle built-in types that have to_unsafe (String, Slice, StaticArray)
          # These have IDs below FIRST_USER_TYPE but still need auto-cast for C calls
          if type_ref == TypeRef::STRING
            class_name = "String"
          elsif type_ref != TypeRef::POINTER && type_ref != TypeRef::VOID &&
                type_ref.id >= TypeRef::FIRST_USER_TYPE
            resolved_name = get_type_name_from_ref(type_ref)
            if resolved_name != "Unknown" && resolved_name != "Pointer"
              class_name = resolved_name
            end
          end
        end
      end
      return arg_val unless class_name

      # Check if this class has a `to_unsafe` method
      to_unsafe_name = "#{class_name}#to_unsafe"
      if @function_defs.has_key?(to_unsafe_name) || @module.has_function?(to_unsafe_name)
        # Emit call: obj.to_unsafe (receiver=obj, no extra args)
        call = Call.new(ctx.next_id, TypeRef::POINTER, arg_val, to_unsafe_name, [] of ValueId)
        ctx.emit(call)
        ctx.register_type(call.id, TypeRef::POINTER)
        return call.id
      end

      arg_val
    end

    # Lower a ProcLiteralNode as a C-compatible callback function.
    # Instead of creating a Proc object (MakeClosure), generates a standalone
    # top-level function and returns a FuncPointer to it.
    private def lower_proc_as_c_callback(
      ctx : LoweringContext,
      proc_node : CrystalV2::Compiler::Frontend::ProcLiteralNode,
      extern_func : ExternFunction,
      arg_idx : Int32,
    ) : ValueId
      # Generate a unique callback function name
      callback_name = "__crystal_callback_#{extern_func.real_name}_#{arg_idx}"

      # Determine param types from the extern function's expected callback signature.
      # The C function parameter at arg_idx should be a function pointer type.
      # We use the proc literal's declared params to build the callback.
      param_types = extern_func.param_types

      # Determine return type — C callbacks for GC are void
      return_type = TypeRef::VOID

      # Create a new top-level function for the callback
      callback_func = @module.create_function(callback_name, return_type)
      callback_ctx = LoweringContext.new(callback_func, @module, @arena)

      # Add parameters from the proc literal
      if params = proc_node.params
        params.each_with_index do |param, idx|
          if param_name = param.name
            name = String.new(param_name)
            param_type = if ta = param.type_annotation
                           type_ref_for_name(String.new(ta))
                         else
                           # Infer from C function signature if possible
                           TypeRef::POINTER
                         end
            hir_param = callback_func.add_param(name, param_type)
            callback_ctx.register_local(name, hir_param.id)
            callback_ctx.register_type(hir_param.id, param_type)
          end
        end
      end

      # Lower the proc body into the callback function
      saved_class = @current_class
      saved_typeof_locals = @current_typeof_locals
      saved_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = nil
      @current_typeof_local_names = nil
      begin
        body = proc_node.body
        if body && !body.empty?
          last_value = lower_body(callback_ctx, body)
          # Terminate the callback function
          block = callback_func.get_block(callback_ctx.current_block)
          unless block.terminator.is_a?(Return) || block.terminator.is_a?(Unreachable)
            callback_ctx.terminate(Return.new(last_value))
          end
        else
          # Empty body — just return void
          nil_lit = Literal.new(callback_ctx.next_id, TypeRef::NIL, nil)
          callback_ctx.emit(nil_lit)
          callback_ctx.terminate(Return.new(nil_lit.id))
        end
      ensure
        @current_class = saved_class
        @current_typeof_locals = saved_typeof_locals
        @current_typeof_local_names = saved_typeof_local_names
      end

      # Emit a FuncPointer in the CALLER's context referencing the callback
      fp = FuncPointer.new(ctx.next_id, TypeRef::POINTER, callback_name)
      ctx.emit(fp)
      ctx.register_type(fp.id, TypeRef::POINTER)
      fp.id
    end

    private def expand_splat_args(
      ctx : LoweringContext,
      arg_exprs : Array(ExprId),
      call_arena : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : Array(ValueId)
      result = [] of ValueId

      old_arena = @arena
      begin
        arg_exprs.each do |arg_expr|
          @arena = call_arena
          if env_get("DEBUG_SPLAT_ARENA")
            inline_desc = if arenas = @inline_arenas
                            arenas.map { |candidate| "#{candidate.class}:#{candidate.size}" }.join(",")
                          else
                            "none"
                          end
            STDERR.puts "[SPLAT_ARENA] expr=#{arg_expr.index} arena=#{@arena.class}:#{@arena.size} inline=#{inline_desc}"
          end
          if env_get("DEBUG_SPLAT_TRACE")
            ctx_info = @last_splat_context || "func=#{ctx.function.name}"
            STDERR.puts "[SPLAT_TRACE] #{ctx_info} expr=#{arg_expr.index}"
          end
          if arg_expr.invalid?
            debug_hook("splat.arg.invalid", "expr=#{arg_expr.index} arena=#{@arena.class} size=#{@arena.size}")
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            result << nil_lit.id
            next
          end
          arg_node = @arena[arg_expr]

          if arg_node.is_a?(CrystalV2::Compiler::Frontend::SplatNode)
            # Splat - try to expand if inner is array literal
            if arg_node.expr.invalid?
              debug_hook("splat.inner.invalid", "expr=#{arg_node.expr.index} arena=#{@arena.class} size=#{@arena.size}")
              nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
              ctx.emit(nil_lit)
              result << nil_lit.id
              next
            end
            @arena = call_arena
            inner_node = @arena[arg_node.expr]
            if inner_node.is_a?(CrystalV2::Compiler::Frontend::ArrayLiteralNode)
              # Expand array elements as individual arguments
              inner_node.elements.each do |elem_id|
                @arena = call_arena
                result << lower_expr(ctx, elem_id)
                @arena = call_arena
                if env_get("DEBUG_SPLAT_TRACE")
                  STDERR.puts "[SPLAT_TRACE_DONE] elem=#{elem_id.index}"
                end
              end
            else
              # Non-literal splat - lower the expression, then check if it's a Tuple
              @arena = call_arena
              inner_val = lower_expr(ctx, arg_node.expr)
              @arena = call_arena
              inner_type = ctx.type_of(inner_val)
              desc = @module.get_type_descriptor(inner_type)
              if desc && (desc.kind == TypeKind::Tuple || desc.name.starts_with?("Tuple("))
                # Tuple splat: extract each element as a separate argument
                elem_types = desc.type_params.reject { |t| t == TypeRef::VOID }
                elem_types.each_with_index do |elem_type, idx|
                  idx_lit = Literal.new(ctx.next_id, TypeRef::INT32, idx.to_i64)
                  ctx.emit(idx_lit)
                  ctx.register_type(idx_lit.id, TypeRef::INT32)
                  extract = IndexGet.new(ctx.next_id, elem_type, inner_val, idx_lit.id)
                  ctx.emit(extract)
                  ctx.register_type(extract.id, elem_type)
                  result << extract.id
                end
                if env_get("DEBUG_SPLAT_TRACE")
                  STDERR.puts "[SPLAT_TRACE_DONE] tuple_unpack=#{elem_types.size} inner=#{arg_node.expr.index}"
                end
              else
                # Not a Tuple - pass through as single argument
                result << inner_val
                if env_get("DEBUG_SPLAT_TRACE")
                  STDERR.puts "[SPLAT_TRACE_DONE] inner=#{arg_node.expr.index}"
                end
              end
            end
          else
            @arena = call_arena
            result << lower_expr(ctx, arg_expr)
            @arena = call_arena
            if env_get("DEBUG_SPLAT_TRACE")
              STDERR.puts "[SPLAT_TRACE_DONE] expr=#{arg_expr.index}"
            end
          end
          @arena = call_arena
        end
      ensure
        @arena = old_arena
      end

      result
    end

    private def pack_splat_args_for_call(
      ctx : LoweringContext,
      args : Array(ValueId),
      method_name : String,
      full_method_name : String?,
      has_block_call : Bool,
      call_has_named_args : Bool,
      receiver_id : ValueId?,
      call_has_splat : Bool,
    ) : Tuple(Array(ValueId), Bool)
      if call_has_splat && args.size == 1
        if desc = @module.get_type_descriptor(ctx.type_of(args.first))
          if desc.kind == TypeKind::Tuple || desc.name.starts_with?("Tuple(")
            return {args, false}
          end
        end
      end

      # When the call does NOT use splat syntax and args are already Tuple types,
      # don't re-wrap to prevent infinite Tuple nesting (e.g., Object#in? calling
      # in?(values) where values is Tuple(Object) — should resolve to
      # in?(collection : Object), not re-pack into Tuple(Tuple(Object))).
      unless call_has_splat
        has_tuple_arg = args.any? do |arg_id|
          if desc = @module.get_type_descriptor(ctx.type_of(arg_id))
            desc.kind == TypeKind::Tuple || desc.name.starts_with?("Tuple(")
          end
        end
        return {args, false} if has_tuple_arg
      end
      func_name = if full_method_name
                    full_method_name
                  elsif receiver_id
                    if desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
                      resolve_method_with_inheritance(desc.name, method_name) || "#{desc.name}##{method_name}"
                    else
                      method_name
                    end
                  elsif current = @current_class
                    sep = @current_method_is_class ? "." : "#"
                    candidate = "#{current}#{sep}#{method_name}"
                    if @function_types.has_key?(candidate) || has_function_base?(candidate)
                      candidate
                    else
                      method_name
                    end
                  else
                    method_name
                  end
      arg_types = args.map { |arg_id| ctx.type_of(arg_id) }
      entry = lookup_function_def_for_call(func_name, args.size, has_block_call, arg_types, call_has_splat, call_has_named_args)
      return {args, false} unless entry

      func_def = entry[1]
      return {args, false} unless params = func_def.params
      if env_get("DEBUG_PUTS_PACK") && method_name == "puts"
        param_debug = params.map do |param|
          name = param.name ? String.new(param.name.not_nil!) : "(anon)"
          type_name = param.type_annotation ? String.new(param.type_annotation.not_nil!) : ""
          flags = [] of String
          flags << "splat" if param.is_splat
          flags << "double_splat" if param.is_double_splat
          "#{name}:#{type_name}#{flags.empty? ? "" : "[#{flags.join(",")}]"}"
        end
        STDERR.puts "[DEBUG_PUTS_PACK] func=#{func_name} entry=#{entry[0]} params=#{param_debug.join("|")}"
      end

      splat_index : Int32? = nil
      splat_is_last = true
      param_index = 0
      saw_splat = false
      params.each do |param|
        next if param.is_block || named_only_separator?(param)
        if param.is_splat && !param.is_double_splat
          splat_index = param_index
          saw_splat = true
        elsif saw_splat
          splat_is_last = false
          break
        end
        param_index += 1
      end

      return {args, false} unless splat_index && splat_is_last
      return {args, false} if args.size <= splat_index

      fixed = args[0, splat_index]
      splat_args = args[splat_index..-1] || [] of ValueId
      return {args, false} if splat_args.empty?

      splat_types = splat_args.map { |arg_id| ctx.type_of(arg_id) }
      if env_get("DEBUG_SPLAT_PACK")
        type_names = splat_types.map { |t| type_name_for_mangling(t) }
        STDERR.puts "[SPLAT_PACK] fn=#{ctx.function.name} method=#{method_name} types=#{type_names.join(", ")}"
      end
      tuple_type = tuple_type_from_arg_types(splat_types, allow_void: true)
      return {args, false} if tuple_type == TypeRef::VOID

      tuple_alloc = Allocate.new(ctx.next_id, tuple_type, splat_args)
      ctx.emit(tuple_alloc)

      {fixed + [tuple_alloc.id], true}
    end

    private def ensure_double_splat_arg(
      ctx : LoweringContext,
      args : Array(ValueId),
      method_name : String,
      full_method_name : String?,
      has_block_call : Bool,
      call_has_named_args : Bool,
      receiver_id : ValueId?,
    ) : Array(ValueId)
      func_name = if full_method_name
                    full_method_name
                  elsif receiver_id
                    if desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
                      resolve_method_with_inheritance(desc.name, method_name) || "#{desc.name}##{method_name}"
                    else
                      method_name
                    end
                  elsif current = @current_class
                    sep = @current_method_is_class ? "." : "#"
                    candidate = "#{current}#{sep}#{method_name}"
                    if @function_types.has_key?(candidate) || has_function_base?(candidate)
                      candidate
                    else
                      method_name
                    end
                  else
                    method_name
                  end
      arg_types = args.map { |arg_id| ctx.type_of(arg_id) }
      entry = lookup_function_def_for_call(func_name, args.size, has_block_call, arg_types, false, call_has_named_args)
      return args unless entry

      func_def = entry[1]
      return args unless params = func_def.params

      double_splat_index : Int32? = nil
      param_index = 0
      params.each do |param|
        next if param.is_block || named_only_separator?(param)
        if param.is_double_splat
          double_splat_index = param_index
          break
        end
        param_index += 1
      end

      return args unless double_splat_index
      return args if args.size > double_splat_index

      result = args.dup
      while result.size < double_splat_index
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        result << nil_lit.id
      end
      result << allocate_named_tuple(ctx, [] of ValueId)
      result
    end

    # Coerce arguments to match parameter types (e.g., wrap concrete types in unions)
    # This is needed when passing Int32 to a parameter of type Int32 | Nil
    private def coerce_args_to_param_types(
      ctx : LoweringContext,
      args : Array(ValueId),
      method_name : String,
    ) : Array(ValueId)
      # Find the target function to get parameter types
      # IMPORTANT: Only use EXACT match to avoid coercing to wrong types.
      # For example, Math.min$Int32_Int32 should NOT fuzzy-match to Math.min$Float32_Float32
      # because that would coerce Int32 args to Float32 incorrectly.
      target_func = @module.function_by_name(method_name)

      # DISABLED: Fuzzy matching can cause wrong type coercion
      # When the exact function doesn't exist yet, we should NOT coerce args
      # based on a different typed overload.
      #
      # unless target_func
      #   base_name = method_name.split("$").first
      #   target_func = @module.functions_by_base_name(base_name).try(&.first?)
      # end
      #
      # unless target_func
      #   if method_name.includes?('#') || method_name.includes?('.')
      #     separator = method_name.includes?('#') ? "#" : "."
      #     parts = method_name.split(separator, 2)
      #     if parts.size == 2
      #       class_part = parts[0]
      #       method_with_types = parts[1]
      #       method_part = method_with_types.split("$").first
      #       base = "#{class_part}#{separator}#{method_part}"
      #       target_func = @module.functions_by_base_name(base).try(&.first?)
      #     end
      #   end
      # end

      return args unless target_func

      # Receiver counts as first implicit parameter for instance methods
      # The function params include self for instance methods
      params = target_func.params
      param_offset = params.first?.try(&.name) == "self" ? 1 : 0

      # Coerce each argument
      result = [] of ValueId
      args.each_with_index do |arg_id, idx|
        param = params[idx + param_offset]?
        if param.nil?
          # No more params - just pass through
          result << arg_id
          next
        end

        arg_type = ctx.type_of(arg_id)
        param_type = param.type
        param_type_name = @module.get_type_descriptor(param_type).try(&.name) || ""

        # Check if we need to coerce: arg is concrete type, param is union containing that type
        if needs_union_coercion?(arg_type, param_type)
          # Determine variant id: 0 for the concrete type, 1 for Nil typically
          variant_id = get_union_variant_id(param_type, arg_type)
          wrap = UnionWrap.new(ctx.next_id, param_type, arg_id, variant_id)
          ctx.emit(wrap)
          ctx.register_type(wrap.id, param_type)
          result << wrap.id
        elsif arg_type != TypeRef::VOID && param_type != TypeRef::VOID && arg_type != param_type
          target_type = nil
          if numeric_primitive?(param_type) && numeric_primitive?(arg_type)
            target_type = param_type
          elsif !param_type_name.empty?
            target_type = numeric_param_target_type(param_type_name, arg_type)
          end

          if target_type && target_type != TypeRef::VOID && target_type != arg_type
            cast = Cast.new(ctx.next_id, target_type, arg_id, target_type)
            ctx.emit(cast)
            ctx.register_type(cast.id, target_type)
            result << cast.id
          else
            result << arg_id
          end
        else
          result << arg_id
        end
      end

      result
    end

    private def coerce_value_to_type(
      ctx : LoweringContext,
      value_id : ValueId,
      target_type : TypeRef,
    ) : ValueId
      return value_id if target_type == TypeRef::VOID
      value_type = ctx.type_of(value_id)
      return value_id if value_type == target_type || value_type == TypeRef::VOID

      if needs_union_coercion?(value_type, target_type)
        variant_id = get_union_variant_id(target_type, value_type)
        if variant_id >= 0
          wrap = UnionWrap.new(ctx.next_id, target_type, value_id, variant_id)
          ctx.emit(wrap)
          ctx.register_type(wrap.id, target_type)
          return wrap.id
        end
      end

      if numeric_primitive?(target_type)
        if numeric_primitive?(value_type) || value_type == TypeRef::POINTER
          cast = Cast.new(ctx.next_id, target_type, value_id, target_type)
          ctx.emit(cast)
          ctx.register_type(cast.id, target_type)
          return cast.id
        end
      end

      value_id
    end

    private def union_type_cached?(type : TypeRef) : Bool
      cached = @union_type_cache[type.id]?
      return cached unless cached.nil?

      union = false
      if type_desc = @module.get_type_descriptor(type)
        union = type_desc.kind == TypeKind::Union
      else
        type_name = get_type_name_from_ref(type)
        union = union_type_name?(type_name)
      end

      @union_type_cache[type.id] = union
      union
    end

    # Check if arg_type needs to be wrapped into param_type union
    private def needs_union_coercion?(arg_type : TypeRef, param_type : TypeRef) : Bool
      # Quick check: same type, no coercion needed
      return false if arg_type == param_type

      return false unless union_type_cached?(param_type)

      # Param is union type - check if arg is a concrete type
      !union_type_cached?(arg_type)
    end

    # Check if a type is a union type
    private def is_union_type?(type : TypeRef) : Bool
      union_type_cached?(type)
    end

    # Check if a type is a nilable Int32 union (Int32 | Nil)
    private def is_nilable_int32_union?(type : TypeRef) : Bool
      if type_desc = @module.get_type_descriptor(type)
        # Check if it's a union with Int32 in the name (Int32___Nil or Int32 | Nil)
        if type_desc.kind == TypeKind::Union
          name = type_desc.name
          return name.includes?("Int32") && (name.includes?("Nil") || name.includes?("nil"))
        end
      end
      false
    end

    private def lookup_function_def_for_call(
      func_name : String,
      arg_count : Int32,
      has_block : Bool,
      arg_types : Array(TypeRef)? = nil,
      call_has_splat : Bool = false,
      call_has_named_args : Bool = false,
    ) : Tuple(String, CrystalV2::Compiler::Frontend::DefNode)?
      unknown_args = arg_types && arg_types.all? { |t| t == TypeRef::VOID }
      if @function_lookup_cache_size != @function_defs.size
        @function_lookup_cache_size = @function_defs.size
      end
      args_hash = 0_u64
      if arg_types
        owner = arg_types.object_id
        if @function_lookup_args_hash_owner == owner
          args_hash = @function_lookup_args_hash_value
        else
          arg_types.each do |arg_type|
            args_hash = (args_hash &* 131_u64) &+ arg_type.id.to_u64
          end
          @function_lookup_args_hash_owner = owner
          @function_lookup_args_hash_value = args_hash
        end
      end
      flags = 0_u8
      flags |= 1_u8 if has_block
      flags |= 2_u8 if arg_types
      flags |= 4_u8 if call_has_splat
      flags |= 8_u8 if call_has_named_args
      flags |= 16_u8 if unknown_args
      name_id = func_name.object_id
      base_name = strip_type_suffix(func_name)
      base_epoch = @function_lookup_base_epoch[base_name]? || 0
      if @function_lookup_last_result_valid &&
         @function_lookup_last_name_id == name_id &&
         @function_lookup_last_arg_count == arg_count &&
         @function_lookup_last_args_hash == args_hash &&
         @function_lookup_last_flags == flags &&
         @function_lookup_last_base_epoch == base_epoch
        return @function_lookup_last_result
      end
      cache_key = FunctionLookupKey.new(
        func_name,
        arg_count,
        args_hash,
        has_block,
        !arg_types.nil?,
        call_has_splat,
        call_has_named_args,
        !!unknown_args
      )
      if entry = @function_lookup_cache[cache_key]?
        if entry.base_epoch == base_epoch
          result = entry.result
          @function_lookup_last_name_id = name_id
          @function_lookup_last_arg_count = arg_count
          @function_lookup_last_args_hash = args_hash
          @function_lookup_last_flags = flags
          @function_lookup_last_base_epoch = base_epoch
          @function_lookup_last_result = result
          @function_lookup_last_result_valid = true
          return result
        end
      end
      if func_name.includes?('$')
        if func_def = @function_defs[func_name]?
          result = {func_name, func_def}
          @function_lookup_cache[cache_key] = FunctionLookupEntry.new(result, base_epoch)
          @function_lookup_last_name_id = name_id
          @function_lookup_last_arg_count = arg_count
          @function_lookup_last_args_hash = args_hash
          @function_lookup_last_flags = flags
          @function_lookup_last_base_epoch = base_epoch
          @function_lookup_last_result = result
          @function_lookup_last_result_valid = true
          return {func_name, func_def}
        end
      end

      overload_keys = [] of String
      if func_name.includes?('#') || func_name.includes?('.')
        parts = parse_method_name_compact(func_name)
        if parts.separator && parts.method
          ensure_method_index_built
          base_owner = strip_generic_args(parts.owner)
          if owner_methods = @method_index[base_owner]?
            if candidates = owner_methods[parts.method.not_nil!]?
              overload_keys = candidates unless candidates.empty?
            end
          end
          # If the callsite owner is a concrete generic instance, prefer
          # candidates that match the exact owner (avoid falling back to
          # generic-template defs without type args).
          if !overload_keys.empty? && parts.owner.includes?('(')
            owner_prefix = "#{parts.owner}#{parts.separator}"
            filtered = [] of String
            overload_keys.each do |cand|
              filtered << cand if cand.starts_with?(owner_prefix)
            end
            overload_keys = filtered unless filtered.empty?
          end
        end
      end

      if overload_keys.empty?
        stripped_func = func_name.includes?('(') ? strip_generic_receiver_for_lookup(func_name) : func_name
        overload_keys = function_def_overloads(func_name, stripped_func)
        if overload_keys.empty?
          # Fall back to base name if call included a mangled suffix.
          base = strip_type_suffix(func_name)
          if base != func_name
            stripped_base = stripped_func != func_name ? strip_type_suffix(stripped_func) : nil
            overload_keys = function_def_overloads(base, stripped_base)
          end
        end
        if overload_keys.empty?
          stripped = stripped_func
          if stripped != func_name
            overload_keys = function_def_overloads(stripped, stripped)
          end
        end
      end
      prefer_non_named = false
      unless call_has_named_args
        prefer_non_named = overload_keys.any? do |name|
          def_node = @function_defs[name]?
          next false unless def_node
          stats = function_param_stats(name, def_node)
          !stats.has_named_only
        end
      end
      if env_get("DEBUG_EACH_OVERLOAD") && func_name.includes?("Tuple#each")
        STDERR.puts "[EACH_OVERLOAD] func=#{func_name} arg_count=#{arg_count} named=#{call_has_named_args} block=#{has_block} prefer_non_named=#{prefer_non_named}"
        overload_keys.each do |name|
          def_node = @function_defs[name]?
          next unless def_node
          stats = function_param_stats(name, def_node)
          STDERR.puts "[EACH_OVERLOAD]   cand=#{name} named_only=#{stats.has_named_only} param_count=#{stats.param_count} required=#{stats.required}"
        end
      end
      prefer_splat = false
      if call_has_splat
        overload_keys.each do |name|
          def_node = @function_defs[name]?
          next unless def_node
          stats = function_param_stats(name, def_node)
          next if !call_has_named_args && stats.has_named_only
          next if prefer_non_named && stats.has_named_only
          if stats.has_splat
            prefer_splat = true
            break
          end
        end
      end
      best : CrystalV2::Compiler::Frontend::DefNode? = nil
      best_name : String? = nil
      best_param_count = Int32::MAX
      best_score = Int32::MIN
      prefer_untyped = false
      if arg_types && arg_types.any? { |t| t == TypeRef::VOID }
        overload_keys.each do |name|
          def_node = @function_defs[name]?
          next unless def_node
          stats = function_param_stats(name, def_node)
          next if !call_has_named_args && stats.has_named_only
          next if prefer_non_named && stats.has_named_only

          if has_block
            next unless stats.has_block
          else
            next if stats.has_block
          end

          param_count = stats.param_count
          has_splat = stats.has_splat
          has_double_splat = stats.has_double_splat
          required = stats.required

          next if arg_count < required
          next if arg_count > param_count && !has_splat && !has_double_splat

          untyped_candidate = untyped_candidate_for?(stats)
          if untyped_candidate
            prefer_untyped = true
            break
          end
        end
      end

      overload_keys.each do |name|
        def_node = @function_defs[name]?
        next unless def_node
        stats = function_param_stats(name, def_node)
        next if !call_has_named_args && stats.has_named_only
        next if prefer_non_named && stats.has_named_only

        if has_block
          next unless stats.has_block
        else
          next if stats.has_block
        end

        param_count = stats.param_count
        has_splat = stats.has_splat
        has_double_splat = stats.has_double_splat
        required = stats.required

        next if arg_count < required
        next if arg_count > param_count && !has_splat && !has_double_splat

        untyped_candidate = untyped_candidate_for?(stats)
        next if prefer_untyped && !untyped_candidate

        score = 0
        compatible = true
        if arg_types && !unknown_args
          func_context = function_context_from_name(name)
          compatible = params_compatible_with_args?(def_node, arg_types, func_context)
          if compatible
            score = params_match_score(def_node, arg_types, func_context)
          end
          next unless compatible
        end
        if arg_types && !unknown_args && arg_types.any? { |t| t == TypeRef::VOID }
          score -= stats.typed_param_count
        end
        if has_splat
          score -= 1
        elsif has_double_splat
          score -= 1
        end
        if call_has_named_args && has_double_splat
          if name.includes?("_double_splat")
            score += 2
          else
            score -= 2
          end
        end
        if prefer_splat
          if has_splat
            score += 2
          else
            score -= 2
          end
        end

        if param_count < best_param_count || (param_count == best_param_count && score > best_score)
          best = def_node
          best_name = name
          best_param_count = param_count
          best_score = score
        end
      end

      unless best && best_name
        # If this is a block call and no overload matched, try a block-only lookup
        # on the base name (e.g., Foo#each_with_index$block).
        if has_block
          base = strip_type_suffix(func_name)
          if block_entry = lookup_block_function_def_for_call(base, arg_count, arg_types)
            @function_lookup_cache[cache_key] = FunctionLookupEntry.new(block_entry, base_epoch)
            @function_lookup_last_name_id = name_id
            @function_lookup_last_arg_count = arg_count
            @function_lookup_last_args_hash = args_hash
            @function_lookup_last_flags = flags
            @function_lookup_last_base_epoch = base_epoch
            @function_lookup_last_result = block_entry
            @function_lookup_last_result_valid = true
            return block_entry
          end
        end
        @function_lookup_cache[cache_key] = FunctionLookupEntry.new(nil, base_epoch)
        @function_lookup_last_name_id = name_id
        @function_lookup_last_arg_count = arg_count
        @function_lookup_last_args_hash = args_hash
        @function_lookup_last_flags = flags
        @function_lookup_last_base_epoch = base_epoch
        @function_lookup_last_result = nil
        @function_lookup_last_result_valid = true
        return nil
      end
      if env_get("DEBUG_PUTS_LOOKUP") && func_name.includes?("IO#puts")
        type_names = if arg_types
                       arg_types.map { |t| type_name_for_mangling(t) }.join(",")
                     else
                       ""
                     end
        STDERR.puts "[DEBUG_PUTS_LOOKUP] func=#{func_name} count=#{arg_count} args=#{type_names} best=#{best_name}"
      end
      result = {best_name, best}
      @function_lookup_cache[cache_key] = FunctionLookupEntry.new(result, base_epoch)
      @function_lookup_last_name_id = name_id
      @function_lookup_last_arg_count = arg_count
      @function_lookup_last_args_hash = args_hash
      @function_lookup_last_flags = flags
      @function_lookup_last_base_epoch = base_epoch
      @function_lookup_last_result = result
      @function_lookup_last_result_valid = true
      result
    end

    private def lookup_block_function_def_for_call(
      func_name : String,
      arg_count : Int32,
      arg_types : Array(TypeRef)? = nil,
      receiver_base : String? = nil,
    ) : Tuple(String, CrystalV2::Compiler::Frontend::DefNode)?
      if @block_lookup_cache_size != @function_defs.size
        @block_lookup_cache.clear
        @block_lookup_cache_size = @function_defs.size
      end
      args_hash = 0_u64
      if arg_types
        arg_types.each do |arg_type|
          args_hash = (args_hash &* 131_u64) &+ arg_type.id.to_u64
        end
      end
      cache_key = BlockLookupKey.new(func_name, arg_count, args_hash, receiver_base, !arg_types.nil?)
      if @block_lookup_cache.has_key?(cache_key)
        return @block_lookup_cache[cache_key]
      end

      best : CrystalV2::Compiler::Frontend::DefNode? = nil
      best_name : String? = nil
      best_param_count = Int32::MAX
      best_score = Int32::MIN

      base_name = strip_type_suffix(func_name)
      func_name_dollar = "#{func_name}$"
      debug_lookup = env_has?("DEBUG_YIELD_INLINE") && func_name.includes?("trace")
      function_def_overloads(base_name).each do |name|
        if debug_lookup
          STDERR.puts "[LOOKUP_BLOCK] checking name=#{name} func_name=#{func_name}"
        end
        next unless name == func_name || name.starts_with?(func_name_dollar)
        def_node = @function_defs[name]?
        next unless def_node
        stats = function_param_stats(name, def_node)
        if debug_lookup
          STDERR.puts "[LOOKUP_BLOCK]   has_block=#{stats.has_block} param_count=#{stats.param_count} required=#{stats.required} arg_count=#{arg_count}"
        end
        next unless stats.has_block

        param_count = stats.param_count
        has_splat = stats.has_splat
        has_double_splat = stats.has_double_splat
        required = stats.required

        if debug_lookup && arg_count < required
          STDERR.puts "[LOOKUP_BLOCK]   SKIP: arg_count < required"
        end
        next if arg_count < required
        if debug_lookup && (arg_count > param_count && !has_splat && !has_double_splat)
          STDERR.puts "[LOOKUP_BLOCK]   SKIP: arg_count > param_count"
        end
        next if arg_count > param_count && !has_splat && !has_double_splat

        score = 0
        if arg_types
          func_context = function_context_from_name(name)
          compatible = params_compatible_with_args?(def_node, arg_types, func_context)
          if debug_lookup && !compatible
            STDERR.puts "[LOOKUP_BLOCK]   SKIP: params_compatible=false arg_types=#{arg_types.map(&.id).join(",")}"
          end
          next unless compatible
          score = params_match_score(def_node, arg_types, func_context)
        end
        if has_splat
          score -= 1
        elsif has_double_splat
          score -= 1
        end

        if param_count < best_param_count || (param_count == best_param_count && score > best_score)
          best = def_node
          best_name = name
          best_param_count = param_count
          best_score = score
        end
      end

      if best && best_name
        result = {best_name, best}
        @block_lookup_cache[cache_key] = result
        return result
      end

      # Fallback: match by method short name across owners (for inherited yield methods).
      # Example: Int32#try should inline Object#try when receiver_base allows it.
      method_short = method_short_from_name(func_name)
      if method_short
        instance_suffix = "##{method_short}"
        class_suffix = ".#{method_short}"
        @function_defs.each do |name, def_node|
          candidate_base = strip_type_suffix_uncached(name)
          next unless candidate_base.ends_with?(instance_suffix) || candidate_base.ends_with?(class_suffix)
          if receiver_base
            owner = method_owner_from_name(candidate_base)
            owner_base = strip_generic_args(owner)
            next unless receiver_allows_yield_owner?(receiver_base, owner_base)
          end

          stats = function_param_stats(name, def_node)
          next unless stats.has_block

          param_count = stats.param_count
          has_splat = stats.has_splat
          has_double_splat = stats.has_double_splat
          required = stats.required
          next if arg_count < required
          next if arg_count > param_count && !has_splat && !has_double_splat

          score = 0
          if arg_types
            func_context = function_context_from_name(name)
            next unless params_compatible_with_args?(def_node, arg_types, func_context)
            score = params_match_score(def_node, arg_types, func_context)
          end
          if has_splat
            score -= 1
          elsif has_double_splat
            score -= 1
          end
          if param_count < best_param_count || (param_count == best_param_count && score > best_score)
            best = def_node
            best_name = name
            best_param_count = param_count
            best_score = score
          end
        end
      end

      if best && best_name
        result = {best_name, best}
        @block_lookup_cache[cache_key] = result
        return result
      end

      @block_lookup_cache[cache_key] = nil
      nil
    end

    private def underscore_lower(name : String) : String
      name.downcase.gsub("_", "")
    end

    private def enum_members_for_type_name(type_name : String, context : String? = nil) : Hash(String, Int64)?
      return nil unless enum_info = @enum_info
      normalized = normalize_declared_type_name(type_name, context)
      candidates = [] of String
      candidates << normalized
      if normalized.ends_with?('?')
        candidates << normalized[0...-1]
      end
      if normalized.includes?('|')
        split_union_type_name(normalized).each do |part|
          candidates << part.strip
        end
      end

      candidates.uniq.each do |candidate|
        lookup = resolve_type_alias_chain(candidate)
        return enum_info[lookup]? if enum_info.has_key?(lookup)
        short_name = last_namespace_component(lookup)
        return enum_info[short_name]? if short_name != lookup && enum_info.has_key?(short_name)
      end
      nil
    end

    private def maybe_log_lower_histo(node : AstNode) : Nil
      return unless env_has?("DEBUG_LOWER_HISTO")

      name = last_namespace_component(node.class.name)
      @lower_histo_counts[name] = (@lower_histo_counts[name]? || 0) + 1
      @lower_histo_total += 1
      @lower_histo_since_check += 1
      if @lower_histo_last.nil?
        @lower_histo_last = Time.instant
        @lower_histo_since_check = 0
        return
      end
      return if @lower_histo_since_check < 4096

      now = Time.instant
      elapsed = now - @lower_histo_last.not_nil!
      if elapsed.total_seconds >= 3
        top = @lower_histo_counts.to_a.sort_by(&.last).reverse.first(12)
        stats = top.map { |(k, v)| "#{k}=#{v}" }.join(" ")
        STDERR.puts "[LOWER_HISTO] total=#{@lower_histo_total} #{stats}"
        @lower_histo_counts.clear
        @lower_histo_total = 0
        @lower_histo_last = now
      end
      @lower_histo_since_check = 0
    end

    private def enum_member_value(type_name : String, symbol_name : String, context : String? = nil) : Int64?
      members = enum_members_for_type_name(type_name, context)
      return nil unless members
      clean_symbol = symbol_name.starts_with?(':') ? symbol_name[1..] : symbol_name
      target = underscore_lower(clean_symbol)
      members.each do |member_name, value|
        return value if underscore_lower(member_name) == target
      end
      # @[Flags] enums auto-generate None = 0 and All = bitor(all members)
      if target == "none"
        return 0_i64
      elsif target == "all"
        all_val = 0_i64
        members.each_value { |v| all_val |= v }
        return all_val
      end
      nil
    end

    private def lower_arg_with_expected_type(
      ctx : LoweringContext,
      arg_expr : ExprId,
      expected_type : TypeRef,
      expected_type_name : String?,
      context : String? = nil,
    ) : ValueId
      arg_node = @arena[arg_expr]
      if expected_type_name && arg_node.is_a?(CrystalV2::Compiler::Frontend::SymbolNode)
        if value = enum_member_value(expected_type_name, String.new(arg_node.name), context)
          lit = Literal.new(ctx.next_id, TypeRef::INT32, value)
          ctx.emit(lit)
          ctx.register_type(lit.id, TypeRef::INT32)
          enum_type_name = resolve_type_alias_chain(expected_type_name)
          (@enum_value_types ||= {} of ValueId => String)[lit.id] = enum_type_name
          return lit.id
        end
      end

      lower_expr(ctx, arg_expr)
    end

    private def allocate_named_tuple(ctx : LoweringContext, values : Array(ValueId)) : ValueId
      named_tuple_type = ctx.get_type("NamedTuple")
      alloc = Allocate.new(ctx.next_id, named_tuple_type, values)
      ctx.emit(alloc)
      alloc.id
    end

    private def lower_args_with_expected_types(
      ctx : LoweringContext,
      positional_args : Array(ExprId),
      method_name : String,
      full_method_name : String?,
      has_block_call : Bool,
      call_arena : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : Array(ValueId)
      func_name = full_method_name || method_name
      arg_types = positional_args.map do |arg_expr|
        arg_node = if arg_expr.index >= 0 && arg_expr.index < call_arena.size
                     call_arena[arg_expr]
                   else
                     nil
                   end
        if arg_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          name = String.new(arg_node.name)
          if local_id = ctx.lookup_local(name)
            ctx.type_of(local_id)
          else
            infer_type_from_expr(arg_expr, @current_class) || TypeRef::VOID
          end
        else
          infer_type_from_expr(arg_expr, @current_class) || TypeRef::VOID
        end
      end
      if env_get("DEBUG_CALL_TYPES") &&
         (func_name.includes?("Unicode.in_category?") || func_name.includes?("Unicode.in_any_category?"))
        arg_type_names = arg_types.map { |t| get_type_name_from_ref(t) }
        STDERR.puts "[CALL_TYPES] name=#{func_name} arg_types=#{arg_type_names.join(",")}"
        positional_args.each_with_index do |arg_expr, idx|
          arg_node = if arg_expr.index >= 0 && arg_expr.index < call_arena.size
                       call_arena[arg_expr]
                     else
                       nil
                     end
          if arg_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            name = String.new(arg_node.name)
            if local_id = ctx.lookup_local(name)
              local_type = get_type_name_from_ref(ctx.type_of(local_id))
              STDERR.puts "[CALL_TYPES] arg#{idx} ident=#{name} local_type=#{local_type}"
            else
              STDERR.puts "[CALL_TYPES] arg#{idx} ident=#{name} local_type=(missing)"
            end
          else
            STDERR.puts "[CALL_TYPES] arg#{idx} node=#{arg_node.class}"
          end
        end
      end
      # If any argument type is unknown, avoid pinning to a specific overload.
      # This prevents premature coercions that can lock in the wrong overload.
      if arg_types.any? { |t| t == TypeRef::VOID }
        return positional_args.map { |arg| lower_expr(ctx, arg) }
      end
      func_entry = lookup_function_def_for_call(func_name, positional_args.size, has_block_call, arg_types)
      func_def = func_entry ? func_entry[1] : nil
      func_context = func_entry ? function_context_from_name(func_entry[0]) : nil
      return positional_args.map { |arg| lower_expr(ctx, arg) } unless func_def

      param_types = [] of TypeRef
      param_type_names = [] of String?

      if params = func_def.params
        params.each do |param|
          next if param.is_block
          next if named_only_separator?(param)

          param_type_name = if ta = param.type_annotation
                              normalize_declared_type_name(String.new(ta), func_context)
                            else
                              nil
                            end

          param_type = if param.is_double_splat
                         param_type_name ? type_ref_for_name(param_type_name) : type_ref_for_name("NamedTuple")
                       else
                         if param_type_name
                           type_ref_for_name(param_type_name)
                         else
                           TypeRef::VOID
                         end
                       end

          param_types << param_type
          param_type_names << param_type_name
        end
      end

      result = [] of ValueId
      old_arena = @arena
      begin
        positional_args.each_with_index do |arg_expr, idx|
          @arena = call_arena
          if env_get("DEBUG_CALL_ARGS")
            kind = if arg_expr.index >= 0 && arg_expr.index < call_arena.size
                     CrystalV2::Compiler::Frontend.node_kind(call_arena[arg_expr]).to_s
                   else
                     "oob"
                   end
            STDERR.puts "[CALL_ARGS] func=#{func_name} idx=#{idx} expr=#{arg_expr.index} kind=#{kind} arena=#{call_arena.class}:#{call_arena.size}"
          end
          if idx < param_types.size
            value_id = lower_arg_with_expected_type(ctx, arg_expr, param_types[idx], param_type_names[idx], func_context)
            result << value_id
            if env_get("DEBUG_CALL_ARGS")
              STDERR.puts "[CALL_ARGS_DONE] func=#{func_name} idx=#{idx} expr=#{arg_expr.index} value=#{value_id} type=#{ctx.type_of(value_id)}"
            end
          else
            value_id = lower_expr(ctx, arg_expr)
            result << value_id
            if env_get("DEBUG_CALL_ARGS")
              STDERR.puts "[CALL_ARGS_DONE] func=#{func_name} idx=#{idx} expr=#{arg_expr.index} value=#{value_id} type=#{ctx.type_of(value_id)}"
            end
          end
          @arena = call_arena
        end
      ensure
        @arena = old_arena
      end

      if env_get("DEBUG_CALL_ARGS")
        STDERR.puts "[CALL_ARGS_END] func=#{func_name} args=#{result.size}"
      end

      result
    end

    # Reorder named arguments to match parameter positions
    private def reorder_named_args(
      ctx : LoweringContext,
      positional_args : Array(ExprId),
      named_args : Array(CrystalV2::Compiler::Frontend::NamedArgument),
      method_name : String,
      full_method_name : String?,
      has_block_call : Bool,
      call_arena : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : Array(ValueId)
      # Get parameter names from function definition
      func_name = full_method_name || method_name
      func_entry = lookup_function_def_for_call(func_name, positional_args.size + named_args.size, has_block_call, nil, false, !named_args.empty?)
      func_def = func_entry ? func_entry[1] : nil
      func_context = func_entry ? function_context_from_name(func_entry[0]) : nil
      def_arena = func_entry ? (@function_def_arenas[func_entry[0]]? || @arena) : @arena

      if func_def && (params = func_def.params)
        param_call_names = [] of String
        param_local_names = [] of String
        param_defaults = [] of ExprId?
        param_types = [] of TypeRef
        param_type_names = [] of String?
        double_splat_index : Int32? = nil

        params.each do |p|
          next if p.is_block
          next if named_only_separator?(p)
          call_name = if ext = p.external_name
                        String.new(ext)
                      elsif name = p.name
                        String.new(name)
                      else
                        ""
                      end
          local_name = p.name ? String.new(p.name.not_nil!) : ""
          param_type_name = if ta = p.type_annotation
                              normalize_declared_type_name(String.new(ta), func_context)
                            else
                              nil
                            end
          param_type = if p.is_double_splat
                         param_type_name ? type_ref_for_name(param_type_name) : type_ref_for_name("NamedTuple")
                       elsif param_type_name
                         type_ref_for_name(param_type_name)
                       else
                         TypeRef::VOID
                       end
          param_call_names << call_name
          param_local_names << local_name
          param_defaults << p.default_value
          param_types << param_type
          param_type_names << param_type_name
          if p.is_double_splat
            double_splat_index = param_types.size - 1
          end
        end

        result = [] of ValueId
        provided = [] of Bool
        old_arena = @arena
        begin
          positional_args.each_with_index do |arg_expr, idx|
            @arena = call_arena
            if idx < param_types.size
              result << lower_arg_with_expected_type(ctx, arg_expr, param_types[idx], param_type_names[idx], func_context)
            else
              result << lower_expr(ctx, arg_expr)
            end
            provided << true
            @arena = call_arena
          end

          extra_named = [] of CrystalV2::Compiler::Frontend::NamedArgument

          # Process named args
          named_args.each do |named_arg|
            arg_name = String.new(named_arg.name)

            # Find position of this parameter
            idx = param_call_names.index(arg_name)
            if idx
              # Extend result array if needed
              while result.size <= idx
                # Fill with nil placeholder (will be replaced)
                nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                ctx.emit(nil_lit)
                result << nil_lit.id
                provided << false
              end
              @arena = call_arena
              result[idx] = lower_arg_with_expected_type(ctx, named_arg.value, param_types[idx], param_type_names[idx], func_context)
              provided[idx] = true
            else
              extra_named << named_arg
            end
          end

          if double_splat_index
            while result.size <= double_splat_index
              nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
              ctx.emit(nil_lit)
              result << nil_lit.id
              provided << false
            end

            unless provided[double_splat_index]
              tuple_values = extra_named.map do |arg|
                @arena = call_arena
                lower_expr(ctx, arg.value)
              end
              result[double_splat_index] = allocate_named_tuple(ctx, tuple_values)
              provided[double_splat_index] = true
              extra_named.clear
            end
          end

          extra_named.each do |named_arg|
            @arena = call_arena
            result << lower_expr(ctx, named_arg.value)
            provided << true
          end

          # Fill missing args with defaults (evaluate in a param-local context)
          if param_defaults.any?
            while result.size < param_call_names.size
              nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
              ctx.emit(nil_lit)
              result << nil_lit.id
              provided << false
            end

            saved_locals = ctx.save_locals
            begin
              locals = ctx.all_locals
              param_local_names.each_with_index do |name, idx|
                next if name.empty?
                if idx < result.size && provided[idx]
                  locals[name] = result[idx]
                end
              end

              param_defaults.each_with_index do |default_expr, idx|
                next if provided[idx]
                next unless default_expr
                @arena = call_arena
                default_id = with_arena(def_arena) {
                  if idx < param_type_names.size && param_type_names[idx]
                    lower_arg_with_expected_type(ctx, default_expr, param_types[idx], param_type_names[idx], func_context)
                  else
                    lower_expr(ctx, default_expr)
                  end
                }
                if param_types[idx] != TypeRef::VOID
                  ctx.register_type(default_id, param_types[idx])
                end
                result[idx] = default_id
                provided[idx] = true
                name = param_local_names[idx]
                locals[name] = default_id unless name.empty?
              end
            ensure
              ctx.restore_locals(saved_locals)
            end
          end
        ensure
          @arena = old_arena
        end
      else
        # No function definition found - just append named args in order
        result = positional_args.map do |arg|
          @arena = call_arena
          lower_expr(ctx, arg)
        end
        named_args.each do |named_arg|
          @arena = call_arena
          result << lower_expr(ctx, named_arg.value)
        end
      end

      result
    end

    private def apply_default_args(
      ctx : LoweringContext,
      args : Array(ValueId),
      method_name : String,
      full_method_name : String?,
      has_block_call : Bool,
      call_has_named_args : Bool,
      receiver_id : ValueId? = nil,
    ) : Array(ValueId)
      func_name = full_method_name || method_name
      arg_types = args.map { |arg_id| ctx.type_of(arg_id) }
      # Pass call_has_named_args=true to allow matching defs with named-only params
      # (e.g. `*, precision : Int = 1`). We fill in their defaults ourselves, so
      # the filter that normally skips named-only defs shouldn't apply here.
      func_entry = lookup_function_def_for_call(func_name, args.size, has_block_call, arg_types, false, true)
      # If not found directly, try parent classes (for inherited methods with defaults)
      unless func_entry
        parts = parse_method_name(func_name)
        if parts.separator == '#' && (method_part = parts.method)
          parent = @class_info[parts.owner]?.try(&.parent_name)
          visited = Set(String).new
          debug_da = env_has?("DEBUG_DEFAULT_ARGS") && func_name.includes?("to_s")
          if debug_da
            STDERR.puts "[DEFAULT_ARGS] Walking parents for #{func_name} (#{args.size} args), method_part=#{method_part}"
          end
          while parent && !func_entry
            break if visited.includes?(parent)
            visited << parent
            parent_func = "#{parent}##{method_part}"
            func_entry = lookup_function_def_for_call(parent_func, args.size, has_block_call, arg_types, false, true)
            if debug_da
              result = func_entry ? "FOUND=#{func_entry[0]}" : "not found"
              STDERR.puts "[DEFAULT_ARGS]   parent=#{parent} try=#{parent_func} → #{result}"
            end
            parent = @class_info[parent]?.try(&.parent_name) unless func_entry
          end
        end
      end
      if env_has?("DEBUG_DEFAULT_ARGS") && func_name.includes?("to_s")
        found_name = func_entry ? func_entry[0] : "nil"
        STDERR.puts "[DEFAULT_ARGS] func_name=#{func_name} args.size=#{args.size} found=#{found_name}"
      end
      return args unless func_entry
      func_def = func_entry[1]
      func_context = function_context_from_name(func_entry[0])
      def_arena = @function_def_arenas[func_entry[0]]? || @arena
      params = func_def.params
      return args unless params

      param_local_names = [] of String
      param_defaults = [] of ExprId?
      param_types = [] of TypeRef
      param_type_names = [] of String?

      params.each do |p|
        next if p.is_block
        next if named_only_separator?(p)
        local_name = p.name ? String.new(p.name.not_nil!) : ""
        param_local_names << local_name
        param_defaults << p.default_value
        if ta = p.type_annotation
          param_type_name = normalize_declared_type_name(String.new(ta), func_context)
          param_types << type_ref_for_name(param_type_name)
          param_type_names << param_type_name
        else
          param_types << TypeRef::VOID
          param_type_names << nil
        end
      end

      return args if args.size >= param_defaults.size

      saved_locals = ctx.save_locals
      saved_current_class = @current_class
      begin
        locals = ctx.all_locals
        # Bind `self` to the receiver so default expressions like `size - 1`
        # evaluate on the correct object (matches original Crystal's behavior
        # of creating wrapper overloads where `self` is the receiver).
        if receiver_id
          # Use register_local to also set @self_id (lookup_local checks
          # @self_id before @locals, so setting only @locals is not enough).
          ctx.register_local("self", receiver_id)
          # Also set the receiver's type and class context so that method
          # resolution (e.g., `size` → `Slice#size`) works correctly.
          if func_context && !func_context.empty?
            receiver_type = type_ref_for_name(func_context)
            if receiver_type != TypeRef::VOID
              ctx.register_type(receiver_id, receiver_type)
            end
            @current_class = func_context
          end
        end
        param_local_names.each_with_index do |name, idx|
          break if idx >= args.size
          locals[name] = args[idx] unless name.empty?
        end

        idx = args.size
        while idx < param_defaults.size
          default_expr = param_defaults[idx]
          break unless default_expr
          default_id = with_arena(def_arena) {
            if idx < param_type_names.size && param_type_names[idx]
              lower_arg_with_expected_type(ctx, default_expr, param_types[idx], param_type_names[idx].not_nil!, func_context)
            else
              lower_expr(ctx, default_expr)
            end
          }
          if param_types[idx] != TypeRef::VOID
            ctx.register_type(default_id, param_types[idx])
          end
          args << default_id
          local_name = param_local_names[idx]
          locals[local_name] = default_id unless local_name.empty?
          idx += 1
        end
      ensure
        ctx.restore_locals(saved_locals)
        @current_class = saved_current_class
      end

      args
    end

    # Intrinsic: n.times { |i| body }
    # Expands to: i = 0; while i < n { body; i += 1 }
    # Uses phi nodes for loop variable AND mutable external variables
    private def lower_times_intrinsic(ctx : LoweringContext, count_id : ValueId, block : CrystalV2::Compiler::Frontend::BlockNode) : ValueId
      # Get block param name (default to "i" if not specified)
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__times_i"

      # Collect variables that might be assigned in the block body (same as while loop)
      assigned_vars = collect_assigned_vars(block.body)
      # Remove the block parameter from assigned vars - it's handled separately
      assigned_vars = assigned_vars.reject { |v| v == param_name }
      inline_vars = Set(String).new

      # Save initial values of mutable variables before the loop
      entry_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      # Initial counter value
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      # Create blocks
      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      # Jump to condition
      ctx.terminate(Jump.new(cond_block))

      # Condition block with phi for counter
      ctx.current_block = cond_block
      counter_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      counter_phi.add_incoming(entry_block, zero.id)
      ctx.emit(counter_phi)

      # Create phi nodes for mutable external variables (same pattern as lower_while)
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          phi.add_incoming(entry_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      # Register counter for use in body
      ctx.register_local(param_name, counter_phi.id)
      ctx.register_type(counter_phi.id, TypeRef::INT32)

      # Compare: i < n
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, counter_phi.id, count_id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      # Lower block body
      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      @loop_exit_stack << exit_block
      @loop_cond_stack << incr_block
      @loop_phi_stack << phi_nodes
      @loop_break_info_stack << [] of {BlockId, Hash(String, ValueId)}
      begin
        lower_body(ctx, block.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
        @loop_exit_stack.pop?
        @loop_cond_stack.pop?
        @loop_phi_stack.pop?
      end
      break_info = @loop_break_info_stack.pop
      body_exit_block = ctx.current_block
      ctx.pop_scope

      # Jump to increment block
      ctx.terminate(Jump.new(incr_block))

      # Increment block: i + 1
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, counter_phi.id, one.id)
      ctx.emit(new_i)

      # Add incoming to counter phi from increment block
      counter_phi.add_incoming(incr_block, new_i.id)

      # Patch mutable variable phi nodes - incoming from incr_block (the actual predecessor of cond_block)
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            # Add incoming from incr_block (not body_block!)
            phi.add_incoming(incr_block, updated_val)
          end
        end
      end

      # Jump back to condition
      ctx.terminate(Jump.new(cond_block))

      # Exit block - merge normal exit + break paths
      ctx.current_block = exit_block
      if break_info.empty?
        phi_nodes.each do |var_name, phi|
          ctx.register_local(var_name, phi.id)
        end
      else
        phi_nodes.each do |var_name, cond_phi|
          exit_phi = Phi.new(ctx.next_id, cond_phi.type)
          exit_phi.add_incoming(cond_block, cond_phi.id)
          break_info.each do |break_block, break_locals|
            if break_val = break_locals[var_name]?
              exit_phi.add_incoming(break_block, break_val)
            else
              exit_phi.add_incoming(break_block, cond_phi.id)
            end
          end
          ctx.emit(exit_phi)
          ctx.register_local(var_name, exit_phi.id)
        end
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Intrinsic: (begin..end).each { |i| body } or (begin...end).each { |i| body }
    # Expands to: i = begin; while i <= end (or < for exclusive) { body; i += 1 }
    private def lower_range_each_intrinsic(
      ctx : LoweringContext,
      range : CrystalV2::Compiler::Frontend::RangeNode,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      # Get block param name
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__range_i"

      # Lower range bounds
      begin_id = lower_expr(ctx, range.begin_expr)
      end_id = lower_expr(ctx, range.end_expr)

      # Collect mutable vars (same as times)
      assigned_vars = collect_assigned_vars(block.body)
      assigned_vars = assigned_vars.reject { |v| v == param_name }
      inline_vars = Set(String).new

      entry_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      # Create blocks
      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block with phi
      ctx.current_block = cond_block
      counter_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      counter_phi.add_incoming(entry_block, begin_id)
      ctx.emit(counter_phi)

      # Phi for mutable vars
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          phi.add_incoming(entry_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      ctx.register_local(param_name, counter_phi.id)
      ctx.register_type(counter_phi.id, TypeRef::INT32)

      # Compare: i <= end (inclusive) or i < end (exclusive)
      cmp_op = range.exclusive ? BinaryOp::Lt : BinaryOp::Le
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, cmp_op, counter_phi.id, end_id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)
      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      @loop_exit_stack << exit_block
      @loop_cond_stack << incr_block
      @loop_phi_stack << phi_nodes
      @loop_break_info_stack << [] of {BlockId, Hash(String, ValueId)}
      begin
        lower_body(ctx, block.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
        @loop_exit_stack.pop?
        @loop_cond_stack.pop?
        @loop_phi_stack.pop?
      end
      break_info = @loop_break_info_stack.pop
      ctx.pop_scope
      ctx.terminate(Jump.new(incr_block))

      # Increment block
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, counter_phi.id, one.id)
      ctx.emit(new_i)

      counter_phi.add_incoming(incr_block, new_i.id)

      # Patch mutable var phis
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            phi.add_incoming(incr_block, updated_val)
          end
        end
      end

      ctx.terminate(Jump.new(cond_block))

      # Exit block - merge normal exit + break paths
      ctx.current_block = exit_block
      if break_info.empty?
        phi_nodes.each do |var_name, phi|
          ctx.register_local(var_name, phi.id)
        end
      else
        phi_nodes.each do |var_name, cond_phi|
          exit_phi = Phi.new(ctx.next_id, cond_phi.type)
          exit_phi.add_incoming(cond_block, cond_phi.id)
          break_info.each do |break_block, break_locals|
            if break_val = break_locals[var_name]?
              exit_phi.add_incoming(break_block, break_val)
            else
              exit_phi.add_incoming(break_block, cond_phi.id)
            end
          end
          ctx.emit(exit_phi)
          ctx.register_local(var_name, exit_phi.id)
        end
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Intrinsic: arr.each { |x| body } for static array with known size
    private def lower_array_each_intrinsic(
      ctx : LoweringContext,
      array_id : ValueId,
      array_size : Int32,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      # Get block param name
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__arr_elem"

      # Collect mutable vars
      assigned_vars = collect_assigned_vars(block.body)
      assigned_vars = assigned_vars.reject { |v| v == param_name }
      inline_vars = Set(String).new

      entry_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      # Emit zero in entry block BEFORE jump (required for phi SSA)
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      # Create blocks
      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block with index phi
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      # Phi for mutable vars
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          phi.add_incoming(entry_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      # Compare: i < size
      size_lit = Literal.new(ctx.next_id, TypeRef::INT32, array_size.to_i64)
      ctx.emit(size_lit)
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_lit.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      # Get element: arr[i]
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)

      # Handle tuple destructuring: |(a, b, ...)| vs single param |x|
      if params = block.params
        if params.size > 1
          # Tuple destructuring - extract each element
          params.each_with_index do |param, idx|
            if pname = param.name
              name = String.new(pname)
              idx_lit = Literal.new(ctx.next_id, TypeRef::INT32, idx.to_i64)
              ctx.emit(idx_lit)
              elem_type = tuple_element_type(element_type, idx) || TypeRef::VOID
              elem_extract = IndexGet.new(ctx.next_id, elem_type, index_get.id, idx_lit.id)
              ctx.emit(elem_extract)
              ctx.register_type(elem_extract.id, elem_type)
              ctx.register_local(name, elem_extract.id)
            end
          end
        else
          # Single parameter - bind whole element
          ctx.register_local(param_name, index_get.id)
        end
      else
        ctx.register_local(param_name, index_get.id)
      end

      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      @loop_exit_stack << exit_block
      @loop_cond_stack << incr_block
      @loop_phi_stack << phi_nodes
      @loop_break_info_stack << [] of {BlockId, Hash(String, ValueId)}
      begin
        lower_body(ctx, block.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
        @loop_exit_stack.pop?
        @loop_cond_stack.pop?
        @loop_phi_stack.pop?
      end
      break_info = @loop_break_info_stack.pop
      ctx.pop_scope
      ctx.terminate(Jump.new(incr_block))

      # Increment block
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)

      index_phi.add_incoming(incr_block, new_i.id)

      # Patch mutable var phis
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            phi.add_incoming(incr_block, updated_val)
          end
        end
      end

      ctx.terminate(Jump.new(cond_block))

      # Exit block - merge normal exit + break paths
      ctx.current_block = exit_block
      if break_info.empty?
        phi_nodes.each do |var_name, phi|
          ctx.register_local(var_name, phi.id)
        end
      else
        phi_nodes.each do |var_name, cond_phi|
          exit_phi = Phi.new(ctx.next_id, cond_phi.type)
          exit_phi.add_incoming(cond_block, cond_phi.id)
          break_info.each do |break_block, break_locals|
            if break_val = break_locals[var_name]?
              exit_phi.add_incoming(break_block, break_val)
            else
              exit_phi.add_incoming(break_block, cond_phi.id)
            end
          end
          ctx.emit(exit_phi)
          ctx.register_local(var_name, exit_phi.id)
        end
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Dynamic array each - gets size at runtime via ArraySize
    private def lower_array_each_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      # Get block param name
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__arr_elem"

      # Collect mutable vars
      assigned_vars = collect_assigned_vars(block.body)
      assigned_vars = assigned_vars.reject { |v| v == param_name }
      inline_vars = Set(String).new

      entry_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      # Emit zero in entry block BEFORE jump (required for phi SSA)
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      # Create blocks
      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block with index phi
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      # Phi for mutable vars
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          phi.add_incoming(entry_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      # Get array size dynamically
      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      # Compare: i < size
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      # Get element: arr[i]
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)

      # Handle tuple destructuring: |(a, b, ...)| vs single param |x|
      if params = block.params
        if params.size > 1
          # Tuple destructuring - extract each element
          params.each_with_index do |param, idx|
            if pname = param.name
              name = String.new(pname)
              idx_lit = Literal.new(ctx.next_id, TypeRef::INT32, idx.to_i64)
              ctx.emit(idx_lit)
              elem_type = tuple_element_type(element_type, idx) || TypeRef::VOID
              elem_extract = IndexGet.new(ctx.next_id, elem_type, index_get.id, idx_lit.id)
              ctx.emit(elem_extract)
              ctx.register_type(elem_extract.id, elem_type)
              ctx.register_local(name, elem_extract.id)
            end
          end
        else
          # Single parameter - bind whole element
          ctx.register_local(param_name, index_get.id)
        end
      else
        ctx.register_local(param_name, index_get.id)
      end

      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      # Push loop stacks so `next` in block body jumps to incr_block (advances index),
      # and `break` jumps to exit_block. Without this, `next` emits `unreachable`.
      @loop_exit_stack << exit_block
      @loop_cond_stack << incr_block  # next → increment → cond (NOT directly to cond)
      @loop_phi_stack << phi_nodes
      @loop_break_info_stack << [] of {BlockId, Hash(String, ValueId)}
      begin
        lower_body(ctx, block.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
        @loop_exit_stack.pop?
        @loop_cond_stack.pop?
        @loop_phi_stack.pop?
      end
      break_info = @loop_break_info_stack.pop
      ctx.pop_scope
      ctx.terminate(Jump.new(incr_block))

      # Increment block
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)

      index_phi.add_incoming(incr_block, new_i.id)

      # Patch mutable var phis
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            phi.add_incoming(incr_block, updated_val)
          end
        end
      end

      ctx.terminate(Jump.new(cond_block))

      # Exit block - merge normal exit + break paths
      ctx.current_block = exit_block
      if break_info.empty?
        phi_nodes.each do |var_name, phi|
          ctx.register_local(var_name, phi.id)
        end
      else
        phi_nodes.each do |var_name, cond_phi|
          exit_phi = Phi.new(ctx.next_id, cond_phi.type)
          exit_phi.add_incoming(cond_block, cond_phi.id)
          break_info.each do |break_block, break_locals|
            if break_val = break_locals[var_name]?
              exit_phi.add_incoming(break_block, break_val)
            else
              exit_phi.add_incoming(break_block, cond_phi.id)
            end
          end
          ctx.emit(exit_phi)
          ctx.register_local(var_name, exit_phi.id)
        end
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Check if a MemberAccessNode's original object is an array (before module retyping)
    private def check_original_receiver_is_array?(ctx : LoweringContext, callee_node : CrystalV2::Compiler::Frontend::MemberAccessNode) : Bool
      orig_obj = @arena[callee_node.object]
      if orig_obj.is_a?(CrystalV2::Compiler::Frontend::ArrayLiteralNode)
        return true
      elsif orig_obj.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
        if pname = orig_obj.name
          var_name = String.new(pname)
          if var_val = ctx.lookup_local(var_name)
            var_type = ctx.type_of(var_val)
            if desc = @module.get_type_descriptor(var_type)
              return desc.kind == TypeKind::Array &&
                (desc.name.starts_with?("Array(") || desc.name.starts_with?("StaticArray("))
            end
          end
        end
      end
      false
    end

    # Get the original array TypeRef for a receiver that may have been retyped
    # to a module (e.g. Enumerable). Returns nil if not determinable.
    private def original_array_type_for_receiver(ctx : LoweringContext, callee_node : CrystalV2::Compiler::Frontend::MemberAccessNode) : TypeRef?
      orig_obj = @arena[callee_node.object]
      if orig_obj.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
        if pname = orig_obj.name
          var_name = String.new(pname)
          if var_val = ctx.lookup_local(var_name)
            var_type = ctx.type_of(var_val)
            if desc = @module.get_type_descriptor(var_type)
              if desc.kind == TypeKind::Array &&
                 (desc.name.starts_with?("Array(") || desc.name.starts_with?("StaticArray("))
                return var_type
              end
            end
          end
        end
      elsif orig_obj.is_a?(CrystalV2::Compiler::Frontend::ArrayLiteralNode)
        # For inline array literals, infer element type from elements
        elem_type_name = "Int32"  # default
        if first_elem_id = orig_obj.elements.first?
          first_elem = @arena[first_elem_id]
          if first_elem.is_a?(CrystalV2::Compiler::Frontend::StringNode)
            elem_type_name = "String"
          elsif first_elem.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
            if first_elem.kind.f64? || first_elem.kind.f32?
              elem_type_name = "Float64"
            elsif first_elem.kind.u8?
              elem_type_name = "UInt8"
            else
              elem_type_name = "Int32"
            end
          elsif first_elem.is_a?(CrystalV2::Compiler::Frontend::BoolNode)
            elem_type_name = "Bool"
          elsif first_elem.is_a?(CrystalV2::Compiler::Frontend::CharNode)
            elem_type_name = "Char"
          end
        end
        if orig_obj.of_type
          # Use explicit type annotation if present (e.g., [] of String)
          of_type_node = @arena[orig_obj.of_type.not_nil!]
          if of_type_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            if tn = of_type_node.name
              elem_type_name = String.new(tn)
            end
          end
        end
        arr_type_name = "Array(#{elem_type_name})"
        @module.types.each_with_index do |desc, idx|
          if desc.name == arr_type_name
            return TypeRef.new((TypeRef::FIRST_USER_TYPE + idx).to_u32)
          end
        end
      end
      nil
    end

    # Check original receiver and fix type if it was retyped by module resolution
    private def check_and_fix_array_receiver_type(ctx : LoweringContext, callee_node : CrystalV2::Compiler::Frontend::MemberAccessNode, receiver_id : ValueId) : Bool
      if check_original_receiver_is_array?(ctx, callee_node)
        if orig_type = original_array_type_for_receiver(ctx, callee_node)
          ctx.register_type(receiver_id, orig_type)
        end
        true
      else
        false
      end
    end

    private def array_intrinsic_receiver?(ctx : LoweringContext, receiver_id : ValueId) : Bool
      receiver_type = ctx.type_of(receiver_id)
      return false if receiver_type == TypeRef::VOID

      if desc = @module.get_type_descriptor(receiver_type)
        return desc.kind == TypeKind::Array &&
          (desc.name.starts_with?("Array(") || desc.name.starts_with?("StaticArray("))
      end

      false
    end

    private def hash_intrinsic_receiver?(ctx : LoweringContext, receiver_id : ValueId) : Bool
      receiver_type = ctx.type_of(receiver_id)
      return false if receiver_type == TypeRef::VOID

      if desc = @module.get_type_descriptor(receiver_type)
        return desc.kind == TypeKind::Hash && desc.name.starts_with?("Hash(")
      end

      false
    end

    # Extract key/value types from a Hash type descriptor name
    private def hash_kv_types(ctx : LoweringContext, hash_id : ValueId) : {TypeRef, TypeRef}
      hash_type = ctx.type_of(hash_id)
      key_type = TypeRef::VOID
      value_type = TypeRef::VOID
      if desc = @module.get_type_descriptor(hash_type)
        name = desc.name
        if name.starts_with?("Hash(") && name.ends_with?(')')
          params_str = name[5, name.size - 6]
          args = split_generic_type_args(params_str)
          if args.size >= 2
            key_type = type_ref_for_name(args[0].strip)
            value_type = type_ref_for_name(args[1].strip)
          end
        end
      end
      {key_type, value_type}
    end

    # Hash#each intrinsic — iterates hash entries with proper PHI nodes for mutable vars.
    # Uses direct field access to Hash internals to avoid block closure variable capture issues.
    # Hash layout (from generated IR analysis):
    #   offset 4:  @first (i32) - first entry index
    #   offset 8:  @entries (ptr) - pointer to entries array
    #   offset 24: @size (i32)
    #   offset 28: @deleted_count (i32)
    #   entries_size = @size + @deleted_count
    # Entry layout:
    #   offset 0:  key (ptr for reference types, inline for value types)
    #   offset 8:  value (varies by type)
    #   offset 12: hash_or_deleted flag (i32, 0 = deleted)
    private def lower_hash_each_dynamic(
      ctx : LoweringContext,
      hash_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      key_type, value_type = hash_kv_types(ctx, hash_id)

      # Get block param names
      key_param = "__hash_key"
      val_param = "__hash_val"
      if params = block.params
        if params.size >= 2
          key_param = String.new(params[0].name.not_nil!) if params[0].name
          val_param = String.new(params[1].name.not_nil!) if params[1].name
        elsif params.size == 1
          # Single param - receives Tuple(K, V) conceptually, but we'll bind as key
          key_param = String.new(params[0].name.not_nil!) if params[0].name
        end
      end

      # Collect mutable vars
      assigned_vars = collect_assigned_vars(block.body)
      assigned_vars = assigned_vars.reject { |v| v == key_param || v == val_param }
      inline_vars = Set(String).new

      entry_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      # Load hash metadata in entry block (before the loop)
      # entries_size = size + deleted_count (total entries including deleted)
      hash_size = FieldGet.new(ctx.next_id, TypeRef::INT32, hash_id, "size", 24)
      ctx.emit(hash_size)
      ctx.register_type(hash_size.id, TypeRef::INT32)

      deleted_count = FieldGet.new(ctx.next_id, TypeRef::INT32, hash_id, "deleted_count", 28)
      ctx.emit(deleted_count)
      ctx.register_type(deleted_count.id, TypeRef::INT32)

      entries_total = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, hash_size.id, deleted_count.id)
      ctx.emit(entries_total)

      # Start index at 0 — we iterate all entries [0, entries_total) skipping deleted
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      # Create blocks (no empty_block — cond handles empty hash naturally: 0 < 0 → false)
      cond_block = ctx.create_block
      body_block = ctx.create_block
      skip_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block with index phi
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      # Phi for mutable vars
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          phi.add_incoming(entry_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      # Compare: index < entries_total (handles empty hash: 0 < 0 → false → exit)
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, entries_total.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block - get entry via runtime helper, check deleted
      ctx.current_block = body_block

      # entry_ptr = __crystal_v2_hash_get_entry_ptr(hash, index)
      entry_call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_hash_get_entry_ptr", [hash_id, index_phi.id])
      ctx.emit(entry_call)
      ctx.register_type(entry_call.id, TypeRef::POINTER)
      entry_ptr_id = entry_call.id

      # is_deleted = __crystal_v2_hash_entry_deleted(entry_ptr)
      deleted_call = Call.new(ctx.next_id, TypeRef::BOOL, nil, "__crystal_v2_hash_entry_deleted", [entry_ptr_id])
      ctx.emit(deleted_call)
      ctx.register_type(deleted_call.id, TypeRef::BOOL)
      is_deleted = deleted_call

      # deleted → skip to incr, not deleted → exec block body
      exec_block = ctx.create_block
      ctx.terminate(Branch.new(is_deleted.id, skip_block, exec_block))

      # Exec block - extract key/value and run block body
      ctx.current_block = exec_block
      ctx.push_scope(ScopeKind::Block)

      # key = entry field at offset 0
      key_val = FieldGet.new(ctx.next_id, key_type, entry_ptr_id, "key", 0)
      ctx.emit(key_val)
      ctx.register_type(key_val.id, key_type)

      # value = entry field at offset 8
      val_val = FieldGet.new(ctx.next_id, value_type, entry_ptr_id, "value", 8)
      ctx.emit(val_val)
      ctx.register_type(val_val.id, value_type)

      if params = block.params
        if params.size >= 2
          ctx.register_local(key_param, key_val.id)
          ctx.register_local(val_param, val_val.id)
        elsif params.size == 1
          # Single param gets the key (or ideally a tuple, but key is more useful)
          ctx.register_local(key_param, key_val.id)
        end
      end

      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      @loop_exit_stack << exit_block
      @loop_cond_stack << incr_block
      @loop_phi_stack << phi_nodes
      @loop_break_info_stack << [] of {BlockId, Hash(String, ValueId)}
      begin
        lower_body(ctx, block.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
        @loop_exit_stack.pop?
        @loop_cond_stack.pop?
        @loop_phi_stack.pop?
      end
      break_info = @loop_break_info_stack.pop
      # Capture post-body block (may differ from exec_block if body has control flow)
      post_exec_block = ctx.current_block
      ctx.pop_scope
      ctx.terminate(Jump.new(incr_block))

      # Skip block (deleted entries) - go directly to incr
      ctx.current_block = skip_block
      ctx.terminate(Jump.new(incr_block))

      # Increment block - merge skip and exec paths
      ctx.current_block = incr_block

      # Merge PHIs for mutable vars (exec path may have updated them, skip path didn't)
      incr_merged = {} of String => ValueId
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          updated_val = ctx.lookup_local(var_name)
          if updated_val && updated_val != phi.id
            # Variable was modified in block body — need merge PHI
            var_type = ctx.type_of(phi.id)
            merge_phi = Phi.new(ctx.next_id, var_type)
            merge_phi.add_incoming(post_exec_block, updated_val)
            merge_phi.add_incoming(skip_block, phi.id)
            ctx.emit(merge_phi)
            incr_merged[var_name] = merge_phi.id
          else
            incr_merged[var_name] = phi.id
          end
        end
      end

      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)

      index_phi.add_incoming(incr_block, new_i.id)

      # Patch cond_block mutable var phis with merged values
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if val = incr_merged[var_name]?
            phi.add_incoming(incr_block, val)
          end
        end
      end

      ctx.terminate(Jump.new(cond_block))

      # Exit block - merge normal exit + break paths
      ctx.current_block = exit_block
      if break_info.empty?
        phi_nodes.each do |var_name, phi|
          ctx.register_local(var_name, phi.id)
        end
      else
        phi_nodes.each do |var_name, cond_phi|
          exit_phi = Phi.new(ctx.next_id, cond_phi.type)
          exit_phi.add_incoming(cond_block, cond_phi.id)
          break_info.each do |break_block, break_locals|
            if break_val = break_locals[var_name]?
              exit_phi.add_incoming(break_block, break_val)
            else
              exit_phi.add_incoming(break_block, cond_phi.id)
            end
          end
          ctx.emit(exit_phi)
          ctx.register_local(var_name, exit_phi.id)
        end
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Hash#keys / Hash#values intrinsic — builds Array by iterating entries
    private def lower_hash_keys_or_values_intrinsic(
      ctx : LoweringContext,
      hash_id : ValueId,
      is_keys : Bool,
    ) : ValueId
      key_type, value_type = hash_kv_types(ctx, hash_id)
      elem_type = is_keys ? key_type : value_type

      # Determine element type name for Array type registration
      elem_type_name = get_type_name_from_ref(elem_type)
      array_type_name = "Array(#{elem_type_name})"
      array_type_ref = type_ref_for_name(array_type_name)

      # Get hash size (= number of live entries)
      hash_size = FieldGet.new(ctx.next_id, TypeRef::INT32, hash_id, "size", 24)
      ctx.emit(hash_size)
      ctx.register_type(hash_size.id, TypeRef::INT32)

      # entries_total = size + deleted_count
      deleted_count = FieldGet.new(ctx.next_id, TypeRef::INT32, hash_id, "deleted_count", 28)
      ctx.emit(deleted_count)
      ctx.register_type(deleted_count.id, TypeRef::INT32)

      entries_total = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, hash_size.id, deleted_count.id)
      ctx.emit(entries_total)

      # Create result array: Array(K) or Array(V) with capacity = hash_size
      result_arr = ArrayNew.new(ctx.next_id, elem_type, hash_size.id)
      ctx.emit(result_arr)
      arr_id = result_arr.id
      # Register with proper Array(T) type so subsequent .size/.each dispatch correctly
      ctx.register_type(arr_id, array_type_ref)

      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      entry_block = ctx.current_block

      # Loop: iterate entries [0, entries_total), skip deleted, fill array
      cond_block = ctx.create_block
      body_block = ctx.create_block
      skip_block = ctx.create_block
      exec_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Cond block with index phi and array_idx phi
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      arr_idx_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      arr_idx_phi.add_incoming(entry_block, zero.id)
      ctx.emit(arr_idx_phi)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, entries_total.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block — check if entry is deleted
      ctx.current_block = body_block
      entry_call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_hash_get_entry_ptr", [hash_id, index_phi.id])
      ctx.emit(entry_call)
      ctx.register_type(entry_call.id, TypeRef::POINTER)

      deleted_call = Call.new(ctx.next_id, TypeRef::BOOL, nil, "__crystal_v2_hash_entry_deleted", [entry_call.id])
      ctx.emit(deleted_call)
      ctx.register_type(deleted_call.id, TypeRef::BOOL)

      ctx.terminate(Branch.new(deleted_call.id, skip_block, exec_block))

      # Exec block — extract key or value, store into array
      ctx.current_block = exec_block
      field_offset = is_keys ? 0 : 8
      field_name = is_keys ? "key" : "value"
      elem_val = FieldGet.new(ctx.next_id, elem_type, entry_call.id, field_name, field_offset)
      ctx.emit(elem_val)
      ctx.register_type(elem_val.id, elem_type)

      # array[arr_idx] = elem
      idx_set = IndexSet.new(ctx.next_id, elem_type, arr_id, arr_idx_phi.id, elem_val.id)
      ctx.emit(idx_set)

      # new_arr_idx = arr_idx + 1
      one_exec = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one_exec)
      new_arr_idx = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, arr_idx_phi.id, one_exec.id)
      ctx.emit(new_arr_idx)

      ctx.terminate(Jump.new(incr_block))

      # Skip block (deleted entry)
      ctx.current_block = skip_block
      ctx.terminate(Jump.new(incr_block))

      # Incr block — increment index, merge arr_idx from exec/skip paths
      ctx.current_block = incr_block

      # Merge arr_idx: exec→new_arr_idx, skip→arr_idx_phi (unchanged)
      arr_idx_merge = Phi.new(ctx.next_id, TypeRef::INT32)
      arr_idx_merge.add_incoming(exec_block, new_arr_idx.id)
      arr_idx_merge.add_incoming(skip_block, arr_idx_phi.id)
      ctx.emit(arr_idx_merge)

      one_incr = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one_incr)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one_incr.id)
      ctx.emit(new_i)

      index_phi.add_incoming(incr_block, new_i.id)
      arr_idx_phi.add_incoming(incr_block, arr_idx_merge.id)

      ctx.terminate(Jump.new(cond_block))

      # Exit block — set array size and return
      ctx.current_block = exit_block
      set_size = ArraySetSize.new(ctx.next_id, TypeRef::VOID, arr_id, hash_size.id)
      ctx.emit(set_size)

      arr_id
    end

    # Array each_with_index intrinsic - iterates with element and index
    private def lower_array_each_with_index_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      # Get block param names (element, index)
      elem_param_name = "__arr_elem"
      index_param_name = "__arr_idx"
      if params = block.params
        if first_param = params[0]?
          if pname = first_param.name
            elem_param_name = String.new(pname)
          end
        end
        if second_param = params[1]?
          if pname = second_param.name
            index_param_name = String.new(pname)
          end
        end
      end

      # Collect mutable vars
      assigned_vars = collect_assigned_vars(block.body)
      assigned_vars = assigned_vars.reject { |v| v == elem_param_name || v == index_param_name }
      inline_vars = Set(String).new

      entry_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      # Emit zero in entry block BEFORE jump (required for phi SSA)
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      # Create blocks
      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block with index phi
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      # Phi for mutable vars
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          phi.add_incoming(entry_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      # Get array size dynamically
      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      # Compare: i < size
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      # Get element: arr[i]
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)
      ctx.register_local(elem_param_name, index_get.id)

      # Register index parameter with INT32 type
      ctx.register_local(index_param_name, index_phi.id)
      ctx.register_type(index_phi.id, TypeRef::INT32)

      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      @loop_exit_stack << exit_block
      @loop_cond_stack << incr_block
      @loop_phi_stack << phi_nodes
      @loop_break_info_stack << [] of {BlockId, Hash(String, ValueId)}
      begin
        lower_body(ctx, block.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
        @loop_exit_stack.pop?
        @loop_cond_stack.pop?
        @loop_phi_stack.pop?
      end
      break_info = @loop_break_info_stack.pop
      ctx.pop_scope
      ctx.terminate(Jump.new(incr_block))

      # Increment block
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)

      index_phi.add_incoming(incr_block, new_i.id)

      # Patch mutable var phis
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            phi.add_incoming(incr_block, updated_val)
          end
        end
      end

      ctx.terminate(Jump.new(cond_block))

      # Exit block - merge normal exit + break paths
      ctx.current_block = exit_block
      if break_info.empty?
        phi_nodes.each do |var_name, phi|
          ctx.register_local(var_name, phi.id)
        end
      else
        phi_nodes.each do |var_name, cond_phi|
          exit_phi = Phi.new(ctx.next_id, cond_phi.type)
          exit_phi.add_incoming(cond_block, cond_phi.id)
          break_info.each do |break_block, break_locals|
            if break_val = break_locals[var_name]?
              exit_phi.add_incoming(break_block, break_val)
            else
              exit_phi.add_incoming(break_block, cond_phi.id)
            end
          end
          ctx.emit(exit_phi)
          ctx.register_local(var_name, exit_phi.id)
        end
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Array map intrinsic - creates new array with transformed elements (compile-time size)
    # Uses inline expansion for small arrays, creating ArrayLiteral with transformed values
    private def lower_array_map_intrinsic(
      ctx : LoweringContext,
      array_id : ValueId,
      array_size : Int32,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      # Get block param name
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__map_elem"

      # Get element type from source array
      source_element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)

      # Collect transformed values
      transformed_values = [] of ValueId
      result_element_type = TypeRef::INT32 # Will be updated based on first result

      (0...array_size).each do |i|
        # Get element: arr[i]
        index_lit = Literal.new(ctx.next_id, TypeRef::INT32, i.to_i64)
        ctx.emit(index_lit)
        ctx.register_type(index_lit.id, TypeRef::INT32)

        index_get = IndexGet.new(ctx.next_id, source_element_type, array_id, index_lit.id)
        ctx.emit(index_get)
        ctx.register_type(index_get.id, source_element_type)

        # Bind block parameter
        ctx.push_scope(ScopeKind::Block)
        ctx.register_local(param_name, index_get.id)
        ctx.register_type(index_get.id, source_element_type)

        # Lower block body to get transformed value
        result_value = lower_body(ctx, block.body)
        ctx.pop_scope

        if result_value
          transformed_values << result_value
          # Track element type from first result
          if i == 0
            result_element_type = ctx.type_of(result_value)
          end
        end
      end

      # Create new ArrayLiteral with transformed values
      arr_lit = ArrayLiteral.new(ctx.next_id, result_element_type, transformed_values)
      ctx.emit(arr_lit)
      # Register proper Array type so array_intrinsic_receiver? recognizes it for each/map/select
      elem_type_name = get_type_name_from_ref(result_element_type)
      if elem_type_name != "Unknown" && elem_type_name != "Void"
        array_type = type_ref_for_name("Array(#{elem_type_name})")
        ctx.register_type(arr_lit.id, array_type)
      else
        ctx.register_type(arr_lit.id, TypeRef::POINTER)
      end
      arr_lit.id
    end

    # Dynamic array map - for arrays with runtime-determined size
    # Currently falls back to returning the source array (not fully implemented)
    private def lower_array_map_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      # Crystal semantics: map returns a NEW array, source is not modified
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__map_elem"

      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      source_type = ctx.type_of(array_id)

      # Get size dynamically
      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      # Allocate new array with same size as source
      new_array = ArrayNew.new(ctx.next_id, element_type, size_val.id)
      ctx.emit(new_array)
      ctx.register_type(new_array.id, source_type)

      entry_block = ctx.current_block
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      # Read from SOURCE array
      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)
      ctx.register_local(param_name, index_get.id)

      result_value = lower_body(ctx, block.body)
      ctx.pop_scope

      # Write to NEW array
      if result_value
        index_set = IndexSet.new(ctx.next_id, element_type, new_array.id, index_phi.id, result_value)
        ctx.emit(index_set)
      end

      ctx.terminate(Jump.new(incr_block))

      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)
      index_phi.add_incoming(incr_block, new_i.id)
      ctx.terminate(Jump.new(cond_block))

      # Exit block: set size on new array and return it
      ctx.current_block = exit_block
      set_size = ArraySetSize.new(ctx.next_id, TypeRef::VOID, new_array.id, size_val.id)
      ctx.emit(set_size)
      new_array.id
    end

    # Select intrinsic for compile-time sized arrays with AST access
    # For [1, 2, 3].select { |x| x > 1 }, evaluates predicate at compile-time
    private def lower_array_select_intrinsic_with_ast(
      ctx : LoweringContext,
      array_literal : CrystalV2::Compiler::Frontend::ArrayLiteralNode,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      # Get block param name
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__select_elem"

      source_element_type = TypeRef::INT32 # Default to Int32

      # Try to evaluate predicate at compile-time for each element
      # Collect indices of elements that pass the predicate
      selected_indices = [] of Int32

      array_literal.elements.each_with_index do |elem_expr_id, i|
        elem_node = @arena[elem_expr_id]

        # Try to get compile-time value of element
        elem_value = extract_compile_time_int(elem_node)
        if elem_value
          # Try to evaluate predicate at compile time
          if evaluate_predicate_at_compile_time(param_name, elem_value, block)
            selected_indices << i
          end
        else
          # Can't evaluate at compile time - include element (conservative)
          selected_indices << i
        end
      end

      # Now lower only the selected elements into a new array
      selected_values = [] of ValueId
      selected_indices.each do |i|
        elem_expr_id = array_literal.elements[i]
        elem_val = lower_expr(ctx, elem_expr_id)
        selected_values << elem_val
      end

      # Create result array with only selected elements
      arr_lit = ArrayLiteral.new(ctx.next_id, source_element_type, selected_values)
      ctx.emit(arr_lit)
      # Register proper Array type so array_intrinsic_receiver? recognizes it for each/map/select
      elem_type_name = get_type_name_from_ref(source_element_type)
      if elem_type_name != "Unknown" && elem_type_name != "Void"
        array_type = type_ref_for_name("Array(#{elem_type_name})")
        ctx.register_type(arr_lit.id, array_type)
      else
        ctx.register_type(arr_lit.id, TypeRef::POINTER)
      end
      arr_lit.id
    end

    # Try to extract compile-time integer value from AST node
    private def extract_compile_time_int(node : CrystalV2::Compiler::Frontend::Node) : Int64?
      case node
      when CrystalV2::Compiler::Frontend::NumberNode
        # NumberNode stores value as Slice(UInt8)
        str_val = String.new(node.value)
        str_val.to_i64?
      else
        nil
      end
    end

    # Try to evaluate a simple predicate at compile time
    # Supports: x > n, x < n, x >= n, x <= n, x == n, x != n
    private def evaluate_predicate_at_compile_time(param_name : String, param_value : Int64, block : CrystalV2::Compiler::Frontend::BlockNode) : Bool
      # Get block body - should be a single expression
      return true if block.body.empty?

      body_expr_id = block.body.last
      body_node = @arena[body_expr_id]

      case body_node
      when CrystalV2::Compiler::Frontend::BinaryNode
        # For x > 2, structure is:
        # BinaryNode { operator: ">", left: x, right: 2 }
        op_name = String.new(body_node.operator)

        # Get left operand (should be our parameter)
        left_node = @arena[body_node.left]
        return true unless left_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)

        # Check if left is our parameter
        left_name = String.new(left_node.name)
        return true unless left_name == param_name

        # Get right operand (should be a number)
        right_node = @arena[body_node.right]
        compare_value = extract_compile_time_int(right_node)
        return true unless compare_value

        # Evaluate comparison
        case op_name
        when ">"  then param_value > compare_value
        when "<"  then param_value < compare_value
        when ">=" then param_value >= compare_value
        when "<=" then param_value <= compare_value
        when "==" then param_value == compare_value
        when "!=" then param_value != compare_value
        else
          true # Unknown op - include element
        end
      when CrystalV2::Compiler::Frontend::CallNode
        # For method-style comparisons: x.>(2)
        callee_node = @arena[body_node.callee]

        case callee_node
        when CrystalV2::Compiler::Frontend::MemberAccessNode
          # Get operator name from member
          op_name = String.new(callee_node.member)

          # Get receiver (object of member access)
          receiver_node = @arena[callee_node.object]
          return true unless receiver_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)

          # Check if receiver is our parameter
          recv_name = String.new(receiver_node.name)
          return true unless recv_name == param_name

          # Get comparison value from args
          args = body_node.args
          return true if args.empty?

          arg_node = @arena[args.first]
          compare_value = extract_compile_time_int(arg_node)
          return true unless compare_value

          # Evaluate comparison
          case op_name
          when ">"  then param_value > compare_value
          when "<"  then param_value < compare_value
          when ">=" then param_value >= compare_value
          when "<=" then param_value <= compare_value
          when "==" then param_value == compare_value
          when "!=" then param_value != compare_value
          else
            true # Unknown op - include element
          end
        else
          true # Unknown callee structure
        end
      else
        true # Can't evaluate - include element conservatively
      end
    end

    # Dynamic array select - for arrays with runtime-determined size
    # TODO: Implement full dynamic select with proper allocation
    # For now, falls back to map-style in-place filtering
    private def lower_array_select_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      # Crystal semantics: select returns a NEW array, source is not modified
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__select_elem"

      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      source_type = ctx.type_of(array_id)

      # Get source size — this is the max capacity for the result
      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      # Allocate new array with capacity = source size
      new_array = ArrayNew.new(ctx.next_id, element_type, size_val.id)
      ctx.emit(new_array)
      # Register same array type so array_intrinsic_receiver? recognizes it
      ctx.register_type(new_array.id, source_type)

      entry_block = ctx.current_block
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      cond_block = ctx.create_block
      body_block = ctx.create_block
      copy_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block: check i < size
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      result_count_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      result_count_phi.add_incoming(entry_block, zero.id)
      ctx.emit(result_count_phi)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block: get element from SOURCE array, evaluate predicate
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)
      ctx.register_local(param_name, index_get.id)

      predicate_result = lower_body(ctx, block.body)
      ctx.pop_scope

      if predicate_result
        ctx.terminate(Branch.new(predicate_result, copy_block, incr_block))
      else
        ctx.terminate(Jump.new(incr_block))
      end

      # Copy block: store element to NEW array at result_count position
      ctx.current_block = copy_block
      index_set = IndexSet.new(ctx.next_id, element_type, new_array.id, result_count_phi.id, index_get.id)
      ctx.emit(index_set)

      one_copy = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one_copy)
      new_count = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, result_count_phi.id, one_copy.id)
      ctx.emit(new_count)
      ctx.terminate(Jump.new(incr_block))

      # Incr block: increment index, update phis
      ctx.current_block = incr_block
      count_incr_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      count_incr_phi.add_incoming(body_block, result_count_phi.id)
      count_incr_phi.add_incoming(copy_block, new_count.id)
      ctx.emit(count_incr_phi)

      one_incr = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one_incr)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one_incr.id)
      ctx.emit(new_i)

      index_phi.add_incoming(incr_block, new_i.id)
      result_count_phi.add_incoming(incr_block, count_incr_phi.id)
      ctx.terminate(Jump.new(cond_block))

      # Exit block: set size on NEW array
      ctx.current_block = exit_block
      set_size = ArraySetSize.new(ctx.next_id, TypeRef::VOID, new_array.id, result_count_phi.id)
      ctx.emit(set_size)

      new_array.id
    end

    # Lower Array#reject { |x| condition } intrinsic
    # Same as select but copies when predicate is FALSE (inverted branch)
    private def lower_array_reject_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__reject_elem"

      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      source_type = ctx.type_of(array_id)

      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      new_array = ArrayNew.new(ctx.next_id, element_type, size_val.id)
      ctx.emit(new_array)
      ctx.register_type(new_array.id, source_type)

      entry_block = ctx.current_block
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      cond_block = ctx.create_block
      body_block = ctx.create_block
      copy_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block: check i < size
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      result_count_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      result_count_phi.add_incoming(entry_block, zero.id)
      ctx.emit(result_count_phi)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block: get element, evaluate predicate
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)
      ctx.register_local(param_name, index_get.id)

      predicate_result = lower_body(ctx, block.body)
      ctx.pop_scope

      if predicate_result
        # INVERTED: copy when predicate is false (reject matching elements)
        ctx.terminate(Branch.new(predicate_result, incr_block, copy_block))
      else
        ctx.terminate(Jump.new(incr_block))
      end

      # Copy block: store element to new array
      ctx.current_block = copy_block
      index_set = IndexSet.new(ctx.next_id, element_type, new_array.id, result_count_phi.id, index_get.id)
      ctx.emit(index_set)

      one_copy = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one_copy)
      new_count = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, result_count_phi.id, one_copy.id)
      ctx.emit(new_count)
      ctx.terminate(Jump.new(incr_block))

      # Incr block
      ctx.current_block = incr_block
      count_incr_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      count_incr_phi.add_incoming(body_block, result_count_phi.id)
      count_incr_phi.add_incoming(copy_block, new_count.id)
      ctx.emit(count_incr_phi)

      one_incr = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one_incr)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one_incr.id)
      ctx.emit(new_i)

      index_phi.add_incoming(incr_block, new_i.id)
      result_count_phi.add_incoming(incr_block, count_incr_phi.id)
      ctx.terminate(Jump.new(cond_block))

      # Exit block: set size on new array
      ctx.current_block = exit_block
      set_size = ArraySetSize.new(ctx.next_id, TypeRef::VOID, new_array.id, result_count_phi.id)
      ctx.emit(set_size)

      new_array.id
    end

    # Lower Array#includes?(value) intrinsic — iterates elements, compares with ==
    private def lower_array_includes_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      value_id : ValueId,
    ) : ValueId
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)

      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      entry_block = ctx.current_block
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)
      true_val = Literal.new(ctx.next_id, TypeRef::BOOL, 1_i64)
      ctx.emit(true_val)
      false_val = Literal.new(ctx.next_id, TypeRef::BOOL, 0_i64)
      ctx.emit(false_val)

      cond_block = ctx.create_block
      body_block = ctx.create_block
      found_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition: i < size
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body: arr[i] == value?
      ctx.current_block = body_block
      elem = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(elem)
      ctx.register_type(elem.id, element_type)

      eq_cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, elem.id, value_id)
      ctx.emit(eq_cmp)
      ctx.terminate(Branch.new(eq_cmp.id, found_block, incr_block))

      # Found block: return true
      ctx.current_block = found_block
      ctx.terminate(Jump.new(exit_block))

      # Incr block
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)
      index_phi.add_incoming(incr_block, new_i.id)
      ctx.terminate(Jump.new(cond_block))

      # Exit block: phi result (true from found_block, false from cond_block)
      ctx.current_block = exit_block
      result_phi = Phi.new(ctx.next_id, TypeRef::BOOL)
      result_phi.add_incoming(found_block, true_val.id)
      result_phi.add_incoming(cond_block, false_val.id)
      ctx.emit(result_phi)

      result_phi.id
    end

    # Lower Array#index(value) intrinsic
    # Returns Int32: index if found, -1 if not found
    private def lower_array_index_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      value_id : ValueId,
    ) : ValueId
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)

      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      entry_block = ctx.current_block
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)
      neg_one = Literal.new(ctx.next_id, TypeRef::INT32, -1_i64)
      ctx.emit(neg_one)
      ctx.register_type(neg_one.id, TypeRef::INT32)

      cond_block = ctx.create_block
      body_block = ctx.create_block
      found_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition: i < size
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body: arr[i] == value?
      ctx.current_block = body_block
      elem = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(elem)
      ctx.register_type(elem.id, element_type)

      eq_cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, elem.id, value_id)
      ctx.emit(eq_cmp)
      ctx.terminate(Branch.new(eq_cmp.id, found_block, incr_block))

      # Found block: return current index
      ctx.current_block = found_block
      ctx.terminate(Jump.new(exit_block))

      # Incr block
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)
      index_phi.add_incoming(incr_block, new_i.id)
      ctx.terminate(Jump.new(cond_block))

      # Exit block: phi result (index from found_block, -1 from cond_block)
      ctx.current_block = exit_block
      result_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      result_phi.add_incoming(found_block, index_phi.id)
      result_phi.add_incoming(cond_block, neg_one.id)
      ctx.emit(result_phi)
      ctx.register_type(result_phi.id, TypeRef::INT32)

      result_phi.id
    end

    # Lower Array#sort → dup + sort in-place
    private def lower_array_sort_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
    ) : ValueId
      # Determine element type to pick the right dup+sort helper
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      helper = case element_type
               when TypeRef::STRING, TypeRef::POINTER
                 "__crystal_v2_sort_string_array_dup"
               else
                 "__crystal_v2_sort_i32_array_dup"
               end

      # Pass the array's type_id so the dup helper can set it in the new array header
      arr_type = ctx.type_of(array_id)
      type_id_lit = Literal.new(ctx.next_id, TypeRef::INT32, arr_type.id.to_i64)
      ctx.emit(type_id_lit)
      ctx.register_type(type_id_lit.id, TypeRef::INT32)

      # Call the combined dup+sort helper: returns a new sorted array
      dup_sort_call = ExternCall.new(ctx.next_id, arr_type, helper, [array_id, type_id_lit.id] of ValueId)
      ctx.emit(dup_sort_call)
      ctx.register_type(dup_sort_call.id, arr_type)

      dup_sort_call.id
    end

    # Lower Array#sort! → sort in-place via qsort
    private def lower_array_sort_bang_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
    ) : ValueId
      # Determine element type to pick the right sort helper
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      helper = case element_type
               when TypeRef::STRING, TypeRef::POINTER
                 "__crystal_v2_sort_string_array"
               else
                 "__crystal_v2_sort_i32_array"
               end

      sort_call = ExternCall.new(ctx.next_id, TypeRef::VOID, helper, [array_id])
      ctx.emit(sort_call)
      ctx.register_type(sort_call.id, TypeRef::NIL)

      array_id
    end

    # Lower Array#any? { |x| condition } intrinsic
    # Returns true if any element matches predicate, false otherwise
    private def lower_array_any_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__arr_elem"

      entry_block = ctx.current_block

      # Emit constants in entry block (must dominate phi references)
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)
      false_val = Literal.new(ctx.next_id, TypeRef::BOOL, 0_i64)
      ctx.emit(false_val)

      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      found_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block: i < size ?
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block: evaluate predicate
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)
      ctx.register_local(param_name, index_get.id)

      predicate_result = lower_body(ctx, block.body)
      ctx.pop_scope

      if predicate_result
        ctx.terminate(Branch.new(predicate_result, found_block, incr_block))
      else
        ctx.terminate(Jump.new(incr_block))
      end

      # Incr block: i++
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)
      index_phi.add_incoming(incr_block, new_i.id)
      ctx.terminate(Jump.new(cond_block))

      # Found block: return true
      ctx.current_block = found_block
      true_val = Literal.new(ctx.next_id, TypeRef::BOOL, 1_i64)
      ctx.emit(true_val)
      ctx.terminate(Jump.new(exit_block))

      # Exit block: phi(false from cond, true from found)
      ctx.current_block = exit_block
      result_phi = Phi.new(ctx.next_id, TypeRef::BOOL)
      result_phi.add_incoming(cond_block, false_val.id)
      result_phi.add_incoming(found_block, true_val.id)
      ctx.emit(result_phi)

      result_phi.id
    end

    # Lower Array#all? { |x| condition } intrinsic
    # Returns true if all elements match predicate, false if any doesn't
    private def lower_array_all_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__arr_elem"

      entry_block = ctx.current_block

      # Emit constants in entry block (must dominate phi references)
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)
      true_val = Literal.new(ctx.next_id, TypeRef::BOOL, 1_i64)
      ctx.emit(true_val)

      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      fail_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block: i < size ?
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block: evaluate predicate
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)
      ctx.register_local(param_name, index_get.id)

      predicate_result = lower_body(ctx, block.body)
      ctx.pop_scope

      if predicate_result
        # If predicate FALSE → fail; if TRUE → continue
        ctx.terminate(Branch.new(predicate_result, incr_block, fail_block))
      else
        ctx.terminate(Jump.new(incr_block))
      end

      # Incr block: i++
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)
      index_phi.add_incoming(incr_block, new_i.id)
      ctx.terminate(Jump.new(cond_block))

      # Fail block: return false
      ctx.current_block = fail_block
      false_val = Literal.new(ctx.next_id, TypeRef::BOOL, 0_i64)
      ctx.emit(false_val)
      ctx.terminate(Jump.new(exit_block))

      # Exit block: phi(true from cond loop-done, false from fail)
      ctx.current_block = exit_block
      result_phi = Phi.new(ctx.next_id, TypeRef::BOOL)
      result_phi.add_incoming(cond_block, true_val.id)
      result_phi.add_incoming(fail_block, false_val.id)
      ctx.emit(result_phi)

      result_phi.id
    end

    # Lower Array#none? { |x| condition } intrinsic
    # Returns true if no elements match predicate
    private def lower_array_none_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      # none? is just !any? — reuse any? and negate
      any_result = lower_array_any_dynamic(ctx, array_id, block)
      not_result = UnaryOperation.new(ctx.next_id, TypeRef::BOOL, UnaryOp::Not, any_result)
      ctx.emit(not_result)
      not_result.id
    end

    # Lower Array#reduce { |acc, elem| ... } intrinsic
    # Reduces array to single value by iterating with accumulator
    private def lower_array_reduce_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      # Extract block parameter names (acc, elem)
      acc_name = "__reduce_acc"
      elem_name = "__reduce_elem"
      if params = block.params
        if params.size >= 1 && (pname = params[0].name)
          acc_name = String.new(pname)
        end
        if params.size >= 2 && (pname = params[1].name)
          elem_name = String.new(pname)
        end
      end

      # Element type - use POINTER since we're typically working with objects
      element_type = TypeRef::POINTER

      # Get array size
      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      # Entry block - initialize accumulator with first element
      entry_block = ctx.current_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)

      # Get first element as initial accumulator
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)
      first_elem = IndexGet.new(ctx.next_id, element_type, array_id, zero.id)
      ctx.emit(first_elem)
      ctx.register_type(first_elem.id, element_type)

      # Create blocks: cond, body, exit
      cond_block = ctx.create_block
      body_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block - check if index < size
      ctx.current_block = cond_block

      # PHI for index (starts at 1, since we already used element 0)
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, one.id)
      ctx.emit(index_phi)

      # PHI for accumulator
      acc_phi = Phi.new(ctx.next_id, element_type)
      acc_phi.add_incoming(entry_block, first_elem.id)
      ctx.emit(acc_phi)
      ctx.register_type(acc_phi.id, element_type)

      # Compare index < size
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block - execute reduce operation
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      # Get current element
      curr_elem = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(curr_elem)
      ctx.register_type(curr_elem.id, element_type)

      # Register block parameters
      ctx.register_local(acc_name, acc_phi.id)
      ctx.register_local(elem_name, curr_elem.id)

      # Lower block body - result becomes new accumulator
      new_acc = lower_body(ctx, block.body)
      ctx.pop_scope

      # Increment index
      incr = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(incr)
      index_phi.add_incoming(body_block, incr.id)

      # Update accumulator PHI
      if new_acc
        acc_phi.add_incoming(body_block, new_acc)
      else
        acc_phi.add_incoming(body_block, acc_phi.id)
      end

      ctx.terminate(Jump.new(cond_block))

      # Exit block - return final accumulator
      ctx.current_block = exit_block
      ctx.register_type(acc_phi.id, element_type)
      acc_phi.id
    end

    # Lower String#each_char { |ch| ... } intrinsic
    # Iterates string bytes as ASCII Chars (sufficient for bootstrap)
    private def lower_string_each_char_intrinsic(
      ctx : LoweringContext,
      string_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__char"

      entry_block = ctx.current_block

      # Emit constants in entry block
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      # Get string bytesize via ExternCall
      bytesize = ExternCall.new(ctx.next_id, TypeRef::INT32, "__crystal_v2_string_bytesize", [string_id])
      ctx.emit(bytesize)
      ctx.register_type(bytesize.id, TypeRef::INT32)

      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block: i < bytesize ?
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, bytesize.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block: load byte, convert to Char, execute block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      # Load byte at index from string data (offset 12 + i)
      char_val = ExternCall.new(ctx.next_id, TypeRef::CHAR, "__crystal_v2_string_byte_at", [string_id, index_phi.id])
      ctx.emit(char_val)
      ctx.register_type(char_val.id, TypeRef::CHAR)
      ctx.register_local(param_name, char_val.id)

      empty_phis = {} of String => Phi
      @loop_exit_stack << exit_block
      @loop_cond_stack << incr_block
      @loop_phi_stack << empty_phis
      @loop_break_info_stack << [] of {BlockId, Hash(String, ValueId)}
      begin
        lower_body(ctx, block.body)
      ensure
        @loop_exit_stack.pop?
        @loop_cond_stack.pop?
        @loop_phi_stack.pop?
      end
      break_info = @loop_break_info_stack.pop
      ctx.pop_scope

      ctx.terminate(Jump.new(incr_block))

      # Incr block: i++
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)
      index_phi.add_incoming(incr_block, new_i.id)
      ctx.terminate(Jump.new(cond_block))

      # Exit block
      ctx.current_block = exit_block
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      ctx.register_type(nil_lit.id, TypeRef::NIL)
      nil_lit.id
    end

    # Lower Array#count { |x| condition } intrinsic
    # Returns the number of elements matching predicate
    private def lower_array_count_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      param_name = block.params.try(&.first?).try(&.name).try { |n| String.new(n) } || "__arr_elem"

      entry_block = ctx.current_block

      # Emit constants in entry block
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)
      zero_count = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero_count)

      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      count_incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block: i < size ?
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      count_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      count_phi.add_incoming(entry_block, zero_count.id)
      ctx.emit(count_phi)

      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block: evaluate predicate
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)
      ctx.register_local(param_name, index_get.id)

      predicate_result = lower_body(ctx, block.body)
      ctx.pop_scope

      if predicate_result
        ctx.terminate(Branch.new(predicate_result, count_incr_block, incr_block))
      else
        ctx.terminate(Jump.new(incr_block))
      end

      # Count incr block: count++, then fall through to incr
      ctx.current_block = count_incr_block
      one_c = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one_c)
      new_count = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, count_phi.id, one_c.id)
      ctx.emit(new_count)
      count_phi.add_incoming(count_incr_block, new_count.id)
      ctx.terminate(Jump.new(incr_block))

      # Incr block: i++
      ctx.current_block = incr_block
      # Need a phi for count coming from body (no match) or count_incr (match)
      count_merged_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      count_merged_phi.add_incoming(body_block, count_phi.id)
      count_merged_phi.add_incoming(count_incr_block, new_count.id)
      ctx.emit(count_merged_phi)

      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)
      index_phi.add_incoming(incr_block, new_i.id)
      count_phi.add_incoming(incr_block, count_merged_phi.id)
      ctx.terminate(Jump.new(cond_block))

      # Exit block: return count
      ctx.current_block = exit_block
      count_phi.id
    end

    # Lower Array#first intrinsic — returns arr[0]
    private def lower_array_first_intrinsic(
      ctx : LoweringContext,
      array_id : ValueId,
    ) : ValueId
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)
      index_get = IndexGet.new(ctx.next_id, element_type, array_id, zero.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)
      index_get.id
    end

    # Lower Array#last intrinsic — returns arr[arr.size - 1]
    private def lower_array_last_intrinsic(
      ctx : LoweringContext,
      array_id : ValueId,
    ) : ValueId
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      last_idx = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Sub, size_val.id, one.id)
      ctx.emit(last_idx)
      index_get = IndexGet.new(ctx.next_id, element_type, array_id, last_idx.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)
      index_get.id
    end

    # Lower Array#min intrinsic — returns minimum element (Int32 arrays)
    private def lower_array_min_intrinsic(
      ctx : LoweringContext,
      array_id : ValueId,
    ) : ValueId
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      entry_block = ctx.current_block

      # Initialize with first element
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)
      first_elem = IndexGet.new(ctx.next_id, element_type, array_id, zero.id)
      ctx.emit(first_elem)
      ctx.register_type(first_elem.id, element_type)

      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)

      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      cond_block = ctx.create_block
      body_block = ctx.create_block
      update_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition: i < size
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, one.id)
      ctx.emit(index_phi)

      min_phi = Phi.new(ctx.next_id, element_type)
      min_phi.add_incoming(entry_block, first_elem.id)
      ctx.emit(min_phi)
      ctx.register_type(min_phi.id, element_type)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body: compare arr[i] < min
      ctx.current_block = body_block
      curr_elem = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(curr_elem)
      ctx.register_type(curr_elem.id, element_type)

      less = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, curr_elem.id, min_phi.id)
      ctx.emit(less)
      ctx.terminate(Branch.new(less.id, update_block, incr_block))

      # Update block: new min = curr_elem
      ctx.current_block = update_block
      min_phi.add_incoming(update_block, curr_elem.id)
      ctx.terminate(Jump.new(incr_block))

      # Incr block: i++
      ctx.current_block = incr_block
      min_merged_phi = Phi.new(ctx.next_id, element_type)
      min_merged_phi.add_incoming(body_block, min_phi.id)
      min_merged_phi.add_incoming(update_block, curr_elem.id)
      ctx.emit(min_merged_phi)
      ctx.register_type(min_merged_phi.id, element_type)

      incr_one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(incr_one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, incr_one.id)
      ctx.emit(new_i)
      index_phi.add_incoming(incr_block, new_i.id)
      min_phi.add_incoming(incr_block, min_merged_phi.id)
      ctx.terminate(Jump.new(cond_block))

      # Exit: return min
      ctx.current_block = exit_block
      min_phi.id
    end

    # Lower Array#max intrinsic — returns maximum element (Int32 arrays)
    private def lower_array_max_intrinsic(
      ctx : LoweringContext,
      array_id : ValueId,
    ) : ValueId
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      entry_block = ctx.current_block

      # Initialize with first element
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)
      first_elem = IndexGet.new(ctx.next_id, element_type, array_id, zero.id)
      ctx.emit(first_elem)
      ctx.register_type(first_elem.id, element_type)

      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)

      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      cond_block = ctx.create_block
      body_block = ctx.create_block
      update_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition: i < size
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, one.id)
      ctx.emit(index_phi)

      max_phi = Phi.new(ctx.next_id, element_type)
      max_phi.add_incoming(entry_block, first_elem.id)
      ctx.emit(max_phi)
      ctx.register_type(max_phi.id, element_type)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body: compare arr[i] > max
      ctx.current_block = body_block
      curr_elem = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(curr_elem)
      ctx.register_type(curr_elem.id, element_type)

      greater = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Gt, curr_elem.id, max_phi.id)
      ctx.emit(greater)
      ctx.terminate(Branch.new(greater.id, update_block, incr_block))

      # Update block: new max = curr_elem
      ctx.current_block = update_block
      max_phi.add_incoming(update_block, curr_elem.id)
      ctx.terminate(Jump.new(incr_block))

      # Incr block: i++
      ctx.current_block = incr_block
      max_merged_phi = Phi.new(ctx.next_id, element_type)
      max_merged_phi.add_incoming(body_block, max_phi.id)
      max_merged_phi.add_incoming(update_block, curr_elem.id)
      ctx.emit(max_merged_phi)
      ctx.register_type(max_merged_phi.id, element_type)

      incr_one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(incr_one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, incr_one.id)
      ctx.emit(new_i)
      index_phi.add_incoming(incr_block, new_i.id)
      max_phi.add_incoming(incr_block, max_merged_phi.id)
      ctx.terminate(Jump.new(cond_block))

      # Exit: return max
      ctx.current_block = exit_block
      max_phi.id
    end

    # Handle String.build { |io| ... } intrinsic
    # This creates a StringBuilder, passes it to the block, and returns the final string
    private def block_param_name(block : CrystalV2::Compiler::Frontend::BlockNode, default : String) : String
      if params = block.params
        if first_param = params.first?
          if pname = first_param.name
            return String.new(pname)
          end
        end
      end
      default
    end

    private def lower_string_build_intrinsic(
      ctx : LoweringContext,
      block : CrystalV2::Compiler::Frontend::BlockNode,
      capacity_id : ValueId?,
    ) : ValueId
      # Extract block parameter name (typically "io")
      io_name = block_param_name(block, "io")

      builder_type = type_ref_for_name("String::Builder")
      capacity_value = capacity_id
      unless capacity_value
        default_capacity = Literal.new(ctx.next_id, TypeRef::INT32, 64_i64)
        ctx.emit(default_capacity)
        ctx.register_type(default_capacity.id, TypeRef::INT32)
        capacity_value = default_capacity.id
      end

      builder_ctor = mangle_function_name("String::Builder.new", [ctx.type_of(capacity_value)])
      remember_callsite_arg_types(builder_ctor, [ctx.type_of(capacity_value)])
      lower_function_if_needed(builder_ctor) unless @function_lowering_states[builder_ctor]?.try(&.completed?)

      builder_call = Call.new(ctx.next_id, builder_type, nil, builder_ctor, [capacity_value])
      ctx.emit(builder_call)
      ctx.register_type(builder_call.id, builder_type)

      # Create a scope for the block
      ctx.push_scope(ScopeKind::Block)

      # Register the block parameter "io" as the builder instance
      ctx.register_local(io_name, builder_call.id)
      ctx.register_type(builder_call.id, builder_type)
      update_typeof_local(io_name, builder_type)
      update_typeof_local_name(io_name, "String::Builder")

      # Lower the block body
      # The block will contain operations like io << "text"
      if body = block.body
        lower_body(ctx, body) unless body.empty?
      end

      ctx.pop_scope

      to_s_name = resolve_method_call(ctx, builder_call.id, "to_s", [] of TypeRef, false)
      remember_callsite_arg_types(to_s_name, [] of TypeRef)
      lower_function_if_needed(to_s_name) unless @function_lowering_states[to_s_name]?.try(&.completed?)
      to_s_call = Call.new(ctx.next_id, TypeRef::STRING, builder_call.id, to_s_name, [] of ValueId)
      ctx.emit(to_s_call)
      ctx.register_type(to_s_call.id, TypeRef::STRING)
      to_s_call.id
    end

    # Inline Object#tap with a BlockNode
    # tap yields self to the block then returns self
    # Example: fd.tap { |x| x.flush_on_newline=(true) }
    # => fd.flush_on_newline=(true); fd
    private def inline_tap_with_block(
      ctx : LoweringContext,
      receiver_id : ValueId,
      block_node : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      ctx.push_scope(ScopeKind::Block)

      # Bind block params to receiver_id
      if params = block_node.params
        params.each_with_index do |param, i|
          param_name = if param.name
                         String.new(param.name.not_nil!)
                       else
                         "_block_param_#{i}"
                       end
          ctx.register_local(param_name, receiver_id)
          ctx.register_type(receiver_id, ctx.type_of(receiver_id))
        end
      end

      # Execute block body
      if body = block_node.body
        body.each do |expr_id|
          lower_expr(ctx, expr_id)
        end
      end

      ctx.pop_scope
      # tap returns self
      receiver_id
    end

    # Inline Object#tap with a ProcLiteralNode (&.something syntax)
    # tap yields self to the block then returns self
    # Example: fd.tap(&.flush_on_newline=(true))
    # => fd.flush_on_newline=(true); fd
    private def inline_tap_with_proc(
      ctx : LoweringContext,
      receiver_id : ValueId,
      proc_node : CrystalV2::Compiler::Frontend::ProcLiteralNode,
    ) : ValueId
      ctx.push_scope(ScopeKind::Block)

      # The proc body is like: x.flush_on_newline=(true)
      # where x is the implicit block param that should be bound to receiver_id
      if body = proc_node.body
        # For short block syntax &.method, the body is a single call where
        # the first param becomes the receiver. We need to evaluate it with
        # the receiver bound as the implicit block param.
        if params = proc_node.params
          # Bind each block param - for &.method, there's typically one implicit param
          params.each_with_index do |param, i|
            param_name = if param.name
                           String.new(param.name.not_nil!)
                         else
                           "_block_param_#{i}"
                         end
            ctx.register_local(param_name, receiver_id)
            ctx.register_type(receiver_id, ctx.type_of(receiver_id))
          end
        end

        # If no explicit params, the &.method syntax uses the receiver directly
        # The body should be evaluated in current context
        body.each do |expr_id|
          lower_expr(ctx, expr_id)
        end
      end

      ctx.pop_scope
      # tap returns self
      receiver_id
    end

    private def inline_try_with_block(
      ctx : LoweringContext,
      receiver_id : ValueId,
      receiver_type : TypeRef,
      block_node : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      if receiver_type == TypeRef::NIL || receiver_type == TypeRef::VOID
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      unless is_union_or_nilable_type?(receiver_type)
        return inline_try_without_nil(ctx, receiver_id) do |non_nil_id|
          inline_try_block_body(ctx, block_node, non_nil_id)
        end
      end

      inline_try_core(ctx, receiver_id, receiver_type) do |non_nil_id|
        inline_try_block_body(ctx, block_node, non_nil_id)
      end
    end

    private def inline_try_block_body(
      ctx : LoweringContext,
      block_node : CrystalV2::Compiler::Frontend::BlockNode,
      param_value : ValueId,
    ) : ValueId
      ctx.push_scope(ScopeKind::Block)

      if params = block_node.params
        params.each_with_index do |param, i|
          param_name = if param.name
                         String.new(param.name.not_nil!)
                       else
                         "_block_param_#{i}"
                       end
          ctx.register_local(param_name, param_value)
          ctx.register_type(param_value, ctx.type_of(param_value))
        end
      end

      value_id = if body = block_node.body
                   lower_body(ctx, body)
                 else
                   nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                   ctx.emit(nil_lit)
                   nil_lit.id
                 end

      ctx.pop_scope
      value_id
    end

    private def inline_try_with_proc(
      ctx : LoweringContext,
      receiver_id : ValueId,
      receiver_type : TypeRef,
      proc_node : CrystalV2::Compiler::Frontend::ProcLiteralNode,
    ) : ValueId
      if receiver_type == TypeRef::NIL || receiver_type == TypeRef::VOID
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      unless is_union_or_nilable_type?(receiver_type)
        return inline_try_without_nil(ctx, receiver_id) do |non_nil_id|
          inline_try_proc_body(ctx, proc_node, non_nil_id)
        end
      end

      inline_try_core(ctx, receiver_id, receiver_type) do |non_nil_id|
        inline_try_proc_body(ctx, proc_node, non_nil_id)
      end
    end

    private def inline_try_proc_body(
      ctx : LoweringContext,
      proc_node : CrystalV2::Compiler::Frontend::ProcLiteralNode,
      param_value : ValueId,
    ) : ValueId
      ctx.push_scope(ScopeKind::Block)

      if params = proc_node.params
        params.each_with_index do |param, i|
          param_name = if param.name
                         String.new(param.name.not_nil!)
                       else
                         "_block_param_#{i}"
                       end
          ctx.register_local(param_name, param_value)
          ctx.register_type(param_value, ctx.type_of(param_value))
        end
      end

      value_id = if body = proc_node.body
                   lower_body(ctx, body)
                 else
                   nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                   ctx.emit(nil_lit)
                   nil_lit.id
                 end

      ctx.pop_scope
      value_id
    end

    private def inline_try_without_nil(
      ctx : LoweringContext,
      receiver_id : ValueId,
      &block : ValueId -> ValueId
    ) : ValueId
      block.call(receiver_id)
    end

    private def inline_try_core(
      ctx : LoweringContext,
      receiver_id : ValueId,
      receiver_type : TypeRef,
      &
    ) : ValueId
      nil_check = lower_nil_check_intrinsic(ctx, receiver_id, receiver_type)
      nil_block = ctx.create_block
      value_block = ctx.create_block
      merge_block = ctx.create_block

      ctx.terminate(Branch.new(nil_check, nil_block, value_block))

      # Nil branch
      ctx.current_block = nil_block
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_exit_block = ctx.current_block
      ctx.terminate(Jump.new(merge_block))

      # Non-nil branch
      ctx.current_block = value_block
      non_nil_id = lower_not_nil_intrinsic(ctx, receiver_id, receiver_type)
      non_nil_type = non_nil_type_for_union(receiver_type)
      original_type : TypeRef? = nil
      if non_nil_type && non_nil_type != receiver_type
        original_type = ctx.type_of(receiver_id)
        ctx.register_type(receiver_id, non_nil_type)
      end

      value_id = yield non_nil_id

      if original_type
        ctx.register_type(receiver_id, original_type.not_nil!)
      end

      value_exit_block = ctx.current_block
      block_data = ctx.get_block(value_exit_block)
      value_has_noreturn = block_data.instructions.any? { |inst| inst.is_a?(Raise) || inst.is_a?(Return) }
      value_flows_to_merge = block_data.terminator.is_a?(Unreachable) && !value_has_noreturn
      if value_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      # Merge
      ctx.current_block = merge_block

      unless value_flows_to_merge
        return nil_lit.id
      end

      value_type = ctx.type_of(value_id)
      if value_type == TypeRef::VOID || value_type == TypeRef::NIL
        return nil_lit.id
      end

      phi_type = is_union_or_nilable_type?(value_type) ? value_type : create_union_type_for_nullable(value_type)
      phi = Phi.new(ctx.next_id, phi_type)
      phi.add_incoming(nil_exit_block, nil_lit.id)
      phi.add_incoming(value_exit_block, value_id)
      ctx.emit(phi)
      ctx.register_type(phi.id, phi_type)
      phi.id
    end

    # Emit a normal call for yield functions when inlining is unsafe.
    private def inline_yield_fallback_call(
      ctx : LoweringContext,
      inline_key : String,
      receiver_id : ValueId?,
      call_args : Array(ValueId),
      block : CrystalV2::Compiler::Frontend::BlockNode,
      block_param_types : Array(TypeRef)? = nil,
    ) : ValueId
      # Register call-site argument types so that when the function is deferred
      # to the work queue, lower_method has type info for untyped parameters.
      # Without this, functions like read_section?(name, &) whose params lack
      # type annotations are silently skipped during deferred lowering.
      callsite_arg_types = call_args.map { |arg| ctx.type_of(arg) }
      remember_callsite_arg_types(inline_key, callsite_arg_types, nil, nil, true)
      lower_function_if_needed(inline_key)
      return_type = get_function_return_type(inline_key)
      block_id = lower_block_to_block_id(ctx, block, block_param_types)
      call = Call.new(ctx.next_id, return_type, receiver_id, inline_key, call_args, block_id)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      ctx.pop_scope
      call.id
    end

    private def inline_caller_local_id(name : String) : ValueId?
      return nil if @inline_caller_locals_stack.empty?

      @inline_caller_locals_stack.reverse_each do |locals|
        if value_id = locals[name]?
          return value_id
        end
      end

      nil
    end

    # Inline a yield-function call with block
    # Transforms: func(args) { |params| block_body }
    # Into: inline func body, replacing yield with block_body
    private def inline_yield_function(
      ctx : LoweringContext,
      func_def : CrystalV2::Compiler::Frontend::DefNode,
      inline_key : String,
      receiver_id : ValueId?,
      call_args : Array(ValueId),
      block : CrystalV2::Compiler::Frontend::BlockNode,
      block_param_types : Array(TypeRef)?,
      callee_arena : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : ValueId
      if env_has?("CRYSTAL_V2_DISABLE_INLINE_YIELD")
        return inline_yield_fallback_call(ctx, inline_key, receiver_id, call_args, block, block_param_types)
      end
      ctx.push_scope(ScopeKind::Block)

      # Prevent infinite recursion / runaway stack usage in aggressive yield inlining.
      # This can happen in stdlib where yield is used deeply (or recursively).
      # Keep inline expansion bounded to avoid runaway lowering on deep stdlib chains.
      max_depth = (env_get("INLINE_YIELD_MAX_DEPTH") || "8").to_i
      max_repeat = (env_get("INLINE_YIELD_MAX_REPEAT") || "2").to_i
      caller_arena = @arena
      repeat_count = @inline_yield_name_stack.count(inline_key)
      if @inline_yield_name_stack.size >= max_depth || repeat_count >= max_repeat
        if env_has?("DEBUG_YIELD_INLINE")
          STDERR.puts "[INLINE_YIELD] skipping inline: #{inline_key} (depth=#{@inline_yield_name_stack.size}, max=#{max_depth}, repeat=#{repeat_count}, max_repeat=#{max_repeat})"
        end
        return inline_yield_fallback_call(ctx, inline_key, receiver_id, call_args, block, block_param_types)
      end
      base_inline_name = strip_type_suffix(inline_key)
      namespace_override = function_namespace_override_for(inline_key, base_inline_name)
      debug_inline_self = false
      if filter = env_get("DEBUG_INLINE_SELF")
        if filter.empty? || filter == "1" || inline_key.includes?(filter) || base_inline_name.includes?(filter)
          debug_inline_self = true
          recv_id = receiver_id ? receiver_id.to_s : "nil"
          recv_type = receiver_id ? get_type_name_from_ref(ctx.type_of(receiver_id)) : "nil"
          STDERR.puts(
            "[INLINE_SELF] callee=#{inline_key} base=#{base_inline_name} recv_id=#{recv_id} recv_type=#{recv_type} depth=#{@inline_yield_block_body_depth} func=#{ctx.function.name}"
          )
        end
      end
      if receiver = receiver_name_from_method_name(base_inline_name)
        if unresolved_generic_receiver?(receiver)
          if receiver_id
            receiver_type_map = type_param_map_for_receiver_type(ctx.type_of(receiver_id))
            if receiver_type_map.empty?
              debug_hook("inline.yield.skip", "callee=#{inline_key} receiver=#{receiver} reason=unresolved_generic")
              return inline_yield_fallback_call(ctx, inline_key, receiver_id, call_args, block, block_param_types)
            end
          else
            debug_hook("inline.yield.skip", "callee=#{inline_key} receiver=#{receiver} reason=unresolved_generic")
            return inline_yield_fallback_call(ctx, inline_key, receiver_id, call_args, block, block_param_types)
          end
        end
      end
      if env_get("DEBUG_YIELD_INLINE_ALL")
        STDERR.puts "[INLINE_YIELD] inline #{inline_key} in #{ctx.function.name}"
      end
      if env_get("DEBUG_YIELD_TRACE") && (inline_key.includes?("char_at") || inline_key.includes?("fetch") || inline_key.includes?("upto"))
        STDERR.puts "[INLINE_YIELD] inline #{inline_key} in #{ctx.function.name}"
      end

      if env_get("DEBUG_INLINE_CRASH") && base_inline_name == "Char::Reader#decode_char_at"
        STDERR.puts "[INLINE_CRASH] callee=#{inline_key} caller=#{ctx.function.name} arena=#{callee_arena.size}"
      end

      block_arena = resolve_arena_for_block(block, caller_arena)
      unless block_arena
        debug_hook("inline.yield.block_arena_missing", "callee=#{inline_key} caller=#{ctx.function.name}")
        return inline_yield_fallback_call(ctx, inline_key, receiver_id, call_args, block, block_param_types)
      end
      @block_node_arenas[block.object_id] = block_arena
      unless block.body.empty?
        max_index = block.body.max_of(&.index)
        if max_index < 0 || max_index >= block_arena.size
          debug_hook(
            "inline.yield.block_arena_mismatch",
            "callee=#{inline_key} max=#{max_index} arena=#{block_arena.size}"
          )
          return inline_yield_fallback_call(ctx, inline_key, receiver_id, call_args, block, block_param_types)
        end
      end

      if func_body = func_def.body
        unless func_body.empty?
          max_index = func_body.max_of(&.index)
          if env_get("DEBUG_INLINE_CRASH") && base_inline_name == "Char::Reader#decode_char_at"
            STDERR.puts "[INLINE_CRASH] callee=#{inline_key} body_size=#{func_body.size} max_index=#{max_index}"
          end
          if max_index < 0 || max_index >= callee_arena.size
            debug_hook("inline.yield.arena_mismatch", "callee=#{inline_key} max=#{max_index} arena=#{callee_arena.size}")
            return inline_yield_fallback_call(ctx, inline_key, receiver_id, call_args, block, block_param_types)
          end
        end
      end

      old_inline_arenas = @inline_arenas
      if old_inline_arenas
        combined = old_inline_arenas.dup
        combined << caller_arena unless combined.includes?(caller_arena)
        combined << callee_arena unless combined.includes?(callee_arena)
        combined << block_arena unless combined.includes?(block_arena)
        @inline_arenas = combined
      else
        @inline_arenas = [caller_arena, callee_arena, block_arena]
      end
      @arena = callee_arena

      # Isolate callee locals from caller locals, but keep caller locals available for block bodies.
      caller_locals = ctx.save_locals
      @inline_caller_locals_stack << caller_locals
      preserved_locals = {} of String => ValueId
      ctx.restore_locals(preserved_locals)

      begin
        pushed_name = false
        pushed_block = false
        pushed_override = false

        @inline_yield_name_stack << inline_key
        pushed_name = true
        if @inline_yield_block_body_depth > 0
          @inline_yield_return_override_stack << InlineReturnOverride.new(false, nil)
          pushed_override = true
        end
        @inline_yield_block_stack << block
        @inline_yield_block_arena_stack << block_arena
        @inline_yield_block_param_types_stack << block_param_types
        @inline_yield_block_return_stack << nil
        pushed_block = true
        inline_return = InlineReturnContext.new(ctx.create_block, [] of {BlockId, ValueId}, ctx.function.id)
        @inline_yield_return_stack << inline_return

        old_current_class = @current_class
        old_current_method = @current_method
        old_current_method_is_class = @current_method_is_class
        @inline_caller_class_stack << old_current_class
        @inline_caller_method_stack << old_current_method
        @inline_caller_method_is_class_stack << old_current_method_is_class
        @inline_caller_type_param_map_stack << @type_param_map.dup
        @block_owner[block.object_id] ||= {
          class_name:  old_current_class,
          method_name: old_current_method,
          is_class:    old_current_method_is_class || false,
        }
        @block_owner_function_ids[block.object_id] ||= ctx.function.id
        if self_id = caller_locals["self"]?
          @block_owner_self_ids[block.object_id] ||= self_id
        end
        inferred_block_return = inline_block_return_type_name(block, block_param_types, old_current_class)
        if inferred_block_return
          @inline_yield_block_return_stack[-1] = inferred_block_return
        end
        if env_get("DEBUG_BLOCK_RETURN") && (inline_key.includes?("sort_by") || inline_key.includes?("map"))
          param_str = block_param_types ? block_param_types.map { |t| get_type_name_from_ref(t) }.join(",") : "nil"
          STDERR.puts "[INLINE_BLOCK_RETURN] callee=#{inline_key} params=#{param_str} return=#{inferred_block_return || "nil"}"
          if inferred_block_return.nil?
            if last_expr = block.body.last?
              node = @arena[last_expr]
              detail = case node
                       when CrystalV2::Compiler::Frontend::IdentifierNode
                         "Identifier(#{String.new(node.name)})"
                       when CrystalV2::Compiler::Frontend::MemberAccessNode
                         "MemberAccess(#{String.new(node.member)})"
                       when CrystalV2::Compiler::Frontend::CallNode
                         callee = @arena[node.callee]
                         "Call(#{callee.class.name})"
                       else
                         node.class.name
                       end
              STDERR.puts "[INLINE_BLOCK_RETURN_EXPR] callee=#{inline_key} node=#{detail}"
            end
          end
        end
        parts = parse_method_name(base_inline_name)
        if method_name = parts.method
          unless parts.owner.empty?
            @current_class = parts.owner
            @current_method = method_name unless method_name.empty?
            @current_method_is_class = parts.is_class
          end
        end
        if recv = func_def.receiver
          recv_name = String.new(recv)
          if recv_name == "self"
            @current_method_is_class = true
          end
        end
        inline_param_map = type_param_map_for_receiver_name(base_inline_name)
        if receiver_id
          receiver_type_map = type_param_map_for_receiver_type(ctx.type_of(receiver_id))
          if !receiver_type_map.empty?
            inline_param_map = inline_param_map.merge(receiver_type_map)
          end
        end
        if registered = function_type_param_map_for(inline_key, base_inline_name)
          inline_param_map = inline_param_map.merge(registered)
        end
        if pending = consume_pending_type_param_map(inline_key)
          inline_param_map = inline_param_map.merge(pending)
          store_function_type_param_map(inline_key, base_inline_name, pending)
        elsif pending = consume_pending_type_param_map(base_inline_name)
          inline_param_map = inline_param_map.merge(pending)
          store_function_type_param_map(inline_key, base_inline_name, pending)
        end
        if type_param_name = block_return_type_param_name(inline_key, base_inline_name)
          unless inline_param_map.has_key?(type_param_name)
            if inferred = inline_block_return_type_name(block, block_param_types, old_current_class)
              inline_param_map[type_param_name] = inferred
              record_pending_type_param_map(inline_key, {type_param_name => inferred})
              record_pending_type_param_map(base_inline_name, {type_param_name => inferred})
            end
          end
        end
        result_value = nil_value(ctx)
        callee_is_class = class_method?(base_inline_name)
        apply_inline = -> do
          # Bind `self` for inlined callee.
          if receiver_id
            ctx.register_local("self", receiver_id)
            ctx.register_type(receiver_id, ctx.type_of(receiver_id))
          elsif callee_is_class
            class_name = method_owner(base_inline_name)
            if class_name.empty?
              class_name = @current_class || ""
            end
            unless class_name.empty?
              class_self = lower_type_literal_from_name(ctx, class_name)
              ctx.register_local("self", class_self)
              ctx.register_type(class_self, ctx.type_of(class_self))
            end
          end
          if debug_inline_self
            bound_id = ctx.lookup_local("self")
            bound_str = bound_id ? bound_id.to_s : "nil"
            bound_type = bound_id ? get_type_name_from_ref(ctx.type_of(bound_id)) : "nil"
            expected_str = receiver_id ? receiver_id.to_s : "nil"
            expected_type = receiver_id ? get_type_name_from_ref(ctx.type_of(receiver_id)) : "nil"
            STDERR.puts(
              "[INLINE_SELF_BOUND] callee=#{inline_key} bound_id=#{bound_str} bound_type=#{bound_type} expected_id=#{expected_str} expected_type=#{expected_type} depth=#{@inline_yield_block_body_depth} func=#{ctx.function.name}"
            )
          end

          # Bind function parameters to call arguments
          if params = func_def.params
            params.each_with_index do |param, idx|
              if pname = param.name
                param_name = String.new(pname)
                if idx < call_args.size
                  arg_id = call_args[idx]
                  ctx.register_local(param_name, arg_id)
                  # Also register the type so it's available when the parameter is accessed
                  ctx.register_type(arg_id, ctx.type_of(arg_id))
                end
              end
            end
          end

          # Lower function body with yield substitution
          if inline_body = func_def.body
            result_value = lower_body(ctx, inline_body)
          end
        end
        if inline_param_map.empty?
          if namespace_override
            with_namespace_override(namespace_override) { apply_inline.call }
          else
            apply_inline.call
          end
        else
          with_type_param_map(inline_param_map) do
            if namespace_override
              with_namespace_override(namespace_override) { apply_inline.call }
            else
              apply_inline.call
            end
          end
        end

        if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
          ctx.terminate(Jump.new(inline_return.exit_block))
          inline_return.incoming << {ctx.current_block, result_value}
        end

        ctx.switch_to_block(inline_return.exit_block)

        begin
          if inline_return.incoming.empty?
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            nil_lit.id
          elsif inline_return.incoming.size == 1
            inline_return.incoming.first[1]
          else
            value_types = inline_return.incoming.map { |(_, val)| ctx.type_of(val) }.reject { |t| t == TypeRef::VOID }.uniq
            phi_type = value_types.first? || TypeRef::VOID

            if value_types.size > 1 && !value_types.all? { |t| numeric_primitive?(t) }
              if union_ref = find_covering_union_type(value_types)
                phi_type = union_ref
              else
                value_names = value_types.map { |t| get_type_name_from_ref(t) }.uniq
                if env_has?("DEBUG_INLINE_RETURN")
                  STDERR.puts "[INLINE_RETURN] callee=#{inline_key} types=#{value_names.join(",")}"
                end
                union_name = value_names.join(" | ")
                phi_type = create_union_type(union_name)
              end
            end

            coerced_incoming = inline_return.incoming.map do |(blk, val)|
              val_type = ctx.type_of(val)
              if val_type == phi_type
                {blk, val}
              elsif is_union_type?(phi_type)
                variant_id = get_union_variant_id(phi_type, val_type)
                if variant_id >= 0
                  wrap = UnionWrap.new(ctx.next_id, phi_type, val, variant_id)
                  ctx.emit_to_block(blk, wrap)
                  {blk, wrap.id}
                else
                  {blk, val}
                end
              elsif numeric_primitive?(val_type) && numeric_primitive?(phi_type)
                cast = Cast.new(ctx.next_id, phi_type, val, phi_type, safe: false)
                ctx.emit_to_block(blk, cast)
                {blk, cast.id}
              else
                {blk, val}
              end
            end

            if phi_type == TypeRef::VOID || phi_type == TypeRef::NIL
              nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
              ctx.emit(nil_lit)
              nil_lit.id
            else
              phi = Phi.new(ctx.next_id, phi_type)
              coerced_incoming.each { |(blk, val)| phi.add_incoming(blk, val) }
              ctx.emit(phi)
              phi.id
            end
          end
        rescue ex
          if env_has?("DEBUG_INLINE_RETURN")
            STDERR.puts "[INLINE_RETURN] error=#{ex.message} callee=#{inline_key} func=#{ctx.function.name} incoming=#{inline_return.incoming.size} blocks=#{ctx.function.blocks.size}"
            inline_return.incoming.each do |(blk, val)|
              STDERR.puts "[INLINE_RETURN]   blk=#{blk} val=%#{val} type=#{get_type_name_from_ref(ctx.type_of(val))}"
            end
          end
          raise ex
        end
      ensure
        @current_class = old_current_class
        @current_method = old_current_method
        @current_method_is_class = old_current_method_is_class || false
        @inline_caller_class_stack.pop?
        @inline_caller_method_stack.pop?
        @inline_caller_method_is_class_stack.pop?
        @inline_caller_type_param_map_stack.pop?
        @inline_yield_block_stack.pop? if pushed_block
        @inline_yield_block_arena_stack.pop? if pushed_block
        @inline_yield_block_param_types_stack.pop? if pushed_block
        @inline_yield_block_return_stack.pop? if pushed_block
        @inline_yield_name_stack.pop? if pushed_name
        @inline_yield_return_stack.pop?
        @inline_yield_return_override_stack.pop? if pushed_override
        # Restore caller locals (including any mutations made inside the inlined block body).
        if restored = @inline_caller_locals_stack.pop?
          ctx.restore_locals(restored)
        end
        @arena = caller_arena
        @inline_arenas = old_inline_arenas
        ctx.pop_scope
      end
    end

    # Inline block body in place of yield
    private def inline_block_body(
      ctx : LoweringContext,
      yield_node : CrystalV2::Compiler::Frontend::YieldNode,
      block : CrystalV2::Compiler::Frontend::BlockNode,
    ) : ValueId
      @inline_yield_block_body_depth += 1
      pushed_override = false
      begin
        # When a block is lexically defined in the function being lowered (ctx.function),
        # a `return` inside it should exit the function entirely (real Return), not jump to
        # an intermediate inline-yield exit block. We detect this by comparing the block's
        # registered function_id against ctx.function.id.
        block_owned_by_current_fn = @block_owner_function_ids[block.object_id]? == ctx.function.id
        base_override = nil
        unless block_owned_by_current_fn
          if active_entry = @inline_yield_return_override_stack.reverse.find(&.active)
            base_override = active_entry.context
          elsif @inline_yield_return_stack.size > 1
            base_override = @inline_yield_return_stack[-2]
          end
        end
        @inline_yield_return_override_stack << InlineReturnOverride.new(true, base_override)
        pushed_override = true

        # Lower yield arguments
        yield_args = if args = yield_node.args
                       args.reject(&.invalid?).map { |arg| lower_expr(ctx, arg) }
                     else
                       [] of ValueId
                     end
        param_types = @inline_yield_block_param_types_stack.last?
        if block_params = block.params
          if block_params.size > 1 && yield_args.size == 1
            expanded_param_types = param_types
            tuple_source_type = if expanded_param_types && expanded_param_types.size == 1
                                  expanded_param_types.first
                                elsif expanded_param_types.nil? || expanded_param_types.empty?
                                  ctx.type_of(yield_args.first)
                                end
            if tuple_source_type
              if tuple_desc = @module.get_type_descriptor(tuple_source_type)
                if tuple_desc.kind == TypeKind::Tuple || tuple_desc.name.starts_with?("Tuple(")
                  tuple_params = tuple_desc.type_params.reject { |t| t == TypeRef::VOID }
                  if tuple_params.size >= block_params.size
                    expanded_param_types = tuple_params
                    tuple_val = yield_args.first
                    expanded_args = [] of ValueId
                    block_params.each_with_index do |_, idx|
                      idx_lit = Literal.new(ctx.next_id, TypeRef::INT32, idx.to_i64)
                      ctx.emit(idx_lit)
                      ctx.register_type(idx_lit.id, TypeRef::INT32)
                      elem_type = tuple_params[idx]? || TypeRef::VOID
                      idx_get = IndexGet.new(ctx.next_id, elem_type, tuple_val, idx_lit.id)
                      ctx.emit(idx_get)
                      ctx.register_type(idx_get.id, elem_type)
                      expanded_args << idx_get.id
                    end
                    yield_args = expanded_args
                    param_types = expanded_param_types
                  end
                end
              end
            end
          end
        end
        if param_types
          param_types.each_with_index do |param_type, idx|
            next if param_type == TypeRef::VOID
            next unless idx < yield_args.size
            yield_args[idx] = coerce_value_to_type(ctx, yield_args[idx], param_type)
          end
        end
        # Lower block body
        # For inlined yield-functions, the block body must run in the *caller* lexical scope
        # (caller locals, caller `self`). Otherwise ivar access inside the block can target
        # the callee receiver (e.g. `tap` receiver) and generate invalid IR.
        owner = @block_owner[block.object_id]?
        caller_locals_index = @inline_caller_locals_stack.size - 1
        if owner
          matched = false
          (@inline_caller_class_stack.size - 1).downto(0) do |idx|
            next unless @inline_caller_class_stack[idx]? == owner[:class_name]
            owner_method = owner[:method_name]
            stack_method = @inline_caller_method_stack[idx]?
            if owner_method.nil? || owner_method.empty? || stack_method == owner_method
              caller_locals_index = idx
              matched = true
              break
            end
          end
          if !matched
            (@inline_caller_class_stack.size - 1).downto(0) do |idx|
              next unless @inline_caller_class_stack[idx]? == owner[:class_name]
              caller_locals_index = idx
              break
            end
          end
        end
        result = if caller_locals = @inline_caller_locals_stack[caller_locals_index]?
                   if owner_self_id = @block_owner_self_ids[block.object_id]?
                     unless caller_locals.has_key?("self")
                       caller_locals = caller_locals.dup
                       caller_locals["self"] = owner_self_id
                     end
                   end
                   caller_class = owner ? owner[:class_name] : @inline_caller_class_stack.last?
                   caller_method = owner ? owner[:method_name] : @inline_caller_method_stack.last?
                   caller_is_class = owner ? owner[:is_class] : (@inline_caller_method_is_class_stack.last? || false)
                   if env_get("DEBUG_INLINE_CALLER")
                     owner_flag = owner ? "owner" : "caller"
                     STDERR.puts "[INLINE_CALLER] #{owner_flag}=#{caller_class}##{caller_method} depth=#{@inline_yield_block_body_depth}"
                   end
                   old_inline_class = @current_class
                   old_inline_method = @current_method
                   old_inline_method_is_class = @current_method_is_class
                   old_type_param_map = @type_param_map
                   @current_class = caller_class
                   @current_method = caller_method
                   @current_method_is_class = caller_is_class
                   if caller_type_map = @inline_caller_type_param_map_stack.last?
                     @type_param_map = caller_type_map
                     @subst_cache_gen &+= 1
                   end
                   begin
                     saved_callee_locals = ctx.save_locals
                     ctx.restore_locals(caller_locals)

                     caller_locals_before_params = ctx.save_locals
                     param_names = [] of String
                     if params = block.params
                       params.each do |param|
                         if pname = param.name
                           param_names << String.new(pname)
                         end
                       end
                     end

                     # Bind block parameters to yield arguments (in caller scope).
                     param_names.each_with_index do |param_name, idx|
                       next unless idx < yield_args.size
                       arg_id = yield_args[idx]
                       if param_types && (param_type = param_types[idx]?) && param_type != TypeRef::VOID
                         ctx.register_local(param_name, arg_id)
                         ctx.register_type(arg_id, param_type)
                         update_typeof_local(param_name, param_type)
                         update_typeof_local_name(param_name, get_type_name_from_ref(param_type))
                       else
                         ctx.register_local(param_name, arg_id)
                         ctx.register_type(arg_id, ctx.type_of(arg_id))
                       end
                     end

                     # Ensure block body is lowered in the caller arena, even when the callee comes from another file.
                     body_result = begin
                       # The block body belongs to the *caller* and may itself contain `yield`.
                       # Temporarily disable the current inlined-yield substitution so nested `yield`
                       # in the block body can bind to an outer inlining context (if any).
                       popped_block = @inline_yield_block_stack.pop?
                       popped_arena = @inline_yield_block_arena_stack.pop?
                       popped_param_types = @inline_yield_block_param_types_stack.pop?
                       if popped_block && popped_block.object_id != block.object_id
                         # Unexpected mismatch; restore stacks and continue without popping.
                         @inline_yield_block_stack << popped_block
                         @inline_yield_block_arena_stack << popped_arena if popped_arena
                         @inline_yield_block_param_types_stack << popped_param_types
                         popped_block = nil
                         popped_arena = nil
                         popped_param_types = nil
                       end

                       old_arena = @arena
                       begin
                         block_arena = resolve_arena_for_block(block, old_arena)
                         chosen_arena = block_arena || popped_arena || @inline_yield_block_arena_stack.last? || old_arena
                         @arena = chosen_arena
                         begin
                           lower_body(ctx, block.body)
                         ensure
                           @arena = old_arena
                         end
                       ensure
                         if popped_block
                           @inline_yield_block_stack << popped_block
                           @inline_yield_block_param_types_stack << popped_param_types
                           if restored_arena = popped_arena
                             @inline_yield_block_arena_stack << restored_arena
                           else
                             @inline_yield_block_arena_stack << old_arena
                           end
                         end
                       end
                     end

                     if env_get("DEBUG_INLINE_YIELD_RESULT")
                       arg_names = yield_args.map { |arg_id| get_type_name_from_ref(ctx.type_of(arg_id)) }.join(",")
                       res_type = ctx.type_of(body_result)
                       res_name = res_type == TypeRef::VOID ? "Void" : get_type_name_from_ref(res_type)
                       callee_name = @inline_yield_name_stack.last? || ""
                       STDERR.puts "[INLINE_YIELD_RESULT] callee=#{callee_name} args=#{arg_names} result=#{res_name}"
                     end

                     caller_locals_after = ctx.save_locals
                     # Block parameters must not leak outside the block.
                     param_names.each do |name|
                       if prev = caller_locals_before_params[name]?
                         caller_locals_after[name] = prev
                       else
                         caller_locals_after.delete(name)
                       end
                     end

                     # If we're in an inline loop context, keep phi-bound locals stable across iterations.
                     if loop_vars = inline_loop_vars_union
                       loop_vars.each do |name|
                         if prev = caller_locals[name]?
                           caller_locals_after[name] = prev
                         else
                           caller_locals_after.delete(name)
                         end
                       end
                     end
                     @inline_caller_locals_stack[caller_locals_index] = caller_locals_after

                     ctx.restore_locals(saved_callee_locals)
                     body_result
                   ensure
                     @current_class = old_inline_class
                     @current_method = old_inline_method
                     @current_method_is_class = old_inline_method_is_class || false
                     @type_param_map = old_type_param_map
                     @subst_cache_gen &+= 1
                   end
                 else
                   # No yield inlining context; just lower block normally.
                   if arenas = @inline_arenas
                     candidate = arenas[0]
                     chosen = candidate
                     unless block.body.empty?
                       max_index = block.body.max_of(&.index)
                       if max_index < 0 || max_index >= candidate.size
                         chosen = @arena
                       end
                     end

                     old_arena = @arena
                     @arena = chosen
                     begin
                       lower_body(ctx, block.body)
                     ensure
                       @arena = old_arena
                     end
                   else
                     lower_body(ctx, block.body)
                   end
                 end

        if env_get("DEBUG_INLINE_BLOCK_RESULT")
          inline_name = @inline_yield_name_stack.last? || ""
          if inline_name.includes?("decode_char_before")
            result_type = result ? ctx.type_of(result) : TypeRef::VOID
            yield_types = yield_args.map { |arg_id| get_type_name_from_ref(ctx.type_of(arg_id)) }
            STDERR.puts "[INLINE_BLOCK_RESULT] callee=#{inline_name} result=#{get_type_name_from_ref(result_type)} yield=#{yield_types.join(",")}"
          end
        end

        # Prefer explicit yield-return type when block body returns Void/Nil.
        if result
          result_type = ctx.type_of(result)
          if result_type == TypeRef::VOID || result_type == TypeRef::NIL
            if inferred = infer_yield_return_type(ctx)
              if inferred != TypeRef::VOID && inferred != TypeRef::NIL
                ctx.register_type(result, inferred)
                result_type = inferred
              end
            end
          end
        end

        # If the block body didn't infer a result type, fall back to a non-void arg type.
        if result && ctx.type_of(result) == TypeRef::VOID
          yield_args.each do |arg_id|
            arg_type = ctx.type_of(arg_id)
            next if arg_type == TypeRef::VOID
            ctx.register_type(result, arg_type)
            break
          end
        end

        result
      ensure
        @inline_yield_return_override_stack.pop? if pushed_override
        @inline_yield_block_body_depth -= 1
      end
    end

    # Helper to create nil value
    private def nil_value(ctx : LoweringContext) : ValueId
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_index(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::IndexNode) : ValueId
      object_id = lower_expr(ctx, node.object)
      obj_node = @arena[node.object]
      if ctx.type_of(object_id) == TypeRef::VOID
        if inferred = infer_type_from_expr(node.object, @current_class)
          if inferred != TypeRef::VOID && inferred != TypeRef::NIL
            ctx.register_type(object_id, inferred)
          end
        end
      end
      if ctx.type_of(object_id) == TypeRef::VOID
        if obj_node.is_a?(CrystalV2::Compiler::Frontend::SelfNode) ||
           (obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && String.new(obj_node.name) == "self")
          if current = @current_class
            resolved_current = resolve_type_alias_chain(substitute_type_params_in_type_name(current))
            inferred = type_ref_for_name(resolved_current)
            if inferred != TypeRef::VOID
              ctx.register_type(object_id, inferred)
            end
          end
        end
      end
      enum_name = nil
      case obj_node
      when CrystalV2::Compiler::Frontend::ConstantNode
        name = String.new(obj_node.name)
        resolved = resolve_class_name_in_context(name)
        resolved = resolve_type_alias_chain(resolved)
        enum_name = resolve_enum_name(resolved) || (@enum_info.try(&.has_key?(resolved)) ? resolved : nil)
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(obj_node.name)
        if ctx.lookup_local(name).nil?
          resolved = resolve_class_name_in_context(name)
          resolved = resolve_type_alias_chain(resolved)
          enum_name = resolve_enum_name(resolved) || (@enum_info.try(&.has_key?(resolved)) ? resolved : nil)
        end
      when CrystalV2::Compiler::Frontend::PathNode
        raw_path = collect_path_string(obj_node)
        full_path = if path_is_absolute?(obj_node)
                      raw_path.starts_with?("::") ? raw_path[2..] : raw_path
                    else
                      resolve_path_string_in_context(raw_path)
                    end
        resolved = resolve_type_alias_chain(full_path)
        enum_name = resolve_enum_name(resolved) || (@enum_info.try(&.has_key?(resolved)) ? resolved : nil)
      end
      if enum_name
        if value_id = lower_enum_bracket_call(ctx, enum_name, node.indexes, @arena)
          return value_id
        end
      end

      # Check if any index is a Range - if so, this is a slice operation
      # Need to check BEFORE lowering the indices so we can handle Range specially
      if node.indexes.size == 1
        idx_node = @arena[node.indexes.first]
        if idx_node.is_a?(CrystalV2::Compiler::Frontend::RangeNode)
          # String#[](Range) intercept: extract begin/end from range, call byte_slice helper
          obj_type = ctx.type_of(object_id)
          if obj_type == TypeRef::STRING || obj_type == TypeRef::POINTER
            begin_id = lower_expr(ctx, idx_node.begin_expr)
            end_id = lower_expr(ctx, idx_node.end_expr)
            exclusive = idx_node.exclusive
            # Calculate length: for inclusive range (0..4), length = end - begin + 1
            # For exclusive range (0...4), length = end - begin
            len_raw = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Sub, end_id, begin_id)
            ctx.emit(len_raw)
            ctx.register_type(len_raw.id, TypeRef::INT32)
            len_id = if !exclusive
                       one_lit = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
                       ctx.emit(one_lit)
                       ctx.register_type(one_lit.id, TypeRef::INT32)
                       len_inc = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, len_raw.id, one_lit.id)
                       ctx.emit(len_inc)
                       ctx.register_type(len_inc.id, TypeRef::INT32)
                       len_inc.id
                     else
                       len_raw.id
                     end
            ext_call = ExternCall.new(ctx.next_id, TypeRef::STRING, "__crystal_v2_string_byte_slice", [object_id, begin_id, len_id])
            ctx.emit(ext_call)
            ctx.register_type(ext_call.id, TypeRef::STRING)
            return ext_call.id
          end

          # Array slice: arr[start..end] -> call Array#[](Range) with the Range value
          # Lower the Range expression to get a Range value with proper type params
          range_id = lower_range(ctx, idx_node)
          range_type = ctx.type_of(range_id)

          if env_has?("DEBUG_RANGE_INDEX")
            range_desc = @module.get_type_descriptor(range_type)
            range_name = range_desc ? range_desc.name : "T#{range_type.id}"
            STDERR.puts "[RANGE_INDEX] range_type=#{range_name}(id=#{range_type.id})"
          end

          # Emit a call to [] for range slicing with proper return type inference.
          arg_types = [range_type]
          method_name = resolve_method_call(ctx, object_id, "[]", arg_types, false)
          # Ensure the target function is lowered (IndexNode bypasses lower_call).
          object_type = ctx.type_of(object_id)
          type_desc = @module.get_type_descriptor(object_type)
          class_name = type_desc.try(&.name) || primitive_class_name(object_type) || ""
          if class_name.empty?
            if obj_node.is_a?(CrystalV2::Compiler::Frontend::SelfNode) ||
               (obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && String.new(obj_node.name) == "self")
              if current = @current_class
                class_name = resolve_type_alias_chain(substitute_type_params_in_type_name(current))
              end
            end
          end
          class_name = normalize_method_owner_name(class_name)
          base_method_name = class_name.empty? ? "[]" : "#{class_name}#[]"
          primary_mangled_name = mangle_function_name(base_method_name, arg_types)
          if env_has?("DEBUG_RANGE_INDEX")
            STDERR.puts "[RANGE_INDEX] class=#{class_name} base=#{base_method_name} mangled=#{primary_mangled_name}"
          end
          remember_callsite_arg_types(primary_mangled_name, arg_types)
          if method_name != primary_mangled_name
            remember_callsite_arg_types(method_name, arg_types)
          end
          callsite_label = nil
          if DebugHooks::ENABLED
            span = node.span
            receiver_name = type_name_for_mangling(ctx.type_of(object_id))
            callsite_label = "func=#{ctx.function.name} method=[] full=#{method_name} class=#{@current_class || ""} recv=#{receiver_name} span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column}"
          end
          with_debug_callsite(callsite_label) do
            lower_function_if_needed(primary_mangled_name)
            if method_name != primary_mangled_name
              lower_function_if_needed(method_name)
            end
          end
          return_type = get_function_return_type(method_name)
          owner_type_for_return = object_type
          owner_part = strip_type_suffix(method_name)
          owner_name = method_owner(owner_part)
          if owner_name && !owner_name.empty?
            if owner_ref = type_ref_for_name(owner_name)
              owner_type_for_return = owner_ref unless owner_ref == TypeRef::VOID
            end
          end
          inferred_return = resolve_return_type_from_def(primary_mangled_name, base_method_name, owner_type_for_return)
          if inferred_return.nil? && method_name != primary_mangled_name
            inferred_return = resolve_return_type_from_def(method_name, base_method_name, owner_type_for_return)
          end
          if inferred_return && inferred_return != TypeRef::VOID
            if return_type == TypeRef::VOID || return_type == TypeRef::POINTER
              return_type = inferred_return
            end
          end
          # Fallback: [] typically returns a value (element or subslice)
          if return_type == TypeRef::VOID
            return_type = TypeRef::POINTER
          end
          call = Call.new(ctx.next_id, return_type, object_id, method_name, [range_id])
          ctx.emit(call)
          ctx.register_type(call.id, return_type)
          return call.id
        end
      end

      # IndexNode has indexes (Array) - can be multi-dimensional like arr[1, 2]
      index_ids = node.indexes.map { |idx| lower_expr(ctx, idx) }

      # Check if this is an array by looking at the object node (ArrayLiteral check)
      # This is necessary because arrays are typed as POINTER but should use IndexGet
      is_array_literal = obj_node.is_a?(CrystalV2::Compiler::Frontend::ArrayLiteralNode)
      # Also check if object is an identifier that was assigned an array
      if !is_array_literal && obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
        # Check if the emitted HIR instruction is an ArrayLiteral
        # (This is a simple check - for now just assume POINTER type without explicit Pointer(T) is an array)
        object_type = ctx.type_of(object_id)
        type_desc = @module.get_type_descriptor(object_type)
        # If it's POINTER but NOT Pointer(T), treat as array
        if object_type == TypeRef::POINTER && !(type_desc && type_desc.name.starts_with?("Pointer"))
          is_array_literal = true
        end
      end

      # Array indexing: use IndexGet for element access
      if is_array_literal && index_ids.size == 1
        element_type = TypeRef::INT32 # Default element type
        index_get = IndexGet.new(ctx.next_id, element_type, object_id, index_ids.first)
        ctx.emit(index_get)
        ctx.register_type(index_get.id, element_type)
        return index_get.id
      end

      # Check if this is pointer indexing (ptr[i])
      object_type = ctx.type_of(object_id)
      type_desc = @module.get_type_descriptor(object_type)
      if type_desc && type_desc.kind == TypeKind::Union
        if unwrapped = unwrap_pointer_union(ctx, object_id, object_type)
          object_id, object_type = unwrapped
          type_desc = @module.get_type_descriptor(object_type)
        end
      end
      is_pointer_type = object_type == TypeRef::POINTER ||
                        (type_desc && type_desc.kind == TypeKind::Pointer) ||
                        (type_desc && type_desc.name.starts_with?("Pointer"))
      if is_pointer_type && index_ids.size == 1
        # Pointer indexing: ptr[i] -> PointerLoad with index
        # Extract element type from Pointer(T) if available
        deref_type = if type_desc && type_desc.name.starts_with?("Pointer(")
                       elem_name = type_desc.name[8, type_desc.name.size - 9]
                       type_ref_for_name(elem_name)
                     else
                       TypeRef::INT32
                     end
        load_node = PointerLoad.new(ctx.next_id, deref_type, object_id, index_ids.first)
        ctx.emit(load_node)
        ctx.register_type(load_node.id, deref_type)
        return load_node.id
      end

      # Check if this is an array-like type (which uses IndexGet for element access)
      is_array_type = type_desc && (type_desc.kind == TypeKind::Array ||
                                    type_desc.name.starts_with?("Array") ||
                                    type_desc.name.starts_with?("StaticArray"))
      # Check if the index is a Range type - if so, we need to call [] method instead of IndexGet
      index_is_range = if index_ids.size == 1
                         idx_type = ctx.type_of(index_ids.first)
                         idx_desc = @module.get_type_descriptor(idx_type)
                         result = idx_desc && idx_desc.name.starts_with?("Range")
                         if env_has?("DEBUG_RANGE_INDEX")
                           STDERR.puts "[RANGE_INDEX_CHECK] is_array=#{is_array_type} idx_type=#{idx_desc.try(&.name) || "nil"}(id=#{idx_type.id}) is_range=#{result}"
                         end
                         result
                       else
                         false
                       end
      if is_array_type && index_ids.size == 1 && !index_is_range
        # Array element access: arr[i] -> IndexGet
        # Prefer the array's element type from the interned TypeDescriptor params.
        # Arrays are represented as POINTER at runtime, so we must carry element type explicitly.
        element_type = TypeRef::INT32
        td = type_desc.not_nil!
        if td.kind == TypeKind::Union
          # For union types like Array(T) | Nil, find the Array variant and get its element type.
          # Union variants are stored in @union_descriptors, not in type_params.
          mir_union_ref = hir_to_mir_type_ref(object_type)
          if union_desc = @union_descriptors[mir_union_ref]?
            union_desc.variants.each do |variant|
              variant_hir_ref = mir_to_hir_type_ref(variant.type_ref)
              if variant_desc = @module.get_type_descriptor(variant_hir_ref)
                if variant_desc.kind == TypeKind::Array || variant_desc.name.starts_with?("Array") || variant_desc.name.starts_with?("StaticArray")
                  element_type = variant_desc.type_params.first? || TypeRef::INT32
                  break
                end
              end
            end
          else
            # Fallback: parse the type name to extract array element type
            # e.g., "Array(Tuple(Int32, Int32, Property)) | Nil" -> extract element from "Array(...)"
            if match = td.name.match(/^Array\((.+)\)\s*\|/)
              element_name = match[1]
              if elem_ref = type_ref_for_name(element_name)
                element_type = elem_ref
              end
            end
          end
        else
          element_type = td.type_params.first? || TypeRef::INT32
        end
        element_type = TypeRef::INT32 if element_type == TypeRef::VOID

        index_get = IndexGet.new(ctx.next_id, element_type, object_id, index_ids.first)
        ctx.emit(index_get)
        ctx.register_type(index_get.id, element_type)
        index_get.id
      # Check if this is a tuple type — intercept to avoid calling Tuple#[]
      # which relies on T.size macro (resolves to 0) causing infinite recursion.
      elsif type_desc && (type_desc.kind == TypeKind::Tuple || type_desc.name.starts_with?("Tuple(")) && index_ids.size == 1
        td = type_desc.not_nil!
        # Determine element type from literal index or use first element type
        element_type = TypeRef::INT32 # default fallback
        idx_node = @arena[node.indexes.first]
        if idx_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
          idx_val = String.new(idx_node.value).to_i?
          if idx_val && idx_val >= 0 && idx_val < td.type_params.size
            element_type = td.type_params[idx_val]
          elsif !td.type_params.empty?
            element_type = td.type_params.first
          end
        elsif !td.type_params.empty?
          element_type = td.type_params.first
        end
        element_type = TypeRef::INT32 if element_type == TypeRef::VOID

        index_get = IndexGet.new(ctx.next_id, element_type, object_id, index_ids.first)
        ctx.emit(index_get)
        ctx.register_type(index_get.id, element_type)
        index_get.id
      elsif ctx.type_of(object_id) == TypeRef::STRING && index_ids.size == 2
        # String#[](Int32, Int32) → substring extraction via runtime helper
        ext_call = ExternCall.new(ctx.next_id, TypeRef::STRING, "__crystal_v2_string_substring", [object_id, index_ids[0], index_ids[1]])
        ctx.emit(ext_call)
        ctx.register_type(ext_call.id, TypeRef::STRING)
        return ext_call.id
      else
        # Everything else (classes like Hash, custom types): call [] method
        # Resolve the method name properly (with class name and mangling)
        arg_types = index_ids.map { |idx| ctx.type_of(idx) }
        # If arg types are still VOID, try to infer from the index AST nodes
        # to avoid selecting the Range overload when the index is Int32.
        if arg_types.any? { |t| t == TypeRef::VOID }
          inferred_types = node.indexes.map do |idx|
            infer_type_from_expr(idx, @current_class) || TypeRef::VOID
          end
          if inferred_types.size == arg_types.size
            arg_types = arg_types.map_with_index do |t, i|
              t == TypeRef::VOID ? inferred_types[i] : t
            end
          end
        end
        method_name = resolve_method_call(ctx, object_id, "[]", arg_types, false)
        # Ensure the target function is lowered (IndexNode bypasses lower_call).
        object_type = ctx.type_of(object_id)
        type_desc = @module.get_type_descriptor(object_type)
        class_name = type_desc.try(&.name) || primitive_class_name(object_type) || ""
        if class_name.empty?
          if obj_node.is_a?(CrystalV2::Compiler::Frontend::SelfNode) ||
             (obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && String.new(obj_node.name) == "self")
            if current = @current_class
              class_name = resolve_type_alias_chain(substitute_type_params_in_type_name(current))
            end
          end
        end
        class_name = normalize_method_owner_name(class_name)
        base_method_name = class_name.empty? ? "[]" : "#{class_name}#[]"
        primary_mangled_name = mangle_function_name(base_method_name, arg_types)
        remember_callsite_arg_types(primary_mangled_name, arg_types)
        if method_name != primary_mangled_name
          remember_callsite_arg_types(method_name, arg_types)
        end
        callsite_label = nil
        if DebugHooks::ENABLED
          span = node.span
          receiver_name = type_name_for_mangling(ctx.type_of(object_id))
          callsite_label = "func=#{ctx.function.name} method=[] full=#{method_name} class=#{@current_class || ""} recv=#{receiver_name} span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column}"
        end
        with_debug_callsite(callsite_label) do
          lower_function_if_needed(primary_mangled_name)
          if method_name != primary_mangled_name
            lower_function_if_needed(method_name)
          end
        end
        return_type = get_function_return_type(method_name)
        owner_type_for_return = object_type
        owner_part = strip_type_suffix(method_name)
        owner_name = method_owner(owner_part)
        if owner_name && !owner_name.empty?
          if owner_ref = type_ref_for_name(owner_name)
            owner_type_for_return = owner_ref unless owner_ref == TypeRef::VOID
          end
        end
        inferred_return = resolve_return_type_from_def(primary_mangled_name, base_method_name, owner_type_for_return)
        if inferred_return.nil? && method_name != primary_mangled_name
          inferred_return = resolve_return_type_from_def(method_name, base_method_name, owner_type_for_return)
        end
        if inferred_return && inferred_return != TypeRef::VOID
          if return_type == TypeRef::VOID || return_type == TypeRef::POINTER
            return_type = inferred_return
          end
        end
        # Fallback: [] typically returns a value (element or subslice)
        if return_type == TypeRef::VOID
          return_type = TypeRef::POINTER
        end
        call = Call.new(ctx.next_id, return_type, object_id, method_name, index_ids)
        ctx.emit(call)
        ctx.register_type(call.id, return_type)
        call.id
      end
    end

    private def lower_enum_predicate(ctx : LoweringContext, object_id : ValueId, member_name : String) : ValueId?
      return nil unless member_name.ends_with?('?')
      enum_name = @enum_value_types.try(&.[object_id]?)
      type_name = get_type_name_from_ref(ctx.type_of(object_id))
      if enum_name.nil? && !type_name.empty?
        enum_name = resolve_enum_name(type_name)
        if enum_name.nil?
          candidates = [] of String
          if type_name.ends_with?('?')
            candidates << type_name[0...-1]
          elsif type_name.includes?('|')
            split_union_type_name(type_name).each { |entry| candidates << entry.strip }
          end
          candidates.each do |candidate|
            if resolved = resolve_enum_name(candidate)
              enum_name = resolved
              break
            end
          end
        end
        # Lazy-discover enum from stdlib if type descriptor exists but enum not registered
        if enum_name.nil? && !type_name.empty?
          obj_type = ctx.type_of(object_id)
          if td = @module.get_type_descriptor(obj_type)
            if lazy_discover_enum_from_source(td.name)
              enum_name = td.name
            end
          end
        end
        if enum_name
          (@enum_value_types ||= {} of ValueId => String)[object_id] = enum_name
        end
      end
      enum_key = enum_name || type_name
      return nil if enum_key.empty?
      members = enum_members_for_type_name(enum_key)
      return nil unless members
      enum_name ||= resolve_enum_name(type_name) || enum_key

      # Try to match the predicate to an enum member (e.g., "data1?" -> "Data1").
      base_name = member_name[0...-1]
      target = underscore_lower(base_name)
      member_match = members.keys.find { |m| underscore_lower(m) == target }
      if member_match.nil? && target == "none"
        enum_type = enum_base_type(enum_name)
        lit = Literal.new(ctx.next_id, enum_type, 0_i64)
        ctx.emit(lit)
        ctx.register_type(lit.id, enum_type)
        cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, object_id, lit.id)
        ctx.emit(cmp)
        ctx.register_type(cmp.id, TypeRef::BOOL)
        return cmp.id
      end
      return nil unless member_match

      member_value = members[member_match]
      enum_type = enum_base_type(enum_name)
      lit = Literal.new(ctx.next_id, enum_type, member_value)
      ctx.emit(lit)
      ctx.register_type(lit.id, enum_type)
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, object_id, lit.id)
      ctx.emit(cmp)
      ctx.register_type(cmp.id, TypeRef::BOOL)
      cmp.id
    end

    private def lower_enum_value_call(
      ctx : LoweringContext,
      object_id : ValueId,
      member_name : String,
    ) : ValueId?
      enum_name = @enum_value_types.try(&.[object_id]?)
      return nil unless enum_name

      target_type = case member_name
                    when "value"          then enum_base_type(enum_name)
                    when "to_i", "to_i32" then TypeRef::INT32
                    when "to_i64"         then TypeRef::INT64
                    when "to_i16"         then TypeRef::INT16
                    when "to_i8"          then TypeRef::INT8
                    when "to_i128"        then type_ref_for_name("Int128")
                    when "to_u32"         then TypeRef::UINT32
                    when "to_u64"         then TypeRef::UINT64
                    when "to_u16"         then TypeRef::UINT16
                    when "to_u8"          then TypeRef::UINT8
                    when "to_u128"        then type_ref_for_name("UInt128")
                    else
                      nil
                    end
      return nil unless target_type

      enum_type = enum_base_type(enum_name)
      return object_id if member_name == "value" || target_type == enum_type

      cast = Cast.new(ctx.next_id, target_type, object_id, target_type, safe: false)
      ctx.emit(cast)
      ctx.register_type(cast.id, target_type)
      cast.id
    end

    private def lower_enum_bracket_call(
      ctx : LoweringContext,
      enum_name : String,
      call_args : Array(ExprId),
      call_arena : CrystalV2::Compiler::Frontend::ArenaLike,
    ) : ValueId?
      members = enum_members_for_type_name(enum_name)
      return nil unless members

      enum_type = enum_base_type(enum_name)
      value_ids = [] of ValueId

      if call_args.empty?
        lit = Literal.new(ctx.next_id, enum_type, 0_i64)
        ctx.emit(lit)
        ctx.register_type(lit.id, enum_type)
        (@enum_value_types ||= {} of ValueId => String)[lit.id] = enum_name
        return lit.id
      end

      call_args.each do |arg_expr|
        arg_node = call_arena[arg_expr]
        value_id : ValueId? = nil

        case arg_node
        when CrystalV2::Compiler::Frontend::SymbolNode
          if value = enum_member_value(enum_name, String.new(arg_node.name))
            lit = Literal.new(ctx.next_id, enum_type, value)
            ctx.emit(lit)
            ctx.register_type(lit.id, enum_type)
            value_id = lit.id
          end
        when CrystalV2::Compiler::Frontend::IdentifierNode
          name = String.new(arg_node.name)
          if ctx.lookup_local(name).nil?
            if value = members[name]?
              lit = Literal.new(ctx.next_id, enum_type, value)
              ctx.emit(lit)
              ctx.register_type(lit.id, enum_type)
              value_id = lit.id
            end
          end
        when CrystalV2::Compiler::Frontend::ConstantNode
          name = String.new(arg_node.name)
          if value = members[name]?
            lit = Literal.new(ctx.next_id, enum_type, value)
            ctx.emit(lit)
            ctx.register_type(lit.id, enum_type)
            value_id = lit.id
          end
        when CrystalV2::Compiler::Frontend::PathNode
          path = with_arena(call_arena) { collect_path_string(arg_node) }
          member = last_namespace_component(path)
          if value = members[member]?
            lit = Literal.new(ctx.next_id, enum_type, value)
            ctx.emit(lit)
            ctx.register_type(lit.id, enum_type)
            value_id = lit.id
          end
        end

        unless value_id
          value_id = lower_expr(ctx, arg_expr)
          value_type = ctx.type_of(value_id)
          if value_type != enum_type
            cast = Cast.new(ctx.next_id, enum_type, value_id, enum_type, safe: false)
            ctx.emit(cast)
            ctx.register_type(cast.id, enum_type)
            value_id = cast.id
          end
        end

        value_ids << value_id
      end

      result_id = value_ids.first
      value_ids[1..].each do |next_id|
        binop = BinaryOperation.new(ctx.next_id, enum_type, BinaryOp::BitOr, result_id, next_id)
        ctx.emit(binop)
        ctx.register_type(binop.id, enum_type)
        result_id = binop.id
      end

      (@enum_value_types ||= {} of ValueId => String)[result_id] = enum_name
      result_id
    end

    private def lower_member_access(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::MemberAccessNode) : ValueId
      obj_node = @arena[node.object]
      member_name = String.new(node.member)

      # Proc#call intercept for zero-arg calls (parsed as MemberAccessNode, not CallNode)
      if member_name == "call"
        proc_recv_id = lower_expr(ctx, node.object)
        proc_recv_type = ctx.type_of(proc_recv_id)
        if proc_recv_desc = @module.get_type_descriptor(proc_recv_type)
          if proc_recv_desc.kind == TypeKind::Proc
            proc_call_args = [] of ValueId
            # Append captured values as hidden extra args
            if capture_ids = @proc_captures_by_value[proc_recv_id]?
              proc_call_args.concat(capture_ids)
            end
            # Extract return type from Proc type_params (last element)
            proc_call_return = TypeRef::VOID
            if proc_recv_desc.type_params.size > 0
              proc_ret = proc_recv_desc.type_params.last
              proc_call_return = proc_ret if proc_ret != TypeRef::VOID
            end
            proc_call = Call.new(ctx.next_id, proc_call_return, proc_recv_id, "Proc#call", proc_call_args)
            ctx.emit(proc_call)
            ctx.register_type(proc_call.id, proc_call_return)
            return proc_call.id
          end
        end
      end

      # Intercept Array#sort/sort! on member access (no parens, no args)
      if member_name == "sort" || member_name == "sort!"
        receiver_id = lower_expr(ctx, node.object)
        is_array = array_intrinsic_receiver?(ctx, receiver_id)
        if !is_array
          is_array = check_and_fix_array_receiver_type(ctx, node, receiver_id)
        end
        if is_array
          if member_name == "sort"
            return lower_array_sort_dynamic(ctx, receiver_id)
          else
            return lower_array_sort_bang_dynamic(ctx, receiver_id)
          end
        end
      end

      if env_get("DEBUG_TO_U32") && ctx.function.name.includes?("key_hash")
        STDERR.puts "[KEY_HASH_MEMBER] member=#{member_name} func=#{ctx.function.name}"
      end
      if debug_env_filter_match?("DEBUG_ENUM_PREDICATE", member_name)
        STDERR.puts "[DEBUG_ENUM_CALL_PATH] lower_member_access method=#{member_name} object=#{obj_node.class.name}"
      end
      if debug_env_filter_match?("DEBUG_HIGH_CALL", member_name)
        var_name = if obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
                     String.new(obj_node.name)
                   else
                     "(non-ident)"
                   end
        STDERR.puts "[HIGH_CALL_MEMBER] obj_node=#{obj_node.class.name.split("::").last} var=#{var_name} current=#{@current_class || ""} method=#{@current_method || ""}"
      end

      # Check if this is a class/module static call like Counter.new (without parens)
      # Similar logic to lower_call for MemberAccessNode
      class_name_str : String? = nil

      if obj_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
        name = String.new(obj_node.name)
        resolved_name = resolve_class_name_in_context(name)
        resolved_name = resolve_type_alias_chain(resolved_name)
        if @module.is_lib?(resolved_name)
          class_name_str = resolved_name
        elsif class_like_namespace?(resolved_name) || primitive_self_type(resolved_name)
          class_name_str = resolved_name
        elsif is_module_method?(resolved_name, member_name)
          class_name_str = resolved_name
        end
      elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
        name = String.new(obj_node.name)
        if ctx.lookup_local(name).nil?
          if env_get("DEBUG_IVAR_ACCESS")
            STDERR.puts "[IVAR_ACCESS] local_missing name=#{name} member=#{member_name}"
          end
          # Resolve type alias if exists (check both @type_aliases and LIBC_TYPE_ALIASES)
          resolved_name = @type_aliases[name]? || LIBC_TYPE_ALIASES[name]? || name
          # Chain resolve if needed - max 10 iterations
          depth = 0
          while (next_resolved = @type_aliases[resolved_name]? || LIBC_TYPE_ALIASES[resolved_name]?) && next_resolved != resolved_name && depth < 10
            resolved_name = next_resolved
            depth += 1
          end
          if resolved_name[0].uppercase?
            resolved_name = resolve_class_name_in_context(resolved_name)
            if @module.is_lib?(resolved_name) ||
               class_like_namespace?(resolved_name) ||
               @enum_info.try(&.has_key?(resolved_name)) ||
               is_module_method?(resolved_name, member_name) ||
               primitive_self_type(resolved_name)
              class_name_str = resolved_name
            end
          end
        end
      elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::GenericNode)
        # Generic type like Hash(Int32, Int32).new
        base_name = resolve_path_like_name(obj_node.base_type)
        if base_name
          base_name = resolve_type_name_in_context(base_name)
          base_name = resolve_type_alias_chain(base_name)
          normalize_typeof_name = ->(type_name : String) : String {
            # Keep unions in generic args (e.g. `Slice(Int32 | Pointer(UInt8))`)
            # so we don't degrade specialization to `Pointer(Void)`.
            if type_name == "Void" || type_name == "Unknown"
              "Pointer(Void)"
            else
              type_name
            end
          }

          type_args = obj_node.type_args.map do |arg_id|
            arg_name = stringify_type_expr(arg_id) || "Unknown"
            arg_name = resolve_typeof_in_type_string(arg_name)
            arg_name = normalize_typeof_name.call(arg_name)
            arg_name = resolve_type_name_in_context(arg_name)
            substitute_type_params_in_type_name(arg_name)
          end
          # Create specialized class name like Hash(Int32, Int32)
          class_name_str = "#{base_name}(#{type_args.join(", ")})"
          class_name_str = substitute_type_params_in_type_name(class_name_str)
          # Monomorphize generic class if not already done
          if !@monomorphized.includes?(class_name_str)
            monomorphize_generic_class(base_name, type_args, class_name_str)
          end
        end
      elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::PathNode)
        # Path like Crystal::EventLoop for nested module/class method calls
        raw_path = collect_path_string(obj_node)
        absolute_path = path_is_absolute?(obj_node)
        full_path = if absolute_path
                      raw_path.starts_with?("::") ? raw_path[2..] : raw_path
                    else
                      resolve_path_string_in_context(raw_path)
                    end
        is_constant_path = resolve_constant_name_in_context(full_path) != nil
        left_name = nil
        if left_id = obj_node.left
          left_node = @arena[left_id]
          left_name = case left_node
                      when CrystalV2::Compiler::Frontend::IdentifierNode
                        String.new(left_node.name)
                      when CrystalV2::Compiler::Frontend::ConstantNode
                        String.new(left_node.name)
                      when CrystalV2::Compiler::Frontend::PathNode
                        left_path = collect_path_string(left_node)
                        left_absolute = path_is_absolute?(left_node)
                        if left_absolute
                          left_path.starts_with?("::") ? left_path[2..] : left_path
                        else
                          resolve_path_string_in_context(left_path)
                        end
                      else
                        nil
                      end
        end
        right_node = @arena[obj_node.right]
        right_name = case right_node
                     when CrystalV2::Compiler::Frontend::IdentifierNode
                       String.new(right_node.name)
                     when CrystalV2::Compiler::Frontend::ConstantNode
                       String.new(right_node.name)
                     else
                       nil
                     end

        resolved_path = resolve_type_alias_chain(full_path)
        if is_constant_path
          if @module.is_lib?(resolved_path) ||
             class_like_namespace?(resolved_path) ||
             @module_defs.has_key?(resolved_path) ||
             @enum_info.try(&.has_key?(resolved_path)) ||
             is_module_method?(resolved_path, member_name) ||
             primitive_self_type(resolved_path)
            class_name_str = resolved_path
          elsif fallback = class_method_fallback_from_module(resolved_path, member_name)
            class_name_str = fallback
          end
        else
          if left_name && right_name
            if enum_info = @enum_info
              if enum_info.has_key?(left_name) && right_name[0]?.try(&.uppercase?)
                class_name_str = nil
              else
                class_name_str = full_path
              end
            else
              class_name_str = full_path
            end
          else
            class_name_str = full_path
          end
        end
        if class_name_str && @module.is_lib?(class_name_str)
          class_name_str = full_path
        end
      end

      # If the object path is an enum literal (Enum::Member), don't treat it as a static call.
      if class_name_str && obj_node.is_a?(CrystalV2::Compiler::Frontend::PathNode)
        raw_path = collect_path_string(obj_node)
        if idx = raw_path.rindex("::")
          prefix = raw_path[0, idx]
          member = raw_path[(idx + 2)..]
          prefix = prefix.starts_with?("::") ? (prefix.size > 2 ? prefix[2..] : "") : prefix
          resolved_prefix = prefix.empty? ? prefix : resolve_path_string_in_context(prefix)
          if member && member[0]?.try(&.uppercase?) && @enum_info.try(&.has_key?(resolved_prefix))
            class_name_str = nil
          end
        end
      end

      # If it's a static class call (like Counter.new), emit as static call
      if env_get("DEBUG_FIBER_CURRENT") && member_name == "current"
        obj_kind = obj_node.class.name.split("::").last
        STDERR.puts "[DEBUG_FIBER_MEMBER] obj=#{obj_kind} class=#{class_name_str || "nil"} current=#{@current_class || "nil"}"
      end
      if class_name_str
        if env_get("DEBUG_IVAR_ACCESS")
          STDERR.puts "[IVAR_ACCESS] static_call member=#{member_name} class=#{class_name_str}"
        end
        return lower_static_member_access_call(ctx, class_name_str, member_name)
      end

      # Detect ptr.value.field pattern (READ): use pointer directly for FieldGet
      # instead of dereferencing first (which would load garbage for struct pointers)
      # GUARD: Only enter this optimization when inner_node.object is a local
      # variable that has already been lowered (has a known type). This avoids
      # speculatively lowering expressions with side effects (calls, etc.) which
      # would cause double evaluation if the optimization fails.
      inner_node = @arena[node.object]
      if inner_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
         String.new(inner_node.member) == "value"
        inner_obj_node = @arena[inner_node.object]
        # Only proceed if inner object is a local variable that's already assigned
        is_safe_to_lower = false
        if inner_obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          var_name = String.new(inner_obj_node.name)
          if local_id = ctx.lookup_local(var_name)
            local_type = ctx.type_of(local_id)
            if local_type == TypeRef::POINTER ||
               (@module.get_type_descriptor(local_type).try(&.kind) == TypeKind::Pointer)
              is_safe_to_lower = true
            end
          end
        end
        if is_safe_to_lower
          ptr_id = lower_expr(ctx, inner_node.object)
          ptr_type = ctx.type_of(ptr_id)
          ptr_desc = @module.get_type_descriptor(ptr_type)
          is_pointer = ptr_type == TypeRef::POINTER ||
                       (ptr_desc && ptr_desc.kind == TypeKind::Pointer)
          if is_pointer
            element_type_name = if ptr_desc && ptr_desc.name.starts_with?("Pointer(")
                                  ptr_desc.name[8...-1]
                                else
                                  nil
                                end
            if element_type_name
              element_type_ref = type_ref_for_name(element_type_name)
              element_desc = @module.get_type_descriptor(element_type_ref)
              element_class_name = element_desc ? element_desc.name : element_type_name
              if ci = @class_info[element_class_name]?
                ivar_name = "@#{member_name}"
                ivar_info = ci.ivars.find { |iv| iv.name == ivar_name }
                if !ivar_info && ci.is_struct && @lib_structs.includes?(element_class_name)
                  ivar_info = ci.ivars.find { |iv| iv.name == member_name || iv.name == "@#{member_name}" }
                end
                if ivar_info
                  field_get = FieldGet.new(ctx.next_id, ivar_info.type, ptr_id, ivar_info.name, ivar_info.offset)
                  ctx.emit(field_get)
                  ctx.register_type(field_get.id, ivar_info.type)
                  return field_get.id
                end
              end
            end
          end
        end
      end

      # Otherwise it's an instance method call - evaluate object first
      object_id = lower_expr(ctx, node.object)

      # Hash#keys / Hash#values intrinsic (intercept before generic dispatch)
      if (member_name == "keys" || member_name == "values") && hash_intrinsic_receiver?(ctx, object_id)
        return lower_hash_keys_or_values_intrinsic(ctx, object_id, member_name == "keys")
      end

      # Array#first / Array#last / Array#min / Array#max / Array#sum intrinsic (MemberAccessNode path)
      if (member_name == "first" || member_name == "last" || member_name == "min" ||
          member_name == "max" || member_name == "sum") && array_intrinsic_receiver?(ctx, object_id)
        case member_name
        when "first" then return lower_array_first_intrinsic(ctx, object_id)
        when "last"  then return lower_array_last_intrinsic(ctx, object_id)
        when "min"   then return lower_array_min_intrinsic(ctx, object_id)
        when "max"   then return lower_array_max_intrinsic(ctx, object_id)
        when "sum"
          ext_call = ExternCall.new(ctx.next_id, TypeRef::INT32, "__crystal_v2_array_sum_int32", [object_id])
          ctx.emit(ext_call)
          ctx.register_type(ext_call.id, TypeRef::INT32)
          return ext_call.id
        end
      end

      # Array#join intrinsic (MemberAccessNode path — no-parens call uses empty separator)
      if member_name == "join" && array_intrinsic_receiver?(ctx, object_id)
        empty_sep = Literal.new(ctx.next_id, TypeRef::STRING, "")
        ctx.emit(empty_sep)
        ctx.register_type(empty_sep.id, TypeRef::STRING)
        ext_call = ExternCall.new(ctx.next_id, TypeRef::STRING, "__crystal_v2_array_join_string", [object_id, empty_sep.id])
        ctx.emit(ext_call)
        ctx.register_type(ext_call.id, TypeRef::STRING)
        return ext_call.id
      end

      # Array#empty? intrinsic (MemberAccessNode path — no-parens call)
      if member_name == "empty?" && array_intrinsic_receiver?(ctx, object_id)
        zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
        ctx.emit(zero)
        size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, object_id)
        ctx.emit(size_val)
        cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, size_val.id, zero.id)
        ctx.emit(cmp)
        ctx.register_type(cmp.id, TypeRef::BOOL)
        return cmp.id
      end

      # Array#size intrinsic (MemberAccessNode path — no-parens call)
      if member_name == "size" && array_intrinsic_receiver?(ctx, object_id)
        size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, object_id)
        ctx.emit(size_val)
        ctx.register_type(size_val.id, TypeRef::INT32)
        return size_val.id
      end

      # If the receiver is an unresolved bare identifier (VOID local), but a
      # top-level function with that name exists, treat it as a zero-arg call.
      if obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
        obj_name = String.new(obj_node.name)
        if ctx.type_of(object_id) == TypeRef::VOID
          if ctx.value_for(object_id).is_a?(Local)
            assigned_locals = @assigned_vars_stack.last?
            is_type_param = type_param_like?(obj_name) || @type_param_map.has_key?(obj_name)
            func_exists = @function_defs.has_key?(obj_name) ||
                          @function_types.has_key?(obj_name) ||
                          has_function_base?(obj_name)
            if obj_name == "caller" && env_get("DEBUG_CALLER_FALLBACK")
              assigned = assigned_locals ? assigned_locals.includes?(obj_name) : false
              STDERR.puts "[CALLER_FALLBACK] access name=#{obj_name} func_exists=#{func_exists} assigned=#{assigned} func=#{ctx.function.name} member=#{member_name}"
            end
            if !is_type_param &&
               (assigned_locals.nil? || !assigned_locals.includes?(obj_name)) &&
               func_exists
              full_name = mangle_function_name(obj_name, [] of TypeRef)
              return_type = @function_types[full_name]? || @function_types[obj_name]? || TypeRef::VOID
              lower_function_if_needed(full_name)
              if return_type == TypeRef::VOID
                return_type = get_function_return_type(full_name)
                if return_type == TypeRef::VOID && full_name != obj_name
                  return_type = get_function_return_type(obj_name)
                end
              end
              call = Call.new(ctx.next_id, return_type, nil, full_name, [] of ValueId)
              ctx.emit(call)
              ctx.register_type(call.id, return_type)
              object_id = call.id
            elsif obj_name == "caller" && !func_exists
              if current = @current_class
                if base = resolve_method_with_inheritance(current, obj_name) ||
                          resolve_method_with_inheritance("Object", obj_name)
                  self_id = emit_self(ctx)
                  full_name = mangle_function_name(base, [] of TypeRef)
                  return_type = @function_types[full_name]? || TypeRef::VOID
                  lower_function_if_needed(full_name)
                  call = Call.new(ctx.next_id, return_type, self_id, full_name, [] of ValueId)
                  ctx.emit(call)
                  ctx.register_type(call.id, return_type)
                  object_id = call.id
                end
              end
            end
          end
        end
      end

      # Check for pointer.value -> PointerLoad
      receiver_type = ctx.type_of(object_id)
      # If the receiver is still VOID/Pointer but we have a typeof-local name,
      # refine it before ivar access (e.g., timeout : Time::Span?).
      if (receiver_type == TypeRef::POINTER || receiver_type == TypeRef::VOID) &&
         obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
        obj_name = String.new(obj_node.name)
        if type_name = lookup_typeof_local_name(obj_name)
          inferred = type_ref_for_name(type_name)
          if inferred != TypeRef::VOID && inferred != receiver_type
            receiver_type = inferred
            ctx.register_type(object_id, receiver_type)
          end
        end
      end
      if (member_name == "to_i" || member_name == "value")
        if @enum_value_types.try(&.[object_id]?)
          if ctx.value_for(object_id).is_a?(Literal)
            desired_type = member_name == "to_i" ? TypeRef::INT32 : receiver_type
            if desired_type != receiver_type
              cast = Cast.new(ctx.next_id, desired_type, object_id, desired_type, safe: false)
              ctx.emit(cast)
              ctx.register_type(cast.id, desired_type)
              return cast.id
            end
            return object_id
          end
        end
      end
      if member_name == "<=>"
        recv_name = get_type_name_from_ref(receiver_type)
        if recv_name == "Object" || recv_name == "Unknown"
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(nil_lit)
          ctx.register_type(nil_lit.id, TypeRef::NIL)
          return nil_lit.id
        end
      end
      if debug_env_filter_match?("DEBUG_HIGH_CALL", member_name)
        recv_name = get_type_name_from_ref(receiver_type)
        STDERR.puts "[HIGH_CALL_RECV] recv_type=#{recv_name} recv_id=#{receiver_type.id} current=#{@current_class || ""} method=#{@current_method || ""}"
      end
      ensure_monomorphized_type(receiver_type) unless receiver_type == TypeRef::VOID
      receiver_is_type_literal = ctx.type_literal?(object_id)
      if debug_env_filter_match?("DEBUG_UNSAFE_CHR", member_name)
        STDERR.puts "[UNSAFE_CHR] receiver=#{get_type_name_from_ref(receiver_type)}"
      end
      if receiver_is_type_literal
        class_name = nil
        if info = class_info_for_type(receiver_type)
          class_name = info.name
        elsif desc = @module.get_type_descriptor(receiver_type)
          class_name = desc.name unless desc.name.empty?
        end
        if class_name
          if member_name == "name"
            lit = Literal.new(ctx.next_id, TypeRef::STRING, class_name)
            ctx.emit(lit)
            ctx.register_type(lit.id, TypeRef::STRING)
            return lit.id
          end
          return lower_static_member_access_call(ctx, class_name, member_name)
        end
      end

      if member_name == "class"
        type_name = get_type_name_from_ref(receiver_type)
        unless type_name.empty?
          lit_id = lower_type_literal_from_name(ctx, type_name)
          ctx.mark_dot_class_literal(lit_id)
          return lit_id
        end
      end

      if member_name == "value"
        if @enum_value_types.try(&.[object_id]?)
          return object_id
        end
      end

      if member_name == "key" || member_name == "value"
        if desc = @module.get_type_descriptor(receiver_type)
          if desc.kind == TypeKind::Tuple || desc.name.starts_with?("Tuple(")
            index = member_name == "key" ? 0 : 1
            if elem = tuple_element_type(receiver_type, index)
              index_lit = Literal.new(ctx.next_id, TypeRef::INT32, index.to_i64)
              ctx.emit(index_lit)
              index_get = IndexGet.new(ctx.next_id, elem, object_id, index_lit.id)
              ctx.emit(index_get)
              ctx.register_type(index_get.id, elem)
              return index_get.id
            end
          end
        end
      end

      # Handle enum predicate methods (.data1?, .block?, etc.)
      # These should compile to `value == Enum::Member` comparisons, not function calls
      if member_name.ends_with?('?')
        if predicate_id = lower_enum_predicate(ctx, object_id, member_name)
          return predicate_id
        end
      end

      if env_get("DEBUG_IVAR_ACCESS")
        STDERR.puts "[IVAR_ACCESS] member_check=#{member_name.inspect} starts_with_at=#{member_name.starts_with?('@')}"
      end

      # Direct ivar access on another object (obj.@ivar) - use field get.
      if member_name.starts_with?('@')
        if env_get("DEBUG_IVAR_ACCESS")
          local_name = obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) ? String.new(obj_node.name) : ""
          local_id = local_name.empty? ? "n/a" : (ctx.lookup_local(local_name).try(&.to_s) || "nil")
          recv_name = get_type_name_from_ref(receiver_type)
          STDERR.puts "[IVAR_ACCESS] member=#{member_name} obj=#{obj_node.class.name} local=#{local_name} local_id=#{local_id} recv=#{recv_name}"
        end
        if info = class_info_for_type(receiver_type)
          if ivar_info = info.ivars.find { |iv| iv.name == member_name }
            field_get = FieldGet.new(ctx.next_id, ivar_info.type, object_id, member_name, ivar_info.offset)
            ctx.emit(field_get)
            ctx.register_type(field_get.id, ivar_info.type)
            return field_get.id
          end
        end
        if is_union_or_nilable_type?(receiver_type)
          type_name = if desc = @module.get_type_descriptor(receiver_type)
                        desc.name
                      else
                        get_type_name_from_ref(receiver_type)
                      end
          variants = split_union_type_name(type_name)
          variants.each_with_index do |variant_name, idx|
            next if variant_name == "Nil"
            variant_ref = type_ref_for_name(variant_name)
            next if variant_ref == TypeRef::VOID
            if info = class_info_for_type(variant_ref)
              if ivar_info = info.ivars.find { |iv| iv.name == member_name }
                unwrapped = UnionUnwrap.new(ctx.next_id, variant_ref, object_id, idx, false)
                ctx.emit(unwrapped)
                ctx.register_type(unwrapped.id, variant_ref)
                field_get = FieldGet.new(ctx.next_id, ivar_info.type, unwrapped.id, member_name, ivar_info.offset)
                ctx.emit(field_get)
                ctx.register_type(field_get.id, ivar_info.type)
                return field_get.id
              end
            end
          end
        end
        module_type_name = get_type_name_from_ref(receiver_type)
        if resolved = resolve_module_typed_ivar(module_type_name, member_name)
          _info, ivar_info = resolved
          field_get = FieldGet.new(ctx.next_id, ivar_info.type, object_id, member_name, ivar_info.offset)
          ctx.emit(field_get)
          ctx.register_type(field_get.id, ivar_info.type)
          return field_get.id
        end
      end

      # Lib struct field access (action.sa_mask) should lower to a direct field get.
      if info = class_info_for_type(receiver_type)
        if info.is_struct && @lib_structs.includes?(info.name)
          if ivar_info = info.ivars.find { |iv| iv.name == member_name || iv.name == "@#{member_name}" }
            field_get = FieldGet.new(ctx.next_id, ivar_info.type, object_id, member_name, ivar_info.offset)
            ctx.emit(field_get)
            ctx.register_type(field_get.id, ivar_info.type)
            return field_get.id
          end
        end
      end

      # Struct getter field access - getters like `entry.hash` should inline as FieldGet
      # when the struct has an @ivar matching the getter name
      recv_type_name = get_type_name_from_ref(receiver_type)
      if env_get("DEBUG_STRUCT_GETTER") && member_name == "hash"
        STDERR.puts "[STRUCT_GETTER_LOWERING] recv=#{recv_type_name} method=#{@current_method || "nil"} class=#{@current_class || "nil"}"
      end
      if info = class_info_for_type(receiver_type)
        if info.is_struct
          # Check for @member_name ivar
          if ivar_info = info.ivars.find { |iv| iv.name == "@#{member_name}" }
            # Verify this is actually a getter (the struct has a method with this name)
            method_base = "#{info.name}##{member_name}"
            if @function_types.has_key?(method_base) || has_function_base?(method_base)
              if env_get("DEBUG_STRUCT_GETTER")
                STDERR.puts "[STRUCT_GETTER] Inlining #{info.name}##{member_name} as FieldGet type=#{get_type_name_from_ref(ivar_info.type)}"
              end
              field_get = FieldGet.new(ctx.next_id, ivar_info.type, object_id, "@#{member_name}", ivar_info.offset)
              ctx.emit(field_get)
              ctx.register_type(field_get.id, ivar_info.type)
              return field_get.id
            end
          elsif env_get("DEBUG_STRUCT_GETTER") && member_name == "hash" && info.name.includes?("Entry")
            ivars_str = info.ivars.map { |iv| iv.name }.join(", ")
            STDERR.puts "[STRUCT_GETTER_MISS] #{info.name}##{member_name} ivars=[#{ivars_str}]"
          end
        end
      elsif member_name == "hash" && recv_type_name.starts_with?("Tuple(")
        # Special case: block parameter might be an Entry struct mistyped as Tuple
        # The Tuple(K, V) might actually be an Entry(K, V) struct from Hash iteration
        if tuple_args = split_generic_type_args(recv_type_name[6...-1])
          entry_params = tuple_args.join(", ")
          entry_name = "Hash::Entry(#{entry_params})"
          if entry_info = @class_info[entry_name]?
            if entry_info.is_struct
              if ivar_info = entry_info.ivars.find { |iv| iv.name == "@hash" }
                if env_get("DEBUG_STRUCT_GETTER")
                  STDERR.puts "[STRUCT_GETTER_ENTRY] tuple=#{recv_type_name} -> entry=#{entry_name} type=#{get_type_name_from_ref(ivar_info.type)}"
                end
                # For this to work, we need to treat the object as the Entry type
                # Since the object_id is already lowered with Tuple type, emit a FieldGet
                # with the hash field offset from the Entry struct
                field_get = FieldGet.new(ctx.next_id, ivar_info.type, object_id, "@hash", ivar_info.offset)
                ctx.emit(field_get)
                ctx.register_type(field_get.id, ivar_info.type)
                return field_get.id
              end
            end
          end
        end
        if env_get("DEBUG_STRUCT_GETTER")
          STDERR.puts "[STRUCT_GETTER_NO_INFO] #{recv_type_name}##{member_name} has no class_info"
        end
      elsif env_get("DEBUG_STRUCT_GETTER") && member_name == "hash"
        STDERR.puts "[STRUCT_GETTER_NO_INFO] #{recv_type_name}##{member_name} has no class_info"
      end

      # Handle nil? intrinsic (union and non-union).
      if member_name == "nil?"
        if is_union_or_nilable_type?(receiver_type)
          return lower_nil_check_intrinsic(ctx, object_id, receiver_type)
        end
        if receiver_type == TypeRef::NIL
          lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
          ctx.emit(lit)
          return lit.id
        elsif receiver_type == TypeRef::POINTER
          nil_val = Literal.new(ctx.next_id, TypeRef::POINTER, 0_i64)
          ctx.emit(nil_val)
          eq_check = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, object_id, nil_val.id)
          ctx.emit(eq_check)
          ctx.register_type(eq_check.id, TypeRef::BOOL)
          return eq_check.id
        else
          lit = Literal.new(ctx.next_id, TypeRef::BOOL, false)
          ctx.emit(lit)
          return lit.id
        end
      end

      # Handle not_nil! intrinsic for union types
      if member_name == "not_nil!" && is_union_or_nilable_type?(receiver_type)
        return lower_not_nil_intrinsic(ctx, object_id, receiver_type)
      end
      if member_name == "not_nil!" && receiver_type != TypeRef::VOID
        return object_id
      end
      if member_name == "not_nil!" && receiver_type == TypeRef::VOID
        ctx.register_type(object_id, TypeRef::POINTER)
        return object_id
      end

      if receiver_type == TypeRef::CHAR && member_name == "ord"
        cast = Cast.new(ctx.next_id, TypeRef::INT32, object_id, TypeRef::INT32)
        ctx.emit(cast)
        ctx.register_type(cast.id, TypeRef::INT32)
        return cast.id
      end

      # Int32#chr → Char (identity, since both are i32 internally)
      if member_name == "chr" && numeric_primitive?(receiver_type)
        cast = Cast.new(ctx.next_id, TypeRef::CHAR, object_id, TypeRef::CHAR)
        ctx.emit(cast)
        ctx.register_type(cast.id, TypeRef::CHAR)
        return cast.id
      end

      if member_name == "unsafe_chr"
        if is_union_or_nilable_type?(receiver_type)
          nil_variant_id = get_union_variant_id(receiver_type, TypeRef::NIL)
          if nil_variant_id >= 0
            unwrapped = lower_not_nil_intrinsic(ctx, object_id, receiver_type)
            unwrapped_type = ctx.type_of(unwrapped)
            if numeric_primitive?(unwrapped_type)
              cast = Cast.new(ctx.next_id, TypeRef::CHAR, unwrapped, TypeRef::CHAR)
              ctx.emit(cast)
              ctx.register_type(cast.id, TypeRef::CHAR)
              STDERR.puts "[UNSAFE_CHR] cast union->Char" if env_get("DEBUG_UNSAFE_CHR")
              return cast.id
            end
          elsif type_desc = @module.get_type_descriptor(receiver_type)
            variants = split_union_type_name(type_desc.name)
            idx = variants.index do |variant|
              next false if variant == "Nil"
              numeric_primitive?(type_ref_for_name(variant))
            end
            if idx
              unwrap_type = type_ref_for_name(variants[idx])
              unwrapped = UnionUnwrap.new(ctx.next_id, unwrap_type, object_id, idx, false)
              ctx.emit(unwrapped)
              ctx.register_type(unwrapped.id, unwrap_type)
              if numeric_primitive?(unwrap_type)
                cast = Cast.new(ctx.next_id, TypeRef::CHAR, unwrapped.id, TypeRef::CHAR)
                ctx.emit(cast)
                ctx.register_type(cast.id, TypeRef::CHAR)
                STDERR.puts "[UNSAFE_CHR] cast unwrap->Char" if env_get("DEBUG_UNSAFE_CHR")
                return cast.id
              end
            end
          end
        end
        case receiver_type
        when TypeRef::CHAR
          return object_id
        when TypeRef::INT8, TypeRef::INT16, TypeRef::INT32, TypeRef::INT64, TypeRef::INT128,
             TypeRef::UINT8, TypeRef::UINT16, TypeRef::UINT32, TypeRef::UINT64, TypeRef::UINT128
          cast = Cast.new(ctx.next_id, TypeRef::CHAR, object_id, TypeRef::CHAR)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::CHAR)
          STDERR.puts "[UNSAFE_CHR] cast primitive->Char" if env_get("DEBUG_UNSAFE_CHR")
          return cast.id
        end
      end

      # Primitive numeric conversions and predicates for member access (no-arg calls).
      target_type = case member_name
                    when "to_i", "to_i32", "to_i32!"
                      TypeRef::INT32
                    when "to_i8", "to_i8!"
                      TypeRef::INT8
                    when "to_i16", "to_i16!"
                      TypeRef::INT16
                    when "to_i64", "to_i64!"
                      TypeRef::INT64
                    when "to_i128", "to_i128!"
                      TypeRef::INT128
                    when "to_u", "to_u32", "to_u32!"
                      TypeRef::UINT32
                    when "to_u8", "to_u8!"
                      TypeRef::UINT8
                    when "to_u16", "to_u16!"
                      TypeRef::UINT16
                    when "to_u64", "to_u64!"
                      TypeRef::UINT64
                    when "to_u128", "to_u128!"
                      TypeRef::UINT128
                    when "to_f", "to_f64", "to_f64!"
                      TypeRef::FLOAT64
                    when "to_f32", "to_f32!"
                      TypeRef::FLOAT32
                    else
                      nil
                    end
      if target_type
        if env_get("DEBUG_TO_U32")
          recv_name = get_type_name_from_ref(receiver_type)
          is_prim = numeric_primitive?(receiver_type)
          STDERR.puts "[TO_U32_MEMBER] member=#{member_name} recv_type=#{receiver_type.id} recv_name=#{recv_name} is_prim=#{is_prim} func=#{ctx.function.name}"
        end
        if receiver_type == TypeRef::VOID
          receiver_type = TypeRef::INT32
          ctx.register_type(object_id, receiver_type)
        end
        variants = nil.as(Array(String)?)
        if type_desc = @module.get_type_descriptor(receiver_type)
          variants = split_union_type_name(type_desc.name)
        else
          type_name = get_type_name_from_ref(receiver_type)
          variants = split_union_type_name(type_name) if union_type_name?(type_name)
        end
        if variants
          idx = variants.index do |variant|
            next false if variant == "Nil"
            numeric_primitive?(type_ref_for_name(variant))
          end
          if idx
            unwrap_type = type_ref_for_name(variants[idx])
            unwrapped = UnionUnwrap.new(ctx.next_id, unwrap_type, object_id, idx, false)
            ctx.emit(unwrapped)
            ctx.register_type(unwrapped.id, unwrap_type)
            if numeric_primitive?(unwrap_type)
              return unwrapped.id if unwrap_type == target_type
              cast = Cast.new(ctx.next_id, target_type, unwrapped.id, target_type)
              ctx.emit(cast)
              ctx.register_type(cast.id, target_type)
              return cast.id
            end
          end
        end
        if numeric_primitive?(receiver_type)
          if env_get("DEBUG_TO_U32") && ctx.function.name.includes?("key_hash")
            recv_name = get_type_name_from_ref(receiver_type)
            target_name = get_type_name_from_ref(target_type)
            STDERR.puts "[KEY_HASH_CAST] receiver=#{recv_name}(#{receiver_type.id}) target=#{target_name}(#{target_type.id}) same=#{receiver_type == target_type} func=#{ctx.function.name}"
          end
          return object_id if receiver_type == target_type
          cast = Cast.new(ctx.next_id, target_type, object_id, target_type)
          ctx.emit(cast)
          ctx.register_type(cast.id, target_type)
          return cast.id
        end
      end
      if numeric_primitive?(receiver_type)
        if member_name == "zero?"
          zero = Literal.new(ctx.next_id, receiver_type, 0_i64)
          ctx.emit(zero)
          ctx.register_type(zero.id, receiver_type)
          cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, object_id, zero.id)
          ctx.emit(cmp)
          ctx.register_type(cmp.id, TypeRef::BOOL)
          return cmp.id
        end
        if receiver_type == TypeRef::UINT8 && member_name == "ascii?"
          limit = Literal.new(ctx.next_id, TypeRef::UINT8, 128_i64)
          ctx.emit(limit)
          ctx.register_type(limit.id, TypeRef::UINT8)
          cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, object_id, limit.id)
          ctx.emit(cmp)
          ctx.register_type(cmp.id, TypeRef::BOOL)
          return cmp.id
        end
        if receiver_type == TypeRef::UINT8 && member_name == "ord"
          cast = Cast.new(ctx.next_id, TypeRef::INT32, object_id, TypeRef::INT32)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT32)
          return cast.id
        end
      end

      # Pointer address conversions for member access (no-arg calls).
      recv_type_desc = @module.get_type_descriptor(receiver_type)
      if recv_type_desc && recv_type_desc.kind == TypeKind::Union
        if member_name.in?("address", "to_u64", "to_i", "to_i64", "to_i32", "to_u32", "to_f64", "value")
          if unwrapped = unwrap_pointer_union(ctx, object_id, receiver_type)
            object_id, receiver_type = unwrapped
            recv_type_desc = @module.get_type_descriptor(receiver_type)
          end
        end
      end
      is_pointer_type = receiver_type == TypeRef::POINTER ||
                        (recv_type_desc && recv_type_desc.name.starts_with?("Pointer"))
      if is_pointer_type
        case member_name
        when "address", "to_u64"
          cast = Cast.new(ctx.next_id, TypeRef::UINT64, object_id, TypeRef::UINT64)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::UINT64)
          return cast.id
        when "to_i", "to_i64"
          cast = Cast.new(ctx.next_id, TypeRef::INT64, object_id, TypeRef::INT64)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT64)
          return cast.id
        when "to_i32"
          cast = Cast.new(ctx.next_id, TypeRef::INT32, object_id, TypeRef::INT32)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT32)
          return cast.id
        when "to_u32"
          cast = Cast.new(ctx.next_id, TypeRef::UINT32, object_id, TypeRef::UINT32)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::UINT32)
          return cast.id
        when "to_f64"
          int_cast = Cast.new(ctx.next_id, TypeRef::UINT64, object_id, TypeRef::UINT64)
          ctx.emit(int_cast)
          ctx.register_type(int_cast.id, TypeRef::UINT64)
          float_cast = Cast.new(ctx.next_id, TypeRef::FLOAT64, int_cast.id, TypeRef::FLOAT64)
          ctx.emit(float_cast)
          ctx.register_type(float_cast.id, TypeRef::FLOAT64)
          return float_cast.id
        end
      end

      # Handle pointer.value -> PointerLoad for typed pointers (Pointer(T))
      type_desc = @module.get_type_descriptor(receiver_type)
      is_pointer_type = receiver_type == TypeRef::POINTER ||
                        (type_desc && type_desc.name.starts_with?("Pointer")) ||
                        (type_desc && type_desc.kind == TypeKind::Pointer)
      if env_get("DEBUG_POINTER_VALUE") && member_name == "value"
        type_name = type_desc ? type_desc.name : "nil"
        STDERR.puts "[PTR_VALUE] receiver_type=#{receiver_type} type_desc=#{type_name} is_pointer=#{is_pointer_type}"
      end
      if is_pointer_type && member_name == "value"
        # Return the dereferenced type from Pointer(T) -> T
        deref_type = if type_desc && type_desc.name.starts_with?("Pointer(") && type_desc.name.ends_with?(')')
                       element_type_name = type_desc.name[8...-1]
                       type_ref_for_name(element_type_name)
                     else
                       TypeRef::UINT8 # Fallback for untyped pointers
                     end
        load_node = PointerLoad.new(ctx.next_id, deref_type, object_id, nil)
        ctx.emit(load_node)
        ctx.register_type(load_node.id, deref_type)
        return load_node.id
      end

      # Check for enum.value -> return the enum value as-is (enums are stored as Int32)
      if receiver_type == TypeRef::INT32 && member_name == "value"
        return object_id
      end
      if enum_value_id = lower_enum_value_call(ctx, object_id, member_name)
        return enum_value_id
      end

      # Special handling for union types containing primitives (like Int32 | Nil)
      # When calling primitive methods on a union, we need to unwrap the value first
      if is_nilable_int32_union?(receiver_type)
        case member_name
        when "to_s"
          # Unwrap Int32 from the union (assuming it's not nil - caller should have checked)
          unwrap = UnionUnwrap.new(ctx.next_id, TypeRef::INT32, object_id, 0, false) # variant 0 = Int32
          ctx.emit(unwrap)
          ctx.register_type(unwrap.id, TypeRef::INT32)
          # Call __crystal_v2_int_to_string on the unwrapped value
          call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_int_to_string", [unwrap.id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::POINTER)
          return call.id
        when "abs"
          # Unwrap Int32 and call abs intrinsic
          unwrap = UnionUnwrap.new(ctx.next_id, TypeRef::INT32, object_id, 0, false)
          ctx.emit(unwrap)
          ctx.register_type(unwrap.id, TypeRef::INT32)
          call = Call.new(ctx.next_id, TypeRef::INT32, nil, "__crystal_v2_int_abs", [unwrap.id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::INT32)
          return call.id
        end
      end

      # Special handling for primitive type methods (Int32, Bool, etc.)
      # These are NOT classes so class_info lookup will fail
      # We use Call with nil receiver and __crystal_v2_* method name, which hir_to_mir
      # automatically converts to ExternCall
      if receiver_type == TypeRef::INT32
        case member_name
        when "to_s"
          call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_int_to_string", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::POINTER)
          return call.id
        when "abs"
          call = Call.new(ctx.next_id, TypeRef::INT32, nil, "__crystal_v2_int_abs", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::INT32)
          return call.id
        when "to_i", "to_i32", "to_i32!"
          return object_id
        when "to_u32", "to_u32!"
          cast = Cast.new(ctx.next_id, TypeRef::UINT32, object_id, TypeRef::UINT32, safe: false)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::UINT32)
          return cast.id
        when "to_i64", "to_i64!"
          cast = Cast.new(ctx.next_id, TypeRef::INT64, object_id, TypeRef::INT64, safe: false)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT64)
          return cast.id
        when "to_u64", "to_u64!"
          cast = Cast.new(ctx.next_id, TypeRef::UINT64, object_id, TypeRef::UINT64, safe: false)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::UINT64)
          return cast.id
        when "to_f", "to_f64"
          call = Call.new(ctx.next_id, TypeRef::FLOAT64, nil, "__crystal_v2_int_to_f64", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::FLOAT64)
          return call.id
        when "times"
          # Int32#times with block - handled in lower_call for blocks
        end
      elsif receiver_type == TypeRef::INT64
        case member_name
        when "to_s"
          call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_int64_to_string", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::POINTER)
          return call.id
        when "to_i", "to_i32", "to_i32!"
          # Truncate to i32
          cast = Cast.new(ctx.next_id, TypeRef::INT32, object_id, TypeRef::INT32, safe: false)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT32)
          return cast.id
        when "to_u32", "to_u32!", "to_u"
          # Truncate to u32 (unchecked)
          cast = Cast.new(ctx.next_id, TypeRef::UINT32, object_id, TypeRef::UINT32, safe: false)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::UINT32)
          return cast.id
        when "to_u64", "to_u64!"
          # Reinterpret as u64 (same bit pattern)
          cast = Cast.new(ctx.next_id, TypeRef::UINT64, object_id, TypeRef::UINT64, safe: false)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::UINT64)
          return cast.id
        when "to_i64"
          return object_id
        when "to_f", "to_f64", "to_f64!"
          cast = Cast.new(ctx.next_id, TypeRef::FLOAT64, object_id, TypeRef::FLOAT64, safe: false)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::FLOAT64)
          return cast.id
        end
      elsif receiver_type == TypeRef::FLOAT64
        case member_name
        when "to_s"
          call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_f64_to_string", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::POINTER)
          return call.id
        when "to_i", "to_i32"
          call = Call.new(ctx.next_id, TypeRef::INT32, nil, "__crystal_v2_f64_to_i32", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::INT32)
          return call.id
        when "to_i64"
          call = Call.new(ctx.next_id, TypeRef::INT64, nil, "__crystal_v2_f64_to_i64", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::INT64)
          return call.id
        end
      elsif receiver_type == TypeRef::CHAR
        case member_name
        when "to_s"
          call = Call.new(ctx.next_id, TypeRef::STRING, nil, "__crystal_v2_char_to_string", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::STRING)
          return call.id
        when "ord"
          # Char#ord returns Int32 (the codepoint)
          cast = Cast.new(ctx.next_id, TypeRef::INT32, object_id, TypeRef::INT32, safe: false)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT32)
          return cast.id
        end
      elsif receiver_type == TypeRef::BOOL
        case member_name
        when "to_s"
          call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_bool_to_string", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::POINTER)
          return call.id
        end
      end

      # String#to_i / to_i64 intercept: convert string to integer via runtime helper
      # Must be here (not in lower_call) because "str".to_i creates MemberAccessNode
      if receiver_type == TypeRef::STRING
        if member_name == "to_i" || member_name == "to_i32"
          ext = ExternCall.new(ctx.next_id, TypeRef::INT32, "__crystal_v2_string_to_i", [object_id])
          ctx.emit(ext)
          ctx.register_type(ext.id, TypeRef::INT32)
          return ext.id
        elsif member_name == "to_i64"
          ext = ExternCall.new(ctx.next_id, TypeRef::INT64, "__crystal_v2_string_to_i64", [object_id])
          ctx.emit(ext)
          ctx.register_type(ext.id, TypeRef::INT64)
          return ext.id
        end
      end

      # Determine receiver type to find the correct method
      resolved_method_name : String? = nil
      return_type = TypeRef::VOID
      if env_get("DEBUG_ENTRY_HASH") && member_name == "hash"
        recv_name = get_type_name_from_ref(receiver_type)
        info_name = @class_info_by_type_id[receiver_type.id]?.try(&.name) || "nil"
        STDERR.puts "[ENTRY_HASH_MEMBER] recv_type_id=#{receiver_type.id} recv_name=#{recv_name} info_name=#{info_name}"
      end

      # Some module-like types can end up with a non-Module descriptor kind (e.g. upgraded),
      # but should still be treated as module receivers for dispatch.
      receiver_is_module_type = module_type_ref?(receiver_type)

      # Try to find method by receiver type with inheritance support.
      # For module-typed value receivers (e.g. `x : M; x.foo`), do NOT resolve to `M#foo`
      # directly here. We need module-typed dispatch (`resolve_method_call`) which can
      # pick a unique includer (e.g. `Box#foo`) or prefer `M.foo` when `extend self` applies.
      if receiver_type.id > 0 && !receiver_is_module_type
        if info = @class_info_by_type_id[receiver_type.id]?
          # Use inheritance-aware method resolution
          if base_method = resolve_method_with_inheritance(info.name, member_name)
            if resolved = resolve_untyped_overload(base_method, 0, false)
              resolved_method_name = resolved
              return_type = get_function_return_type(resolved)
            elsif resolved = resolve_ancestor_overload(info.name, member_name, 0, false)
              resolved_method_name = resolved
              return_type = get_function_return_type(resolved)
            else
              resolved_method_name = base_method
              return_type = get_function_return_type(base_method)
            end
            if env_get("DEBUG_ENTRY_HASH") && member_name == "hash" && info.name.includes?("Entry")
              ret_name = get_type_name_from_ref(return_type)
              STDERR.puts "[ENTRY_HASH_RESOLVED] base_method=#{base_method} resolved=#{resolved_method_name} return_type=#{ret_name}"
            end
          end
        end
      end

      # Fallback 1: Try to match by type descriptor name (when type_ref IDs don't match)
      if resolved_method_name.nil? && receiver_type.id > 0 && !receiver_is_module_type
        if type_desc = @module.get_type_descriptor(receiver_type)
          type_name = type_desc.name
          # Try full name first
          if @class_info.has_key?(type_name)
            if base_method = resolve_method_with_inheritance(type_name, member_name)
              if resolved = resolve_untyped_overload(base_method, 0, false)
                resolved_method_name = resolved
                return_type = get_function_return_type(resolved)
              elsif resolved = resolve_ancestor_overload(type_name, member_name, 0, false)
                resolved_method_name = resolved
                return_type = get_function_return_type(resolved)
              else
                resolved_method_name = base_method
                return_type = get_function_return_type(base_method)
              end
            end
          else
            # Try to find a class that ends with the type name (handle namespacing)
            # e.g., type_name="Span" matches "CrystalV2::Compiler::Frontend::Span"
            if candidates = @short_type_index[type_name]?
              if candidate = candidates.first?
                if base_method = resolve_method_with_inheritance(candidate, member_name)
                  if resolved = resolve_untyped_overload(base_method, 0, false)
                    resolved_method_name = resolved
                    return_type = get_function_return_type(resolved)
                  elsif resolved = resolve_ancestor_overload(candidate, member_name, 0, false)
                    resolved_method_name = resolved
                    return_type = get_function_return_type(resolved)
                  else
                    resolved_method_name = base_method
                    return_type = get_function_return_type(base_method)
                  end
                end
              end
            end
          end
        end
      end

      # Fallback 2: search all classes for this method (only when receiver type is unknown)
      if resolved_method_name.nil? && receiver_type.id == 0
        if candidates = @method_bases_by_name[member_name]?
          if test_name = candidates.first?
            resolved_method_name = test_name
            return_type = get_function_return_type(test_name)
          end
        end
      end

      base_method_name = resolved_method_name
      if base_method_name.nil?
        base_method_name = resolve_method_call(ctx, object_id, member_name, [] of TypeRef, false)
        if dollar = base_method_name.index('$')
          base_method_name = base_method_name[0, dollar]
        end
      end

      args = apply_default_args(ctx, [] of ValueId, member_name, base_method_name, false, false)
      arg_types = args.map { |arg_id| ctx.type_of(arg_id) }

      actual_name = if resolved_method_name
                      mangled_name = mangle_function_name(resolved_method_name, arg_types)
                      if @function_types.has_key?(mangled_name) || @module.has_function?(mangled_name)
                        mangled_name
                      elsif has_function_base?(resolved_method_name)
                        resolved_method_name
                      else
                        mangled_name
                      end
                    else
                      resolve_method_call(ctx, object_id, member_name, arg_types, false)
                    end
      if entry = lookup_function_def_for_call(base_method_name, args.size, false, arg_types)
        actual_name = entry[0]
      end
      if type_desc = @module.get_type_descriptor(receiver_type)
        if type_desc.kind == TypeKind::Union
          union_name = normalize_union_type_name(type_desc.name)
          if resolved = resolve_union_method_call(union_name, member_name, arg_types, false)
            actual_name = resolved
          end
        end
      end

      # Special handling for Tuple#size - return compile-time constant based on type parameters
      if member_name == "size"
        if type_desc = @module.get_type_descriptor(receiver_type)
          tuple_size = tuple_size_from_type_name(type_desc.name)
          if tuple_size.nil?
            base_name = type_desc.name.split("(").first
            tuple_size = type_desc.type_params.size if base_name == "Tuple" && !type_desc.type_params.empty?
          end
          if tuple_size
            lit = Literal.new(ctx.next_id, TypeRef::INT32, tuple_size.to_i64)
            ctx.emit(lit)
            ctx.register_type(lit.id, TypeRef::INT32)
            return lit.id
          end
        end
      end

      return_type = get_function_return_type(actual_name)
      forced_return_type = false
      if return_type == TypeRef::VOID && actual_name != base_method_name
        base_return = get_function_return_type(base_method_name)
        if base_return != TypeRef::VOID
          return_type = base_return
          actual_name = base_method_name
        end
      end
      if debug_env_filter_match?("DEBUG_MEMBER_RETURN", member_name, actual_name, base_method_name)
        STDERR.puts "[MEMBER_RETURN] member=#{member_name} actual=#{actual_name} base=#{base_method_name} return=#{get_type_name_from_ref(return_type)}"
      end
      if return_type == TypeRef::VOID || return_type == TypeRef::NIL
        if inferred = resolve_return_type_from_def(actual_name, base_method_name, receiver_type)
          return_type = inferred unless inferred == TypeRef::VOID || inferred == TypeRef::NIL
        end
      end
      if debug_env_filter_match?("DEBUG_MEMBER_RETURN", member_name, actual_name, base_method_name)
        STDERR.puts "[MEMBER_RETURN] after member=#{member_name} actual=#{actual_name} base=#{base_method_name} return=#{get_type_name_from_ref(return_type)}"
      end
      if debug_hook_filter_match?(member_name, actual_name)
        recv_name = receiver_type == TypeRef::VOID ? "Void" : get_type_name_from_ref(receiver_type)
        ret_name = return_type == TypeRef::VOID ? "Void" : get_type_name_from_ref(return_type)
        debug_hook("member.access", "member=#{member_name} recv=#{recv_name} actual=#{actual_name} return=#{ret_name}")
      end
      if tuple_return = tuple_return_type_for_method(receiver_type, member_name)
        return_type = tuple_return
      end
      if member_name == "first" || member_name == "last" || member_name == "first?" || member_name == "last?"
        recv_type = ctx.type_of(object_id)
        if type_desc = @module.get_type_descriptor(recv_type)
          if elem_name = element_type_for_type_name(type_desc.name)
            elem_type = type_ref_for_name(elem_name)
            if elem_type != TypeRef::VOID
              return_type = member_name.ends_with?('?') ? create_union_type_for_nullable(elem_type) : elem_type
              forced_return_type = true
              if env_get("DEBUG_MEMBER_FIRST_LAST")
                recv_name = get_type_name_from_ref(recv_type)
                ret_name = get_type_name_from_ref(return_type)
                STDERR.puts "[MEMBER_FIRST_LAST] member=#{member_name} recv=#{recv_name} elem=#{elem_name} ret=#{ret_name}"
              end
            end
          end
        end
      end
      if member_name.ends_with?('?') &&
         (return_type == TypeRef::BOOL || return_type == TypeRef::VOID || return_type == TypeRef::NIL)
        if inferred = infer_unannotated_query_return_type(member_name, ctx.type_of(object_id))
          return_type = inferred
        end
      end

      # Fallback for stdlib methods that should return a value (like to_a, map, etc.)
      # Same logic as in lower_call for consistency
      if return_type == TypeRef::VOID
        if member_name == "find" || member_name == "find!"
          if type_desc = @module.get_type_descriptor(ctx.type_of(object_id))
            if elem_name = element_type_for_type_name(type_desc.name)
              elem_type = type_ref_for_name(elem_name)
              return_type = member_name == "find!" ? elem_type : create_union_type_for_nullable(elem_type)
            end
          end
        elsif member_name == "find_index"
          return_type = create_union_type_for_nullable(TypeRef::INT32)
        end
        if return_type == TypeRef::VOID
          if inferred = infer_unannotated_search_return_type(member_name, ctx.type_of(object_id))
            return_type = inferred
          end
        end

        # Methods returning Bool (predicate methods)
        methods_returning_bool = ["empty?", "any?", "all?", "none?", "includes?",
                                  "starts_with?", "ends_with?", "blank?", "present?",
                                  "valid?", "nil?", "is_a?", "responds_to?"]
        # Methods returning Int32
        methods_returning_int32 = ["size", "length", "count", "bytesize", "hash",
                                   "index", "rindex", "ord"]
        if methods_returning_bool.includes?(member_name)
          return_type = TypeRef::BOOL
        elsif methods_returning_int32.includes?(member_name)
          return_type = TypeRef::INT32
        else
          methods_returning_self_or_value = ["to_a", "to_s", "map", "select", "reduce", "each",
                                             "first", "last", "dup", "clone", "cover",
                                             "compact", "flatten", "sort", "reverse", "uniq",
                                             "join", "split", "strip", "chomp", "chars",
                                             "keys", "values", "value", # 'value' is common getter
                                             "lines", "bytes", "codepoints", "graphemes",
                                             "rstrip", "lstrip", "downcase", "upcase", "capitalize",
                                             "gsub", "sub", "tr", "delete", "squeeze",
                                             "rjust", "ljust", "center", "each_line",
                                             "each_with_index", "map_with_index", "select_with_index",
                                             "find", "find_index",
                                             "sum", "product", "min", "max", "minmax", "sample",
                                             "take", "drop", "take_while", "drop_while",
                                             "group_by", "partition", "zip", "transpose",
                                             "shuffle", "rotate", "pop", "shift", "slice",
                                             "to_slice", "to_unsafe", "to_h", "to_set", "copy_from"]
          if methods_returning_self_or_value.includes?(member_name)
            return_type = TypeRef::POINTER
          end
        end
      end

      # Methods that return the same type as the receiver.
      # Handle this even if return_type is NIL (often incorrectly registered for abstract modules).
      methods_returning_receiver_type = ["tap", "itself", "clamp", "abs", "ceil", "floor", "round", "truncate",
                                         "remainder", "tdiv", "unsafe_mod", "unsafe_div", "gcd", "lcm"]
      if methods_returning_receiver_type.includes?(member_name)
        recv_type = ctx.type_of(object_id)
        # Only override if receiver is not Nil (these methods don't make sense on Nil)
        if recv_type != TypeRef::NIL && recv_type != TypeRef::VOID
          if env_has?("DEBUG_RECV_TYPE") && (member_name == "abs" || member_name == "remainder")
            STDERR.puts "[RECV_TYPE] member=#{member_name} recv_type=#{recv_type.id} old_return=#{return_type.id} current_class=#{@current_class || ""} current_method=#{@current_method || ""}"
          end
          return_type = recv_type
        elsif env_has?("DEBUG_RECV_TYPE") && (member_name == "abs" || member_name == "remainder")
          STDERR.puts "[RECV_TYPE_SKIP] member=#{member_name} recv_type=#{recv_type.id} return=#{return_type.id} current_class=#{@current_class || ""} current_method=#{@current_method || ""}"
        end
        if env_get("DEBUG_ITSELF") && member_name == "itself"
          recv_name = recv_type == TypeRef::VOID ? "Void" : get_type_name_from_ref(recv_type)
          ret_name = return_type == TypeRef::VOID ? "Void" : get_type_name_from_ref(return_type)
          STDERR.puts "[ITSELF] recv=#{recv_name} return=#{ret_name}"
        end
      end

      call_virtual = false
      if type_desc = @module.get_type_descriptor(ctx.type_of(object_id))
        call_virtual = type_desc.kind.in?(TypeKind::Union, TypeKind::Module)
        if !call_virtual && type_desc.kind == TypeKind::Generic
          call_virtual = module_like_type_name?(type_desc.name) || module_includers_match?(type_desc.name)
        end
        if !call_virtual && (module_like_type_name?(type_desc.name) || module_includers_match?(type_desc.name))
          call_virtual = true
        end
        if !call_virtual && type_desc.kind == TypeKind::Class
          abstract_base = base_method_name ? abstract_def?(base_method_name) : false
          call_virtual = class_has_subclasses?(type_desc.name) || abstract_base
        end
      end
      if !call_virtual && base_method_name
        if owner = method_owner(base_method_name)
          if @module_defs.has_key?(owner) || module_like_type_name?(owner) || module_includers_match?(owner)
            call_virtual = true
          end
        end
      end
      if !call_virtual && object_id
        if abstract_def?(actual_name) ||
           (base_method_name && abstract_def?(base_method_name))
          call_virtual = true
        end
      end
      if !call_virtual && object_id
        if self_id = ctx.lookup_local("self") || emit_self(ctx)
          if object_id == self_id
            if current = @current_class
              module_key = strip_generic_args(current)
              if @module_defs.has_key?(module_key)
                call_virtual = true
              end
            else
              fn_parts = parse_method_name(ctx.function.name)
              if fn_parts.is_instance
                owner = strip_generic_args(fn_parts.owner)
                if @module_defs.has_key?(owner)
                  call_virtual = true
                end
              end
            end
          end
        end
      end
      if env_has?("DEBUG_VIRTUAL_CALLS") && object_id
        recv_type = ctx.type_of(object_id)
        recv_desc = @module.get_type_descriptor(recv_type)
        recv_name = recv_desc ? "#{recv_desc.name}(#{recv_desc.kind})" : recv_type.id.to_s
        STDERR.puts "[HIR_VIRTUAL_CALL] method=#{member_name} recv=#{recv_name} virtual=#{call_virtual}"
      end

      if return_type == TypeRef::VOID && object_id
        abstract_target = abstract_def?(actual_name) ||
                          (base_method_name && abstract_def?(base_method_name))
        if abstract_target || call_virtual
          owner = ""
          if base_method_name
            owner = method_owner(base_method_name)
          end
          if owner.empty?
            owner = method_owner(actual_name)
          end
          if !owner.empty? && (module_like_type_name?(owner) || @module_includers.has_key?(strip_generic_args(owner)))
            if inferred = infer_return_type_from_includers(owner, member_name, arg_types, false)
              return_type = inferred
            end
          end
        end
      end

      # Ensure virtual dispatch targets are lowered so MIR can build vdispatch tables.
      if call_virtual
        if type_desc = @module.get_type_descriptor(ctx.type_of(object_id))
          if type_desc.kind == TypeKind::Class
            ah = arg_types_hash(arg_types)
            vf = vdispatch_flags(false)
            key = {type_desc.name, member_name, ah, vf}
            unless @virtual_targets_lowered.includes?(key)
              @virtual_targets_lowered.add(key)
              owners = [type_desc.name] + collect_subclasses_cached(type_desc.name)
              ensure_method_index_built
              owners.each do |owner|
                base_owner = strip_generic_args(owner)
                unless @method_index[base_owner]?.try(&.has_key?(member_name))
                  next unless @class_info.has_key?(owner)
                end
                base_name = "#{owner}##{member_name}"
                candidate = mangle_function_name(base_name, arg_types, false)
                lower_function_if_needed(candidate)
                lower_function_if_needed(base_name) unless candidate == base_name
              end
            end
          elsif type_desc.kind == TypeKind::Union
            union_name = normalize_union_type_name(type_desc.name)
            ah = arg_types_hash(arg_types)
            vf = vdispatch_flags(false, is_union: true)
            key = {union_name, member_name, ah, vf}
            unless @virtual_targets_lowered.includes?(key)
              @virtual_targets_lowered.add(key)
              split_union_type_name(union_name).each do |variant|
                next if variant == "Nil"
                resolved_variant = resolve_type_alias_chain(variant)
                expanded = [] of String
                [resolved_variant, variant].uniq.each do |owner|
                  if owner.includes?('|')
                    split_union_type_name(owner).each { |entry| expanded << entry }
                  else
                    expanded << owner
                  end
                end
                if env_get("DEBUG_VDISPATCH_UNION") && member_name == "next_power_of_two"
                  STDERR.puts "[VDISPATCH_UNION_HIR] variant=#{variant} resolved=#{resolved_variant} expanded=#{expanded.join(",")}"
                end
                expanded.uniq.each do |owner|
                  base_name = "#{owner}##{member_name}"
                  candidate = mangle_function_name(base_name, arg_types, false)
                  lower_function_if_needed(candidate)
                  lower_function_if_needed(base_name) unless candidate == base_name
                end
              end
            end
          elsif type_desc.kind == TypeKind::Module || (type_desc.kind == TypeKind::Generic &&
                (module_like_type_name?(type_desc.name) || module_includers_match?(type_desc.name)))
            module_name = type_desc.name
            if type_desc.kind == TypeKind::Generic
              module_name = strip_generic_args(module_name)
            end
            ah = arg_types_hash(arg_types)
            vf = vdispatch_flags(false, is_module: true)
            key = {module_name, member_name, ah, vf}
            unless @virtual_targets_lowered.includes?(key)
              @virtual_targets_lowered.add(key)
              includers = @module_includers[module_name]? || begin
                short_name = last_namespace_component(module_name)
                @module_includers[short_name]?
              end
              if includers
                owners = includers.to_a + collect_subclasses(includers.to_a)
                owners.each do |owner|
                  base_name = "#{owner}##{member_name}"
                  candidate = mangle_function_name(base_name, arg_types, false)
                  lower_function_if_needed(candidate)
                  lower_function_if_needed(base_name) unless candidate == base_name
                end
              end
            end
          end
        end
      end

      primary_name = if resolved_method_name
                       mangle_function_name(resolved_method_name, arg_types)
                     else
                       actual_name
                     end

      if (desc = @module.get_type_descriptor(receiver_type))
        if desc.kind == TypeKind::Tuple || desc.name.starts_with?("Tuple(")
          union_parts = desc.type_params.map { |ref| get_type_name_from_ref(ref) }.reject(&.empty?)
          if !union_parts.empty?
            tuple_union = union_parts.join(" | ")
            tuple_list = union_parts.join(", ")
            map = {"T" => tuple_union, "T__tuple" => tuple_list}
            record_pending_type_param_map(primary_name, map)
            record_pending_type_param_map(actual_name, map)
            record_pending_type_param_map(base_method_name, map) if base_method_name
          end
        end
      end

      if debug_env_filter_match?("DEBUG_CALL_TRACE", member_name, actual_name, primary_name)
        STDERR.puts "[CALL_TRACE] stage=before_lower_function method=#{member_name} actual=#{actual_name} primary=#{primary_name} return=#{return_type.id}"
      end
      lower_function_if_needed(primary_name)
      if actual_name != primary_name
        lower_function_if_needed(actual_name)
      end

      if return_type == TypeRef::VOID
        return_type = get_function_return_type(actual_name)
        if return_type == TypeRef::VOID && actual_name != primary_name
          return_type = get_function_return_type(primary_name)
        end
      end
      if !forced_return_type && (func = @module.function_by_name(actual_name))
        if func.return_type != TypeRef::VOID && func.return_type != TypeRef::NIL && func.return_type != return_type
          return_type = func.return_type
        end
      end
      resolved_return_type = get_function_return_type(actual_name)
      if resolved_return_type == TypeRef::VOID && actual_name != primary_name
        resolved_return_type = get_function_return_type(primary_name)
      end
      if !forced_return_type &&
         resolved_return_type != TypeRef::VOID &&
         resolved_return_type != TypeRef::NIL &&
         resolved_return_type != return_type
        return_type = resolved_return_type
      end

      if debug_env_filter_match?("DEBUG_CALL_TRACE", member_name, actual_name, primary_name)
        STDERR.puts "[CALL_TRACE] stage=before_coerce method=#{member_name} actual=#{actual_name} args=#{args.size}"
      end
      args = coerce_args_to_param_types(ctx, args, actual_name)
      if debug_env_filter_match?("DEBUG_CALL_TRACE", member_name, actual_name, primary_name)
        STDERR.puts "[CALL_TRACE] stage=before_emit method=#{member_name} actual=#{actual_name} args=#{args.size}"
      end
      if debug_env_filter_match?("DEBUG_MEMBER_CALL", member_name, actual_name)
        STDERR.puts "[MEMBER_CALL] name=#{actual_name} return_id=#{return_type.id} return=#{get_type_name_from_ref(return_type)}"
      end
      call = Call.new(ctx.next_id, return_type, object_id, actual_name, args, nil, call_virtual)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      if enum_name = enum_return_name_for(actual_name)
        (@enum_value_types ||= {} of ValueId => String)[call.id] = enum_name
      end
      if debug_env_filter_match?("DEBUG_CALL_TRACE", member_name, actual_name, primary_name)
        STDERR.puts "[CALL_TRACE] stage=after_emit method=#{member_name} actual=#{actual_name}"
      end
      call.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # ASSIGNMENT
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_assign(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::AssignNode) : ValueId
      value_id = lower_expr(ctx, node.value)
      target_node = @arena[node.target]

      case target_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(target_node.name)
        value_type = ctx.type_of(value_id)
        if debug_name = env_get("DEBUG_ASSIGN_VAR")
          if debug_name == name
            type_name = value_type == TypeRef::VOID ? "Void" : get_type_name_from_ref(value_type)
            STDERR.puts "[ASSIGN_VAR] scope=#{@current_class || ""}##{@current_method || ""} name=#{name} type=#{type_name}"
          end
        end
        if env_get("DEBUG_ASSIGN_SEPARATORS") && name == "separators" && value_type == TypeRef::NIL
          val_node = @arena[node.value]
          if val_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
            callee = @arena[val_node.callee]
            callee_desc = case callee
                          when CrystalV2::Compiler::Frontend::MemberAccessNode
                            obj = @arena[callee.object]
                            obj_kind = obj.class.name.split("::").last
                            "MemberAccess(#{obj_kind}.#{String.new(callee.member)})"
                          when CrystalV2::Compiler::Frontend::IdentifierNode
                            "Identifier(#{String.new(callee.name)})"
                          else
                            callee.class.name.split("::").last
                          end
            block_kind = if blk = val_node.block
                           @arena[blk].class.name.split("::").last
                         else
                           "nil"
                         end
            STDERR.puts "[ASSIGN_SEPARATORS] value_call=#{callee_desc} args=#{val_node.args.size} block=#{block_kind}"
          end
        end
        if env_get("DEBUG_VALUE_ASSIGN") && name == "value"
          type_name = value_type == TypeRef::VOID ? "Void" : get_type_name_from_ref(value_type)
          STDERR.puts "[ASSIGN] scope=#{@current_class || ""}##{@current_method || ""} name=value type=#{type_name}"
        end
        if existing = ctx.lookup_local(name)
          # Reassignment
          copy = Copy.new(ctx.next_id, value_type, value_id)
          ctx.emit(copy)
          ctx.register_local(name, copy.id)
          if enum_name = @enum_value_types.try(&.[value_id]?)
            enum_map = @enum_value_types ||= {} of ValueId => String
            enum_map[copy.id] = enum_name
          end
          # Propagate proc captures through reassignment copies
          if caps = @proc_captures_by_value[value_id]?
            @proc_captures_by_value[copy.id] = caps
          end
          update_typeof_local(name, value_type)
          if concrete_name = concrete_type_name_for(value_type)
            existing_name = lookup_typeof_local_name(name)
            if existing_name.nil? || module_like_type_name?(existing_name)
              update_typeof_local_name(name, concrete_name)
            end
          end
          copy.id
        else
          # New variable
          local = Local.new(ctx.next_id, value_type, name, ctx.current_scope)
          ctx.emit(local)
          ctx.register_local(name, value_id)
          # Also emit copy
          copy = Copy.new(ctx.next_id, value_type, value_id)
          ctx.emit(copy)
          ctx.register_local(name, copy.id)
          if enum_name = @enum_value_types.try(&.[value_id]?)
            enum_map = @enum_value_types ||= {} of ValueId => String
            enum_map[local.id] = enum_name
            enum_map[copy.id] = enum_name
          end
          # Propagate proc captures through assignment copies
          if caps = @proc_captures_by_value[value_id]?
            @proc_captures_by_value[copy.id] = caps
          end
          update_typeof_local(name, value_type)
          if concrete_name = concrete_type_name_for(value_type)
            update_typeof_local_name(name, concrete_name)
          end
          copy.id
        end
      when CrystalV2::Compiler::Frontend::InstanceVarNode
        name = String.new(target_node.name)
        value_type = ctx.type_of(value_id)
        ivar_offset = get_ivar_offset(name)
        ivar_type = get_ivar_type(name)
        if class_name = @current_class
          if class_info = @class_info[class_name]?
            ivars = class_info.ivars
            if idx = ivars.index { |iv| iv.name == name }
              existing = ivars[idx]
              merged_type = existing.type
              if existing.type == TypeRef::VOID && value_type != TypeRef::VOID
                merged_type = value_type
              elsif value_type != TypeRef::VOID && existing.type != value_type
                merged_type = union_type_for_values(existing.type, value_type)
              end
              if merged_type != existing.type
                # Avoid widening ivar layouts after offsets are fixed (union may increase size).
                if existing.type == TypeRef::VOID || type_size(merged_type) == type_size(existing.type)
                  ivars[idx] = IVarInfo.new(name, merged_type, existing.offset)
                  ivar_type = merged_type
                else
                  ivar_type = existing.type
                  debug_hook("ivar.union.skip", "class=#{class_name} ivar=#{name} from=#{get_type_name_from_ref(existing.type)} to=#{get_type_name_from_ref(merged_type)}")
                end
              else
                ivar_type = existing.type
              end
              ivar_offset = existing.offset
            elsif value_type != TypeRef::VOID
              new_offset = class_info.size
              ivars << IVarInfo.new(name, value_type, new_offset)
              new_size = new_offset + type_size(value_type)
              @class_info[class_name] = ClassInfo.new(
                class_info.name,
                class_info.type_ref,
                ivars,
                class_info.class_vars,
                new_size,
                class_info.is_struct,
                class_info.parent_name
              )
              @class_info_by_type_id[class_info.type_ref.id] = @class_info[class_name]
              @class_info_version += 1
              ivar_type = value_type
              ivar_offset = new_offset
            end
          end
        end
        self_id = emit_self(ctx)
        if class_name && (enum_name = @enum_value_types.try(&.[value_id]?))
          enum_map = @enum_ivar_types ||= {} of String => Hash(String, String)
          class_map = enum_map[class_name]? || begin
            new_map = {} of String => String
            enum_map[class_name] = new_map
            new_map
          end
          class_map[name] = enum_name
        end

        # Check if ivar is a union type - need to wrap the value
        if ivar_type && is_union_type?(ivar_type)
          # Get the type of the value being assigned
          value_type = ctx.type_of(value_id)
          variant_id = get_union_variant_id(ivar_type, value_type)

          if variant_id >= 0
            # Wrap value into union with type_id
            union_wrap = UnionWrap.new(ctx.next_id, ivar_type, value_id, variant_id)
            ctx.emit(union_wrap)
            ctx.register_type(union_wrap.id, ivar_type)

            # Store the wrapped union value
            field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, self_id, name, union_wrap.id, ivar_offset)
            ctx.emit(field_set)
            return value_id
          end
        end

        # Regular (non-union) field assignment
        field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, self_id, name, value_id, ivar_offset)
        ctx.emit(field_set)
        value_id
      when CrystalV2::Compiler::Frontend::ClassVarNode
        # Name includes @@ prefix, strip it
        raw_name = String.new(target_node.name)
        name = raw_name.lstrip('@')
        cvar_type = get_class_var_type(name)
        class_name = @current_class || ""
        if env_has?("DEBUG_DEFERRED_CLASSVAR")
          next_id = ctx.next_id
          STDERR.puts "[CLASSVAR_SET] Emitting ClassVarSet: class=#{class_name} cvar=#{name} func=#{ctx.function.name} block=#{ctx.current_block} next_id=#{next_id}"
        end
        if cvar_type == TypeRef::VOID
          value_type = ctx.type_of(value_id)
          record_class_var_type(class_name, name, value_type)
          cvar_type = value_type unless value_type == TypeRef::VOID
        end
        if enum_name = @enum_value_types.try(&.[value_id]?)
          enum_map = @enum_cvar_types ||= {} of String => Hash(String, String)
          class_map = enum_map[class_name]? || begin
            new_map = {} of String => String
            enum_map[class_name] = new_map
            new_map
          end
          class_map[name] = enum_name
        end
        # Coerce value to classvar type (e.g., wrap bare ptr into union)
        if cvar_type != TypeRef::VOID
          value_id = coerce_value_to_type(ctx, value_id, cvar_type)
        end
        class_var_set = ClassVarSet.new(ctx.next_id, cvar_type, class_name, name, value_id)
        ctx.emit(class_var_set)
        class_var_set.id
      when CrystalV2::Compiler::Frontend::IndexNode
        object_id = lower_expr(ctx, target_node.object)
        index_ids = target_node.indexes.map { |idx| lower_expr(ctx, idx) }

        # Check if this is pointer indexing (ptr[i] = val)
        object_type = ctx.type_of(object_id)
        type_desc = @module.get_type_descriptor(object_type)
        if type_desc && type_desc.kind == TypeKind::Union
          if unwrapped = unwrap_pointer_union(ctx, object_id, object_type, ctx.type_of(value_id))
            object_id, object_type = unwrapped
            type_desc = @module.get_type_descriptor(object_type)
          end
        end
        is_pointer_type = object_type == TypeRef::POINTER ||
                          (type_desc && type_desc.kind == TypeKind::Pointer)

        if is_pointer_type && index_ids.size == 1
          # Pointer store: ptr[i] = val -> PointerStore with index
          store_type = ctx.type_of(value_id)
          store_node = PointerStore.new(ctx.next_id, store_type, object_id, value_id, index_ids.first)
          ctx.emit(store_node)
          return value_id
        end

        # Check if this is an array-like type (which uses IndexSet for element assignment)
        is_array_type = type_desc && (type_desc.kind == TypeKind::Array ||
                                      type_desc.name.starts_with?("Array") ||
                                      type_desc.name.starts_with?("StaticArray") ||
                                      type_desc.name.starts_with?("Slice"))

        if is_array_type && index_ids.size == 1
          # Array element assignment: arr[i] = val -> IndexSet
          element_type = type_desc.not_nil!.type_params.first? || ctx.type_of(value_id)
          element_type = TypeRef::INT32 if element_type == TypeRef::VOID
          index_set = IndexSet.new(ctx.next_id, element_type, object_id, index_ids.first, value_id)
          ctx.emit(index_set)
          value_id
        else
          # Everything else (classes like Hash, custom types): call []= method
          # Resolve the method name properly (with class name and mangling)
          all_args = index_ids + [value_id]
          arg_types = all_args.map { |arg| ctx.type_of(arg) }
          method_name = resolve_method_call(ctx, object_id, "[]=", arg_types, false)
          return_type = get_function_return_type(method_name)
          # Ensure the []= method is lowered
          remember_callsite_arg_types(method_name, arg_types)
          lower_function_if_needed(method_name)
          call = Call.new(ctx.next_id, return_type, object_id, method_name, all_args)
          ctx.emit(call)
          ctx.register_type(call.id, return_type)
          call.id
        end
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # obj.field = value -> call setter method or direct field set
        field_name = String.new(target_node.member)
        lib_name = case obj_node = @arena[target_node.object]
                   when CrystalV2::Compiler::Frontend::ConstantNode
                     resolved = resolve_class_name_in_context(String.new(obj_node.name))
                     resolved = resolve_type_alias_chain(resolved)
                     @module.is_lib?(resolved) ? resolved : nil
                   when CrystalV2::Compiler::Frontend::IdentifierNode
                     name = String.new(obj_node.name)
                     if ctx.lookup_local(name).nil? && name[0]?.try(&.uppercase?)
                       resolved = resolve_class_name_in_context(name)
                       resolved = resolve_type_alias_chain(resolved)
                       @module.is_lib?(resolved) ? resolved : nil
                     end
                   when CrystalV2::Compiler::Frontend::PathNode
                     raw_path = collect_path_string(obj_node)
                     full_path = path_is_absolute?(obj_node) ? raw_path.sub(/^::/, "") : resolve_path_string_in_context(raw_path)
                     @module.is_lib?(full_path) ? full_path : nil
                   else
                     nil
                   end
        if lib_name
          if extern_global = @module.get_extern_global(lib_name, field_name)
            value_type = extern_global.type
            class_var_set = ClassVarSet.new(ctx.next_id, value_type, lib_name, field_name, value_id)
            ctx.emit(class_var_set)
            return class_var_set.id
          end
        end

        static_owner = case obj_node
                       when CrystalV2::Compiler::Frontend::ConstantNode
                         resolved = resolve_class_name_in_context(String.new(obj_node.name))
                         resolve_type_alias_chain(resolved)
                       when CrystalV2::Compiler::Frontend::IdentifierNode
                         name = String.new(obj_node.name)
                         if ctx.lookup_local(name).nil? && name[0]?.try(&.uppercase?)
                           resolved = resolve_class_name_in_context(name)
                           resolve_type_alias_chain(resolved)
                         end
                       when CrystalV2::Compiler::Frontend::PathNode
                         raw_path = collect_path_string(obj_node)
                         full_path = path_is_absolute?(obj_node) ? raw_path.sub(/^::/, "") : resolve_path_string_in_context(raw_path)
                         resolve_type_alias_chain(full_path)
                       else
                         nil
                       end
        if static_owner
          if class_like_namespace?(static_owner) || module_like_type_name?(static_owner) ||
             @enum_info.try(&.has_key?(static_owner))
            setter_name = "#{field_name}="
            full_method_name = resolve_class_method_with_inheritance(static_owner, setter_name) || "#{static_owner}.#{setter_name}"
            arg_types = [ctx.type_of(value_id)]
            return_type = get_function_return_type(full_method_name)
            remember_callsite_arg_types(full_method_name, arg_types)
            lower_function_if_needed(full_method_name)
            call = Call.new(ctx.next_id, return_type, nil, full_method_name, [value_id])
            ctx.emit(call)
            ctx.register_type(call.id, return_type)
            return call.id
          end
        end

        # Detect ptr.value.field = val pattern: use pointer directly
        # instead of dereferencing (which would load garbage for struct pointers)
        inner_node = @arena[target_node.object]
        if inner_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
           String.new(inner_node.member) == "value"
          ptr_id = lower_expr(ctx, inner_node.object)
          ptr_type = ctx.type_of(ptr_id)
          ptr_desc = @module.get_type_descriptor(ptr_type)
          is_pointer = ptr_type == TypeRef::POINTER ||
                       (ptr_desc && ptr_desc.kind == TypeKind::Pointer)
          if is_pointer
            # Resolve pointed-to type for field layout
            element_type_name = if ptr_desc && ptr_desc.name.starts_with?("Pointer(")
                                  ptr_desc.name[8...-1]
                                else
                                  nil
                                end
            if element_type_name
              element_type_ref = type_ref_for_name(element_type_name)
              element_desc = @module.get_type_descriptor(element_type_ref)
              element_class_name = element_desc ? element_desc.name : element_type_name
              if ci = @class_info[element_class_name]?
                ivar_name = "@#{field_name}"
                ivar_info = ci.ivars.find { |iv| iv.name == ivar_name }
                if !ivar_info && ci.is_struct && @lib_structs.includes?(element_class_name)
                  ivar_info = ci.ivars.find { |iv| iv.name == field_name }
                end
                if ivar_info
                  field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, ptr_id, ivar_info.name, value_id, ivar_info.offset)
                  ctx.emit(field_set)
                  return field_set.id
                end
              end
            end
          end
        end

        object_id = lower_expr(ctx, target_node.object)

        # Get the object's type to resolve the setter method
        object_type = ctx.type_of(object_id)
        type_desc = @module.get_type_descriptor(object_type)

        if field_name == "value"
          if type_desc && type_desc.kind == TypeKind::Union
            if unwrapped = unwrap_pointer_union(ctx, object_id, object_type, ctx.type_of(value_id))
              object_id, object_type = unwrapped
              type_desc = @module.get_type_descriptor(object_type)
            end
          end
          is_pointer_type = object_type == TypeRef::POINTER ||
                            (type_desc && type_desc.kind == TypeKind::Pointer)
          if is_pointer_type
            store_node = PointerStore.new(ctx.next_id, TypeRef::VOID, object_id, value_id, nil)
            ctx.emit(store_node)
            return store_node.id
          end
        end

        # Try direct field access if we know the class layout
        class_name = type_desc ? type_desc.name : nil
        if class_name && @class_info.has_key?(class_name)
          class_info = @class_info[class_name]

          # Check if this is a known field (ivar)
          ivar_name = "@#{field_name}"
          if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
            # Check if ivar is a union type - need to wrap the value
            ivar_type = ivar_info.type
            store_val = value_id
            if is_union_type?(ivar_type)
              value_type = ctx.type_of(value_id)
              variant_id = get_union_variant_id(ivar_type, value_type)
              if variant_id >= 0
                union_wrap = UnionWrap.new(ctx.next_id, ivar_type, value_id, variant_id)
                ctx.emit(union_wrap)
                ctx.register_type(union_wrap.id, ivar_type)
                store_val = union_wrap.id
              end
            end
            field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, object_id, ivar_name, store_val, ivar_info.offset)
            ctx.emit(field_set)
            return field_set.id
          elsif class_info.is_struct && @lib_structs.includes?(class_name)
            if ivar_info = class_info.ivars.find { |iv| iv.name == field_name }
              field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, object_id, field_name, value_id, ivar_info.offset)
              ctx.emit(field_set)
              return field_set.id
            end
          end
        end

        # Fallback to setter method call: obj.field=(value)
        setter_name = "#{field_name}="
        arg_types = [ctx.type_of(value_id)]
        method_name = resolve_method_call(ctx, object_id, setter_name, arg_types, false)
        return_type = get_function_return_type(method_name)
        if !@module.has_function?(method_name)
          if accessor = ensure_accessor_method(ctx, object_id, setter_name)
            return_type = accessor[0]
            method_name = accessor[1]
          end
        end
        # Ensure the setter method is lowered
        remember_callsite_arg_types(method_name, arg_types)
        lower_function_if_needed(method_name)
        call = Call.new(ctx.next_id, return_type, object_id, method_name, [value_id])
        ctx.emit(call)
        ctx.register_type(call.id, return_type)
        call.id
      when CrystalV2::Compiler::Frontend::GlobalNode
        # Global variable assignment: $name = value
        name = String.new(target_node.name)
        value_type = ctx.type_of(value_id)
        class_var_set = ClassVarSet.new(ctx.next_id, value_type, "$", name, value_id)
        ctx.emit(class_var_set)
        class_var_set.id
      else
        raise LoweringError.new("Unsupported assignment target: #{target_node.class}", target_node)
      end
    end

    private def lower_static_member_access_call(
      ctx : LoweringContext,
      class_name_str : String,
      member_name : String,
    ) : ValueId
      if extern_global = @module.get_extern_global(class_name_str, member_name)
        class_var_get = ClassVarGet.new(ctx.next_id, extern_global.type, class_name_str, member_name)
        ctx.emit(class_var_get)
        ctx.register_type(class_var_get.id, extern_global.type)
        return class_var_get.id
      end
      if extern_func = @module.get_extern_function(class_name_str, member_name)
        return emit_extern_call(ctx, extern_func, [] of ValueId)
      end

      full_method_name = if member_name == "new"
                           "#{class_name_str}.#{member_name}"
                         else
                           resolve_class_method_with_inheritance(class_name_str, member_name) || "#{class_name_str}.#{member_name}"
                         end
      if member_name == "new"
        if class_info = @class_info[class_name_str]?
          generate_allocator(class_name_str, class_info, force: true)
        end
      end

      if member_name == "null" && full_method_name.starts_with?("Pointer(")
        zero = Literal.new(ctx.next_id, TypeRef::INT64, 0_i64)
        ctx.emit(zero)
        ctx.register_type(zero.id, TypeRef::INT64)
        cast = Cast.new(ctx.next_id, TypeRef::POINTER, zero.id, TypeRef::POINTER)
        ctx.emit(cast)
        ctx.register_type(cast.id, TypeRef::POINTER)
        return cast.id
      end

      enum_name = resolve_enum_name(class_name_str)

      args = apply_default_args(ctx, [] of ValueId, member_name, full_method_name, false, false)
      if enum_name && member_name == "new"
        enum_type = enum_base_type(enum_name)
        if args.size == 1
          value_id = args.first
          value_type = ctx.type_of(value_id)
          if value_type != enum_type
            cast = Cast.new(ctx.next_id, enum_type, value_id, enum_type, safe: false)
            ctx.emit(cast)
            ctx.register_type(cast.id, enum_type)
            (@enum_value_types ||= {} of ValueId => String)[cast.id] = enum_name
            return cast.id
          end
          (@enum_value_types ||= {} of ValueId => String)[value_id] = enum_name
          return value_id
        end
      end

      arg_types = args.map { |arg_id| ctx.type_of(arg_id) }
      mangled_name = mangle_function_name(full_method_name, arg_types)
      # DEBUG: Catch short names being used for method calls
      if env_has?("DEBUG_SHORT_NAMES") && full_method_name &&
         (full_method_name.starts_with?("Seek#") || full_method_name.starts_with?("Seek.") ||
         full_method_name.starts_with?("Section#") || full_method_name.starts_with?("Section.") ||
         full_method_name.starts_with?("LoadCommand#") || full_method_name.starts_with?("LoadCommand."))
        STDERR.puts "[SHORT_NAME_CALL] full_method_name=#{full_method_name}, mangled=#{mangled_name}"
      end
      actual_name = if @function_types.has_key?(mangled_name) || @module.has_function?(mangled_name)
                      mangled_name
                    elsif has_function_base?(full_method_name)
                      full_method_name
                    else
                      mangled_name
                    end
      return_type = get_function_return_type(actual_name)
      if member_name == "new" && class_name_str == "Range" && arg_types.size >= 2
        begin_name = get_type_name_from_ref(arg_types[0])
        end_name = get_type_name_from_ref(arg_types[1])
        if begin_name != "Void" && end_name != "Void"
          range_name = "Range(#{begin_name}, #{end_name})"
          monomorphize_generic_class("Range", [begin_name, end_name], range_name)
          return_type = type_ref_for_name(range_name)
        end
      end
      # For .new, use class type_ref as return type
      if member_name == "new" && return_type == TypeRef::VOID
        if enum_name
          return_type = enum_base_type(enum_name)
        elsif class_info = @class_info[class_name_str]?
          return_type = class_info.type_ref
        else
          return_type = TypeRef::POINTER
        end
      end

      lower_function_if_needed(mangled_name)
      if actual_name != mangled_name
        lower_function_if_needed(actual_name)
      end

      args = coerce_args_to_param_types(ctx, args, actual_name)
      call = Call.new(ctx.next_id, return_type, nil, actual_name, args)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      if enum_name = enum_return_name_for(actual_name)
        (@enum_value_types ||= {} of ValueId => String)[call.id] = enum_name
      end
      if enum_name && return_type == enum_base_type(enum_name)
        (@enum_value_types ||= {} of ValueId => String)[call.id] = enum_name
      end
      call.id
    end

    private def lower_multiple_assign(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::MultipleAssignNode) : ValueId
      # MultipleAssignNode has a single value (destructured)
      # e.g., a, b, c = expr  where expr is a tuple/array
      if value_node = @arena[node.value]
        if tuple_node = value_node.as?(CrystalV2::Compiler::Frontend::TupleLiteralNode)
          element_ids = tuple_node.elements.map { |elem| lower_expr(ctx, elem) }
          if env_get("DBG_MULTI_ASSIGN")
            element_ids.each_with_index do |eid, i|
              etype = ctx.type_of(eid)
              STDERR.puts "[MULTI_ASSIGN_TUPLE] idx=#{i} value_id=#{eid} type=#{etype.id} name=#{get_type_name_from_ref(etype)} scope=#{@current_class || ""}##{@current_method || ""}"
            end
          end
          node.targets.each_with_index do |target_expr, idx|
            next unless value_id = element_ids[idx]?
            assign_value_to_target(ctx, target_expr, value_id)
          end
          return element_ids.last? || begin
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            nil_lit.id
          end
        end
      end

      rhs_id = lower_expr(ctx, node.value)
      rhs_type = ctx.type_of(rhs_id)

      if env_get("DBG_MULTI_ASSIGN")
        rhs_name = get_type_name_from_ref(rhs_type)
        STDERR.puts "[MULTI_ASSIGN] rhs_type=#{rhs_type.id} name=#{rhs_name} targets=#{node.targets.size} scope=#{@current_class || ""}##{@current_method || ""}"
      end

      # For each target, emit index operation to destructure
      node.targets.each_with_index do |target_expr, idx|
        target_node = @arena[target_expr]

        # Index into the RHS to get this element
        index_lit = Literal.new(ctx.next_id, TypeRef::INT32, idx.to_i64)
        ctx.emit(index_lit)
        element_type = tuple_element_type(rhs_type, idx) || TypeRef::VOID
        element_id = IndexGet.new(ctx.next_id, element_type, rhs_id, index_lit.id)
        ctx.emit(element_id)
        ctx.register_type(element_id.id, element_type)

        assign_value_to_target(ctx, target_expr, element_id.id)
      end

      rhs_id
    end

    private def assign_value_to_target(
      ctx : LoweringContext,
      target_expr : CrystalV2::Compiler::Frontend::ExprId,
      value_id : ValueId,
    ) : ValueId
      target_node = @arena[target_expr]

      case target_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(target_node.name)
        value_type = ctx.type_of(value_id)
        if debug_name = env_get("DEBUG_ASSIGN_VAR")
          if debug_name == name
            type_name = value_type == TypeRef::VOID ? "Void" : get_type_name_from_ref(value_type)
            STDERR.puts "[ASSIGN_VAR] scope=#{@current_class || ""}##{@current_method || ""} name=#{name} type=#{type_name}"
          end
        end
        if existing = ctx.lookup_local(name)
          copy = Copy.new(ctx.next_id, value_type, value_id)
          ctx.emit(copy)
          ctx.register_local(name, copy.id)
          if enum_name = @enum_value_types.try(&.[value_id]?)
            enum_map = @enum_value_types ||= {} of ValueId => String
            enum_map[copy.id] = enum_name
          end
          update_typeof_local(name, value_type)
          if concrete_name = concrete_type_name_for(value_type)
            existing_name = lookup_typeof_local_name(name)
            if existing_name.nil? || module_like_type_name?(existing_name)
              update_typeof_local_name(name, concrete_name)
            end
          end
          copy.id
        else
          local = Local.new(ctx.next_id, value_type, name, ctx.current_scope)
          ctx.emit(local)
          ctx.register_local(name, value_id)
          copy = Copy.new(ctx.next_id, value_type, value_id)
          ctx.emit(copy)
          ctx.register_local(name, copy.id)
          if enum_name = @enum_value_types.try(&.[value_id]?)
            enum_map = @enum_value_types ||= {} of ValueId => String
            enum_map[local.id] = enum_name
            enum_map[copy.id] = enum_name
          end
          update_typeof_local(name, value_type)
          if concrete_name = concrete_type_name_for(value_type)
            update_typeof_local_name(name, concrete_name)
          end
          copy.id
        end
      when CrystalV2::Compiler::Frontend::InstanceVarNode
        name = String.new(target_node.name)
        value_type = ctx.type_of(value_id)
        ivar_offset = get_ivar_offset(name)
        ivar_type = get_ivar_type(name)
        if class_name = @current_class
          if class_info = @class_info[class_name]?
            ivars = class_info.ivars
            if idx = ivars.index { |iv| iv.name == name }
              existing = ivars[idx]
              merged_type = existing.type
              if existing.type == TypeRef::VOID && value_type != TypeRef::VOID
                merged_type = value_type
              elsif value_type != TypeRef::VOID && existing.type != value_type
                merged_type = union_type_for_values(existing.type, value_type)
              end
              if merged_type != existing.type
                if existing.type == TypeRef::VOID || type_size(merged_type) == type_size(existing.type)
                  ivars[idx] = IVarInfo.new(name, merged_type, existing.offset)
                  ivar_type = merged_type
                else
                  ivar_type = existing.type
                  debug_hook("ivar.union.skip", "class=#{class_name} ivar=#{name} from=#{get_type_name_from_ref(existing.type)} to=#{get_type_name_from_ref(merged_type)}")
                end
              else
                ivar_type = existing.type
              end
              ivar_offset = existing.offset
            elsif value_type != TypeRef::VOID
              new_offset = class_info.size
              ivars << IVarInfo.new(name, value_type, new_offset)
              new_size = new_offset + type_size(value_type)
              @class_info[class_name] = ClassInfo.new(
                class_info.name,
                class_info.type_ref,
                ivars,
                class_info.class_vars,
                new_size,
                class_info.is_struct,
                class_info.parent_name
              )
              @class_info_by_type_id[class_info.type_ref.id] = @class_info[class_name]
              @class_info_version += 1
              ivar_type = value_type
              ivar_offset = new_offset
            end
          end
        end
        self_id = emit_self(ctx)
        if class_name && (enum_name = @enum_value_types.try(&.[value_id]?))
          enum_map = @enum_ivar_types ||= {} of String => Hash(String, String)
          class_map = enum_map[class_name]? || begin
            new_map = {} of String => String
            enum_map[class_name] = new_map
            new_map
          end
          class_map[name] = enum_name
        end

        if ivar_type && is_union_type?(ivar_type)
          value_type = ctx.type_of(value_id)
          variant_id = get_union_variant_id(ivar_type, value_type)
          if variant_id >= 0
            union_wrap = UnionWrap.new(ctx.next_id, ivar_type, value_id, variant_id)
            ctx.emit(union_wrap)
            ctx.register_type(union_wrap.id, ivar_type)
            field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, self_id, name, union_wrap.id, ivar_offset)
            ctx.emit(field_set)
            return value_id
          end
        end

        field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, self_id, name, value_id, ivar_offset)
        ctx.emit(field_set)
        value_id
      when CrystalV2::Compiler::Frontend::ClassVarNode
        raw_name = String.new(target_node.name)
        name = raw_name.lstrip('@')
        cvar_type = get_class_var_type(name)
        class_name = @current_class || ""
        if cvar_type == TypeRef::VOID
          value_type = ctx.type_of(value_id)
          record_class_var_type(class_name, name, value_type)
          cvar_type = value_type unless value_type == TypeRef::VOID
        end
        if enum_name = @enum_value_types.try(&.[value_id]?)
          enum_map = @enum_cvar_types ||= {} of String => Hash(String, String)
          class_map = enum_map[class_name]? || begin
            new_map = {} of String => String
            enum_map[class_name] = new_map
            new_map
          end
          class_map[name] = enum_name
        end
        # Coerce value to classvar type (e.g., wrap bare ptr into union)
        if cvar_type != TypeRef::VOID
          value_id = coerce_value_to_type(ctx, value_id, cvar_type)
        end
        class_var_set = ClassVarSet.new(ctx.next_id, cvar_type, class_name, name, value_id)
        ctx.emit(class_var_set)
        class_var_set.id
      when CrystalV2::Compiler::Frontend::IndexNode
        object_id = lower_expr(ctx, target_node.object)
        index_ids = target_node.indexes.map { |idx| lower_expr(ctx, idx) }

        object_type = ctx.type_of(object_id)
        type_desc = @module.get_type_descriptor(object_type)
        if type_desc && type_desc.kind == TypeKind::Union
          if unwrapped = unwrap_pointer_union(ctx, object_id, object_type, ctx.type_of(value_id))
            object_id, object_type = unwrapped
            type_desc = @module.get_type_descriptor(object_type)
          end
        end
        is_pointer_type = object_type == TypeRef::POINTER ||
                          (type_desc && type_desc.kind == TypeKind::Pointer)

        if is_pointer_type && index_ids.size == 1
          store_type = ctx.type_of(value_id)
          store_node = PointerStore.new(ctx.next_id, store_type, object_id, value_id, index_ids.first)
          ctx.emit(store_node)
          return value_id
        end

        is_array_type = type_desc && (type_desc.kind == TypeKind::Array ||
                                      type_desc.name.starts_with?("Array") ||
                                      type_desc.name.starts_with?("StaticArray") ||
                                      type_desc.name.starts_with?("Slice"))

        if is_array_type && index_ids.size == 1
          element_type = type_desc.not_nil!.type_params.first? || ctx.type_of(value_id)
          element_type = TypeRef::INT32 if element_type == TypeRef::VOID
          index_set = IndexSet.new(ctx.next_id, element_type, object_id, index_ids.first, value_id)
          ctx.emit(index_set)
          value_id
        else
          all_args = index_ids + [value_id]
          arg_types = all_args.map { |arg| ctx.type_of(arg) }
          method_name = resolve_method_call(ctx, object_id, "[]=", arg_types, false)
          return_type = get_function_return_type(method_name)
          remember_callsite_arg_types(method_name, arg_types)
          lower_function_if_needed(method_name)
          call = Call.new(ctx.next_id, return_type, object_id, method_name, all_args)
          ctx.emit(call)
          ctx.register_type(call.id, return_type)
          call.id
        end
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        field_name = String.new(target_node.member)
        lib_name = case obj_node = @arena[target_node.object]
                   when CrystalV2::Compiler::Frontend::ConstantNode
                     resolved = resolve_class_name_in_context(String.new(obj_node.name))
                     resolved = resolve_type_alias_chain(resolved)
                     @module.is_lib?(resolved) ? resolved : nil
                   when CrystalV2::Compiler::Frontend::IdentifierNode
                     name = String.new(obj_node.name)
                     if ctx.lookup_local(name).nil? && name[0]?.try(&.uppercase?)
                       resolved = resolve_class_name_in_context(name)
                       resolved = resolve_type_alias_chain(resolved)
                       @module.is_lib?(resolved) ? resolved : nil
                     end
                   when CrystalV2::Compiler::Frontend::PathNode
                     raw_path = collect_path_string(obj_node)
                     full_path = path_is_absolute?(obj_node) ? raw_path.sub(/^::/, "") : resolve_path_string_in_context(raw_path)
                     @module.is_lib?(full_path) ? full_path : nil
                   else
                     nil
                   end
        if lib_name
          if extern_global = @module.get_extern_global(lib_name, field_name)
            value_type = extern_global.type
            class_var_set = ClassVarSet.new(ctx.next_id, value_type, lib_name, field_name, value_id)
            ctx.emit(class_var_set)
            return class_var_set.id
          end
        end

        object_id = lower_expr(ctx, target_node.object)
        object_type = ctx.type_of(object_id)
        type_desc = @module.get_type_descriptor(object_type)

        if field_name == "value"
          if type_desc && type_desc.kind == TypeKind::Union
            if unwrapped = unwrap_pointer_union(ctx, object_id, object_type, ctx.type_of(value_id))
              object_id, object_type = unwrapped
              type_desc = @module.get_type_descriptor(object_type)
            end
          end
          is_pointer_type = object_type == TypeRef::POINTER ||
                            (type_desc && type_desc.kind == TypeKind::Pointer)
          if is_pointer_type
            store_node = PointerStore.new(ctx.next_id, TypeRef::VOID, object_id, value_id, nil)
            ctx.emit(store_node)
            return store_node.id
          end
        end

        class_name = type_desc ? type_desc.name : nil
        if class_name && @class_info.has_key?(class_name)
          class_info = @class_info[class_name]
          ivar_name = "@#{field_name}"
          if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
            # Check if ivar is a union type - need to wrap the value
            ivar_type = ivar_info.type
            store_val = value_id
            if is_union_type?(ivar_type)
              value_type = ctx.type_of(value_id)
              variant_id = get_union_variant_id(ivar_type, value_type)
              if variant_id >= 0
                union_wrap = UnionWrap.new(ctx.next_id, ivar_type, value_id, variant_id)
                ctx.emit(union_wrap)
                ctx.register_type(union_wrap.id, ivar_type)
                store_val = union_wrap.id
              end
            end
            field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, object_id, ivar_name, store_val, ivar_info.offset)
            ctx.emit(field_set)
            return field_set.id
          elsif class_info.is_struct && @lib_structs.includes?(class_name)
            if ivar_info = class_info.ivars.find { |iv| iv.name == field_name }
              field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, object_id, field_name, value_id, ivar_info.offset)
              ctx.emit(field_set)
              return field_set.id
            end
          end
        end

        setter_name = "#{field_name}="
        arg_types = [ctx.type_of(value_id)]
        method_name = resolve_method_call(ctx, object_id, setter_name, arg_types, false)
        return_type = get_function_return_type(method_name)
        if !@module.has_function?(method_name)
          if accessor = ensure_accessor_method(ctx, object_id, setter_name)
            return_type = accessor[0]
            method_name = accessor[1]
          end
        end
        remember_callsite_arg_types(method_name, arg_types)
        lower_function_if_needed(method_name)
        call = Call.new(ctx.next_id, return_type, object_id, method_name, [value_id])
        ctx.emit(call)
        ctx.register_type(call.id, return_type)
        call.id
      when CrystalV2::Compiler::Frontend::GlobalNode
        name = String.new(target_node.name)
        value_type = ctx.type_of(value_id)
        class_var_set = ClassVarSet.new(ctx.next_id, value_type, "$", name, value_id)
        ctx.emit(class_var_set)
        class_var_set.id
      else
        raise LoweringError.new("Unsupported assignment target: #{target_node.class}", target_node)
      end
    end

    # ═══════════════════════════════════════════════════════════════════════
    # CLOSURES
    # ═══════════════════════════════════════════════════════════════════════

    private def compute_block_captures(
      ctx : LoweringContext,
      closure_scope : ScopeId,
      saved_locals : Hash(String, ValueId),
      assigned_vars : Set(String),
    ) : Array(CapturedVar)
      return [] of CapturedVar if saved_locals.empty?

      value_to_name = {} of ValueId => String
      saved_locals.each { |name, id| value_to_name[id] = name }

      captured_names = Set(String).new
      ctx.function.blocks.each do |block|
        next unless scope_within?(ctx.function, block.scope, closure_scope)
        block.instructions.each do |inst|
          each_operand_for_capture(inst) do |operand|
            if name = value_to_name[operand]?
              captured_names << name
            end
          end
        end
      end

      captures = [] of CapturedVar
      captured_names.each do |name|
        value_id = saved_locals[name]
        by_ref = assigned_vars.includes?(name)
        captures << CapturedVar.new(value_id, name, by_ref)
      end
      captures
    end

    private def scope_within?(function : Function, scope_id : ScopeId, root_scope : ScopeId) : Bool
      current = scope_id
      loop do
        return true if current == root_scope
        scope = function.get_scope(current)
        parent = scope.parent
        return false unless parent
        current = parent
      end
    end

    private def each_operand_for_capture(value : Value, &block : ValueId ->)
      case value
      when Copy
        yield value.source
      when BinaryOperation
        yield value.left
        yield value.right
      when UnaryOperation
        yield value.operand
      when Call
        if recv = value.receiver
          yield recv
        end
        value.args.each { |arg| yield arg }
      when FieldGet
        yield value.object
      when FieldSet
        yield value.object
        yield value.value
      when IndexGet
        yield value.object
        yield value.index
      when IndexSet
        yield value.object
        yield value.index
        yield value.value
      when MakeClosure
        value.captures.each { |cap| yield cap.value_id }
      when Yield
        value.args.each { |arg| yield arg }
      when Phi
        value.incoming.each { |(_, val)| yield val }
      when Cast
        yield value.value
      when IsA
        yield value.value
      when Allocate
        value.constructor_args.each { |arg| yield arg }
      end
    end

    private def lower_block(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::BlockNode) : ValueId
      block_id = lower_block_to_block_id(ctx, node)

      # Create MakeClosure
      captures = @block_captures.delete(block_id) || [] of CapturedVar

      closure = MakeClosure.new(ctx.next_id, TypeRef::VOID, block_id, captures)
      ctx.emit(closure)
      closure.id
    end

    private def lower_block_to_block_id(
      ctx : LoweringContext,
      node : CrystalV2::Compiler::Frontend::BlockNode,
      param_types : Array(TypeRef)? = nil,
    ) : BlockId
      saved_block = ctx.current_block
      @block_node_arenas[node.object_id] = @arena
      @block_owner[node.object_id] = {
        class_name:  @current_class,
        method_name: @current_method,
        is_class:    @current_method_is_class,
      }
      @block_owner_function_ids[node.object_id] = ctx.function.id
      if ctx.lookup_local("self").nil?
        param = ctx.function.params.find { |p| p.name == "self" }
        if param.nil? && ctx.function.name.includes?('#')
          param = ctx.function.params.first?
        end
        if param
          ctx.register_local("self", param.id)
          ctx.register_type(param.id, param.type)
        end
      end
      # Save locals before lowering block body - block-local vars shouldn't leak
      saved_locals = ctx.save_locals
      if self_id = saved_locals["self"]?
        @block_owner_self_ids[node.object_id] = self_id
      end
      assigned_vars = collect_assigned_vars(node.body).to_set
      if params = node.params
        params.each do |param|
          next unless param_name = param.name
          assigned_vars.delete(String.new(param_name))
        end
      end
      old_typeof_locals = @current_typeof_locals
      old_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = old_typeof_locals ? old_typeof_locals.dup : old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names ? old_typeof_local_names.dup : old_typeof_local_names

      ctx.push_scope(ScopeKind::Closure)
      closure_scope = ctx.current_scope
      body_block = ctx.create_block
      ctx.current_block = body_block

      # Add block parameters (params can be nil)
      # Default to POINTER type since block parameters are typically objects (IO, etc.)
      if params = node.params
        effective_param_types = param_types
        if effective_param_types && effective_param_types.size == 1 && params.size > 1
          if tuple_desc = @module.get_type_descriptor(effective_param_types[0])
            if tuple_desc.kind == TypeKind::Tuple || tuple_desc.name.starts_with?("Tuple(")
              tuple_params = tuple_desc.type_params.reject { |t| t == TypeRef::VOID }
              if tuple_params.size >= params.size
                effective_param_types = tuple_params
              end
            end
          end
        end
        params.each_with_index do |param, idx|
          if param_name = param.name
            name = String.new(param_name)
            param_type = if ta = param.type_annotation
                           type_ref_for_name(String.new(ta))
                         elsif effective_param_types && (resolved = effective_param_types[idx]?)
                           resolved
                         else
                           TypeRef::POINTER # Default to pointer for block params
                         end
            param_type = TypeRef::POINTER if param_type == TypeRef::VOID
            if env_get("DEBUG_BLOCK_PARAMS") && param_types
              STDERR.puts "[BLOCK_PARAMS] block_param name=#{name} type=#{get_type_name_from_ref(param_type)}"
            end
            param_val = Parameter.new(ctx.next_id, param_type, idx, name)
            ctx.emit(param_val)
            ctx.register_local(name, param_val.id)
            ctx.register_type(param_val.id, param_type)
            update_typeof_local(name, param_type)
            if ta = param.type_annotation
              update_typeof_local_name(name, String.new(ta))
            elsif param_type != TypeRef::VOID
              update_typeof_local_name(name, get_type_name_from_ref(param_type))
            end
            if param_type != TypeRef::VOID
              track_enum_value(param_val.id, get_type_name_from_ref(param_type))
            end
          end
        end
      end

      # Lower body
      last_value = lower_body(ctx, node.body)
      ctx.pop_scope

      @block_captures[body_block] = compute_block_captures(ctx, closure_scope, saved_locals, assigned_vars)

      # Implicit return from block
      if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
        ctx.terminate(Return.new(last_value))
      end

      ctx.current_block = saved_block
      # Restore locals - block-local vars shouldn't pollute outer scope
      ctx.restore_locals(saved_locals)
      @current_typeof_locals = old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names
      body_block
    end

    private def lower_block_pass_proc(
      ctx : LoweringContext,
      proc_expr : ExprId,
      param_types : Array(TypeRef)? = nil,
    ) : BlockId
      @inline_yield_proc_depth += 1
      proc_node = @arena[proc_expr]
      if env_get("DEBUG_BLOCK_PARAMS") && proc_node.is_a?(CrystalV2::Compiler::Frontend::ProcLiteralNode) == false
        STDERR.puts "[BLOCK_PARAMS] proc_node=#{proc_node.class}"
      end
      proc_id = if param_types && proc_node.is_a?(CrystalV2::Compiler::Frontend::ProcLiteralNode)
                  lower_proc_literal(ctx, proc_node, param_types)
                else
                  lower_expr(ctx, proc_expr)
                end

      saved_block = ctx.current_block
      saved_locals = ctx.save_locals
      assigned_vars = Set(String).new
      old_typeof_locals = @current_typeof_locals
      old_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = old_typeof_locals ? old_typeof_locals.dup : old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names ? old_typeof_local_names.dup : old_typeof_local_names

      ctx.push_scope(ScopeKind::Closure)
      closure_scope = ctx.current_scope
      body_block = ctx.create_block
      ctx.current_block = body_block

      if param_types.nil?
        if type_desc = @module.get_type_descriptor(ctx.type_of(proc_id))
          if type_desc.kind == TypeKind::Proc && type_desc.type_params.size > 1
            param_types = type_desc.type_params[0...-1]
          end
        end
      end

      param_ids = [] of ValueId
      if param_types
        param_types.each_with_index do |param_type, idx|
          name = "__arg#{idx}"
          param_val = Parameter.new(ctx.next_id, param_type, idx, name)
          ctx.emit(param_val)
          ctx.register_local(name, param_val.id)
          ctx.register_type(param_val.id, param_type)
          update_typeof_local(name, param_type)
          if param_type != TypeRef::VOID
            update_typeof_local_name(name, get_type_name_from_ref(param_type))
          end
          param_ids << param_val.id
        end
      end

      arg_types = param_ids.map { |param_id| ctx.type_of(param_id) }
      actual_name = resolve_method_call(ctx, proc_id, "call", arg_types, false)
      return_type = get_function_return_type(actual_name)
      if return_type == TypeRef::VOID
        if type_desc = @module.get_type_descriptor(ctx.type_of(proc_id))
          if type_desc.kind == TypeKind::Proc && type_desc.type_params.size > 1
            return_type = type_desc.type_params.last
          end
        end
      end

      call = Call.new(ctx.next_id, return_type, proc_id, actual_name, param_ids)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)

      if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
        ctx.terminate(Return.new(call.id))
      end

      @block_captures[body_block] = compute_block_captures(ctx, closure_scope, saved_locals, assigned_vars)

      ctx.current_block = saved_block
      ctx.restore_locals(saved_locals)
      @current_typeof_locals = old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names
      body_block
    ensure
      @inline_yield_proc_depth -= 1
    end

    # Build a synthetic BlockNode for block pass (&block) so yield inlining can substitute it.
    # The block body calls proc.call(__arg0, __arg1, ...)
    private def build_block_from_block_pass(
      proc_expr : ExprId,
      param_types : Array(TypeRef)?,
      span : CrystalV2::Compiler::Frontend::Span,
    ) : CrystalV2::Compiler::Frontend::BlockNode
      proc_node = @arena[proc_expr]
      param_count = if param_types
                      param_types.size
                    elsif proc_node.is_a?(CrystalV2::Compiler::Frontend::ProcLiteralNode) && (params = proc_node.params)
                      params.size
                    else
                      1
                    end

      params = [] of CrystalV2::Compiler::Frontend::Parameter
      arg_ids = [] of CrystalV2::Compiler::Frontend::ExprId
      if param_count > 0
        param_count.times do |idx|
          name = "__arg#{idx}"
          name_slice = name.to_slice
          params << CrystalV2::Compiler::Frontend::Parameter.new(name_slice, span: span, name_span: span)
          arg_ids << @arena.add_typed(CrystalV2::Compiler::Frontend::IdentifierNode.new(span, name_slice))
        end
      end

      if arg_ids.first? && block_pass_implicit_receiver?(proc_expr)
        rewritten = rewrite_block_pass_receiver(proc_expr, arg_ids.first, span)
        block_node = CrystalV2::Compiler::Frontend::BlockNode.new(span, params.empty? ? nil : params, [rewritten])
        @block_node_arenas[block_node.object_id] = @arena
        return block_node
      end

      call_member = @arena.add_typed(
        CrystalV2::Compiler::Frontend::MemberAccessNode.new(span, proc_expr, "call".to_slice)
      )
      call_expr = @arena.add_typed(
        CrystalV2::Compiler::Frontend::CallNode.new(span, call_member, arg_ids, nil)
      )

      block_node = CrystalV2::Compiler::Frontend::BlockNode.new(span, params.empty? ? nil : params, [call_expr])
      @block_node_arenas[block_node.object_id] = @arena
      block_node
    end

    private def block_pass_implicit_receiver?(expr_id : ExprId) : Bool
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::ImplicitObjNode,
           CrystalV2::Compiler::Frontend::SelfNode
        true
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        block_pass_implicit_receiver?(node.object)
      when CrystalV2::Compiler::Frontend::CallNode
        block_pass_implicit_receiver?(node.callee)
      else
        false
      end
    end

    private def rewrite_block_pass_receiver(
      expr_id : ExprId,
      arg_id : ExprId,
      span : CrystalV2::Compiler::Frontend::Span,
    ) : ExprId
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::ImplicitObjNode,
           CrystalV2::Compiler::Frontend::SelfNode
        arg_id
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        new_obj = rewrite_block_pass_receiver(node.object, arg_id, span)
        @arena.add_typed(CrystalV2::Compiler::Frontend::MemberAccessNode.new(node.span, new_obj, node.member))
      when CrystalV2::Compiler::Frontend::CallNode
        new_callee = rewrite_block_pass_receiver(node.callee, arg_id, span)
        @arena.add_typed(
          CrystalV2::Compiler::Frontend::CallNode.new(node.span, new_callee, node.args, node.block, node.named_args)
        )
      else
        expr_id
      end
    end

    # Scan proc body AST to collect referenced identifier names (for capture detection).
    # Simple recursive walk — handles common node types.
    private def collect_proc_body_identifiers(body : Array(ExprId)) : Set(String)
      names = Set(String).new
      body.each { |eid| collect_proc_body_ident_walk(eid, names) }
      names
    end

    private def collect_proc_body_ident_walk(expr_id : ExprId, names : Set(String))
      return if expr_id.index < 0 || expr_id.index >= @arena.size
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        names.add(String.new(node.name))
      when CrystalV2::Compiler::Frontend::BinaryNode
        collect_proc_body_ident_walk(node.left, names)
        collect_proc_body_ident_walk(node.right, names)
      when CrystalV2::Compiler::Frontend::UnaryNode
        collect_proc_body_ident_walk(node.operand, names)
      when CrystalV2::Compiler::Frontend::CallNode
        collect_proc_body_ident_walk(node.callee, names)
        node.args.each { |a| collect_proc_body_ident_walk(a, names) }
        if blk = node.block
          collect_proc_body_ident_walk(blk, names)
        end
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        collect_proc_body_ident_walk(node.object, names)
      when CrystalV2::Compiler::Frontend::IfNode
        collect_proc_body_ident_walk(node.condition, names)
        node.then_body.each { |e| collect_proc_body_ident_walk(e, names) }
        if eb = node.else_body
          eb.each { |e| collect_proc_body_ident_walk(e, names) }
        end
      when CrystalV2::Compiler::Frontend::WhileNode
        collect_proc_body_ident_walk(node.condition, names)
        node.body.each { |e| collect_proc_body_ident_walk(e, names) }
      when CrystalV2::Compiler::Frontend::AssignNode
        collect_proc_body_ident_walk(node.target, names)
        collect_proc_body_ident_walk(node.value, names)
      when CrystalV2::Compiler::Frontend::ReturnNode
        if v = node.value
          collect_proc_body_ident_walk(v, names)
        end
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        node.elements.each { |e| collect_proc_body_ident_walk(e, names) }
      when CrystalV2::Compiler::Frontend::StringInterpolationNode
        node.pieces.each do |piece|
          if e = piece.expr
            collect_proc_body_ident_walk(e, names)
          end
        end
      when CrystalV2::Compiler::Frontend::BlockNode
        node.body.each { |e| collect_proc_body_ident_walk(e, names) }
      when CrystalV2::Compiler::Frontend::TernaryNode
        collect_proc_body_ident_walk(node.condition, names)
        collect_proc_body_ident_walk(node.true_branch, names)
        collect_proc_body_ident_walk(node.false_branch, names)
      when CrystalV2::Compiler::Frontend::CaseNode
        if cond = node.value
          collect_proc_body_ident_walk(cond, names)
        end
        node.when_branches.each do |wb|
          wb.conditions.each { |c| collect_proc_body_ident_walk(c, names) }
          wb.body.each { |b| collect_proc_body_ident_walk(b, names) }
        end
        if eb = node.else_branch
          eb.each { |e| collect_proc_body_ident_walk(e, names) }
        end
      end
    end

    private def lower_proc_literal(
      ctx : LoweringContext,
      node : CrystalV2::Compiler::Frontend::ProcLiteralNode,
      param_type_override : Array(TypeRef)? = nil,
    ) : ValueId
      # Generate unique function name for the proc body
      proc_func_name = "__crystal_proc_#{@proc_function_counter}"
      @proc_function_counter += 1

      # Determine param types
      proc_param_types = [] of TypeRef
      if params = node.params
        params.each_with_index do |param, idx|
          if param_name = param.name
            param_type = if ta = param.type_annotation
                           type_ref_for_name(String.new(ta))
                         elsif param_type_override && (override = param_type_override[idx]?)
                           override
                         else
                           TypeRef::VOID
                         end
            proc_param_types << param_type
          end
        end
      end

      # Pre-determine return type (may be refined after lowering)
      proc_return_type = if rt = node.return_type
                           type_ref_for_name(String.new(rt))
                         else
                           TypeRef::VOID # Will be updated after body lowering
                         end

      # Create standalone function for the proc body
      proc_func = @module.create_function(proc_func_name, proc_return_type)
      proc_ctx = LoweringContext.new(proc_func, @module, @arena)

      # Collect proc param names (to exclude from capture detection)
      proc_param_names = Set(String).new
      if params = node.params
        params.each do |param|
          if param_name = param.name
            proc_param_names.add(String.new(param_name))
          end
        end
      end

      # Detect captures: scan proc body for identifiers that reference parent locals
      referenced_names = collect_proc_body_identifiers(node.body)
      parent_locals = ctx.save_locals  # {name => ValueId}
      captures = [] of {String, ValueId, TypeRef}  # {name, parent_value_id, type}
      referenced_names.each do |name|
        next if proc_param_names.includes?(name)
        next if name == "self"
        if parent_value_id = parent_locals[name]?
          parent_type = ctx.type_of(parent_value_id)
          next if parent_type == TypeRef::VOID
          captures << {name, parent_value_id, parent_type}
        end
      end

      # Add parameters to the standalone function
      if params = node.params
        params.each_with_index do |param, idx|
          if param_name = param.name
            name = String.new(param_name)
            param_type = proc_param_types[idx]? || TypeRef::VOID
            hir_param = proc_func.add_param(name, param_type)
            proc_ctx.register_local(name, hir_param.id)
            proc_ctx.register_type(hir_param.id, param_type)
            update_typeof_local(name, param_type)
            if ta = param.type_annotation
              update_typeof_local_name(name, String.new(ta))
            end
          end
        end
      end

      # Add captured variables as hidden extra parameters
      captures.each do |cap_name, _parent_vid, cap_type|
        hir_param = proc_func.add_param("__capture_#{cap_name}", cap_type)
        proc_ctx.register_local(cap_name, hir_param.id)
        proc_ctx.register_type(hir_param.id, cap_type)
      end

      # Save and lower body into the standalone function
      saved_class = @current_class
      saved_typeof_locals = @current_typeof_locals
      saved_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = saved_typeof_locals ? saved_typeof_locals.dup : nil
      @current_typeof_local_names = saved_typeof_local_names ? saved_typeof_local_names.dup : nil

      @inline_yield_proc_depth += 1
      last_value = begin
        lower_body(proc_ctx, node.body)
      ensure
        @inline_yield_proc_depth -= 1
      end

      # Terminate the proc function — always add Return unless already terminated with Return
      block = proc_func.get_block(proc_ctx.current_block)
      unless block.terminator.is_a?(Return)
        proc_ctx.terminate(Return.new(last_value))
      end

      # Update return type from actual lowered body type
      if proc_return_type == TypeRef::VOID
        actual_return_type = proc_ctx.type_of(last_value)
        if actual_return_type != TypeRef::VOID
          proc_return_type = actual_return_type
          proc_func.return_type = proc_return_type
        end
      end

      @current_class = saved_class
      @current_typeof_locals = saved_typeof_locals
      @current_typeof_local_names = saved_typeof_local_names

      # Compute proc type (user-visible, does NOT include captures)
      proc_type = @module.intern_type(TypeDescriptor.new(TypeKind::Proc, "Proc", proc_param_types + [proc_return_type]))

      # Return FuncPointer in caller's context, registered with Proc type
      fp = FuncPointer.new(ctx.next_id, proc_type, proc_func_name)
      ctx.emit(fp)
      ctx.register_type(fp.id, proc_type)

      # Store capture parent value IDs for use at call site
      if !captures.empty?
        capture_parent_ids = captures.map { |_, parent_vid, _| parent_vid }
        @proc_captures_by_value[fp.id] = capture_parent_ids
      end

      fp.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # COLLECTIONS
    # ═══════════════════════════════════════════════════════════════════════

    # Find common ancestor class for two class names by walking parent chains.
    private def find_common_ancestor_class(a : String, b : String) : String?
      return a if a == b
      # Build ancestor chain for a
      ancestors_a = [a]
      current = a
      while parent = @class_info[current]?.try(&.parent_name)
        break if parent.empty?
        ancestors_a << parent
        current = parent
      end
      # Walk b's ancestor chain and find first match
      current = b
      return current if ancestors_a.includes?(current)
      while parent = @class_info[current]?.try(&.parent_name)
        break if parent.empty?
        current = parent
        return current if ancestors_a.includes?(current)
      end
      nil
    end

    private def lower_array_literal(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::ArrayLiteralNode) : ValueId
      element_ids = node.elements.map { |e| lower_expr(ctx, e) }

      # Determine element type from explicit `of` type, or from elements (or Int32 default)
      element_type_name = nil
      element_type = if of_type = node.of_type
                       if type_str = stringify_type_expr(of_type)
                         element_type_name = normalize_declared_type_name(type_str)
                         type_ref_for_name(element_type_name)
                       else
                         element_ids.size > 0 ? ctx.type_of(element_ids.first) : TypeRef::INT32
                       end
                     elsif element_ids.size > 0
                       first_type = ctx.type_of(element_ids.first)
                       # Check if all elements have the same type
                       all_same = element_ids.all? { |id| ctx.type_of(id) == first_type }
                       if all_same
                         first_type
                       else
                         # Mixed types — find common ancestor class
                         type_names = element_ids.map { |id| get_type_name_from_ref(ctx.type_of(id)) }.uniq
                         ancestor = type_names.reduce { |a, b| find_common_ancestor_class(a, b) || a }
                         if ancestor && ancestor != "Unknown" && ancestor != "Void"
                           element_type_name = ancestor
                           type_ref_for_name(ancestor)
                         else
                           first_type
                         end
                       end
                     else
                       TypeRef::INT32
                     end

      # Create ArrayLiteral instruction (not generic Allocate)
      arr = ArrayLiteral.new(ctx.next_id, element_type, element_ids)
      arr.lifetime = LifetimeTag::StackLocal # Default to stack until escape analysis
      ctx.emit(arr)
      element_type_name ||= get_type_name_from_ref(element_type)
      if element_type_name != "Unknown" && element_type_name != "Void"
        array_type = type_ref_for_name("Array(#{element_type_name})")
        ctx.register_type(arr.id, array_type)
      else
        # Fallback when element type is unresolved.
        ctx.register_type(arr.id, TypeRef::POINTER)
      end
      arr.id
    end

    private def lower_hash_literal(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::HashLiteralNode) : ValueId
      # Lower key-value pairs first to infer types
      entries = [] of {ValueId, ValueId}
      node.entries.each do |entry|
        key_id = lower_expr(ctx, entry.key)
        value_id = lower_expr(ctx, entry.value)
        entries << {key_id, value_id}
      end

      key_type = if key_type_expr = node.of_key_type
                   type_ref_for_name(normalize_declared_type_name(String.new(key_type_expr)))
                 elsif entries.size > 0
                   ctx.type_of(entries[0][0])
                 else
                   TypeRef::VOID
                 end
      value_type = if value_type_expr = node.of_value_type
                     type_ref_for_name(normalize_declared_type_name(String.new(value_type_expr)))
                   elsif entries.size > 0
                     ctx.type_of(entries[0][1])
                   else
                     TypeRef::VOID
                   end
      key_name = get_type_name_from_ref(key_type)
      value_name = get_type_name_from_ref(value_type)
      hash_type_name = "Hash(#{key_name}, #{value_name})"
      hash_type = type_ref_for_name(hash_type_name)

      # Direct allocation via runtime helper — bypasses broken constructor overload chains
      # (Hash.new has multiple overloads that become dead-code stubs calling each other
      # when V is a pointer type like String)
      type_id_lit = Literal.new(ctx.next_id, TypeRef::INT32, hash_type.id.to_i64)
      ctx.emit(type_id_lit)
      ctx.register_type(type_id_lit.id, TypeRef::INT32)
      hash_call = ExternCall.new(ctx.next_id, hash_type, "__crystal_v2_hash_new", [type_id_lit.id] of ValueId)
      ctx.emit(hash_call)
      ctx.register_type(hash_call.id, hash_type)

      # For each entry, call hash[key] = value
      entries.each do |key_id, value_id|
        set_name = "#{hash_type_name}#[]="
        set_call = Call.new(ctx.next_id, value_type, hash_call.id, set_name, [key_id, value_id], nil, false)
        ctx.emit(set_call)
      end

      hash_call.id
    end

    private def lower_tuple_literal(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::TupleLiteralNode) : ValueId
      element_ids = node.elements.map { |e| lower_expr(ctx, e) }

      element_names = element_ids.map { |id| get_type_name_from_ref(ctx.type_of(id)) }
      normalized_names = element_names.map do |name|
        (name == "Void" || name == "Unknown") ? "Unknown" : name
      end
      tuple_type = type_ref_for_name("Tuple(#{normalized_names.join(", ")})")
      alloc = Allocate.new(ctx.next_id, tuple_type, element_ids)
      ctx.emit(alloc)
      record_allocation_location(ctx, alloc.id, @arena, node)
      alloc.id
    end

    private def lower_named_tuple_literal(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::NamedTupleLiteralNode) : ValueId
      # NamedTuple is like a Tuple but with named fields
      # For now, we treat it similarly to a Tuple - lowering values in order
      # The key names are available for type-level operations
      element_ids = node.entries.map { |entry| lower_expr(ctx, entry.value) }

      # Create a NamedTuple type based on keys
      # For simplicity, use NamedTuple as the type (real Crystal has specialized types)
      named_tuple_type = ctx.get_type("NamedTuple")
      alloc = Allocate.new(ctx.next_id, named_tuple_type, element_ids)
      ctx.emit(alloc)
      record_allocation_location(ctx, alloc.id, @arena, node)
      alloc.id
    end

    private def lower_range(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::RangeNode) : ValueId
      begin_id = lower_expr(ctx, node.begin_expr)
      end_id = lower_expr(ctx, node.end_expr)

      # Include exclusive flag as third argument
      excl_lit = Literal.new(ctx.next_id, TypeRef::BOOL, node.exclusive)
      ctx.emit(excl_lit)

      begin_name = get_type_name_from_ref(ctx.type_of(begin_id))
      end_name = get_type_name_from_ref(ctx.type_of(end_id))
      range_type_name = if begin_name == "Unknown" || end_name == "Unknown" ||
                           begin_name.includes?('|') || end_name.includes?('|')
                          "Range"
                        else
                          "Range(#{begin_name}, #{end_name})"
                        end
      range_type = type_ref_for_name(range_type_name)
      alloc = Allocate.new(ctx.next_id, range_type, [begin_id, end_id, excl_lit.id])
      ctx.emit(alloc)
      record_allocation_location(ctx, alloc.id, @arena, node)
      alloc.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # TYPE OPERATIONS
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_as(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::AsNode) : ValueId
      value_id = lower_expr(ctx, node.expression)
      # target_type is Slice(UInt8) - type name as bytes
      target_type = type_ref_for_name(String.new(node.target_type))

      # Check if value is union type - use UnionUnwrap instead of Cast
      value_type = ctx.type_of(value_id)
      if is_union_type?(value_type)
        variant_id = get_union_variant_id(value_type, target_type)
        if variant_id >= 0
          # Unsafe unwrap - assumes type_id matches (caller should have checked with is_a?)
          unwrap = UnionUnwrap.new(ctx.next_id, target_type, value_id, variant_id, safe: false)
          ctx.emit(unwrap)
          return unwrap.id
        end
      end

      # Regular cast for non-union types
      cast = Cast.new(ctx.next_id, target_type, value_id, target_type, safe: false)
      ctx.emit(cast)
      cast.id
    end

    private def lower_as_question(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::AsQuestionNode) : ValueId
      value_id = lower_expr(ctx, node.expression)
      # target_type is Slice(UInt8) - type name as bytes
      target_type = type_ref_for_name(String.new(node.target_type))

      cast = Cast.new(ctx.next_id, target_type, value_id, target_type, safe: true)
      ctx.emit(cast)
      cast.id
    end

    private def lower_is_a(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::IsANode) : ValueId
      value_id = lower_expr(ctx, node.expression)
      # target_type is Slice(UInt8) - type name as bytes
      target_name = String.new(node.target_type)
      check_type = type_ref_for_name(target_name)

      # Check if value is a union type - use UnionIs for runtime type check
      value_type = ctx.type_of(value_id)
      if is_union_type?(value_type)
        # Get the variant_type_id for the check_type within this union
        variant_id = get_union_variant_id(value_type, check_type)
        if variant_id >= 0
          union_is = UnionIs.new(ctx.next_id, value_id, variant_id)
          ctx.emit(union_is)
          return union_is.id
        end
      end

      # Try to resolve is_a? statically using known type hierarchies.
      # This is critical for primitive types (Int32, etc.) where runtime type_id
      # loads from value types would crash (no object header).
      if value_name = primitive_class_name(value_type)
        # Try with original target name first (e.g., "Int::Signed")
        static_result = primitive_is_a_hierarchy?(value_name, target_name)
        if static_result.nil?
          # Try with resolved target (might be a union like "Int8 | Int16 | ...")
          resolved_target = resolve_type_name_in_context(target_name)
          resolved_target = resolve_type_alias_chain(resolved_target)
          if resolved_target.includes?('|')
            # Union type — check if value_name is one of the variants
            variants = resolved_target.split("|").map(&.strip)
            static_result = variants.includes?(value_name)
          else
            static_result = primitive_is_a_hierarchy?(value_name, resolved_target)
          end
        end
        unless static_result.nil?
          lit = Literal.new(ctx.next_id, TypeRef::BOOL, static_result)
          ctx.emit(lit)
          ctx.register_type(lit.id, TypeRef::BOOL)
          return lit.id
        end
      end
      # Also try statically_is_a_type? for non-primitive types
      static = statically_is_a_type?(value_type, check_type)
      unless static.nil?
        lit = Literal.new(ctx.next_id, TypeRef::BOOL, static)
        ctx.emit(lit)
        ctx.register_type(lit.id, TypeRef::BOOL)
        return lit.id
      end

      # Regular is_a check for non-union types
      is_a = IsA.new(ctx.next_id, value_id, check_type)
      ctx.emit(is_a)
      is_a.id
    end

    private def lower_responds_to(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::RespondsToNode) : ValueId
      value_id = lower_expr(ctx, node.expression)
      value_type = ctx.type_of(value_id)

      # Get method name from the symbol literal
      method_name_node = @arena[node.method_name]
      method_name = case method_name_node
                    when CrystalV2::Compiler::Frontend::SymbolNode
                      String.new(method_name_node.name)
                    else
                      ""
                    end

      # Try to determine at compile time if the type responds to this method
      type_desc = @module.get_type_descriptor(value_type)
      class_name = type_desc ? type_desc.name : nil

      result = false
      if class_name && !method_name.empty?
        # Check if the class has this method
        # O(1) lookup: check exact match or mangled version exists
        full_method = "#{class_name}.#{method_name}"
        result = @function_types.has_key?(full_method) || has_function_base?(full_method)
      end

      # Return compile-time constant boolean
      bool_lit = Literal.new(ctx.next_id, TypeRef::BOOL, result)
      ctx.emit(bool_lit)
      bool_lit.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # HELPERS
    # ═══════════════════════════════════════════════════════════════════════

    # Sequential lowering (method/def bodies) should stop after a terminal
    # instruction. Crystal still type-checks unreachable code, but codegen must
    # not emit calls from it, or we can end up monomorphizing "dead" generic
    # instantiations and triggering spurious missing symbols at link time.
    private def should_stop_sequential_lowering?(ctx : LoweringContext) : Bool
      block = ctx.get_block(ctx.current_block)
      term = block.terminator

      # Explicit return always terminates the current control-flow path.
      return true if term.is_a?(Return)

      # We use Unreachable as both a default placeholder terminator and the
      # explicit terminator for `raise`. Disambiguate by checking whether this
      # block actually ends in a Raise instruction.
      if term.is_a?(Unreachable)
        insts = block.instructions
        if insts.size > 0
          last = insts[insts.size - 1]
          return true if last.is_a?(Raise)
          prev = insts.size > 1 ? insts[insts.size - 2] : nil
          return true if prev && prev.is_a?(Raise)
        end
      end

      false
    end

    private def lower_body(ctx : LoweringContext, body : Array(ExprId)) : ValueId
      last_value : ValueId? = nil
      progress_filter = env_get("DEBUG_LOWER_PROGRESS")
      progress_match = nil
      if progress_filter && @current_class && @current_method
        method_name = "#{@current_class}##{@current_method}"
        progress_match = progress_filter == "1" || method_name.includes?(progress_filter)
      end
      progress_every = env_get("DEBUG_LOWER_PROGRESS_EVERY").try(&.to_i?)
      slow_only = env_has?("DEBUG_LOWER_SLOW_ONLY")
      body.each_with_index do |expr_id, idx|
        next if expr_id.invalid?
        if progress_match && !slow_only
          if progress_every && progress_every > 0
            if idx % progress_every == 0
              STDERR.puts "[LOWER_PROGRESS] method=#{@current_class}##{@current_method} idx=#{idx}/#{body.size}"
            end
          else
            node = @arena[expr_id]
            STDERR.puts "[LOWER_PROGRESS] method=#{@current_class}##{@current_method} idx=#{idx} node=#{node.class.name}"
          end
        end
        if progress_match
          start_time = Time.instant
          last_value = lower_expr(ctx, expr_id)
          elapsed_ms = (Time.instant - start_time).total_milliseconds
          slow_threshold = 200.0
          if threshold_str = env_get("DEBUG_LOWER_SLOW_MS")
            slow_threshold = threshold_str.to_f? || 200.0
          end
          if elapsed_ms >= slow_threshold
            node = @arena[expr_id]
            call_name = nil
            if node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
              callee_node = @arena[node.callee]
              case callee_node
              when CrystalV2::Compiler::Frontend::IdentifierNode
                call_name = String.new(callee_node.name)
              when CrystalV2::Compiler::Frontend::PathNode
                right_node = @arena[callee_node.right]
                case right_node
                when CrystalV2::Compiler::Frontend::IdentifierNode
                  call_name = String.new(right_node.name)
                when CrystalV2::Compiler::Frontend::ConstantNode
                  call_name = String.new(right_node.name)
                end
              end
            end
            if source = @sources_by_arena[@arena]?
              span = node.span
              start = span.start_offset
              length = span.end_offset - span.start_offset
              if length > 0 && start >= 0 && start < source.bytesize
                slice_len = length > 80 ? 80 : length
                snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
                extra = call_name ? " call=#{call_name}" : ""
                STDERR.puts "[LOWER_SLOW_BODY] method=#{@current_class}##{@current_method} idx=#{idx} #{elapsed_ms.round(1)}ms node=#{node.class.name}#{extra} \"#{snippet}\""
              else
                extra = call_name ? " call=#{call_name}" : ""
                STDERR.puts "[LOWER_SLOW_BODY] method=#{@current_class}##{@current_method} idx=#{idx} #{elapsed_ms.round(1)}ms node=#{node.class.name}#{extra}"
              end
            else
              extra = call_name ? " call=#{call_name}" : ""
              STDERR.puts "[LOWER_SLOW_BODY] method=#{@current_class}##{@current_method} idx=#{idx} #{elapsed_ms.round(1)}ms node=#{node.class.name}#{extra}"
            end
          end
        else
          last_value = lower_expr(ctx, expr_id)
        end
        break if should_stop_sequential_lowering?(ctx)
      end

      last_value || begin
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      end
    end

    private def get_type_name(expr_id : ExprId) : String
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::PathNode
        String.new(node.names.first)
      when CrystalV2::Compiler::Frontend::GenericNode
        String.new(node.name)
      when CrystalV2::Compiler::Frontend::IdentifierNode
        String.new(node.name)
      else
        "Unknown"
      end
    end

    # Sanitize malformed type names with unbalanced parentheses
    private def sanitize_type_name(name : String) : String
      name = normalize_missing_generic_parens(name)
      # Handle union types by sanitizing each part separately, without splitting
      # unions nested inside generics.
      if name.includes?('|')
        parts = split_union_type_name(name).map { |part| sanitize_type_name_part(part.strip) }
        return parts.join(" | ")
      end

      sanitize_type_name_part(name)
    end

    private def sanitize_type_name_part(name : String) : String
      name = normalize_missing_generic_parens(name)

      if info = split_generic_base_and_args(name)
        args = split_generic_type_args(info[:args]).map do |arg|
          sanitize_type_name(arg.strip)
        end
        name = "#{info[:base]}(#{args.join(", ")})"
      end

      # Count parens to check balance
      open_count = name.count('(')
      close_count = name.count(')')

      return name if open_count == close_count

      # Remove extra closing parens - find and remove unbalanced ones
      if close_count > open_count
        result = String::Builder.new
        depth = 0
        extra_close = close_count - open_count

        name.each_char do |c|
          case c
          when '('
            depth += 1
            result << c
          when ')'
            if depth > 0
              depth -= 1
              result << c
            else
              # This is an unbalanced close paren
              if extra_close > 0
                extra_close -= 1
                # Skip this paren
              else
                result << c
              end
            end
          else
            result << c
          end
        end

        return normalize_missing_generic_parens(result.to_s)
      end

      # Remove extra opening parens from the end (less common)
      if open_count > close_count
        result = String::Builder.new
        depth = 0
        extra_open = open_count - close_count

        # Reverse scan to find unbalanced opens at end
        chars = name.chars.reverse
        kept_chars = [] of Char

        chars.each do |c|
          case c
          when ')'
            depth += 1
            kept_chars << c
          when '('
            if depth > 0
              depth -= 1
              kept_chars << c
            else
              if extra_open > 0
                extra_open -= 1
              else
                kept_chars << c
              end
            end
          else
            kept_chars << c
          end
        end

        return normalize_missing_generic_parens(kept_chars.reverse.join)
      end

      name
    end

    # Fix cases like "TupleString, String" (missing parens around args).
    # Only applies when there is a comma but no "(" to avoid changing valid names.
    private def normalize_missing_generic_parens(name : String) : String
      return name if name.empty?
      return name if name.includes?('(')
      return name unless name.includes?(',')
      return name if name.includes?("->")
      # `Foo::{A, B}` is not a generic instantiation. It represents a tuple
      # literal in a namespace (used by some internal type printers). Don't
      # rewrite it into `Foo({A, B})` because that collapses arity and can
      # trigger invalid monomorphization like `Hash(Tuple(K, V))`.
      return name if name.includes?("::{")

      # Handle "Tuple::String, String" (generic base + "::" + args).
      if idx = name.rindex("::")
        prefix = name[0, idx]
        suffix = name[idx + 2..]
        base = last_namespace_component(prefix)
        if (BUILTIN_GENERIC_BASES.includes?(base) || @generic_templates.has_key?(base)) &&
           suffix && !suffix.empty?
          rest = suffix.strip
          return name if rest.empty? || rest.ends_with?(',')
          normalized = "#{base}(#{rest})"
          head = prefix.byte_slice(0, prefix.bytesize - base.bytesize)
          return head.empty? ? normalized : "#{head}#{normalized}"
        end
      end

      prefix = ""
      suffix_start = 0
      if idx = name.rindex("::")
        prefix = name[0, idx + 2]
        suffix_start = idx + 2
      end
      suffix = name[suffix_start..]
      base = generic_base_prefix_for_missing_parens(suffix)
      return name unless base
      rest = suffix.byte_slice(base.bytesize, suffix.bytesize - base.bytesize).strip
      return name if rest.empty? || rest.ends_with?(',')

      normalized = "#{base}(#{rest})"
      return normalized if prefix.empty?

      qualified = "#{prefix}#{normalized}"
      if BUILTIN_GENERIC_BASES.includes?(base) && !type_name_exists?(qualified)
        return normalized
      end
      qualified
    end

    private def generic_base_prefix_for_missing_parens(name : String) : String?
      BUILTIN_GENERIC_BASES.each do |base|
        next unless name.starts_with?(base)
        next if name.bytesize <= base.bytesize
        return base
      end
      @generic_templates.each_key do |base|
        next unless name.starts_with?(base)
        next if name.bytesize <= base.bytesize
        return base
      end
      nil
    end

    private def normalize_tuple_literal_type_name(name : String) : String
      trimmed = name.strip
      return trimmed unless trimmed.starts_with?('{') && trimmed.ends_with?('}')

      inner = trimmed[1, trimmed.size - 2]
      tuple_args = split_generic_type_args(inner)
      "Tuple(#{tuple_args.join(", ")})"
    end

    private def type_cache_context : String?
      @current_namespace_override || @current_class
    end

    private def type_cache_key(name : String) : String
      return name if name.empty?
      return name if name.starts_with?("::")
      return name if name.includes?("::")
      return name if @top_level_type_names.includes?(name)
      return name if builtin_alias_target?(name) || LIBC_TYPE_ALIASES.has_key?(name)
      return name if BUILTIN_TYPE_NAMES.includes?(name)
      if name.includes?('(')
        base = strip_generic_args(name)
        return name if BUILTIN_GENERIC_BASES.includes?(base)
      end
      context = type_cache_context
      return name if context.nil? || context.empty?
      "#{context}::#{name}"
    end

    private def register_type_cache_key(cache_key : String) : Nil
      return if cache_key.empty?
      # Track generic prefix keys like "Foo(" at the start.
      if idx = cache_key.index("::")
        first_segment = cache_key[0, idx]
        base = strip_generic_args(first_segment)
        if !base.empty? && cache_key.starts_with?("#{base}(")
          set = @type_cache_keys_by_generic_prefix[base]? || begin
            created = Set(String).new
            @type_cache_keys_by_generic_prefix[base] = created
            created
          end
          set << cache_key
        end
      else
        base = strip_generic_args(cache_key)
        if !base.empty? && cache_key.starts_with?("#{base}(")
          set = @type_cache_keys_by_generic_prefix[base]? || begin
            created = Set(String).new
            @type_cache_keys_by_generic_prefix[base] = created
            created
          end
          set << cache_key
        end
      end

      # Avoid split allocations; walk namespace segments and index nested ones.
      seg_start = 0
      seg_index = 0
      i = 0
      bytesize = cache_key.bytesize
      while i < bytesize
        if cache_key.to_unsafe[i] == ':'.ord && i + 1 < bytesize && cache_key.to_unsafe[i + 1] == ':'.ord
          if seg_index > 0
            part = cache_key.byte_slice(seg_start, i - seg_start)
            base = strip_generic_args(part)
            unless base.empty?
              set = @type_cache_keys_by_component[base]? || begin
                created = Set(String).new
                @type_cache_keys_by_component[base] = created
                created
              end
              set << cache_key
            end
          end
          seg_index += 1
          i += 2
          seg_start = i
          next
        end
        i += 1
      end
      if seg_index > 0 && seg_start < bytesize
        part = cache_key.byte_slice(seg_start, bytesize - seg_start)
        base = strip_generic_args(part)
        unless base.empty?
          set = @type_cache_keys_by_component[base]? || begin
            created = Set(String).new
            @type_cache_keys_by_component[base] = created
            created
          end
          set << cache_key
        end
      end
    end

    private def store_type_cache(cache_key : String, type_ref : TypeRef) : TypeRef
      @type_cache[cache_key] = type_ref
      register_type_cache_key(cache_key)
      type_ref
    end

    # Fast helper to get last component of a namespace path (e.g., "Foo::Bar::Baz" -> "Baz")
    # Avoids allocating an array like split("::").last would
    @[AlwaysInline]
    private def last_namespace_component(name : String) : String
      if idx = name.rindex("::")
        name[(idx + 2)..]
      else
        name
      end
    end

    # Returns last component only if name contains "::", otherwise nil
    @[AlwaysInline]
    private def last_namespace_component_if_nested(name : String) : String?
      if idx = name.rindex("::")
        name[(idx + 2)..]
      else
        nil
      end
    end

    @[AlwaysInline]
    private def namespace_bucket_for(name : String) : String
      if idx = name.index("::")
        name[0, idx]
      else
        name
      end
    end

    @[AlwaysInline]
    private def first_namespace_component(name : String) : String
      if idx = name.index("::")
        name[0, idx]
      else
        name
      end
    end

    private def current_type_name_context_key : TypeNameContextKey?
      override = @current_namespace_override
      current = @current_class
      locals = @current_typeof_local_names
      locals_hash = 0_u64
      if locals && !locals.empty?
        owner = locals.object_id
        if @current_typeof_local_names_hash_owner == owner
          locals_hash = @current_typeof_local_names_hash
        else
          locals_hash = locals.hash
          @current_typeof_local_names_hash = locals_hash
          @current_typeof_local_names_hash_owner = owner
        end
      end
      type_params_hash = 0_u64
      if !@type_param_map.empty?
        owner = @type_param_map.object_id
        if @type_param_map_hash_owner == owner
          type_params_hash = @type_param_map_hash_value
        else
          type_params_hash = @type_param_map.hash
          @type_param_map_hash_value = type_params_hash
          @type_param_map_hash_owner = owner
        end
      end
      return nil if override.nil? && current.nil? && locals_hash == 0_u64 && type_params_hash == 0_u64
      TypeNameContextKey.new(override, current, locals_hash, type_params_hash)
    end

    private def resolved_type_name_cache_get(name : String) : String?
      if ctx = current_type_name_context_key
        if @resolved_type_name_last_entry_ctx == ctx && @resolved_type_name_last_entry_name_id == name.object_id
          if value = @resolved_type_name_last_entry_value
            invalid = @resolved_type_name_invalidations[name]?
            if invalid.nil? || @resolved_type_name_last_entry_epoch >= invalid
              record_cache_stat("resolved_type_ctx", true)
              return value
            end
          end
        end
        map = nil
        if @resolved_type_name_cache_last_ctx_key == ctx
          map = @resolved_type_name_cache_last_ctx_map
        end
        unless map
          map = @resolved_type_name_cache_by_ctx[ctx]?
          @resolved_type_name_cache_last_ctx_key = ctx
          @resolved_type_name_cache_last_ctx_map = map
        end
        if map
          if entry = map[name]?
            if resolved_type_name_cache_entry_valid?(name, entry)
              record_cache_stat("resolved_type_ctx", true)
              @resolved_type_name_last_entry_ctx = ctx
              @resolved_type_name_last_entry_name_id = name.object_id
              @resolved_type_name_last_entry_value = entry.value
              @resolved_type_name_last_entry_epoch = entry.epoch
              return entry.value
            end
          end
          record_cache_stat("resolved_type_ctx", false)
          return nil
        end
        record_cache_stat("resolved_type_ctx", false)
        nil
      else
        if entry = @resolved_type_name_cache_global[name]?
          if resolved_type_name_cache_entry_valid?(name, entry)
            record_cache_stat("resolved_type_global", true)
            return entry.value
          end
        end
        record_cache_stat("resolved_type_global", false)
        nil
      end
    end

    private def resolved_type_name_cache_set(name : String, value : String) : Nil
      if ctx = current_type_name_context_key
        map = nil
        if @resolved_type_name_cache_last_ctx_key == ctx
          map = @resolved_type_name_cache_last_ctx_map
        end
        unless map
          map = @resolved_type_name_cache_by_ctx[ctx]?
        end
        unless map
          map = {} of String => ResolvedTypeNameCacheEntry
          @resolved_type_name_cache_by_ctx[ctx] = map
        end
        entry = ResolvedTypeNameCacheEntry.new(value, @resolved_type_name_cache_epoch)
        map[name] = entry
        @resolved_type_name_cache_last_ctx_key = ctx
        @resolved_type_name_cache_last_ctx_map = map
        @resolved_type_name_last_entry_ctx = ctx
        @resolved_type_name_last_entry_name_id = name.object_id
        @resolved_type_name_last_entry_value = value
        @resolved_type_name_last_entry_epoch = entry.epoch
      else
        @resolved_type_name_cache_global[name] = ResolvedTypeNameCacheEntry.new(value, @resolved_type_name_cache_epoch)
      end
    end

    private def invalidate_resolved_type_name_cache_for(name : String) : Nil
      short = last_namespace_component_if_nested(name)
      @resolved_type_name_cache_epoch &+= 1
      @resolved_type_name_invalidations[name] = @resolved_type_name_cache_epoch
      @resolved_type_name_invalidations[short] = @resolved_type_name_cache_epoch if short
    end

    private def resolved_type_name_cache_entry_valid?(name : String, entry : ResolvedTypeNameCacheEntry) : Bool
      if invalid = @resolved_type_name_invalidations[name]?
        entry.epoch >= invalid
      else
        true
      end
    end

    private def invalidate_type_literal_cache_for(name : String) : Nil
      return if @type_literal_class_cache.empty?
      short = last_namespace_component_if_nested(name)
      suffix_class = "#{name}.class"
      suffix_meta = "#{name}.metaclass"
      suffix_short_class = short ? "#{short}.class" : nil
      suffix_short_meta = short ? "#{short}.metaclass" : nil
      keys = [] of String
      @type_literal_class_cache.each_key do |key|
        if key.ends_with?(suffix_class) || key.ends_with?(suffix_meta) ||
           (suffix_short_class && key.ends_with?(suffix_short_class)) ||
           (suffix_short_meta && key.ends_with?(suffix_short_meta))
          keys << key
        end
      end
      keys.each { |key| @type_literal_class_cache.delete(key) }
    end

    private def invalidate_type_cache_for_namespace(name : String) : Nil
      return if name.empty?
      invalidate_resolved_type_name_cache_for(name)
      invalidate_type_literal_cache_for(name)
      keys = [] of String
      if @type_cache.has_key?(name)
        keys << name
      end
      if entries = @type_cache_keys_by_component[name]?
        entries.each { |entry| keys << entry }
      end
      if entries = @type_cache_keys_by_generic_prefix[name]?
        entries.each { |entry| keys << entry }
      end

      # Only compute short name if the name contains "::"
      if short = last_namespace_component_if_nested(name)
        if @type_cache.has_key?(short)
          keys << short
        end
        if entries = @type_cache_keys_by_component[short]?
          entries.each { |entry| keys << entry }
        end
        if entries = @type_cache_keys_by_generic_prefix[short]?
          entries.each { |entry| keys << entry }
        end
      end

      keys.each { |key| @type_cache.delete(key) }
    end

    private def invalidate_type_cache_for_macro_output(output : String) : Nil
      return if output.empty?
      return unless output.matches?(/\b(class|module|struct|enum|lib|alias)\b/)

      if context = type_cache_context
        invalidate_type_cache_for_namespace(context)
      else
        @type_cache.clear
        @type_cache_keys_by_component.clear
        @type_cache_keys_by_generic_prefix.clear
        @resolved_type_name_cache_global.clear
        @resolved_type_name_cache_by_ctx.clear
        @resolved_type_name_invalidations.clear
        @resolved_type_name_cache_epoch = 0
        @resolved_type_name_last_entry_ctx = nil
        @resolved_type_name_last_entry_name_id = 0_u64
        @resolved_type_name_last_entry_value = nil
        @resolved_type_name_last_entry_epoch = 0
        @type_literal_class_cache.clear
        @type_name_normalize_cache.clear
      end
    end

    # Parse types from mangled name suffix (e.g., "Pointer(LibC::Kevent)_Int32" -> [Pointer(LibC::Kevent), Int32])
    private def parse_types_from_suffix(suffix : String) : Array(TypeRef)
      result = [] of TypeRef
      return result if suffix.empty?

      # Split on underscores, but handle parentheses for generic types
      parts = [] of String
      current = String::Builder.new
      paren_depth = 0

      suffix.each_char do |ch|
        case ch
        when '('
          paren_depth += 1
          current << ch
        when ')'
          paren_depth -= 1
          current << ch
        when '_'
          if paren_depth > 0
            current << ch
          else
            part = current.to_s
            parts << part unless part.empty?
            current = String::Builder.new
          end
        else
          current << ch
        end
      end
      final_part = current.to_s
      parts << final_part unless final_part.empty?

      parts.each do |part|
        # Skip mangling markers that are not types (block/named/splat/arity).
        next if part == "block" || part == "named" || part == "splat" || part == "double" || part == "double_splat"
        next if part.starts_with?("arity")
        # Convert mangled type name back to Crystal type name
        # e.g., "Pointer(LibC::Kevent)" stays as is
        # e.g., "LibC__Kevent" -> "LibC::Kevent"
        type_name = part.gsub("__", "::")
        type_ref = type_ref_for_name(type_name)
        result << type_ref if type_ref != TypeRef::VOID
      end

      result
    end

    private def merge_call_arg_types_from_suffix(
      call_types : Array(TypeRef),
      parsed_types : Array(TypeRef),
    ) : Array(TypeRef)
      return call_types if parsed_types.empty? || call_types.empty?
      return call_types if parsed_types.size != call_types.size

      merged = call_types.dup
      parsed_types.each_with_index do |parsed, idx|
        next if parsed == TypeRef::VOID
        if merged[idx] == TypeRef::VOID
          merged[idx] = parsed
          next
        end
        call_desc = @module.get_type_descriptor(merged[idx])
        parsed_desc = @module.get_type_descriptor(parsed)
        next unless call_desc && parsed_desc
        next unless call_desc.kind == TypeKind::Module && parsed_desc.kind == TypeKind::Module

        call_name = resolve_type_alias_chain(call_desc.name)
        parsed_name = resolve_type_alias_chain(parsed_desc.name)
        if parsed_name.starts_with?("#{call_name}::")
          merged[idx] = parsed
        end
      end

      merged
    end

    private def call_type_satisfies_signature?(call_type : TypeRef, sig_type : TypeRef) : Bool
      return true if sig_type == TypeRef::VOID
      return true if call_type == sig_type
      return true if is_union_type?(sig_type) && get_union_variant_id(sig_type, call_type) >= 0

      call_desc = @module.get_type_descriptor(call_type)
      sig_desc = @module.get_type_descriptor(sig_type)
      return false unless call_desc && sig_desc

      call_name = resolve_type_alias_chain(call_desc.name)
      sig_name = resolve_type_alias_chain(sig_desc.name)
      return true if call_name == sig_name

      # Allow specialized generic instances to satisfy base generic restrictions:
      #   sig: Array, call: Array(Int32)
      #   sig: Pointer, call: Pointer(UInt8)
      call_base = strip_generic_args(call_name)
      sig_base = strip_generic_args(sig_name)
      return true if sig_name == sig_base && call_base == sig_base

      # Allow nested module names to satisfy module restrictions:
      #   sig: IO::ByteFormat, call: IO::ByteFormat::LittleEndian
      if sig_desc.kind == TypeKind::Module && call_desc.kind == TypeKind::Module
        return true if call_name.starts_with?("#{sig_name}::")
      end

      false
    end

    private def signature_param_types_for_suffix_merge(node : CrystalV2::Compiler::Frontend::DefNode) : Array(TypeRef)
      types = [] of TypeRef
      if params = node.params
        params.each do |param|
          next if named_only_separator?(param) || param.is_block
          if ta = param.type_annotation
            types << type_ref_for_name(String.new(ta))
          elsif param.is_double_splat
            types << type_ref_for_name("NamedTuple")
          else
            types << TypeRef::VOID
          end
        end
      end
      types
    end

    private def merge_call_arg_types_from_suffix_with_signature(
      call_types : Array(TypeRef),
      parsed_types : Array(TypeRef),
      node : CrystalV2::Compiler::Frontend::DefNode,
    ) : Array(TypeRef)
      return call_types if parsed_types.empty? || call_types.empty?

      sig_types = signature_param_types_for_suffix_merge(node)
      return call_types if sig_types.empty? || sig_types.size != call_types.size

      # Align parsed types to parameter positions. If parsed types cover all params,
      # treat them as positional. Otherwise, treat them as "typed params only" and
      # map them to non-VOID signature positions (matching mangle_function_name).
      aligned = Array(TypeRef).new(sig_types.size, TypeRef::VOID)
      if parsed_types.size == sig_types.size
        parsed_types.each_with_index { |t, i| aligned[i] = t }
      else
        parsed_idx = 0
        sig_types.each_with_index do |sig, idx|
          next if sig == TypeRef::VOID
          break if parsed_idx >= parsed_types.size
          aligned[idx] = parsed_types[parsed_idx]
          parsed_idx += 1
        end
      end

      merged = call_types.dup
      aligned.each_with_index do |sig, idx|
        next if sig == TypeRef::VOID
        call = merged[idx]
        if call == TypeRef::VOID
          merged[idx] = sig
          next
        end
        next if call_type_satisfies_signature?(call, sig)
        merged[idx] = sig
      end

      merged
    end

    private def strip_mangled_suffix_flags(suffix : String) : String
      stripped = suffix
      flags = ["_block", "_named", "_splat", "_double_splat"]
      loop do
        removed = false
        flags.each do |flag|
          if stripped.ends_with?(flag)
            stripped = stripped[0, stripped.size - flag.size]
            removed = true
            break
          end
        end
        break unless removed
      end
      stripped
    end

    private def suffix_has_block_flag?(suffix : String) : Bool
      return true if suffix == "block"
      return true if suffix.ends_with?("_block")
      return true if suffix.includes?("_block_")
      false
    end

    private def map_suffix_for_primitive_template(suffix : String, template_owner : String) : String?
      stripped = strip_mangled_suffix_flags(suffix)
      flags = suffix[stripped.size, suffix.size - stripped.size]
      parsed = parse_types_from_suffix(stripped)
      return nil if parsed.empty?

      mapped = parsed.map do |type_ref|
        type_name = get_type_name_from_ref(type_ref)
        if type_name != "Unknown" && primitive_template_owner(type_name) == template_owner
          type_ref_for_name(template_owner)
        else
          type_ref
        end
      end

      return nil if mapped == parsed

      mapped_suffix = mapped.map { |type_ref| type_name_for_mangling(type_ref) }.join("_")
      mapped_suffix + flags
    end

    private def def_params_untyped?(func_def : CrystalV2::Compiler::Frontend::DefNode) : Bool
      params = func_def.params
      return false unless params

      has_regular = false
      params.each do |param|
        next if named_only_separator?(param) || param.is_block || param.is_double_splat
        has_regular = true
        if ta = param.type_annotation
          type_name = String.new(ta)
          next if type_name == "_"
          next if type_param_like?(type_name) && !@type_param_map.has_key?(type_name) && short_type_param_name?(type_name)
          return false
        end
      end

      has_regular
    end

    private def type_ref_for_name(name : String) : TypeRef
      raw_name = name
      has_union = false
      has_comma = false
      has_paren = false
      has_brace = false
      simple_name = true
      i = 0
      while i < name.bytesize
        byte = name.to_unsafe[i]
        case byte
        when '|'.ord
          has_union = true
        when ','.ord
          has_comma = true
        when '('.ord, ')'.ord
          has_paren = true
        when '{'.ord, '}'.ord
          has_brace = true
        when ':'.ord, '_'.ord
          # allowed in simple names
        else
          simple_name = false unless (byte >= 'A'.ord && byte <= 'Z'.ord) ||
                                     (byte >= 'a'.ord && byte <= 'z'.ord) ||
                                     (byte >= '0'.ord && byte <= '9'.ord)
        end
        i += 1
      end
      if simple_name && !has_union && !has_comma && !has_paren && !has_brace
        if @type_param_map.empty? && (@current_typeof_local_names.nil? || @current_typeof_local_names.not_nil!.empty?) &&
           !name.includes?("self") && !name.includes?("typeof(")
          return TypeRef::VOID if name == "_"
          lookup_name = name
          absolute_name = lookup_name.starts_with?("::")
          lookup_name = lookup_name[2..] if absolute_name
          lookup_name = resolve_type_name_in_context(lookup_name) unless absolute_name
          cache_key_name = absolute_name ? "::#{lookup_name}" : lookup_name
          cache_key = type_cache_key(cache_key_name)
          if cached = @type_cache[cache_key]?
            return cached unless nested_shadowed_type_name?(lookup_name)
          end
        end
      end
      if env_get("DEBUG_TUPLE_PAREN") && has_comma && name.includes?("Tuple") && !has_paren
        STDERR.puts "[DEBUG_TUPLE_PAREN_INPUT] name=#{name}"
      end
      # Sanitize malformed type names (extra parens etc)
      if has_union || has_comma || has_paren || has_brace
        if cached = @type_name_normalize_cache[raw_name]?
          name = cached
        else
          name = sanitize_type_name(name)
          # Normalize union type names: "Int32|Nil" -> "Int32 | Nil"
          # This ensures consistent caching regardless of spacing and avoids splitting
          # nested unions inside generics.
          if has_union && name.includes?('|')
            name = split_union_type_name(name).map(&.strip).join(" | ")
          end
          # Normalize generic spacing to avoid cache misses like "Hash(String,Int32)" vs "Hash(String, Int32)"
          if (has_paren || has_comma) && (info = split_generic_base_and_args(name))
            arg_names = split_generic_type_args(info[:args]).map do |arg|
              normalize_tuple_literal_type_name(arg.strip)
            end
            name = "#{info[:base]}(#{arg_names.join(", ")})"
          end
          @type_name_normalize_cache[raw_name] = name
        end
      end
      if env_get("DEBUG_TUPLE_PAREN") && has_comma && name.includes?("Tuple") && !name.includes?('(')
        STDERR.puts "[DEBUG_TUPLE_PAREN_SANITIZED] name=#{name}"
      end

      normalized_name = name

      # "_" is a wildcard type in Crystal (untyped parameter).
      # Treat it as VOID to allow callsite-driven specialization.
      return TypeRef::VOID if normalized_name == "_"

      lookup_name = normalized_name
      resolved_in_context = false
      if lookup_name == "Bytes"
        lookup_name = "Slice(UInt8)"
      end
      if env_get("DEBUG_TYPE_PATH") && lookup_name.includes?('/')
        STDERR.puts "[TYPE_PATH] name=#{lookup_name} current=#{@current_class || ""} method=#{@current_method || ""} ns=#{@current_namespace_override || ""}"
      end

      # Handle type literals early to avoid namespace prefixing on ".class"
      if lookup_name.ends_with?(".class") || lookup_name.ends_with?(".metaclass")
        if base_name = resolve_type_literal_class_name(lookup_name)
          cache_key = type_cache_key(lookup_name)
          result = type_ref_for_name(base_name)
          store_type_cache(cache_key, result)
          return result
        end
      end

      absolute_name = lookup_name.starts_with?("::")
      if !absolute_name && !lookup_name.includes?('|')
        old_lookup = lookup_name
        lookup_name = resolve_type_name_in_context(lookup_name)
        resolved_in_context = true
        if env_get("DEBUG_WUINT128") && old_lookup == "UInt128"
          STDERR.puts "[DEBUG_WUINT128] type_ref_for_name: UInt128 resolved to #{lookup_name}, current=#{@current_class || "(nil)"}"
        end
      end

      if BUILTIN_TYPE_NAMES.includes?(lookup_name)
        if !lookup_name.includes?("::")
          resolved = resolve_class_name_in_context(lookup_name)
          if resolved != lookup_name
            return type_ref_for_name(resolved)
          end
        end
        # Before returning builtin type, check if there's a nested type
        # that shadows this name in the current context or namespace override
        # (e.g., WUInt::UInt128 should resolve to the record, not global UInt128).
        if shadow = resolve_nested_builtin_shadow(lookup_name)
          if env_get("DEBUG_WUINT128") && lookup_name == "UInt128"
            STDERR.puts "[DEBUG_WUINT128] Found nested shadow: #{shadow}, returning nested type directly"
          end
          invalidate_resolved_type_name_cache_for(lookup_name)
          return type_ref_for_name(shadow)
        end
        # No nested shadow found, return builtin type
        if builtin_ref = builtin_type_ref_for(lookup_name)
          cache_key = type_cache_key(lookup_name)
          if cached = @type_cache[cache_key]?
            return cached if cached == builtin_ref
            store_type_cache(cache_key, builtin_ref)
            return builtin_ref
          end
          store_type_cache(cache_key, builtin_ref)
          return builtin_ref
        end
      end
      if lookup_name.includes?("typeof(")
        lookup_name = resolve_typeof_in_type_string(lookup_name)
      end
      # Resolve type parameters (including nested generics) before cache and namespace resolution.
      # Also substitute `self` and generic owner params even when the explicit map is empty.
      if !@type_param_map.empty? ||
         (@current_typeof_local_names.try(&.empty?) == false) ||
         lookup_name.includes?("self") ||
         (@current_class && @current_class.not_nil!.includes?('('))
        substituted_name = substitute_type_params_in_type_name(lookup_name)
        lookup_name = substituted_name if substituted_name != lookup_name
      end
      # Treat short uppercase identifiers (T, U, V) as method type params before
      # namespace resolution to avoid creating fake nested classes like Foo::U.
      if type_param_like?(lookup_name) && !@type_param_map.has_key?(lookup_name)
        return TypeRef::VOID if short_type_param_name?(lookup_name)
      end
      orig_name = lookup_name
      absolute_name = lookup_name.starts_with?("::")
      lookup_name = lookup_name[2..] if absolute_name
      if type_param_like?(lookup_name)
        mapped = @type_param_map[lookup_name]?
        if mapped.nil? || mapped == lookup_name
          # Treat short uppercase identifiers as type params; longer names are likely
          # forward-referenced types (e.g., EncodingOptions).
          return TypeRef::VOID if short_type_param_name?(lookup_name)
        end
      end
      resolved_alias = resolve_type_alias_chain(lookup_name)
      lookup_name = resolved_alias if resolved_alias != lookup_name
      lookup_name = normalize_missing_generic_parens(lookup_name)
      cache_key_name = absolute_name ? "::#{lookup_name}" : lookup_name
      if !@type_param_map.empty? && !lookup_name.includes?('(') && lookup_name.includes?("::")
        if current = @current_class
          current_base = if info = split_generic_base_and_args(current)
                           info[:base]
                         else
                           current
                         end
          if lookup_name.starts_with?("#{current_base}::")
            if template = @generic_templates[lookup_name]?
              mapped_args = template.type_params.map { |param| @type_param_map[param]? }
              if mapped_args.all?(&.itself)
                specialized_name = "#{lookup_name}(#{mapped_args.join(", ")})"
                return type_ref_for_name(specialized_name)
              end
            end
          end
        end
      end
      if lookup_name.ends_with?(".class") || lookup_name.ends_with?(".metaclass")
        if base_name = resolve_type_literal_class_name(lookup_name)
          cache_key = type_cache_key(lookup_name)
          result = type_ref_for_name(base_name)
          store_type_cache(cache_key, result)
          return result
        end
      end
      cache_key = type_cache_key(cache_key_name)
      debug_hook_type_cache(orig_name, type_cache_context || "", cache_key, lookup_name)

      if lookup_name.ends_with?('?')
        base_name = lookup_name[0, lookup_name.size - 1]
        if base_name.empty?
          store_type_cache(cache_key, TypeRef::NIL)
          return TypeRef::NIL
        end
        union_name = "#{base_name} | Nil"
        result = create_union_type(absolute_name ? "::#{union_name}" : union_name)
        store_type_cache(cache_key, result)
        return result
      end

      if cached = @type_cache[cache_key]?
        # If a union-like name was previously cached as a non-union descriptor,
        # invalidate and recompute so we don't treat unions as classes.
        if union_type_name?(lookup_name)
          if cached && (desc = @module.get_type_descriptor(cached))
            if desc.kind == TypeKind::Union
              return cached
            end
          end
          @type_cache.delete(cache_key)
          cached = nil
        end
        if cached.nil?
          # Fall through to recompute after cache invalidation.
        end
        if !lookup_name.empty? && !lookup_name.includes?('(')
          module_name = lookup_name
          if !@module_defs.has_key?(module_name) && !module_name.starts_with?("Crystal::") && module_name.includes?("::")
            crystal_prefixed = "Crystal::#{module_name}"
            module_name = crystal_prefixed if @module_defs.has_key?(crystal_prefixed)
          end
          if @module_defs.has_key?(module_name) && !class_like_namespace?(module_name)
            if cached && (desc = @module.get_type_descriptor(cached))
              if desc.kind != TypeKind::Module
                result = @module.intern_type(TypeDescriptor.new(TypeKind::Module, module_name))
                store_type_cache(cache_key, result)
                return result
              end
            else
              result = @module.intern_type(TypeDescriptor.new(TypeKind::Module, module_name))
              store_type_cache(cache_key, result)
              return result
            end
          end
        end
        if cached
          if info = split_generic_base_and_args(lookup_name)
            if template = @generic_templates[info[:base]]?
              if desc = @module.get_type_descriptor(cached)
                expected_kind = template.is_struct ? TypeKind::Struct : TypeKind::Class
                return cached if desc.kind == expected_kind
              else
                return cached
              end
            else
              return cached
            end
          else
            return cached
          end
        end
      end

      if proc_ref = proc_type_ref_for_name(lookup_name)
        store_type_cache(cache_key, proc_ref)
        return proc_ref
      end

      # Normalize tuple literal types: "{A, B}" -> "Tuple(A, B)"
      # Do this before union handling so inner unions are preserved.
      if lookup_name.starts_with?('{') && lookup_name.ends_with?('}')
        inner = lookup_name[1, lookup_name.size - 2]
        tuple_args = split_generic_type_args(inner)
        tuple_name = "Tuple(#{tuple_args.join(", ")})"
        result = type_ref_for_name(tuple_name)
        store_type_cache(cache_key, result)
        return result
      end

      # Check for union type syntax (top-level only): "Type1 | Type2"
      # NOTE: Don't treat nested unions inside generics as unions here.
      # create_union_type handles its own caching.
      if union_type_name?(lookup_name)
        variants = split_union_type_name(lookup_name)
        if variants.size > 1
          result = create_union_type(absolute_name ? "::#{lookup_name}" : lookup_name)
          return result
        end
      end

      if !lookup_name.empty? && !lookup_name.includes?("::")
        if current = @current_class
          current_base = if info = split_generic_base_and_args(current)
                           info[:base]
                         else
                           current
                         end
          if alias_target = @type_aliases["#{current_base}::#{lookup_name}"]?
            result = type_ref_for_name(alias_target)
            store_type_cache(cache_key, result)
            return result
          end
        end
      end

      # Mark as being processed with placeholder to break cycles (BEFORE any recursion)
      # Only for non-union types - union types are handled by create_union_type
      store_type_cache(cache_key, TypeRef::VOID)

      # Handle nullable type suffix: "T?" means "T | Nil"
      if lookup_name.ends_with?('?')
        base_name = lookup_name[0, lookup_name.size - 1]
        # Substitute type parameter if present
        base_name = @type_param_map[base_name]? || base_name
        union_name = absolute_name ? "::#{base_name} | Nil" : "#{base_name} | Nil"
        result = create_union_type(union_name)
        store_type_cache(cache_key, result)
        return result
      end

      # Check if this is a type alias (but not self-referencing)
      if alias_target = @type_aliases[lookup_name]?
        if alias_target != lookup_name
          result = type_ref_for_name(alias_target)
          store_type_cache(cache_key, result)
          return result
        end
      end

      # Check LibC type aliases (platform-specific fallback)
      if libc_target = LIBC_TYPE_ALIASES[lookup_name]?
        result = type_ref_for_name(libc_target)
        store_type_cache(cache_key, result)
        return result
      end

      # Handle generic types like Pointer(K), Array(T) - substitute type parameters
      if info = split_generic_base_and_args(lookup_name)
        # Parse generic: "Pointer(K)" -> base="Pointer", params=["K"]
        base_name = info[:base]
        params_str = info[:args]

        # First split generic args with proc-arrow disambiguation (so `A, B -> C`
        # stays a single arg). If arity doesn't match the template, retry with a
        # strict split (treat commas as separators) because `T, U ->` can also be
        # the *second* generic argument (e.g. `Hash(String, String ->)`), not a
        # proc continuation for the full args list.
        raw_params = split_generic_type_args(params_str)
        if template = @generic_templates[base_name]?
          expected_arity = template.type_params.size
          if raw_params.size != expected_arity
            strict_params = split_proc_type_inputs(params_str)
            raw_params = strict_params if strict_params.size == expected_arity
          end
        end

        # Substitute each type parameter
        substituted_params = raw_params.map do |param|
          param = param.strip
          param = @type_param_map[param]? || param
          # Resolve type aliases (e.g., Crystal::System::FileDescriptor::Handle → Int32)
          alias_resolved = resolve_type_alias_chain(param)
          param = alias_resolved if alias_resolved != param
          normalize_tuple_literal_type_name(param)
        end

        # Debug: some call sites accidentally create `Hash(Tuple(K, V))` instead of `Hash(K, V)`.
        # This is a bootstrap blocker because Hash expects 2 type args. Track who generates it.
        if env_get("DEBUG_HASH_ARITY") && base_name == "Hash" && substituted_params.size == 1 && substituted_params[0].starts_with?("Tuple(")
          STDERR.puts "[HASH_ARITY] raw=#{raw_name} lookup=#{lookup_name} args=#{params_str}"
          STDERR.puts "[HASH_ARITY] substituted=#{substituted_params[0]} current_class=#{@current_class || "nil"} current_method=#{@current_method || "nil"} ns=#{@current_namespace_override || "nil"}"
          caller.first(10).each { |frame| STDERR.puts "  #{frame}" }
        end

        # Reconstruct with substituted params
        substituted_name = "#{base_name}(#{substituted_params.join(", ")})"
        if base_name == "StaticArray"
          debug_hook("type.static_array", "name=#{lookup_name} substituted=#{substituted_name} params=#{substituted_params.join(", ")}")
        end
        if substituted_name != lookup_name
          # Types changed - recurse with new name
          return type_ref_for_name(substituted_name)
        end

        # Avoid materializing generics with unresolved type parameters.
        # This preserves prior behavior for `Array(T)`/`Pointer(T)` while
        # still allowing concrete generics like `Slice(UInt8)`.
        unresolved_param = substituted_params.any? do |param|
          param_name = param.strip
          next false if param_name.empty?
          next false if @type_param_map.has_key?(param_name)
          if template = @generic_templates[base_name]?
            template.type_params.includes?(param_name)
          else
            param_name.matches?(/\A[A-Z]\z/)
          end
        end
        if unresolved_param
          @type_cache.delete(cache_key)
          return TypeRef::VOID
        end

        # Intern a parameterized type descriptor so downstream passes can recover element/key/value types.
        # This is critical for arrays/hashes/pointers where runtime representation is "ptr", but codegen
        # still needs the generic parameters for correct loads/stores.
        type_params = substituted_params.map do |param|
          ref = type_ref_for_name(param)
          if ref == TypeRef::VOID
            stripped = param.strip
            if !stripped.empty? && stripped != "_" && !short_type_param_name?(stripped)
              resolved = stripped
              # Avoid keeping VOID for named types that should resolve (e.g. nested aliases).
              if alias_target = @type_aliases[stripped]?
                ref = type_ref_for_name(alias_target)
              elsif current = @current_class
                if alias_target = @type_aliases["#{current}::#{stripped}"]?
                  ref = type_ref_for_name(alias_target)
                end
              end
              if ref == TypeRef::VOID
                resolved = resolve_type_alias_chain(resolve_type_name_in_context(stripped))
                if resolved != stripped
                  ref = type_ref_for_name(resolved)
                end
              end
              if ref == TypeRef::VOID && !type_param_like?(stripped)
                unless resolved == "Void" || resolved == "Unknown"
                  if union_type_name?(resolved)
                    ref = create_union_type(normalize_union_type_name(resolved))
                  else
                    ref = @module.intern_type(TypeDescriptor.new(TypeKind::Class, resolved))
                  end
                end
              end
            end
          end
          ref
        end
        type_kind = case base_name
                    when "Array", "StaticArray" then TypeKind::Array
                    when "Hash"                 then TypeKind::Hash
                    when "Pointer"              then TypeKind::Pointer
                    when "Tuple"                then TypeKind::Tuple
                    when "NamedTuple"           then TypeKind::NamedTuple
                    else
                      if template = @generic_templates[base_name]?
                        template.is_struct ? TypeKind::Struct : TypeKind::Class
                      else
                        TypeKind::Generic
                      end
                    end
        result = @module.intern_type(TypeDescriptor.new(type_kind, substituted_name, type_params))
        if base_name == "StaticArray"
          desc = @module.get_type_descriptor(result)
          debug_hook("type.static_array.result", "name=#{desc ? desc.name : "?"} params=#{type_params.map { |t| get_type_name_from_ref(t) }.join(", ")}")
        end
        store_type_cache(cache_key, result)

        # Trigger monomorphization if this is a generic class/struct template
        # This ensures included module methods get registered for the specialized type
        if template = @generic_templates[base_name]?
          unless @monomorphized.includes?(substituted_name)
            if !concrete_type_args?(substituted_params)
              STDERR.puts "[MONO] Skipping unresolved: #{substituted_name}" if env_has?("DEBUG_MONO")
            elsif @suppress_monomorphization
              # Skip eager monomorphization while scanning specialized bodies.
            elsif @defer_monomorphization
              # Queue for later - templates may not be fully registered yet
              @pending_monomorphizations << {base_name, substituted_params, substituted_name}
            else
              monomorphize_generic_class(base_name, substituted_params, substituted_name)
            end
          end
        end

        return result
      end

      # Handle pointer types (Void*, Pointer(T), T*)
      # IMPORTANT: This must be checked BEFORE the case statement for "Void"
      if lookup_name.ends_with?('*')
        base_name = lookup_name
        star_count = 0
        while base_name.ends_with?('*')
          base_name = base_name[0...-1]
          star_count += 1
        end
        base_name = base_name.strip
        if base_name.empty?
          store_type_cache(cache_key, TypeRef::POINTER)
          return TypeRef::POINTER
        end

        pointer_name = base_name
        star_count.times { pointer_name = "Pointer(#{pointer_name})" }
        result = type_ref_for_name(pointer_name)
        store_type_cache(cache_key, result)
        return result
      end

      if lookup_name == "Pointer"
        # Pointer(T) or just Pointer -> pointer type
        store_type_cache(cache_key, TypeRef::POINTER)
        return TypeRef::POINTER
      end

      result = case lookup_name
               when "Void"    then TypeRef::VOID
               when "Nil"     then TypeRef::NIL
               when "Bool"    then TypeRef::BOOL
               when "Int8"    then TypeRef::INT8
               when "Int16"   then TypeRef::INT16
               when "Int32"   then TypeRef::INT32
               when "Int64"   then TypeRef::INT64
               when "Int128"  then TypeRef::INT128
               when "UInt8"   then TypeRef::UINT8
               when "UInt16"  then TypeRef::UINT16
               when "UInt32"  then TypeRef::UINT32
               when "UInt64"  then TypeRef::UINT64
               when "UInt128" then TypeRef::UINT128
               when "Float32" then TypeRef::FLOAT32
               when "Float64" then TypeRef::FLOAT64
               when "Char"    then TypeRef::CHAR
               when "String"  then TypeRef::STRING
               when "Symbol"  then TypeRef::SYMBOL
               else
                 # Check if this is an enum type - create TypeDescriptor to preserve name for mangling
                 # (enums use Int32 storage but need their semantic name for method dispatch)
                 if enum_info = @enum_info
                   if enum_info.has_key?(lookup_name)
                     # Use Struct kind since enums are value types
                     enum_ref = @module.intern_type(TypeDescriptor.new(TypeKind::Struct, lookup_name))
                     store_type_cache(cache_key, enum_ref)
                     return enum_ref
                   end
                 end

                 # Prefer already-registered concrete types to preserve kind (struct vs class).
                 if info = @class_info[lookup_name]?
                   store_type_cache(cache_key, info.type_ref)
                   return info.type_ref
                 end
                 # Fallback: try with Crystal:: prefix for stdlib types like EventLoop::Polling::Arena::Index
                 # which should resolve to Crystal::EventLoop::Polling::Arena::Index
                 if !lookup_name.starts_with?("Crystal::") && lookup_name.includes?("::")
                   crystal_prefixed = "Crystal::#{lookup_name}"
                   if info = @class_info[crystal_prefixed]?
                     store_type_cache(cache_key, info.type_ref)
                     return info.type_ref
                   end
                 end
                 if @top_level_class_kinds.has_key?(lookup_name)
                   is_struct = @top_level_class_kinds[lookup_name]
                   type_kind = is_struct ? TypeKind::Struct : TypeKind::Class
                   result = @module.intern_type(TypeDescriptor.new(type_kind, lookup_name))
                   store_type_cache(cache_key, result)
                   return result
                 end
                 if @module_defs.has_key?(lookup_name) && !class_like_namespace?(lookup_name)
                   result = @module.intern_type(TypeDescriptor.new(TypeKind::Module, lookup_name))
                   store_type_cache(cache_key, result)
                   return result
                 end
                 if !lookup_name.starts_with?("Crystal::") && lookup_name.includes?("::")
                   crystal_prefixed = "Crystal::#{lookup_name}"
                   if @module_defs.has_key?(crystal_prefixed) && !class_like_namespace?(crystal_prefixed)
                     result = @module.intern_type(TypeDescriptor.new(TypeKind::Module, crystal_prefixed))
                     store_type_cache(cache_key, result)
                     return result
                   end
                 end

                 # Final guard: if this still looks like a union, prefer a union descriptor.
                 if union_type_name?(lookup_name)
                   union_ref = create_union_type(normalize_union_type_name(lookup_name))
                   store_type_cache(cache_key, union_ref)
                   return union_ref if union_ref != TypeRef::VOID
                 end

                 # For unknown types, keep the unqualified name to avoid poisoning
                 # the cache with a context-specific namespace.
                 @module.intern_type(TypeDescriptor.new(TypeKind::Class, lookup_name))
               end
      # Cache the result to avoid VOID placeholder being returned on subsequent calls
      store_type_cache(cache_key, result)
      result
    end

    # Create a union type from "Type1 | Type2 | Type3" syntax
    private def create_union_type(name : String) : TypeRef
      # Parse variant type names (handle both "Type1 | Type2" and "Type1|Type2")
      variant_names = split_union_type_name(name)
      if variant_names.empty?
        return TypeRef::VOID
      end

      expanded_variants = [] of String
      variant_names.each do |variant|
        absolute = variant.starts_with?("::")
        raw_variant = absolute ? variant[2..] : variant
        resolved = resolve_type_alias_chain(raw_variant)
        if resolved.includes?('|')
          split_union_type_name(resolved).each do |entry|
            expanded_variants << (absolute ? "::#{entry}" : entry)
          end
        else
          expanded_variants << (absolute ? "::#{resolved}" : resolved)
        end
      end
      expanded_variants.uniq!

      resolved_variant_names = expanded_variants.map do |variant|
        absolute = variant.starts_with?("::")
        resolved = absolute ? variant[2..] : variant
        if !@type_param_map.empty?
          resolved = substitute_type_params_in_type_name(resolved)
        end
        resolved = resolve_type_name_in_context(resolved) unless absolute
        if type_param_like?(resolved)
          mapped = @type_param_map[resolved]?
          if mapped.nil? || mapped == resolved
            resolved = "Pointer"
          end
        end
        absolute ? "::#{resolved}" : resolved
      end
      resolved_variant_names.reject!(&.empty?)

      normalized_name = normalize_union_type_name(resolved_variant_names.join(" | "))
      resolved_variant_names = split_union_type_name(normalized_name)
      if @union_in_progress.includes?(normalized_name)
        # If we're already building this union, prefer a cached concrete type.
        if cached = @type_cache[type_cache_key(normalized_name)]?
          return cached unless cached == TypeRef::VOID
        end
        # Return a provisional union type to avoid VOID cascading into inference.
        provisional = @module.intern_type(TypeDescriptor.new(TypeKind::Union, normalized_name))
        store_type_cache(type_cache_key(normalized_name), provisional)
        return provisional
      end

      @union_in_progress << normalized_name
      begin
        # Canonicalize by TypeRef to avoid duplicate variants like Thread | Nil | Thread.
        variant_refs = resolved_variant_names.map { |vn| type_ref_for_name(vn) }
        seen_refs = Set(TypeRef).new
        dedup_names = [] of String
        dedup_refs = [] of TypeRef
        variant_refs.each_with_index do |ref, idx|
          next if seen_refs.includes?(ref)
          seen_refs << ref
          dedup_refs << ref
          canonical = get_type_name_from_ref(ref)
          canonical = resolved_variant_names[idx] if canonical == "Unknown"
          dedup_names << canonical
        end
        # Canonicalize order: sort by name, but keep Nil first (matches Crystal semantics).
        ordered = dedup_names.zip(dedup_refs)
        ordered.sort_by! do |(vname, vref)|
          nil_flag = (vref == TypeRef::NIL || vname == "Nil" || vname.ends_with?("::Nil")) ? 0 : 1
          {nil_flag, vname}
        end
        resolved_variant_names = ordered.map(&.[0])
        variant_refs = ordered.map(&.[1])

        normalized_name = resolved_variant_names.join(" | ")
        if resolved_variant_names.size == 1
          return variant_refs.first
        end
        cache_key = type_cache_key(normalized_name)

        # Check cache first to prevent infinite recursion
        if cached = @type_cache[cache_key]?
          return cached if cached == TypeRef::VOID
          ensure_union_descriptor(cached, normalized_name, resolved_variant_names)
          return cached
        end
        # Mark as being processed with placeholder to break cycles
        store_type_cache(cache_key, TypeRef::VOID)

        # Get TypeRefs for each variant (recursive to handle nested unions)
        if env_get("DEBUG_UNION_TYPES")
          refs_debug = variant_refs.map { |ref| get_type_name_from_ref(ref) }.join(", ")
          enum_debug = resolved_variant_names.map do |vn|
            @enum_info ? @enum_info.not_nil!.has_key?(vn) : false
          end.join(", ")
          STDERR.puts "[DEBUG_UNION_TYPES] name=#{normalized_name} variants=#{resolved_variant_names.join(", ")} refs=#{refs_debug} enum_known=#{enum_debug}"
        end

        # Create union type and register descriptor
        type_ref = @module.intern_type(TypeDescriptor.new(TypeKind::Union, normalized_name))
        register_union_descriptor(type_ref, normalized_name, resolved_variant_names, variant_refs)

        # Update cache with real value (replacing placeholder)
        store_type_cache(cache_key, type_ref)

        type_ref
      ensure
        @union_in_progress.delete(normalized_name)
      end
    end

    private def ensure_union_descriptor(
      type_ref : TypeRef,
      normalized_name : String,
      resolved_variant_names : Array(String),
    ) : Nil
      mir_union_type_ref = hir_to_mir_type_ref(type_ref)
      return if @union_descriptors.has_key?(mir_union_type_ref)

      variant_refs = resolved_variant_names.map { |vn| type_ref_for_name(vn) }
      register_union_descriptor(type_ref, normalized_name, resolved_variant_names, variant_refs)
    end

    private def register_union_descriptor(
      type_ref : TypeRef,
      normalized_name : String,
      resolved_variant_names : Array(String),
      variant_refs : Array(TypeRef),
    ) : Nil
      mir_union_type_ref = hir_to_mir_type_ref(type_ref)
      return if @union_descriptors.has_key?(mir_union_type_ref)

      # Calculate union layout
      variants = [] of MIR::UnionVariantDescriptor
      max_size = 0
      max_align = 4 # Minimum alignment for type_id

      variant_refs.each_with_index do |vref, idx|
        # Convert HIR::TypeRef to MIR::TypeRef using proper ID mapping
        mir_type_ref = hir_to_mir_type_ref(vref)
        if mir_type_ref == mir_union_type_ref
          # Guard against self-referential union variants (can happen with unresolved type params).
          if env_get("DEBUG_UNION_TYPES")
            STDERR.puts "[DEBUG_UNION_TYPES] self-variant #{normalized_name} -> Pointer"
          end
          vref = TypeRef::POINTER
          mir_type_ref = MIR::TypeRef::POINTER
        end

        vsize = type_size(vref)
        valign = type_alignment(vref)
        max_size = {max_size, vsize}.max
        max_align = {max_align, valign}.max

        variants << MIR::UnionVariantDescriptor.new(
          type_id: idx,
          type_ref: mir_type_ref,
          full_name: resolved_variant_names[idx],
          size: vsize,
          alignment: valign,
          field_offsets: nil
        )
      end

      # Total size: header (4 bytes for type_id) + padding + max payload
      payload_offset = ((4 + max_align - 1) // max_align) * max_align
      total_size = payload_offset + max_size

      # Create union descriptor
      descriptor = MIR::UnionDescriptor.new(
        name: normalized_name,
        variants: variants,
        total_size: total_size,
        alignment: max_align
      )

      # Store descriptor for LLVM backend
      @union_descriptors[mir_union_type_ref] = descriptor
    end

    # Create a nullable union type (T | Nil) from a concrete type
    private def create_union_type_for_nullable(concrete_type : TypeRef) : TypeRef
      # Get the name of the concrete type
      type_name = get_type_name_from_ref(concrete_type)
      union_name = type_name == "Nil" ? "Nil" : "Nil | #{type_name}"

      # Create the union type via the string-based method
      create_union_type(union_name)
    end

    # Get the type name from a TypeRef
    private def get_type_name_from_ref(type_ref : TypeRef) : String
      case type_ref
      when TypeRef::VOID    then "Void"
      when TypeRef::BOOL    then "Bool"
      when TypeRef::INT8    then "Int8"
      when TypeRef::INT16   then "Int16"
      when TypeRef::INT32   then "Int32"
      when TypeRef::INT64   then "Int64"
      when TypeRef::INT128  then "Int128"
      when TypeRef::UINT8   then "UInt8"
      when TypeRef::UINT16  then "UInt16"
      when TypeRef::UINT32  then "UInt32"
      when TypeRef::UINT64  then "UInt64"
      when TypeRef::UINT128 then "UInt128"
      when TypeRef::FLOAT32 then "Float32"
      when TypeRef::FLOAT64 then "Float64"
      when TypeRef::CHAR    then "Char"
      when TypeRef::STRING  then "String"
      when TypeRef::NIL     then "Nil"
      when TypeRef::SYMBOL  then "Symbol"
      when TypeRef::POINTER then "Pointer"
      else
        # Look up in type registry
        if desc = @module.get_type_descriptor(type_ref)
          desc.name
        else
          "Unknown"
        end
      end
    end

    # Convert HIR::TypeRef to MIR::TypeRef with proper ID mapping
    # HIR and MIR have different primitive type IDs
    private def hir_to_mir_type_ref(hir_type : TypeRef) : MIR::TypeRef
      case hir_type
      when TypeRef::VOID    then MIR::TypeRef::VOID
      when TypeRef::BOOL    then MIR::TypeRef::BOOL
      when TypeRef::INT8    then MIR::TypeRef::INT8
      when TypeRef::INT16   then MIR::TypeRef::INT16
      when TypeRef::INT32   then MIR::TypeRef::INT32
      when TypeRef::INT64   then MIR::TypeRef::INT64
      when TypeRef::INT128  then MIR::TypeRef::INT128
      when TypeRef::UINT8   then MIR::TypeRef::UINT8
      when TypeRef::UINT16  then MIR::TypeRef::UINT16
      when TypeRef::UINT32  then MIR::TypeRef::UINT32
      when TypeRef::UINT64  then MIR::TypeRef::UINT64
      when TypeRef::UINT128 then MIR::TypeRef::UINT128
      when TypeRef::FLOAT32 then MIR::TypeRef::FLOAT32
      when TypeRef::FLOAT64 then MIR::TypeRef::FLOAT64
      when TypeRef::CHAR    then MIR::TypeRef::CHAR
      when TypeRef::STRING  then MIR::TypeRef::STRING
      when TypeRef::NIL     then MIR::TypeRef::NIL
      when TypeRef::SYMBOL  then MIR::TypeRef::SYMBOL
      when TypeRef::POINTER then MIR::TypeRef::POINTER
      else
        # User-defined types: offset by 20 (matching hir_to_mir.cr convert_type)
        MIR::TypeRef.new(hir_type.id + 20_u32)
      end
    end

    # Convert MIR::TypeRef back to HIR::TypeRef (inverse of hir_to_mir_type_ref).
    private def mir_to_hir_type_ref(mir_type : MIR::TypeRef) : TypeRef
      case mir_type
      when MIR::TypeRef::VOID    then TypeRef::VOID
      when MIR::TypeRef::BOOL    then TypeRef::BOOL
      when MIR::TypeRef::INT8    then TypeRef::INT8
      when MIR::TypeRef::INT16   then TypeRef::INT16
      when MIR::TypeRef::INT32   then TypeRef::INT32
      when MIR::TypeRef::INT64   then TypeRef::INT64
      when MIR::TypeRef::INT128  then TypeRef::INT128
      when MIR::TypeRef::UINT8   then TypeRef::UINT8
      when MIR::TypeRef::UINT16  then TypeRef::UINT16
      when MIR::TypeRef::UINT32  then TypeRef::UINT32
      when MIR::TypeRef::UINT64  then TypeRef::UINT64
      when MIR::TypeRef::UINT128 then TypeRef::UINT128
      when MIR::TypeRef::FLOAT32 then TypeRef::FLOAT32
      when MIR::TypeRef::FLOAT64 then TypeRef::FLOAT64
      when MIR::TypeRef::CHAR    then TypeRef::CHAR
      when MIR::TypeRef::STRING  then TypeRef::STRING
      when MIR::TypeRef::NIL     then TypeRef::NIL
      when MIR::TypeRef::SYMBOL  then TypeRef::SYMBOL
      when MIR::TypeRef::POINTER then TypeRef::POINTER
      else
        first_user_mir = TypeRef::FIRST_USER_TYPE + 20_u32
        if mir_type.id >= first_user_mir
          TypeRef.new(mir_type.id - 20_u32)
        else
          TypeRef::POINTER
        end
      end
    end

    private def type_ref_for_expr(ctx : LoweringContext, expr_id : ExprId) : TypeRef
      name = get_type_name(expr_id)
      type_ref_for_name(name)
    end

    # Check if a type is a union type or nilable (T | Nil)
    private def is_union_or_nilable_type?(type : TypeRef) : Bool
      is_union_type?(type)
    end

    # Intrinsic: value.nil? for union types
    # Checks if the union's type tag indicates Nil variant
    private def lower_nil_check_intrinsic(ctx : LoweringContext, value_id : ValueId, value_type : TypeRef) : ValueId
      nil_variant_id = get_union_variant_id(value_type, TypeRef::NIL)
      if nil_variant_id < 0
        # Fallback: if we can't resolve a union variant, conservatively return false.
        # This should be rare (union descriptors are registered during AST->HIR conversion).
        lit = Literal.new(ctx.next_id, TypeRef::BOOL, false)
        ctx.emit(lit)
        return lit.id
      end

      # Emit UnionIs instruction to check if value is Nil variant
      union_is = UnionIs.new(ctx.next_id, value_id, nil_variant_id)
      ctx.emit(union_is)
      ctx.register_type(union_is.id, TypeRef::BOOL)
      union_is.id
    end

    # Intrinsic: value.not_nil! for union types
    # Extracts the non-nil value from a union (asserts it's not nil)
    private def lower_not_nil_intrinsic(ctx : LoweringContext, value_id : ValueId, value_type : TypeRef) : ValueId
      # Determine the non-nil variant and its index from the union descriptor.
      non_nil_type = TypeRef::POINTER
      non_nil_variant = -1
      extra_non_nil = false
      non_nil_type_name : String? = nil

      mir_union_ref = hir_to_mir_type_ref(value_type)
      if descriptor = @union_descriptors[mir_union_ref]?
        descriptor.variants.each_with_index do |variant, idx|
          next if variant.type_ref == MIR::TypeRef::NIL
          if non_nil_variant >= 0
            extra_non_nil = true
            break
          end
          non_nil_variant = idx
          non_nil_type_name = variant.full_name
          # Use full_name for semantic type (preserves enum type like Signal instead of storage Int32)
          non_nil_type = type_ref_for_name(variant.full_name)
        end
      end

      # Only unwrap when a single concrete non-nil variant exists.
      if non_nil_variant >= 0 && !extra_non_nil
        unwrap = UnionUnwrap.new(ctx.next_id, non_nil_type, value_id, non_nil_variant, false)
        ctx.emit(unwrap)
        ctx.register_type(unwrap.id, non_nil_type)
        # Register enum type for the unwrapped value so predicates work correctly
        if non_nil_type_name && @enum_info.try(&.has_key?(non_nil_type_name))
          (@enum_value_types ||= {} of ValueId => String)[unwrap.id] = non_nil_type_name
        end
        return unwrap.id
      end

      # Fallback: return the original value to avoid incorrect narrowing.
      value_id
    end

    private def unwrap_non_nil_to_block(
      ctx : LoweringContext,
      block_id : BlockId,
      value_id : ValueId,
      value_type : TypeRef,
    ) : ValueId
      return value_id unless is_union_or_nilable_type?(value_type)

      non_nil_type = TypeRef::POINTER
      non_nil_variant = -1
      extra_non_nil = false
      non_nil_type_name : String? = nil

      mir_union_ref = hir_to_mir_type_ref(value_type)
      if descriptor = @union_descriptors[mir_union_ref]?
        descriptor.variants.each_with_index do |variant, idx|
          next if variant.type_ref == MIR::TypeRef::NIL
          if non_nil_variant >= 0
            extra_non_nil = true
            break
          end
          non_nil_variant = idx
          non_nil_type_name = variant.full_name
          # Use full_name for semantic type (preserves enum type like Signal instead of storage Int32)
          non_nil_type = type_ref_for_name(variant.full_name)
        end
      end

      return value_id if non_nil_variant < 0 || extra_non_nil

      unwrap = UnionUnwrap.new(ctx.next_id, non_nil_type, value_id, non_nil_variant, false)
      ctx.emit_to_block(block_id, unwrap)
      ctx.register_type(unwrap.id, non_nil_type)
      # Register enum type for the unwrapped value so predicates work correctly
      if non_nil_type_name && @enum_info.try(&.has_key?(non_nil_type_name))
        (@enum_value_types ||= {} of ValueId => String)[unwrap.id] = non_nil_type_name
      end
      unwrap.id
    end
  end
end
