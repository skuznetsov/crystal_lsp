# AST to HIR Lowering
#
# Converts Crystal AST (from parser) to High-Level IR for analysis.
# This is the first stage of the codegen pipeline.
#
# See docs/codegen_architecture.md for full specification.

require "./hir"
require "./debug_hooks"
require "../frontend/ast"
require "../mir/mir"
require "../../runtime"
require "../semantic/macro_expander"
require "../semantic/symbol_table"

module Crystal::HIR
  # Error raised during AST to HIR conversion
  class LoweringError < Exception
    getter node : CrystalV2::Compiler::Frontend::Node?
    getter details : String

    def initialize(@details : String, @node : CrystalV2::Compiler::Frontend::Node? = nil)
      super(@details)
    end
  end

  # Context for lowering a single function
  class LoweringContext
    getter function : Function
    getter module : Module
    getter arena : CrystalV2::Compiler::Frontend::ArenaLike

    # Current block being built
    property current_block : BlockId

    # Variable name → ValueId mapping per scope
    @locals : Hash(String, ValueId)

    # Scope stack for nested scopes
    @scope_stack : Array(ScopeId)

    # Type cache
    @type_cache : Hash(String, TypeRef)

    # Value → Type mapping for type inference
    @value_types : Hash(ValueId, TypeRef)
    @values : Hash(ValueId, Value)
    @type_literal_values : Set(ValueId)

    def initialize(@function : Function, @module : Module, @arena)
      @current_block = @function.entry_block
      @locals = {} of String => ValueId
      @scope_stack = [@function.scopes[0].id]  # Function scope
      @type_cache = {} of String => TypeRef
      @value_types = {} of ValueId => TypeRef
      @values = {} of ValueId => Value
      @type_literal_values = Set(ValueId).new
    end

    # Get current scope
    def current_scope : ScopeId
      @scope_stack.last
    end

    # Push new scope
    def push_scope(kind : ScopeKind) : ScopeId
      scope_id = @function.create_scope(kind, current_scope)
      @scope_stack << scope_id
      scope_id
    end

    # Pop scope
    def pop_scope : ScopeId
      @scope_stack.pop
    end

    # Create new block in current scope
    def create_block : BlockId
      @function.create_block(current_scope)
    end

    # Get block by ID
    def get_block(id : BlockId) : Block
      @function.get_block(id)
    end

    # Switch to a different block
    def switch_to_block(id : BlockId)
      @current_block = id
    end

    # Get current block ID
    def current_block_id : BlockId
      @current_block
    end

    # Add instruction to current block
    def emit(value : Value) : Value
      get_block(@current_block).add(value)
      @value_types[value.id] = value.type  # Track type for inference
      @values[value.id] = value
      if value.is_a?(Literal) && value.value.is_a?(Nil) && value.type.id >= TypeRef::FIRST_USER_TYPE
        @type_literal_values.add(value.id)
        STDERR.puts "[TYPE_LITERAL] id=#{value.id} type=#{value.type.id}" if ENV["DEBUG_TYPE_LITERAL"]?
      end
      value
    end

    # Add instruction to a specific block (used for inserting before phi nodes)
    def emit_to_block(block_id : BlockId, value : Value) : Value
      get_block(block_id).add(value)
      @value_types[value.id] = value.type
      @values[value.id] = value
      if value.is_a?(Literal) && value.value.is_a?(Nil) && value.type.id >= TypeRef::FIRST_USER_TYPE
        @type_literal_values.add(value.id)
        STDERR.puts "[TYPE_LITERAL] id=#{value.id} type=#{value.type.id}" if ENV["DEBUG_TYPE_LITERAL"]?
      end
      value
    end

    # Look up the type of a value by ID
    def type_of(id : ValueId) : TypeRef
      @value_types[id]? || TypeRef::VOID
    end

    # Register type for a value (used for params not emitted via emit)
    def register_type(id : ValueId, type : TypeRef)
      @value_types[id] = type
    end

    def value_for(id : ValueId) : Value?
      @values[id]?
    end

    def type_literal?(id : ValueId) : Bool
      @type_literal_values.includes?(id)
    end

    def mark_type_literal(id : ValueId)
      @type_literal_values.add(id)
    end

    # Set terminator for current block
    def terminate(term : Terminator)
      get_block(@current_block).terminator = term
    end

    # Next value ID
    def next_id : ValueId
      @function.next_value_id
    end

    # Register local variable
    def register_local(name : String, value_id : ValueId)
      @locals[name] = value_id
      @function.get_scope(current_scope).add_local(value_id)
    end

    # Lookup local variable
    def lookup_local(name : String) : ValueId?
      @locals[name]?
    end

    # Save current locals state (for branching)
    def save_locals : Hash(String, ValueId)
      @locals.dup
    end

    # Restore locals state (for else branch)
    def restore_locals(saved : Hash(String, ValueId))
      @locals = saved.dup
    end

    # Get all current locals
    def all_locals : Hash(String, ValueId)
      @locals
    end

    # Get or create type ref
    def get_type(name : String) : TypeRef
      @type_cache[name]? || begin
        type_ref = case name
                   when "Void"           then TypeRef::VOID
                   when "Nil"            then TypeRef::NIL
                   when "Bool"           then TypeRef::BOOL
                   when "Int8"           then TypeRef::INT8
                   when "Int16"          then TypeRef::INT16
                   when "Int32"          then TypeRef::INT32
                   when "Int64"          then TypeRef::INT64
                   when "Int128"         then TypeRef::INT128
                   when "UInt8"          then TypeRef::UINT8
                   when "UInt16"         then TypeRef::UINT16
                   when "UInt32"         then TypeRef::UINT32
                   when "UInt64"         then TypeRef::UINT64
                   when "UInt128"        then TypeRef::UINT128
                   when "Float32"        then TypeRef::FLOAT32
                   when "Float64"        then TypeRef::FLOAT64
                   when "Char"           then TypeRef::CHAR
                   when "String"         then TypeRef::STRING
                   when "Symbol"         then TypeRef::SYMBOL
                   else
                     # User-defined type
                     @module.intern_type(TypeDescriptor.new(TypeKind::Class, name))
                   end
        @type_cache[name] = type_ref
        type_ref
      end
    end
  end

  # Instance variable info for class layout
  record IVarInfo, name : String, type : TypeRef, offset : Int32

  # Class variable info
  record ClassVarInfo, name : String, type : TypeRef, initial_value : Int64?

  # Class type info (is_struct=true for value types)
  record ClassInfo, name : String, type_ref : TypeRef, ivars : Array(IVarInfo), class_vars : Array(ClassVarInfo), size : Int32, is_struct : Bool = false, parent_name : String? = nil

  # Macro parameter metadata (internal/external names + prefix).
  record MacroParamInfo, name : String, external_name : String? = nil, prefix : String = ""

  # Class-level accessor entry (class_getter/class_setter/class_property)
  record ClassAccessorEntry,
    owner : String,
    spec : CrystalV2::Compiler::Frontend::AccessorSpec,
    arena : CrystalV2::Compiler::Frontend::ArenaLike,
    kind : Symbol

  # Generic class template (not yet specialized)
  record GenericClassTemplate,
    name : String,                                    # Base name like "Box"
    type_params : Array(String),                      # ["T"] or ["K", "V"]
    node : CrystalV2::Compiler::Frontend::ClassNode,  # Original AST node for re-lowering
    arena : CrystalV2::Compiler::Frontend::ArenaLike, # Arena for looking up body ExprIds
    is_struct : Bool = false

  # Main AST to HIR converter
  class AstToHir
    alias AstNode = CrystalV2::Compiler::Frontend::Node
    alias ExprId = CrystalV2::Compiler::Frontend::ExprId

    private struct CallSignature
      getter base_name : String
      getter arity : Int32
      getter has_block : Bool

      def initialize(@base_name : String, @arity : Int32, @has_block : Bool)
      end
    end

    private record CallsiteArgs, types : Array(TypeRef), literals : Array(Bool)?

    private class InitParamsCapture
      property params : Array({String, TypeRef})
      property source : Symbol

      def initialize
        @params = [] of {String, TypeRef}
        @source = :none
      end
    end

    # Platform-specific LibC type aliases (fallback for unevaluated macro conditionals)
    # On 64-bit systems (aarch64-darwin, x86_64-*):
    # Includes both LibC:: prefixed and bare names for direct use
    LIBC_TYPE_ALIASES = {
      # With LibC:: prefix
      "LibC::Char"      => "UInt8",
      "LibC::UChar"     => "UInt8",
      "LibC::SChar"     => "Int8",
      "LibC::Short"     => "Int16",
      "LibC::UShort"    => "UInt16",
      "LibC::Int"       => "Int32",
      "LibC::UInt"      => "UInt32",
      "LibC::Long"      => "Int64",      # 64-bit
      "LibC::ULong"     => "UInt64",     # 64-bit
      "LibC::LongLong"  => "Int64",
      "LibC::ULongLong" => "UInt64",
      "LibC::Float"     => "Float32",
      "LibC::Double"    => "Float64",
      "LibC::SizeT"     => "UInt64",     # 64-bit: ULong -> UInt64
      "LibC::SSizeT"    => "Int64",      # 64-bit: Long -> Int64
      "LibC::PtrDiffT"  => "Int64",      # 64-bit: Long -> Int64
      "LibC::OffT"      => "Int64",      # 64-bit
      "LibC::ModeT"     => "UInt16",     # darwin
      "LibC::PidT"      => "Int32",
      "LibC::UidT"      => "UInt32",
      "LibC::GidT"      => "UInt32",
      "LibC::TimeT"     => "Int64",      # 64-bit
      "LibC::ClockT"    => "UInt64",     # darwin
      # Without LibC:: prefix (for macro conditionals that define these)
      "Char"     => "UInt8",
      "UChar"    => "UInt8",
      "SChar"    => "Int8",
      "Short"    => "Int16",
      "UShort"   => "UInt16",
      "Int"      => "Int32",
      "UInt"     => "UInt32",
      "Long"     => "Int64",             # 64-bit
      "ULong"    => "UInt64",            # 64-bit
      "SizeT"    => "UInt64",            # 64-bit
      "SSizeT"   => "Int64",             # 64-bit
    }

    # Top-level user-defined `def main` is renamed to avoid clashing with the C entrypoint.
    TOP_LEVEL_MAIN_BASE = "__crystal_user_main"
    # Marker for top-level `fun` definitions (C ABI). Stored in DefNode.receiver.
    FUN_DEF_RECEIVER = "__fun__"

    getter module : Module
    property arena : CrystalV2::Compiler::Frontend::ArenaLike

    # Pre-registered function signatures for forward reference support
    @function_types : Hash(String, TypeRef)

    # Index of function base names (without $ type suffix) for fast prefix lookups
    # Maps base name -> true (existence check)
    @function_base_names : Set(String)

    # Cached return type for a function base name (without $ suffix).
    # This is used for method resolution when only the base name is known.
    @function_base_return_types : Hash(String, TypeRef)
    # Enum return type names for functions whose declared return is an enum.
    @function_enum_return_names : Hash(String, String)
    # Functions whose return value is a type literal (e.g., EventLoop.backend_class).
    @function_return_type_literals : Set(String)

    # Class type information
    getter class_info : Hash(String, ClassInfo)
    # Module-level class vars (modules don't have ClassInfo entries)
    @module_class_vars : Hash(String, Array(ClassVarInfo))
    # Track lib struct/union types for field access lowering.
    @lib_structs : Set(String)

    # Initialize parameters for each class (for new() generation)
    @init_params : Hash(String, Array({String, TypeRef}))

    # Current class being lowered (for ivar access)
    @current_class : String?
    # Override namespace used for resolving short type names (module mixins).
    @current_namespace_override : String?

    # Union type descriptors for debug info (keyed by MIR::TypeRef)
    getter union_descriptors : Hash(MIR::TypeRef, MIR::UnionDescriptor)

    # AST of function definitions for inline expansion
    @function_defs : Hash(String, CrystalV2::Compiler::Frontend::DefNode)
    @function_def_arenas : Hash(String, CrystalV2::Compiler::Frontend::ArenaLike)

    # Functions that contain yield (candidates for inline)
    @yield_functions : Set(String)
    # Functions whose explicit returns are all `return yield` (block-return-dependent).
    @yield_return_functions : Set(String)
    @yield_return_checked : Set(String)

    # Track functions lowered lazily to avoid re-entrancy/duplication.
    @lowered_functions : Set(String)
    @lowering_functions : Set(String)
    # Call-site argument types for lazily lowered functions (mangled name -> arg types).
    @pending_arg_types : Hash(String, Array(TypeRef))
    @pending_arg_types_by_arity : Hash(String, Hash(Int32, Array(CallsiteArgs)))
    @pending_arg_types_by_signature : Hash(CallSignature, Array(CallsiteArgs))
    # Call-site type-literal flags for lazily lowered functions (mangled name -> arg literal flags).
    @pending_arg_type_literals : Hash(String, Array(Bool))
    # Call-site type parameter bindings for lazily lowered functions (mangled name -> map).
    @pending_type_param_maps : Hash(String, Hash(String, String))
    # Captured type parameter bindings for module methods copied into concrete classes.
    @function_type_param_maps : Hash(String, Hash(String, String))
    # Namespace overrides for module instance methods copied into concrete classes.
    @function_namespace_overrides : Hash(String, String)

    # Generic class templates (base name -> template)
    @generic_templates : Hash(String, GenericClassTemplate)
    # Additional generic class reopenings (base name -> templates)
    @generic_reopenings : Hash(String, Array(GenericClassTemplate))

    # Already monomorphized generic classes (specialized name -> true)
    @monomorphized : Set(String)

    # Debug counters
    @template_reg_counter : Int32?
    @mono_counter : Int32?

    # Pending monomorphizations (deferred until after all templates are registered)
    @pending_monomorphizations : Array({String, Array(String), String})
    @defer_monomorphization : Bool
    # Suppress monomorphization while scanning specialized class bodies.
    @suppress_monomorphization : Bool
    # Only lower bodies for monomorphized classes when explicitly enabled.
    @eager_monomorphization : Bool

    # Current type parameter substitutions for generic lowering
    @type_param_map : Hash(String, String)

    # Current method name being lowered (for super calls)
    @current_method : String?
    # Track whether the current method is a class/module method (self.)
    @current_method_is_class : Bool

    # Locals available for resolving typeof(...) in type positions (per def)
    @current_typeof_locals : Hash(String, TypeRef)?
    # Guard against recursive inference loops (arena object_id + expr index).
    @infer_expr_stack : Set(UInt64)

    # Macro definitions (name -> {MacroDefNode, arena})
    @macro_defs : Hash(String, {CrystalV2::Compiler::Frontend::MacroDefNode, CrystalV2::Compiler::Frontend::ArenaLike})
    # Macro parameter lists (name -> MacroParamInfo)
    @macro_params : Hash(String, Array(MacroParamInfo))

    # Class-level accessors (full method name -> entry)
    @class_accessor_entries : Hash(String, ClassAccessorEntry)

    # Module AST definitions (name -> list of {node, arena}) for mixin expansion.
    # Many stdlib "modules" provide instance methods meant to be included into classes/structs.
    @module_defs : Hash(String, Array({CrystalV2::Compiler::Frontend::ModuleNode, CrystalV2::Compiler::Frontend::ArenaLike}))
    # Track concrete types that include a module for module-typed receiver fallback.
    @module_includers : Hash(String, Set(String))
    # Reverse mapping: track which modules each class includes (for method lookup)
    @class_included_modules : Hash(String, Set(String))
    # Modules that have `extend self` applied (treat defs without receiver as class methods).
    @module_extend_self : Set(String)

    # Type aliases (alias_name -> target_type_name)
    @type_aliases : Hash(String, String)

    # Track which allocators have been generated (to avoid duplicates for reopened classes)
    @generated_allocators : Set(String)

    # Type cache to prevent infinite recursion in type_ref_for_name/create_union_type
    @type_cache : Hash(String, TypeRef)

    # Temporary arena switching context for cross-file yield inlining:
    # {caller_arena, callee_arena}
    @inline_arenas : Array(CrystalV2::Compiler::Frontend::ArenaLike)? = nil

    # While inlining yield-functions, we must preserve caller locals for the block body.
    # Otherwise callee locals (especially `self`) can leak into the caller and break ivar access.
    @inline_caller_locals_stack : Array(Hash(String, ValueId)) = [] of Hash(String, ValueId)
    # Preserve caller class/method so block bodies resolve unqualified calls in caller scope.
    @inline_caller_class_stack : Array(String?) = [] of String?
    @inline_caller_method_stack : Array(String?) = [] of String?
    @inline_caller_method_is_class_stack : Array(Bool) = [] of Bool
    # Preserve caller type-parameter bindings for block bodies during yield inlining.
    @inline_caller_type_param_map_stack : Array(Hash(String, String)) = [] of Hash(String, String)
    # Loop-carried locals for inline yield contexts (used to keep phi-bound values stable).
    @inline_loop_vars_stack : Array(Set(String)) = [] of Set(String)

    # While inlining yield-functions, substitute `yield` with the call-site block body.
    # Use a stack to support nested inlining (a block body may itself contain `yield`).
    @inline_yield_block_stack : Array(CrystalV2::Compiler::Frontend::BlockNode) = [] of CrystalV2::Compiler::Frontend::BlockNode
    @inline_yield_block_arena_stack : Array(CrystalV2::Compiler::Frontend::ArenaLike) = [] of CrystalV2::Compiler::Frontend::ArenaLike

    # Track currently inlined yield-functions to avoid infinite inline recursion on stdlib code.
    @inline_yield_name_stack : Array(String) = [] of String
    # Track when we are lowering an inlined block body to keep non-local returns intact.
    @inline_yield_block_body_depth : Int32 = 0
    # Track when we are lowering proc literal bodies (returns should not escape).
    @inline_yield_proc_depth : Int32 = 0

    # Inline return handling for yield-function inlining.
    class InlineReturnContext
      getter exit_block : BlockId
      getter incoming : Array({BlockId, ValueId})
      getter function_id : FunctionId

      def initialize(@exit_block : BlockId, @incoming : Array({BlockId, ValueId}), @function_id : FunctionId)
      end
    end

    struct InlineReturnOverride
      getter active : Bool
      getter context : InlineReturnContext?

      def initialize(@active : Bool, @context : InlineReturnContext?)
      end
    end

    @inline_yield_return_stack : Array(InlineReturnContext) = [] of InlineReturnContext
    @inline_yield_return_override_stack : Array(InlineReturnOverride) = [] of InlineReturnOverride

    # Captures computed for block literals (body_block -> captures).
    @block_captures : Hash(BlockId, Array(CapturedVar)) = {} of BlockId => Array(CapturedVar)
    # Map block node object ids to the arena they were created in.
    @block_node_arenas : Hash(UInt64, CrystalV2::Compiler::Frontend::ArenaLike) = {} of UInt64 => CrystalV2::Compiler::Frontend::ArenaLike

    # Track declared type names for locals (used to resolve module-typed receivers).
    @current_typeof_local_names : Hash(String, String)?
    # Short name index for class/struct lookups (short -> full names).
    @short_type_index : Hash(String, Set(String))
    # Track constant definitions and inferred types for constant resolution.
    @constant_defs : Set(String)
    @constant_types : Hash(String, TypeRef)

    # Track top-level `def main` so we can remap calls and avoid entrypoint collisions.
    @top_level_main_defined : Bool

    # Source text per arena (used to reconstruct macro literal text from spans).
    @sources_by_arena : Hash(CrystalV2::Compiler::Frontend::ArenaLike, String)
    # Source path per arena (used for diagnostics).
    @paths_by_arena : Hash(CrystalV2::Compiler::Frontend::ArenaLike, String)
    # Extra source snippets (macro expansion/reparse) to keep slices alive.
    @extra_sources_by_arena : Hash(CrystalV2::Compiler::Frontend::ArenaLike, Array(String))
    @last_splat_context : String?
    @type_literal_values : Set(ValueId)
    @debug_callsite : String?
    @pending_def_annotations : Array(Tuple(CrystalV2::Compiler::Frontend::AnnotationNode, CrystalV2::Compiler::Frontend::ArenaLike))

    def initialize(
      @arena,
      module_name : String = "main",
      sources_by_arena : Hash(CrystalV2::Compiler::Frontend::ArenaLike, String)? = nil,
      paths_by_arena : Hash(CrystalV2::Compiler::Frontend::ArenaLike, String)? = nil
    )
      @module = Module.new(module_name)
      @function_types = {} of String => TypeRef
      @function_base_names = Set(String).new
      @function_base_return_types = {} of String => TypeRef
      @function_enum_return_names = {} of String => String
      @function_return_type_literals = Set(String).new
      @class_info = {} of String => ClassInfo
      @module_class_vars = {} of String => Array(ClassVarInfo)
      @lib_structs = Set(String).new
      @init_params = {} of String => Array({String, TypeRef})
      @current_class = nil
      @current_namespace_override = nil
      @current_method = nil
      @current_method_is_class = false
      @current_typeof_locals = nil
      @infer_expr_stack = Set(UInt64).new
      @union_descriptors = {} of MIR::TypeRef => MIR::UnionDescriptor
      @function_defs = {} of String => CrystalV2::Compiler::Frontend::DefNode
      @function_def_arenas = {} of String => CrystalV2::Compiler::Frontend::ArenaLike
      @yield_functions = Set(String).new
      @yield_return_functions = Set(String).new
      @yield_return_checked = Set(String).new
      @lowered_functions = Set(String).new
      @lowering_functions = Set(String).new
      @pending_arg_types = {} of String => Array(TypeRef)
      @pending_arg_types_by_arity = {} of String => Hash(Int32, Array(CallsiteArgs))
      @pending_arg_types_by_signature = {} of CallSignature => Array(CallsiteArgs)
      @pending_arg_type_literals = {} of String => Array(Bool)
      @pending_type_param_maps = {} of String => Hash(String, String)
      @function_type_param_maps = {} of String => Hash(String, String)
      @function_namespace_overrides = {} of String => String
      @generic_templates = {} of String => GenericClassTemplate
      @generic_reopenings = {} of String => Array(GenericClassTemplate)
      @monomorphized = Set(String).new
      @pending_monomorphizations = [] of {String, Array(String), String}
      @defer_monomorphization = true  # Start in deferred mode
      @suppress_monomorphization = false
      @eager_monomorphization = ENV.has_key?("CRYSTAL_V2_EAGER_MONO")
      @type_param_map = {} of String => String
      @macro_defs = {} of String => {CrystalV2::Compiler::Frontend::MacroDefNode, CrystalV2::Compiler::Frontend::ArenaLike}
      @macro_params = {} of String => Array(MacroParamInfo)
      @class_accessor_entries = {} of String => ClassAccessorEntry
      @module_defs = {} of String => Array({CrystalV2::Compiler::Frontend::ModuleNode, CrystalV2::Compiler::Frontend::ArenaLike})
      @module_includers = {} of String => Set(String)
      @class_included_modules = {} of String => Set(String)
      @module_extend_self = Set(String).new
      @type_aliases = {} of String => String
      @generated_allocators = Set(String).new
      @type_cache = {} of String => TypeRef
      @short_type_index = {} of String => Set(String)
      @current_typeof_local_names = nil
      @top_level_main_defined = false
      @block_captures = {} of BlockId => Array(CapturedVar)
      @block_node_arenas = {} of UInt64 => CrystalV2::Compiler::Frontend::ArenaLike
      @sources_by_arena = sources_by_arena || {} of CrystalV2::Compiler::Frontend::ArenaLike => String
      @paths_by_arena = paths_by_arena || {} of CrystalV2::Compiler::Frontend::ArenaLike => String
      @extra_sources_by_arena = {} of CrystalV2::Compiler::Frontend::ArenaLike => Array(String)
      @last_splat_context = nil
      @type_literal_values = Set(ValueId).new
      @constant_defs = Set(String).new
      @constant_types = {} of String => TypeRef
      @debug_callsite = nil
      @pending_def_annotations = [] of Tuple(CrystalV2::Compiler::Frontend::AnnotationNode, CrystalV2::Compiler::Frontend::ArenaLike)
    end

    private def with_debug_callsite(label : String?, &)
      return yield unless DebugHooks::ENABLED && label

      previous = @debug_callsite
      @debug_callsite = label
      begin
        yield
      ensure
        @debug_callsite = previous
      end
    end

    private def clear_pending_effect_annotations : Nil
      @pending_def_annotations.clear
    end

    private def effect_annotation_name(node : CrystalV2::Compiler::Frontend::AnnotationNode) : String?
      name = resolve_annotation_name(node.name)
      return nil unless name
      return name if name.in?("NoEscape", "Transfer", "ThreadShared", "FFIExposed", "ReturnsAlias", "Taints")
      nil
    end

    private def taint_tag_from_expr(expr_id : CrystalV2::Compiler::Frontend::ExprId) : String?
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::SymbolNode
        tag = String.new(node.name)
        tag.starts_with?(":") ? tag[1..] : tag
      when CrystalV2::Compiler::Frontend::StringNode
        String.new(node.value)
      when CrystalV2::Compiler::Frontend::IdentifierNode
        String.new(node.name)
      else
        nil
      end
    end

    private def taint_named_arg_truthy?(expr_id : CrystalV2::Compiler::Frontend::ExprId) : Bool
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::BoolNode
        node.value
      when CrystalV2::Compiler::Frontend::NilNode
        false
      else
        true
      end
    end

    private def apply_taint_tag(summary : MethodEffectSummary, tag : String) : MethodEffectSummary
      normalized = tag.downcase
      case normalized
      when "thread_shared", "threadshared", "thread-shared"
        summary.thread_shared = true
      when "ffi_exposed", "ffiexposed", "ffi-exposed", "ffi"
        summary.ffi_exposed = true
      end
      summary
    end

    private def apply_taints_annotation(
      node : CrystalV2::Compiler::Frontend::AnnotationNode,
      summary : MethodEffectSummary
    ) : MethodEffectSummary
      node.args.each do |arg_id|
        if tag = taint_tag_from_expr(arg_id)
          summary = apply_taint_tag(summary, tag)
        end
      end

      if named_args = node.named_args
        named_args.each do |named_arg|
          next unless taint_named_arg_truthy?(named_arg.value)
          summary = apply_taint_tag(summary, String.new(named_arg.name))
        end
      end

      summary
    end

    private def remember_effect_annotation(
      node : CrystalV2::Compiler::Frontend::AnnotationNode,
      arena : CrystalV2::Compiler::Frontend::ArenaLike
    ) : Nil
      with_arena(arena) do
        return unless effect_annotation_name(node)
      end
      @pending_def_annotations << {node, arena}
    end

    private def register_pending_method_effects(full_name : String, _param_count : Int32) : Nil
      return if @pending_def_annotations.empty?

      summary = MethodEffectSummary.new
      @pending_def_annotations.each do |annotation_node, annotation_arena|
        with_arena(annotation_arena) do
          case effect_annotation_name(annotation_node)
          when "NoEscape"
            summary.no_escape = true
          when "Transfer"
            summary.transfer = true
          when "ThreadShared"
            summary.thread_shared = true
          when "FFIExposed"
            summary.ffi_exposed = true
          when "ReturnsAlias"
            summary.returns_alias = true
          when "Taints"
            summary = apply_taints_annotation(annotation_node, summary)
          end
        end
      end

      clear_pending_effect_annotations
      @module.add_method_effect(full_name, summary) unless summary.empty?
    end

    private def fun_def?(node : CrystalV2::Compiler::Frontend::DefNode) : Bool
      if recv = node.receiver
        String.new(recv) == FUN_DEF_RECEIVER
      else
        false
      end
    end

    private def record_module_inclusion(module_name : String, class_name : String) : Nil
      # Resolve type aliases in the module name (e.g., Engine::MatchData -> PCRE2::MatchData)
      resolved_module_name = resolve_module_alias_for_include(module_name)
      if ENV["DEBUG_MODULE_INCLUDE"]? && (module_name.includes?("FileDescriptor") || class_name.includes?("EventLoop") || module_name.includes?("MatchData"))
        STDERR.puts "[DEBUG_MODULE_INCLUDE] #{class_name} <= #{module_name} (resolved: #{resolved_module_name})"
      end
      set = @module_includers[resolved_module_name]? || begin
        new_set = Set(String).new
        @module_includers[resolved_module_name] = new_set
        new_set
      end
      set.add(class_name)
      @module.register_module_includer(resolved_module_name, class_name)
      # Also record reverse mapping (class -> modules it includes)
      class_set = @class_included_modules[class_name]? || begin
        new_set = Set(String).new
        @class_included_modules[class_name] = new_set
        new_set
      end
      class_set.add(resolved_module_name)
      debug_hook("module.include", "#{class_name} <= #{resolved_module_name}")
    end

    # Resolve type aliases for module names like Engine::MatchData -> Regex::PCRE::MatchData
    private def resolve_module_alias_for_include(module_name : String) : String
      return module_name if module_name.empty?

      candidates = [] of String
      candidates << module_name

      if current = @current_class
        if current.includes?("::")
          parts = current.split("::")
          parts.pop
          while parts.size > 0
            candidates << "#{parts.join("::")}::#{module_name}"
            parts.pop
          end
        end
      end

      candidates.each do |candidate|
        resolved = resolve_module_alias_prefix(candidate)
        return resolved if @module_defs.has_key?(resolved)
      end

      module_name
    end

    private def resolve_module_alias_prefix(module_name : String) : String
      return resolve_type_alias_chain(module_name) unless module_name.includes?("::")

      parts = module_name.split("::")
      (parts.size - 1).downto(1) do |i|
        prefix = parts[0, i].join("::")
        resolved_prefix = resolve_type_alias_chain(prefix)
        if resolved_prefix != prefix
          return ([resolved_prefix] + parts[i..]).join("::")
        end
      end

      resolve_type_alias_chain(module_name)
    end

    private def named_only_separator?(param : CrystalV2::Compiler::Frontend::Parameter) : Bool
      param.is_splat && param.name.nil? && param.external_name.nil?
    end

    # Register a function type and maintain the base name index
    private def register_function_type(full_name : String, return_type : TypeRef)
      @function_types[full_name] = return_type
      # Extract base name (without $ type suffix) for fast lookups
      base_name = full_name.split("$").first
      @function_base_names.add(base_name)
      # Cache a representative return type for the base name.
      # Prefer a non-VOID return type when available.
      if return_type != TypeRef::VOID
        cached = @function_base_return_types[base_name]?
        if cached.nil? || cached == TypeRef::VOID || (cached == TypeRef::NIL && return_type != TypeRef::NIL)
          @function_base_return_types[base_name] = return_type
        end
      end
      # Debug hook: extract class and method from base_name (Class#method or Class.method)
      if base_name.includes?("#")
        parts = base_name.split("#", 2)
        debug_hook_method_register(full_name, parts[0], parts[1])
      elsif base_name.includes?(".")
        parts = base_name.split(".", 2)
        debug_hook_method_register(full_name, parts[0], parts[1])
      else
        debug_hook_method_register(full_name, "", base_name)
      end
      if DebugHooks::ENABLED && (full_name.includes?("bsearch") || base_name.ends_with?("#first") || base_name.ends_with?(".first"))
        debug_hook("method.return", "name=#{full_name} type=#{get_type_name_from_ref(return_type)}")
      end
      if ENV["DEBUG_TO_S_REGISTER"]? && base_name.ends_with?("#to_s")
        STDERR.puts "[TO_S_REGISTER] full=#{full_name} base=#{base_name} ret=#{get_type_name_from_ref(return_type)}"
      end
    end

    private def enum_return_name_for(function_name : String) : String?
      if enum_name = @function_enum_return_names[function_name]?
        return enum_name
      end
      base_name = function_name.split("$").first
      if enum_name = @function_enum_return_names[base_name]?
        return enum_name
      end

      # Fallback: derive enum return name from the def's return type annotation.
      def_node = @function_defs[function_name]? || @function_defs[base_name]?
      return nil unless def_node
      rt = def_node.return_type
      return nil unless rt

      owner = function_context_from_name(base_name)
      old_class = @current_class
      @current_class = owner if owner
      resolved = resolve_type_name_in_context(String.new(rt))
      @current_class = old_class
      if enum_name = resolve_enum_name(resolved)
        @function_enum_return_names[function_name] = enum_name
        @function_enum_return_names[base_name] = enum_name
        return enum_name
      end

      nil
    end

    # Check if a function exists with given base name (fast O(1) lookup)
    private def has_function_base?(base_name : String) : Bool
      @function_base_names.includes?(base_name)
    end

    private def abstract_def?(full_name : String) : Bool
      def_node = @function_defs[full_name]?
      return false unless def_node
      def_node.body.nil?
    end

    private def class_has_subclasses?(class_name : String) : Bool
      @class_info.each_value.any? do |info|
        parent = info.parent_name
        next false unless parent
        parent == class_name || parent.ends_with?("::#{class_name}")
      end
    end

    # Get class info by name
    def get_class_info(name : String) : ClassInfo?
      @class_info[name]?
    end

    # Enum info: name -> {member_name -> value}
    @enum_info : Hash(String, Hash(String, Int64))?
    # Enum base types: name -> underlying type
    @enum_base_types : Hash(String, TypeRef)?
    # Map enum value literals to their enum type names (for method resolution).
    @enum_value_types : Hash(ValueId, String)?

    private def enum_base_type_for_node(node : CrystalV2::Compiler::Frontend::EnumNode) : TypeRef
      if base = node.base_type
        type_ref_for_name(String.new(base))
      else
        TypeRef::INT32
      end
    end

    private def register_enum_base_type(enum_name : String, base_type : TypeRef)
      enum_base_types = @enum_base_types ||= {} of String => TypeRef
      enum_base_types[enum_name] = base_type
    end

    private def enum_base_type(enum_name : String) : TypeRef
      @enum_base_types.try(&.[enum_name]?) || TypeRef::INT32
    end

    private def resolve_enum_name(name : String) : String?
      return nil unless enum_info = @enum_info
      return name if enum_info.has_key?(name)
      short_name = name.split("::").last?
      return short_name if short_name && enum_info.has_key?(short_name)
      if short_name
        matches = enum_info.keys.select { |key| key.ends_with?("::#{short_name}") }
        return matches.first if matches.size == 1
      end
      matches = enum_info.keys.select { |key| key.ends_with?("::#{name}") }
      return matches.first if matches.size == 1
      nil
    end

    # Track a value as an enum type if the type name is a known enum
    # Call this after registering a local/param to associate it with its enum type
    private def track_enum_value(value_id : ValueId, type_name : String)
      return if type_name.empty?

      candidates = [] of String
      if type_name.includes?("|")
        candidates = type_name.split("|").map(&.strip)
      elsif type_name.ends_with?("?")
        candidates << type_name[0, type_name.size - 1]
      else
        candidates << type_name
      end

      candidates.each do |candidate|
        resolved = resolve_type_name_in_context(candidate)
        resolved = resolve_type_alias_chain(resolved)
        if enum_name = resolve_enum_name(resolved)
          (@enum_value_types ||= {} of ValueId => String)[value_id] = enum_name
          break
        end
      end
    end

    # Register an enum type (pass 1)
    def register_enum(node : CrystalV2::Compiler::Frontend::EnumNode)
      enum_name = String.new(node.name)
      @enum_info ||= {} of String => Hash(String, Int64)

      members = {} of String => Int64
      current_value = 0_i64

      node.members.each do |member|
        member_name = String.new(member.name)
        # If member has explicit value, use it
        if val_id = member.value
          val_node = @arena[val_id]
          if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
            current_value = String.new(val_node.value).to_i64? || current_value
          end
        end
        members[member_name] = current_value
        current_value += 1
      end

      @enum_info.not_nil![enum_name] = members
      invalidate_type_cache_for_namespace(enum_name)
      register_enum_base_type(enum_name, enum_base_type_for_node(node))
      register_enum_methods(node, enum_name)
    end

    # Register an enum type with explicit name (for nested enums)
    def register_enum_with_name(node : CrystalV2::Compiler::Frontend::EnumNode, full_enum_name : String)
      full_enum_name = resolve_class_name_for_definition(full_enum_name)
      @enum_info ||= {} of String => Hash(String, Int64)

      members = {} of String => Int64
      current_value = 0_i64

      node.members.each do |member|
        member_name = String.new(member.name)
        # If member has explicit value, use it
        if val_id = member.value
          val_node = @arena[val_id]
          if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
            current_value = String.new(val_node.value).to_i64? || current_value
          end
        end
        members[member_name] = current_value
        current_value += 1
      end

      @enum_info.not_nil![full_enum_name] = members
      invalidate_type_cache_for_namespace(full_enum_name)
      base_type = enum_base_type_for_node(node)
      register_enum_base_type(full_enum_name, base_type)
      debug_hook_enum_register(full_enum_name, @module.get_type_descriptor(base_type).try(&.name) || "?")
      register_enum_methods(node, full_enum_name)
    end

    def register_constant(node : CrystalV2::Compiler::Frontend::ConstantNode, owner_name : String? = nil)
      const_name = String.new(node.name)
      record_constant_definition(owner_name, const_name, node.value, @arena)
    end

    def register_constant_value(
      name : String,
      value_id : ExprId,
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      owner_name : String? = nil
    )
      record_constant_definition(owner_name, name, value_id, arena)
    end

    # Register a macro definition (pass 1)
    def register_macro(node : CrystalV2::Compiler::Frontend::MacroDefNode, scope_name : String? = nil)
      macro_name = String.new(node.name)
      key = scope_name ? "#{scope_name}::#{macro_name}" : macro_name
      @macro_defs[key] = {node, @arena}
      @macro_params[key] = extract_macro_params(node)
    end

    private def lookup_macro_entry(method_name : String, scope_name : String? = nil)
      if scope = scope_name
        scoped = "#{scope}::#{method_name}"
        if ENV["DEBUG_RECORD_LOOKUP"]? && method_name == "record"
          STDERR.puts "[DEBUG_RECORD_LOOKUP] scope=#{scope} scoped=#{scoped} has_scoped=#{@macro_defs.has_key?(scoped)} has_global=#{@macro_defs.has_key?(method_name)}"
        end
        if entry = @macro_defs[scoped]?
          return {entry, scoped}
        end
      end
      if entry = @macro_defs[method_name]?
        if ENV["DEBUG_RECORD_LOOKUP"]? && method_name == "record"
          STDERR.puts "[DEBUG_RECORD_LOOKUP] scope=(none) has_global=true"
        end
        return {entry, method_name}
      end
      if ENV["DEBUG_RECORD_LOOKUP"]? && method_name == "record"
        STDERR.puts "[DEBUG_RECORD_LOOKUP] scope=#{scope_name || "(none)"} has_global=false"
      end
      nil
    end

    private def macro_def_maybe_defines_type?(
      macro_def : CrystalV2::Compiler::Frontend::MacroDefNode,
      macro_arena : CrystalV2::Compiler::Frontend::ArenaLike
    ) : Bool
      old_arena = @arena
      @arena = macro_arena
      begin
        body = @arena[macro_def.body]
        if body.is_a?(CrystalV2::Compiler::Frontend::MacroLiteralNode)
          if raw_text = macro_literal_raw_text(body)
            return raw_text.includes?("class") || raw_text.includes?("struct") ||
                   raw_text.includes?("module") || raw_text.includes?("enum")
          end
        end
      ensure
        @arena = old_arena
      end
      false
    end

    private def register_nested_types_from_macro_expansion(class_name : String, expr_id : ExprId)
      return if expr_id.invalid?
      member = unwrap_visibility_member(@arena[expr_id])
      if ENV["DEBUG_MACRO_TYPE_REG"]?
        STDERR.puts "[DEBUG_MACRO_TYPE_REG] expanded root=#{member.class}"
      end
      case member
      when CrystalV2::Compiler::Frontend::BlockNode
        member.body.each do |child_id|
          register_nested_types_from_macro_expansion(class_name, child_id)
        end
      when CrystalV2::Compiler::Frontend::ClassNode
        nested_name = String.new(member.name)
        full_name = "#{class_name}::#{nested_name}"
        if ENV["DEBUG_MACRO_TYPE_REG"]?
          STDERR.puts "[DEBUG_MACRO_TYPE_REG] register class #{full_name}"
        end
        register_class_with_name(member, full_name)
      when CrystalV2::Compiler::Frontend::ModuleNode
        nested_name = String.new(member.name)
        full_name = "#{class_name}::#{nested_name}"
        if ENV["DEBUG_MACRO_TYPE_REG"]?
          STDERR.puts "[DEBUG_MACRO_TYPE_REG] register module #{full_name}"
        end
        register_module_with_name(member, full_name)
      when CrystalV2::Compiler::Frontend::EnumNode
        nested_name = String.new(member.name)
        full_name = "#{class_name}::#{nested_name}"
        if ENV["DEBUG_MACRO_TYPE_REG"]?
          STDERR.puts "[DEBUG_MACRO_TYPE_REG] register enum #{full_name}"
        end
        register_enum_with_name(member, full_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        result = try_evaluate_macro_condition(member.condition)
        if result == true
          register_nested_types_from_macro_expansion(class_name, member.then_body)
        elsif result == false
          if else_body = member.else_body
            register_nested_types_from_macro_expansion(class_name, else_body)
          end
        else
          register_nested_types_from_macro_expansion(class_name, member.then_body)
          if else_body = member.else_body
            register_nested_types_from_macro_expansion(class_name, else_body)
          end
        end
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_class(member, class_name)
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_class(member, class_name)
      end
    end

    private def register_class_members_from_expansion(
      class_name : String,
      expr_id : ExprId,
      defined_class_method_full_names : Set(String),
      visited_extends : Set(String)
    ) : Nil
      return if expr_id.invalid?
      member = unwrap_visibility_member(@arena[expr_id])
      if !member.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode) &&
         !member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
        clear_pending_effect_annotations
      end
      case member
      when CrystalV2::Compiler::Frontend::BlockNode
        member.body.each do |child_id|
          register_class_members_from_expansion(class_name, child_id, defined_class_method_full_names, visited_extends)
        end
      when CrystalV2::Compiler::Frontend::ExtendNode
        register_module_class_methods_for(class_name, member.target, defined_class_method_full_names, visited_extends)
      when CrystalV2::Compiler::Frontend::MacroDefNode
        register_macro(member, class_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        result = try_evaluate_macro_condition(member.condition)
        if result == true
          register_class_members_from_expansion(class_name, member.then_body, defined_class_method_full_names, visited_extends)
        elsif result == false
          if else_body = member.else_body
            else_node = @arena[else_body]
            if else_node.is_a?(CrystalV2::Compiler::Frontend::MacroIfNode)
              register_class_members_from_expansion(class_name, else_body, defined_class_method_full_names, visited_extends)
            else
              register_class_members_from_expansion(class_name, else_body, defined_class_method_full_names, visited_extends)
            end
          end
        else
          register_class_members_from_expansion(class_name, member.then_body, defined_class_method_full_names, visited_extends)
          if else_body = member.else_body
            register_class_members_from_expansion(class_name, else_body, defined_class_method_full_names, visited_extends)
          end
        end
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        if raw_text = macro_literal_raw_text(member)
          expanded = expand_flag_macro_text(raw_text) || raw_text
          if program = parse_macro_literal_program(expanded)
            program.roots.each do |child_id|
              register_class_members_from_expansion(class_name, child_id, defined_class_method_full_names, visited_extends)
            end
          end
        end
      end
    end

    private def extract_macro_params(node : CrystalV2::Compiler::Frontend::MacroDefNode) : Array(MacroParamInfo)
      source = @sources_by_arena[@arena]?
      return [] of MacroParamInfo unless source

      span = node.span
      start = span.start_offset
      length = span.end_offset - span.start_offset
      return [] of MacroParamInfo if length <= 0
      return [] of MacroParamInfo if start < 0 || start >= source.bytesize
      if start + length > source.bytesize
        length = source.bytesize - start
      end

      snippet = source.byte_slice(start, length)
      lexer = CrystalV2::Compiler::Frontend::Lexer.new(snippet)

      params = [] of MacroParamInfo
      seen_macro = false
      seen_name = false
      depth = 0
      current_tokens = [] of CrystalV2::Compiler::Frontend::Token

      loop do
        token = lexer.next_token
        break if token.kind == CrystalV2::Compiler::Frontend::Token::Kind::EOF
        next if token.kind == CrystalV2::Compiler::Frontend::Token::Kind::Whitespace ||
                token.kind == CrystalV2::Compiler::Frontend::Token::Kind::Comment

        case token.kind
        when CrystalV2::Compiler::Frontend::Token::Kind::Macro
          seen_macro = true
        when CrystalV2::Compiler::Frontend::Token::Kind::Identifier
          name = String.new(token.slice)
          if seen_macro && !seen_name
            seen_name = true
          elsif depth == 1
            current_tokens << token
          end
        when CrystalV2::Compiler::Frontend::Token::Kind::LParen
          if seen_name && depth == 0
            depth = 1
          elsif depth > 0
            depth += 1
          end
        when CrystalV2::Compiler::Frontend::Token::Kind::RParen
          if depth == 1
            if info = parse_macro_param_tokens(current_tokens)
              params << info
            end
            current_tokens.clear
            depth = 0
            break
          elsif depth > 1
            depth -= 1
          end
        when CrystalV2::Compiler::Frontend::Token::Kind::Comma
          if depth == 1
            if info = parse_macro_param_tokens(current_tokens)
              params << info
            end
            current_tokens.clear
          end
        when CrystalV2::Compiler::Frontend::Token::Kind::StarStar
          current_tokens << token if depth == 1
        when CrystalV2::Compiler::Frontend::Token::Kind::Star
          current_tokens << token if depth == 1
        else
          current_tokens << token if depth == 1
        end
      end

      params
    end

    private def parse_macro_param_tokens(tokens : Array(CrystalV2::Compiler::Frontend::Token)) : MacroParamInfo?
      return nil if tokens.empty?

      prefix = ""
      names = [] of String

      tokens.each do |token|
        case token.kind
        when CrystalV2::Compiler::Frontend::Token::Kind::StarStar
          prefix = "**"
        when CrystalV2::Compiler::Frontend::Token::Kind::Star
          prefix = "*"
        when CrystalV2::Compiler::Frontend::Token::Kind::Identifier
          names << String.new(token.slice)
        end
      end

      return nil if names.empty?
      if names.first? == "__name"
        names.shift
      end
      return nil if names.empty?

      internal = names.last
      external = names.size > 1 ? names.first : nil
      MacroParamInfo.new(internal, external, prefix)
    end

    # Register a type alias (pass 1)
    # e.g., alias HIR = Crystal::HIR
    def register_alias(node : CrystalV2::Compiler::Frontend::AliasNode)
      alias_name = String.new(node.name)
      full_alias_name = alias_full_name_from_span(node) || alias_name
      context = if full_alias_name.includes?("::")
                  parts = full_alias_name.split("::")
                  parts.size > 1 ? parts[0...-1].join("::") : nil
                else
                  nil
                end
      old_class = @current_class
      @current_class = context if context
      target_name = resolve_alias_target(String.new(node.value))
      @current_class = old_class if context
      previous = @type_aliases[full_alias_name]?
      register_type_alias(full_alias_name, target_name)
      if ENV.has_key?("DEBUG_ALIAS") && @type_aliases[full_alias_name]? == target_name && previous != target_name
        STDERR.puts "[ALIAS] Registered (top): #{full_alias_name} => #{target_name}"
      end
    end

    private def alias_full_name_from_span(node : CrystalV2::Compiler::Frontend::AliasNode) : String?
      source = @sources_by_arena[@arena]?
      return nil unless source

      span = node.span
      start = span.start_offset
      finish = span.end_offset
      return nil if start < 0 || finish <= start || finish > source.bytesize

      snippet = source.byte_slice(start, finish - start)
      if match = snippet.match(/alias\s+([A-Za-z0-9_:]+)\s*=/)
        return match[1]
      end

      nil
    end

    private def register_type_alias(alias_name : String, target_name : String)
      if existing = @type_aliases[alias_name]?
        if existing != target_name
          if ENV.has_key?("DEBUG_ALIAS")
            STDERR.puts "[ALIAS] Skipping redefinition: #{alias_name} already #{existing}, new #{target_name}"
          end
          return
        end
      end
      @type_aliases[alias_name] = target_name
      @type_cache.delete(alias_name)
      invalidate_type_cache_for_namespace(alias_name)
    end

    # Register a C library binding (pass 1)
    # e.g., lib LibC ... end
    def register_lib(
      node : CrystalV2::Compiler::Frontend::LibNode,
      annotations : Array(Tuple(CrystalV2::Compiler::Frontend::AnnotationNode, CrystalV2::Compiler::Frontend::ArenaLike))? = nil
    )
      if annotations
        old_arena = @arena
        annotations.each do |annotation_node, annotation_arena|
          @arena = annotation_arena
          register_link_libraries_from_annotation(annotation_node)
        end
        @arena = old_arena
      end

      lib_name = String.new(node.name)

      if body = node.body
        # First pass: register lib-local types so extern param/return types resolve correctly.
        body.each do |expr_id|
          body_node = @arena[expr_id]
          register_lib_member(body_node, lib_name, :types)
        end

        # Second pass: register extern functions after types are available.
        body.each do |expr_id|
          body_node = @arena[expr_id]
          register_lib_member(body_node, lib_name, :externs)
        end
      end
    end

    private def register_lib_member(node : AstNode, lib_name : String, pass : Symbol)
      case node
      when CrystalV2::Compiler::Frontend::AliasNode
        return unless pass == :types
        alias_name = String.new(node.name)
        old_class = @current_class
        @current_class = lib_name
        target_name = resolve_alias_target(String.new(node.value))
        @current_class = old_class
        full_alias_name = "#{lib_name}::#{alias_name}"
        register_type_alias(full_alias_name, target_name)
      when CrystalV2::Compiler::Frontend::EnumNode
        return unless pass == :types
        enum_name = String.new(node.name)
        full_enum_name = "#{lib_name}::#{enum_name}"
        register_enum_with_name(node, full_enum_name)
      when CrystalV2::Compiler::Frontend::ClassNode
        return unless pass == :types
        struct_name = String.new(node.name)
        full_struct_name = "#{lib_name}::#{struct_name}"
        register_class_with_name(node, full_struct_name)
        @lib_structs.add(full_struct_name)
      when CrystalV2::Compiler::Frontend::FunNode
        return unless pass == :externs
        register_extern_fun(lib_name, node)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        process_macro_if_in_lib(node, lib_name, pass)
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_lib(node, lib_name, pass)
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_lib(node, lib_name, pass)
      end
    end

    private def process_macro_if_in_lib(node : CrystalV2::Compiler::Frontend::MacroIfNode, lib_name : String, pass : Symbol)
      if raw_text = macro_if_raw_text(node)
        nested_macro_end = raw_text.scan(/\{%\s*end\s*%\}/).size > 1
        unless nested_macro_end
          if expanded = expand_flag_macro_text(raw_text)
            if parsed = parse_macro_literal_lib_body(expanded)
              program, body = parsed
              with_arena(program.arena) do
                body.each do |expr_id|
                  register_lib_member(@arena[expr_id], lib_name, pass)
                end
              end
              return
            end
          end
        end
      end

      result = try_evaluate_macro_condition(node.condition)
      if result == true
        process_macro_body_in_lib(node.then_body, lib_name, pass)
      elsif result == false
        if else_node = node.else_body
          else_ast = @arena[else_node]
          case else_ast
          when CrystalV2::Compiler::Frontend::MacroIfNode
            process_macro_if_in_lib(else_ast, lib_name, pass)
          else
            process_macro_body_in_lib(else_node, lib_name, pass)
          end
        end
      else
        process_macro_body_in_lib(node.then_body, lib_name, pass)
        if else_node = node.else_body
          process_macro_body_in_lib(else_node, lib_name, pass)
        end
      end
    end

    private def process_macro_body_in_lib(body_id : ExprId, lib_name : String, pass : Symbol)
      body_node = @arena[body_id]
      case body_node
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_lib(body_node, lib_name, pass)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        process_macro_if_in_lib(body_node, lib_name, pass)
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_lib(body_node, lib_name, pass)
      else
        register_lib_member(body_node, lib_name, pass)
      end
    end

    private def process_macro_for_in_lib(node : CrystalV2::Compiler::Frontend::MacroForNode, lib_name : String, pass : Symbol)
      iter_vars = node.iter_vars.map { |name| String.new(name) }
      return if iter_vars.empty?

      values = macro_for_iterable_values(node.iterable)
      return unless values

      source = @sources_by_arena[@arena]?
      program = CrystalV2::Compiler::Frontend::Program.new(@arena, [] of ExprId)
      expander = CrystalV2::Compiler::Semantic::MacroExpander.new(
        program,
        @arena,
        CrystalV2::Runtime.target_flags,
        recovery_mode: true,
        macro_source: source
      )
      owner_type = macro_owner_type_for(lib_name)

      expanded = String.build do |io|
        values.each_with_index do |value, idx|
          vars = {} of String => CrystalV2::Compiler::Semantic::MacroValue
          vars[iter_vars[0]] = value
          if idx_name = iter_vars[1]?
            vars[idx_name] = CrystalV2::Compiler::Semantic::MacroNumberValue.new(idx.to_i64)
          end
          if body_output = expander.expand_literal(node.body, variables: vars, owner_type: owner_type)
            io << body_output
            io << "\n"
          end
        end
      end

      sanitized = strip_macro_lines(expanded)
      if parsed = parse_macro_literal_lib_body(sanitized)
        program, body = parsed
        with_arena(program.arena) do
          body.each do |expr_id|
            register_lib_member(@arena[expr_id], lib_name, pass)
          end
        end
      end
    end

    private def process_macro_literal_in_lib(node : CrystalV2::Compiler::Frontend::MacroLiteralNode, lib_name : String, pass : Symbol)
      if raw_text = macro_literal_raw_text(node)
        expanded = expand_flag_macro_text(raw_text) || raw_text
        if parsed = parse_macro_literal_lib_body(expanded)
          program, body = parsed
          with_arena(program.arena) do
            body.each do |expr_id|
              register_lib_member(@arena[expr_id], lib_name, pass)
            end
          end
          return
        end
      end

      texts = macro_literal_active_texts(node)
      combined = texts.join("\n")
      if parsed = parse_macro_literal_lib_body(combined)
        program, body = parsed
        with_arena(program.arena) do
          body.each do |expr_id|
            register_lib_member(@arena[expr_id], lib_name, pass)
          end
        end
        return
      end

      texts.each do |text|
        next if text.strip.empty?
        if parsed = parse_macro_literal_lib_body(text)
          program, body = parsed
          with_arena(program.arena) do
            body.each do |expr_id|
              register_lib_member(@arena[expr_id], lib_name, pass)
            end
          end
        end
      end
    end

    private def expand_macro_expr(
      macro_def : CrystalV2::Compiler::Frontend::MacroDefNode,
      macro_arena : CrystalV2::Compiler::Frontend::ArenaLike,
      args : Array(ExprId),
      named_args : Array(CrystalV2::Compiler::Frontend::NamedArgument)?,
      block_id : ExprId?,
      macro_key : String
    ) : ExprId
      macro_name = String.new(macro_def.name)
      params = @macro_params[macro_key]? || @macro_params[macro_name]? || [] of MacroParamInfo
      if ENV["DEBUG_MACRO_EXPAND"]?
        STDERR.puts "[MACRO_EXPAND] name=#{macro_name} key=#{macro_key} args=#{args.size} named=#{named_args.try(&.size) || 0}"
      end
      if ENV["DEBUG_MACRO_PIECES"]? && macro_name == "record"
        body_node = macro_arena[macro_def.body]
        if body_node.is_a?(CrystalV2::Compiler::Frontend::MacroLiteralNode)
          body_node.pieces.each_with_index do |piece, idx|
            next unless piece.kind.text?
            next unless text = piece.text
            if text.includes?("struct")
              STDERR.puts "[MACRO_PIECES] idx=#{idx} text=#{text.inspect}"
            end
          end
          body_node.pieces.each_with_index do |piece, idx|
            next unless piece.kind.expression?
            expr_id = piece.expr
            expr_class = expr_id ? macro_arena[expr_id].class : Nil
            detail = nil
            if expr_id
              expr_node = macro_arena[expr_id]
              if expr_node.is_a?(CrystalV2::Compiler::Frontend::MacroExpressionNode)
                inner = macro_arena[expr_node.expression]
                detail = "inner=#{inner.class}"
                if literal = CrystalV2::Compiler::Frontend.node_literal_string(inner)
                  detail += " literal=#{literal.inspect}"
                end
                if inner.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                  obj = macro_arena[inner.object]
                  detail += " member=#{String.new(inner.member)} obj=#{obj.class}"
                  if obj_lit = CrystalV2::Compiler::Frontend.node_literal_string(obj)
                    detail += " obj_lit=#{obj_lit.inspect}"
                  end
                elsif inner.is_a?(CrystalV2::Compiler::Frontend::CallNode)
                  callee = macro_arena[inner.callee]
                  detail += " callee=#{callee.class}"
                  if callee_lit = CrystalV2::Compiler::Frontend.node_literal_string(callee)
                    detail += " callee_lit=#{callee_lit.inspect}"
                  end
                end
              end
            end
            STDERR.puts "[MACRO_PIECES] expr idx=#{idx} trim_left=#{piece.trim_left} trim_right=#{piece.trim_right} class=#{expr_class} #{detail}".rstrip
          end
          body_node.pieces.each_with_index do |piece, idx|
            next unless piece.kind.control_start?
            next unless keyword = piece.control_keyword
            expr_id = piece.expr
            expr_class = expr_id ? macro_arena[expr_id].class : Nil
            STDERR.puts "[MACRO_PIECES] control idx=#{idx} keyword=#{keyword} expr=#{expr_class}"
          end
        end
      end
      if ENV["DEBUG_MACRO_ARGS"]? && macro_name == "record"
        param_desc = params.map { |param| "#{param.prefix}#{param.name}" }
        STDERR.puts "[MACRO_ARGS] params=#{param_desc.join(",")}"
      end

      normalized_args, normalized_named = normalize_macro_call_args(params, args, named_args)
      if macro_arena != @arena
        if ENV["DEBUG_MACRO_ARGS"]? && macro_name == "record"
          if source = @sources_by_arena[@arena]?
            args.each_with_index do |expr_id, idx|
              snippet = slice_source_for_expr_in_arena(expr_id, @arena, source)
              STDERR.puts "[MACRO_ARGS] raw#{idx}=#{snippet.inspect}"
            end
          end
        end
        normalized_args = normalized_args.map do |expr_id|
          reparse_expr_for_macro(expr_id, @arena, macro_arena)
        end
        normalized_named = normalized_named.try do |list|
          list.map { |named_arg| reparse_named_arg_for_macro(named_arg, @arena, macro_arena) }
        end
      end
      return ExprId.new(-1) if normalized_args.any?(&.invalid?) || normalized_named.try(&.any? { |arg| arg.value.invalid? })
      if ENV["DEBUG_MACRO_ARGS"]? && macro_name == "record"
        normalized_args.each_with_index do |expr_id, idx|
          node = macro_arena[expr_id]
          STDERR.puts "[MACRO_ARGS] #{macro_name} arg#{idx}=#{node.class}"
        end
      end

      macro_params = params.map { |param| "#{param.prefix}#{param.name}" }
      macro_symbol = CrystalV2::Compiler::Semantic::MacroSymbol.new(
        macro_name,
        macro_def.body,
        macro_def.body,
        macro_params
      )

      program = CrystalV2::Compiler::Frontend::Program.new(macro_arena, [] of ExprId)
      expander = CrystalV2::Compiler::Semantic::MacroExpander.new(
        program,
        macro_arena,
        CrystalV2::Runtime.target_flags,
        recovery_mode: true,
        source_provider: ->(expr_id : ExprId) : String? { macro_block_body_text(expr_id) },
        macro_source: @sources_by_arena[macro_arena]?,
        source_sink: ->(code : String) { store_extra_source(macro_arena, code) }
      )

      owner_type = @current_class ? macro_owner_type_for(@current_class.not_nil!) : nil
      expanded_id = expander.expand(
        macro_symbol,
        normalized_args,
        owner_type,
        named_args: normalized_named,
        block_id: block_id
      )
      if output = expander.last_output
        invalidate_type_cache_for_macro_output(output)
      end
      if ENV["DEBUG_MACRO_OUTPUT"]? && macro_name == "record"
        if output = expander.last_output
          snippet = output.size > 400 ? "#{output[0, 400]}..." : output
          STDERR.puts "[MACRO_OUTPUT] name=#{macro_name} len=#{output.bytesize} snippet=#{snippet.inspect}"
        end
      end
      expanded_id
    end

    # Expand a macro call inline using the full macro expander.
    private def expand_macro(
      ctx : LoweringContext,
      macro_def : CrystalV2::Compiler::Frontend::MacroDefNode,
      macro_arena : CrystalV2::Compiler::Frontend::ArenaLike,
      args : Array(ExprId),
      named_args : Array(CrystalV2::Compiler::Frontend::NamedArgument)?,
      block_id : ExprId?,
      macro_key : String
    ) : ValueId
      expanded_id = expand_macro_expr(macro_def, macro_arena, args, named_args, block_id, macro_key)
      if expanded_id.invalid?
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      old_arena = @arena
      @arena = macro_arena
      begin
        last_id = lower_expanded_macro_expr(ctx, expanded_id)
        last_id || begin
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(nil_lit)
          nil_lit.id
        end
      ensure
        @arena = old_arena
      end
    end

    private def normalize_macro_call_args(
      params : Array(MacroParamInfo),
      args : Array(ExprId),
      named_args : Array(CrystalV2::Compiler::Frontend::NamedArgument)?
    ) : {Array(ExprId), Array(CrystalV2::Compiler::Frontend::NamedArgument)?}
      external_to_internal = {} of String => String
      params.each do |param|
        if ext = param.external_name
          external_to_internal[ext] = param.name
        end
      end

      normalized_named = [] of CrystalV2::Compiler::Frontend::NamedArgument
      named_args.try do |list|
        list.each do |named_arg|
          external = String.new(named_arg.name)
          internal = external_to_internal[external]? || external
          normalized_named << CrystalV2::Compiler::Frontend::NamedArgument.new(
            internal.to_slice,
            named_arg.value,
            named_arg.name_span,
            named_arg.value_span
          )
        end
      end

      {args, normalized_named.empty? ? nil : normalized_named}
    end

    private def reparse_expr_for_macro(
      expr_id : ExprId,
      source_arena : CrystalV2::Compiler::Frontend::ArenaLike,
      target_arena : CrystalV2::Compiler::Frontend::ArenaLike
    ) : ExprId
      return expr_id if source_arena == target_arena
      source = @sources_by_arena[source_arena]?
      return ExprId.new(-1) unless source

      text = slice_source_for_expr_in_arena(expr_id, source_arena, source)
      return ExprId.new(-1) unless text
      store_extra_source(target_arena, text)

      lexer = CrystalV2::Compiler::Frontend::Lexer.new(text)
      parser = CrystalV2::Compiler::Frontend::Parser.new(lexer, target_arena, recovery_mode: true)
      program = parser.parse_program
      program.roots.first? || ExprId.new(-1)
    end

    private def reparse_named_arg_for_macro(
      named_arg : CrystalV2::Compiler::Frontend::NamedArgument,
      source_arena : CrystalV2::Compiler::Frontend::ArenaLike,
      target_arena : CrystalV2::Compiler::Frontend::ArenaLike
    ) : CrystalV2::Compiler::Frontend::NamedArgument
      value_id = reparse_expr_for_macro(named_arg.value, source_arena, target_arena)
      CrystalV2::Compiler::Frontend::NamedArgument.new(
        named_arg.name,
        value_id,
        named_arg.name_span,
        named_arg.value_span
      )
    end

    private def macro_block_body_text(block_id : ExprId) : String
      return "" if block_id.invalid?
      block_node = @arena[block_id]
      return "" unless block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
      return "" if block_node.body.empty?

      source = @sources_by_arena[@arena]?
      return "" unless source

      texts = [] of String
      block_node.body.each do |expr_id|
        snippet = slice_source_for_expr_in_arena(expr_id, @arena, source)
        texts << snippet if snippet
      end
      texts.join("\n")
    end

    private def slice_source_for_expr_in_arena(
      expr_id : ExprId,
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      source : String
    ) : String?
      return nil if expr_id.invalid?
      node = arena[expr_id]

      span = node.span
      start = span.start_offset
      length = span.end_offset - span.start_offset
      return nil if length <= 0
      return nil if start < 0 || start >= source.bytesize
      if start + length > source.bytesize
        length = source.bytesize - start
      end
      source.byte_slice(start, length)
    end

    private def macro_owner_type_for(class_name : String) : CrystalV2::Compiler::Semantic::ClassSymbol?
      info = @class_info[class_name]?
      return nil unless info

      scope = CrystalV2::Compiler::Semantic::SymbolTable.new
      class_scope = CrystalV2::Compiler::Semantic::SymbolTable.new

      symbol = CrystalV2::Compiler::Semantic::ClassSymbol.new(
        class_name,
        ExprId.new(-1),
        scope: scope,
        class_scope: class_scope,
        superclass_name: info.parent_name,
        type_parameters: nil,
        is_struct: info.is_struct,
        is_abstract: false
      )

      info.ivars.each do |ivar|
        type_name = type_name_for_macro(ivar.type)
        ivar_name = ivar.name
        ivar_name = ivar_name[1..-1] if ivar_name.starts_with?("@")
        symbol.add_instance_var(ivar_name, type_name, nil, false)
      end

      instance_method_names_for_class(class_name).each do |method_name|
        method_scope = CrystalV2::Compiler::Semantic::SymbolTable.new(scope)
        method_symbol = CrystalV2::Compiler::Semantic::MethodSymbol.new(
          method_name,
          ExprId.new(-1),
          scope: method_scope
        )
        scope.redefine(method_name, method_symbol)
      end

      symbol
    end

    private def instance_method_names_for_class(class_name : String) : Array(String)
      prefix = "#{class_name}#"
      names = Set(String).new
      @function_defs.each_key do |key|
        next unless key.starts_with?(prefix)
        raw = key[prefix.size..]
        method_name = raw.split("(").first
        names.add(method_name)
      end
      names.to_a
    end

    private def type_name_for_macro(type_ref : TypeRef) : String?
      if name = concrete_type_name_for(type_ref)
        return name
      end
      if desc = @module.get_type_descriptor(type_ref)
        return desc.name
      end
      nil
    end

    private def lower_expanded_macro_expr(ctx : LoweringContext, expr_id : ExprId) : ValueId
      if expr_id.invalid?
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::ClassNode
        name = String.new(node.name)
        full_name = resolve_class_name_for_definition(name)
        register_class_with_name(node, full_name)
        lower_class_with_name(node, full_name)
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::ModuleNode
        name = String.new(node.name)
        full_name = resolve_class_name_for_definition(name)
        register_module_with_name(node, full_name)
        lower_module_with_name(node, full_name)
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::EnumNode
        name = String.new(node.name)
        full_name = resolve_class_name_for_definition(name)
        register_enum_with_name(node, full_name)
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      when CrystalV2::Compiler::Frontend::BlockNode
        last_id : ValueId? = nil
        node.body.each do |child_id|
          last_id = lower_expanded_macro_expr(ctx, child_id)
        end
        last_id || begin
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(nil_lit)
          nil_lit.id
        end
      else
        lower_expr(ctx, expr_id)
      end
    end

    private def resolve_path_like_name(expr_id : ExprId) : String?
      return nil if expr_id.invalid?

      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        String.new(node.name)
      when CrystalV2::Compiler::Frontend::ConstantNode
        String.new(node.name)
      when CrystalV2::Compiler::Frontend::PathNode
        left = node.left
        left_name = left ? resolve_path_like_name(left.not_nil!) : nil
        right_name = resolve_path_like_name(node.right)
        return nil unless right_name
        left_name ? "#{left_name}::#{right_name}" : right_name
      when CrystalV2::Compiler::Frontend::GenericNode
        resolve_path_like_name(node.base_type)
      else
        nil
      end
    end

    private def stringify_type_expr(expr_id : ExprId) : String?
      return nil if expr_id.invalid?

      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::TypeofNode
        inner = node.args.first?
        inner ? resolve_typeof_expr(inner) : "Pointer(Void)"
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(node.name)
        @type_param_map[name]? || name
      when CrystalV2::Compiler::Frontend::ConstantNode
        name = String.new(node.name)
        @type_param_map[name]? || name
      when CrystalV2::Compiler::Frontend::PathNode
        resolve_path_string_in_context(collect_path_string(node))
      when CrystalV2::Compiler::Frontend::CallNode
        base = resolve_path_like_name(node.callee) || stringify_type_expr(node.callee)
        return nil unless base
        args = [] of String
        node.args.each do |arg|
          if str = stringify_type_expr(arg)
            args << str
          end
        end
        "#{base}(#{args.join(", ")})"
      when CrystalV2::Compiler::Frontend::GenericNode
        base = stringify_type_expr(node.base_type)
        return nil unless base
        args = [] of String
        node.type_args.each do |arg|
          if str = stringify_type_expr(arg)
            args << str
          end
        end
        "#{base}(#{args.join(", ")})"
      when CrystalV2::Compiler::Frontend::TupleLiteralNode
        args = [] of String
        node.elements.each do |elem|
          args << (stringify_type_expr(elem) || "Unknown")
        end
        "Tuple(#{args.join(", ")})"
      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        entries = node.entries.map do |entry|
          key = String.new(entry.key)
          value = stringify_type_expr(entry.value) || "Unknown"
          "#{key}: #{value}"
        end
        "NamedTuple(#{entries.join(", ")})"
      when CrystalV2::Compiler::Frontend::IndexNode
        base = stringify_type_expr(node.object)
        return nil unless base
        if node.indexes.size == 1
          idx_node = @arena[node.indexes.first]
          if idx_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
            idx_str = String.new(idx_node.value)
            return "StaticArray(#{base}, #{idx_str})"
          end
        end
        nil
      when CrystalV2::Compiler::Frontend::UnaryNode
        base = stringify_type_expr(node.operand)
        return nil unless base
        op = String.new(node.operator)
        case op
        when "?"
          "#{base}?"
        when "*", "**"
          "#{base}#{op}"
        else
          nil
        end
      when CrystalV2::Compiler::Frontend::BinaryNode
        op = String.new(node.operator)
        return nil unless op == "|"
        left = stringify_type_expr(node.left)
        right = stringify_type_expr(node.right)
        return nil unless left && right
        "#{left} | #{right}"
      else
        nil
      end
    end

    private def type_like_expr_id?(expr_id : ExprId) : Bool
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(node.name)
        return true if name[0]?.try(&.uppercase?) || @type_param_map.has_key?(name)
        false
      when CrystalV2::Compiler::Frontend::ConstantNode,
           CrystalV2::Compiler::Frontend::PathNode,
           CrystalV2::Compiler::Frontend::GenericNode,
           CrystalV2::Compiler::Frontend::TypeofNode
        true
      when CrystalV2::Compiler::Frontend::CallNode
        type_like_call_expr?(node)
      else
        false
      end
    end

    private def type_like_call_expr?(node : CrystalV2::Compiler::Frontend::CallNode) : Bool
      base = resolve_path_like_name(node.callee) || stringify_type_expr(node.callee)
      return false unless base
      base = resolve_type_alias_chain(base)
      return false unless base[0]?.try(&.uppercase?) || base.includes?("::")
      node.args.all? { |arg_id| type_like_expr_id?(arg_id) }
    end

    private def normalize_typeof_type_name(type_name : String) : String
      return "Pointer(Void)" if type_name.empty? || type_name == "Void" || type_name == "Unknown" || type_name.includes?("|")
      type_name
    end

    private def resolve_typeof_expr(expr_id : ExprId) : String
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(node.name)
        # Parser stores typeof(...) as identifier name in generic type args
        if name.starts_with?("typeof(") && name.ends_with?(")")
          inner_expr = name[7..-2]  # Extract content between typeof( and )
          resolve_typeof_string_expr(inner_expr)
        else
          resolve_typeof_inner(name)
        end
      when CrystalV2::Compiler::Frontend::InstanceVarNode
        resolve_typeof_inner(String.new(node.name))
      when CrystalV2::Compiler::Frontend::ClassVarNode
        resolve_typeof_inner(String.new(node.name))
      when CrystalV2::Compiler::Frontend::SelfNode
        resolve_typeof_inner("self")
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # Handle expressions like str.to_unsafe.value
        resolve_typeof_member_chain(node)
      when CrystalV2::Compiler::Frontend::CallNode
        # Handle expressions like str.to_unsafe()
        resolve_typeof_call_chain(node)
      else
        "Pointer(Void)"
      end
    end

    # Resolve typeof from a string expression like "str.to_unsafe.value"
    # This handles the case where parser stores typeof(...) as an identifier name
    private def resolve_typeof_string_expr(expr : String) : String
      expr = expr.strip

      # Split on dots to get the call chain
      # Handle patterns like: str.to_unsafe.value, str.to_slice, @buffer.to_unsafe
      parts = split_method_chain(expr)
      return resolve_typeof_inner(expr) if parts.size <= 1

      # Start with the base variable's type
      base = parts[0].strip
      current_type = resolve_typeof_inner(base)
      return "Pointer(Void)" if current_type == "Pointer(Void)"

      # Walk through each method call
      parts[1..].each do |method_part|
        method_name = method_part.gsub(/\(\)$/, "").strip  # Remove trailing ()

        case method_name
        when "to_unsafe"
          if current_type == "String"
            current_type = "Pointer(UInt8)"
          elsif current_type.starts_with?("Array(") && current_type.ends_with?(")")
            inner = current_type[6..-2]
            current_type = "Pointer(#{inner})"
          elsif current_type.starts_with?("Slice(") && current_type.ends_with?(")")
            inner = current_type[6..-2]
            current_type = "Pointer(#{inner})"
          elsif current_type.starts_with?("Pointer(")
            # Already a pointer, to_unsafe is identity
          else
            # Default to Pointer(current_type)
            current_type = "Pointer(#{current_type})"
          end
        when "to_slice"
          if current_type == "String"
            current_type = "Slice(UInt8)"
          elsif current_type.starts_with?("Array(") && current_type.ends_with?(")")
            inner = current_type[6..-2]
            current_type = "Slice(#{inner})"
          end
        when "value"
          # Dereference pointer: Pointer(T).value -> T
          if current_type.starts_with?("Pointer(") && current_type.ends_with?(")")
            current_type = current_type[8..-2]
          end
        when "size", "bytesize"
          current_type = "Int32"
        else
          # Try to look up return type
          method_full_name = "#{current_type}##{method_name}"
          if ret_type = @function_types[method_full_name]?
            current_type = get_type_name_from_ref(ret_type)
          else
            return "Pointer(Void)"  # Unknown method
          end
        end
      end

      current_type
    end

    # Split a method chain string, handling nested parentheses
    private def split_method_chain(expr : String) : Array(String)
      parts = [] of String
      current = String::Builder.new
      depth = 0

      expr.each_char do |c|
        case c
        when '(', '[', '{'
          depth += 1
          current << c
        when ')', ']', '}'
          depth -= 1
          current << c
        when '.'
          if depth == 0
            parts << current.to_s
            current = String::Builder.new
          else
            current << c
          end
        else
          current << c
        end
      end

      parts << current.to_s unless current.empty?
      parts
    end

    # Resolve typeof for member access chains like str.to_unsafe.value
    private def resolve_typeof_member_chain(node : CrystalV2::Compiler::Frontend::MemberAccessNode) : String
      member_name = String.new(node.member)

      # Special case: x.to_unsafe.value pattern - common for getting element type
      # This handles typeof(str.to_unsafe.value) where str is String
      if member_name == "value"
        obj = @arena[node.object]
        if obj.is_a?(CrystalV2::Compiler::Frontend::CallNode)
          callee = @arena[obj.callee]
          if callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
            call_method = String.new(callee.member)
            if call_method == "to_unsafe"
              # x.to_unsafe.value - infer x's element type
              base_obj = @arena[callee.object]
              # Check if base is String parameter (common pattern)
              if base_obj.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
                # For String.to_unsafe.value, returns UInt8
                # This is a conservative assumption but handles the common case
                return "UInt8"
              end
            end
          end
        end
      end

      # Get the base type
      base_type = resolve_typeof_expr(node.object)
      return "Pointer(Void)" if base_type == "Pointer(Void)"

      # Handle common patterns
      case member_name
      when "value"
        # Pointer(T).value returns T
        if base_type.starts_with?("Pointer(") && base_type.ends_with?(")")
          inner = base_type[8..-2]  # Extract T from Pointer(T)
          return inner
        end
        # For other types, return element type if available
        if element_type = extract_element_type(base_type)
          return element_type
        end
      end

      # Try to look up the return type of the method
      method_full_name = "#{base_type}##{member_name}"
      if ret_type = @function_types[method_full_name]?
        return get_type_name_from_ref(ret_type)
      end

      "Pointer(Void)"
    end

    # Resolve typeof for call chains like str.to_unsafe()
    private def resolve_typeof_call_chain(node : CrystalV2::Compiler::Frontend::CallNode) : String
      callee = @arena[node.callee]
      case callee
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        method_name = String.new(callee.member)
        if method_name == "element_type"
          if arg_id = node.args.first?
            arg_node = @arena[arg_id]
            chained = false
            if arg_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
              inner_callee = @arena[arg_node.callee]
              chained = inner_callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
                        String.new(inner_callee.member) == "element_type"
            end
            inner_type = resolve_typeof_expr(arg_id)
            if inner_type == "Pointer(Void)" && arg_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
              if type_name = lookup_typeof_local_name(String.new(arg_node.name))
                inner_type = type_name
              end
            end
            element_type = element_type_for_type_name(inner_type)
            return inner_type if element_type.nil? && chained
            return element_type if element_type
          end
        end

        base_type = resolve_typeof_expr(callee.object)
        return "Pointer(Void)" if base_type == "Pointer(Void)"

        # Handle common stdlib methods
        case method_name
        when "to_unsafe"
          # String.to_unsafe returns Pointer(UInt8)
          if base_type == "String"
            return "Pointer(UInt8)"
          end
          # Array(T).to_unsafe returns Pointer(T)
          if base_type.starts_with?("Array(") && base_type.ends_with?(")")
            inner = base_type[6..-2]
            return "Pointer(#{inner})"
          end
          # Slice(T).to_unsafe returns Pointer(T)
          if base_type.starts_with?("Slice(") && base_type.ends_with?(")")
            inner = base_type[6..-2]
            return "Pointer(#{inner})"
          end
        when "to_slice"
          # String.to_slice returns Slice(UInt8)
          if base_type == "String"
            return "Slice(UInt8)"
          end
        end

        # Try to look up the return type of the method
        method_full_name = "#{base_type}##{method_name}"
        if ret_type = @function_types[method_full_name]?
          return get_type_name_from_ref(ret_type)
        end
      when CrystalV2::Compiler::Frontend::IdentifierNode
        # Simple identifier call like some_func()
        method_name = String.new(callee.name)
        # Look up return type
        if ret_type = @function_types[method_name]?
          return get_type_name_from_ref(ret_type)
        end
      end

      "Pointer(Void)"
    end

    # Extract element type from container types
    private def extract_element_type(type_name : String) : String?
      if type_name.starts_with?("Array(") && type_name.ends_with?(")")
        return type_name[6..-2]
      elsif type_name.starts_with?("Slice(") && type_name.ends_with?(")")
        return type_name[6..-2]
      elsif type_name.starts_with?("Pointer(") && type_name.ends_with?(")")
        return type_name[8..-2]
      elsif type_name.starts_with?("StaticArray(") && type_name.ends_with?(")")
        # StaticArray(T, N) - extract T
        inner = type_name[12..-2]
        if comma_idx = inner.index(',')
          return inner[0, comma_idx].strip
        end
      end
      nil
    end

    private def resolve_typeof_inner(expr : String) : String
      expr = expr.strip
      if expr == "self"
        return normalize_typeof_type_name(@current_class || "Pointer(Void)")
      end

      if locals = @current_typeof_locals
        if type_ref = locals[expr]?
          resolved = get_type_name_from_ref(type_ref)
          return normalize_typeof_type_name(resolved) unless resolved == "Void"
        end
      end
      if type_name = lookup_typeof_local_name(expr)
        return normalize_typeof_type_name(type_name)
      end

      if class_name = @current_class
        if info = @class_info[class_name]?
          if expr.starts_with?("@@")
            cvar_name = expr.lstrip('@')
            if cvar = info.class_vars.find { |cv| cv.name == cvar_name }
              return normalize_typeof_type_name(get_type_name_from_ref(cvar.type))
            end
          elsif expr.starts_with?("@")
            if ivar = info.ivars.find { |iv| iv.name == expr }
              return normalize_typeof_type_name(get_type_name_from_ref(ivar.type))
            end
          end
        end
      end

      drop_nil = false
      if expr.ends_with?(".not_nil!")
        drop_nil = true
        expr = expr[0, expr.size - 9].strip
      end

      index_suffix = nil
      if expr.ends_with?("]")
        if match = expr.match(/^(.*)\[(\d+)\]\s*$/)
          expr = match[1].strip
          index_suffix = match[2].to_i
        end
      end

      if resolved = resolve_element_type_expression(expr)
        resolved = apply_index_to_type_name(resolved, index_suffix) if index_suffix
        resolved = drop_nil_from_union(resolved) if drop_nil
        return normalize_typeof_type_name(resolved)
      end

      # Allow simple constant/path typeof usage in type contexts (no local scope needed).
      if expr.includes?("::") || (expr.size > 0 && expr[0].uppercase?)
        resolved = resolve_type_alias_chain(expr)
        if !resolved.includes?("::")
          resolved = resolve_class_name_in_context(resolved)
        end
        if @class_info.has_key?(resolved) || @module_defs.has_key?(resolved)
          return normalize_typeof_type_name(resolved)
        end
      end

      "Pointer(Void)"
    end

    ELEMENT_TYPE_PREFIXES = ["Enumerable.element_type", "::Enumerable.element_type", "Indexable.element_type",
                             "::Indexable.element_type", "Iterator.element_type", "::Iterator.element_type",
                             "Iterable.element_type", "::Iterable.element_type"] of String

    private def resolve_element_type_expression(expr : String) : String?
      prefix = ELEMENT_TYPE_PREFIXES.find { |p| expr.starts_with?(p) }
      return nil unless prefix

      rest = expr[prefix.size, expr.size - prefix.size].strip
      arg_str = if rest.starts_with?("(")
                  extract_balanced_paren_content(rest)
                else
                  rest
                end
      return nil if arg_str.nil? || arg_str.empty?

      arg_expr = arg_str.not_nil!.strip
      chained = ELEMENT_TYPE_PREFIXES.any? { |p| arg_expr.starts_with?(p) }
      inner_type = resolve_typeof_inner(arg_expr)
      if !chained && inner_type == "Pointer(Void)" && arg_expr.size > 0 && arg_expr[0].uppercase?
        inner_type = arg_expr
      end

      element_type = element_type_for_type_name(inner_type)
      return inner_type if element_type.nil? && chained
      element_type
    end

    private def extract_balanced_paren_content(expr : String) : String?
      return nil unless expr.starts_with?("(")
      depth = 0
      i = 0
      while i < expr.bytesize
        ch = expr.byte_at(i).unsafe_chr
        case ch
        when '('
          depth += 1
        when ')'
          depth -= 1
          if depth == 0
            return expr[1, i - 1].strip
          end
        end
        i += 1
      end
      nil
    end

    private def element_type_for_type_name(type_name : String) : String?
      name = type_name.strip
      if name.includes?("|")
        variants = name.split("|").map(&.strip)
        element_variants = variants.compact_map { |v| element_type_for_type_name(v) }
        uniq = element_variants.uniq
        return uniq.join(" | ") unless uniq.empty?
      end

      if name.ends_with?("?")
        base = name[0, name.size - 1]
        return element_type_for_type_name(base)
      end

      paren = name.index('(')
      if paren && name.ends_with?(")")
        base = name[0, paren]
        params_str = name[paren + 1, name.size - paren - 2]
        args = split_generic_type_args(params_str)
        case base
        when "Array", "StaticArray", "Slice", "Deque", "Set", "Indexable", "Enumerable", "Iterator", "Iterable", "Range"
          return args.first?
        when "Tuple"
          return args.join(" | ") unless args.empty?
        when "Hash"
          return "Tuple(#{args[0]}, #{args[1]})" if args.size >= 2
        end
      end

      return "Char" if name == "String"

      nil
    end

    private def array_element_type_for_value(
      ctx : LoweringContext,
      array_id : ValueId,
      default_type : TypeRef
    ) : TypeRef
      element_type = ctx.type_of(array_id)
      if type_desc = @module.get_type_descriptor(element_type)
        if elem_name = element_type_for_type_name(type_desc.name)
          return type_ref_for_name(elem_name)
        end
      end
      return default_type if element_type == TypeRef::VOID
      element_type
    end

    private def apply_index_to_type_name(type_name : String, index : Int32?) : String
      return type_name unless index
      name = type_name.strip
      if name.includes?("|")
        variants = name.split("|").map(&.strip)
        indexed = variants.compact_map { |v| apply_index_to_type_name(v, index) }
        uniq = indexed.uniq
        return uniq.join(" | ") unless uniq.empty?
      end

      if name.starts_with?("Tuple(") && name.ends_with?(")")
        params_str = name[6, name.size - 7]
        args = split_generic_type_args(params_str)
        return args[index]? || type_name
      end

      if name.starts_with?("Array(") && name.ends_with?(")")
        params_str = name[6, name.size - 7]
        args = split_generic_type_args(params_str)
        return args.first? || type_name
      end

      type_name
    end

    private def drop_nil_from_union(type_name : String) : String
      return type_name unless type_name.includes?("|")
      parts = type_name.split("|").map(&.strip)
      filtered = parts.reject { |p| p == "Nil" }
      return "Nil" if filtered.empty?
      filtered.uniq.join(" | ")
    end

    private def resolve_typeof_in_type_string(type_name : String) : String
      return type_name unless type_name.includes?("typeof(")

      output = String.build do |io|
        i = 0
        while i < type_name.bytesize
          if i + 7 <= type_name.bytesize && type_name.byte_slice(i, 7) == "typeof("
            start = i + 7
            depth = 1
            j = start
            while j < type_name.bytesize && depth > 0
              ch = type_name[j]
              if ch == '('
                depth += 1
              elsif ch == ')'
                depth -= 1
              end
              j += 1
            end
            if depth != 0
              io << type_name[i]
              i += 1
              next
            end
            inner = type_name.byte_slice(start, j - start - 1)
            io << resolve_typeof_inner(inner)
            i = j
          else
            io << type_name[i]
            i += 1
          end
        end
      end

      output
    end

    private def resolve_alias_target(target_name : String) : String
      resolved = normalize_declared_type_name(target_name)
      return target_name if resolved.includes?("Pointer(Void)") || resolved.includes?("Unknown")

      # If the alias target is an unqualified constant and nothing is registered yet,
      # keep it relative to the current namespace so later lookup resolves correctly.
      if current = @current_class
        if resolved.matches?(/\A[A-Za-z_][A-Za-z0-9_]*\z/) && !type_name_exists?(resolved) && !builtin_alias_target?(resolved)
          return "#{current}::#{resolved}"
        end
      end

      resolved
    end

    private def normalize_declared_type_name(type_name : String, context : String? = nil) : String
      resolved = resolve_typeof_in_type_string(type_name)
      @type_param_map.each do |param, actual|
        resolved = substitute_type_param(resolved, param, actual)
      end

      old_class = @current_class
      @current_class = context if context
      begin
        if resolved.includes?("|")
          resolved.split("|").map do |part|
            resolve_type_name_in_context(part.strip)
          end.join(" | ")
        else
          resolve_type_name_in_context(resolved)
        end
      ensure
        @current_class = old_class if context
      end
    end

    private def update_typeof_local(name : String, type_ref : TypeRef) : Nil
      return unless locals = @current_typeof_locals
      locals[name] = type_ref
    end

    private def update_typeof_local_name(name : String, type_name : String) : Nil
      return unless locals = @current_typeof_local_names
      normalized = normalize_declared_type_name(type_name)
      if ENV["DEBUG_TYPE_CLASS"]? && normalized.ends_with?(".class")
        STDERR.puts "[DEBUG_TYPE_CLASS] local=#{name} type_name=#{normalized}"
      end
      locals[name] = normalized
    end

    private def concrete_type_name_for(type_ref : TypeRef) : String?
      return nil if type_ref == TypeRef::VOID

      # Prefer direct primitive names to avoid missing descriptors.
      primitive_name = case type_ref
                       when TypeRef::NIL     then "Nil"
                       when TypeRef::BOOL    then "Bool"
                       when TypeRef::INT8    then "Int8"
                       when TypeRef::INT16   then "Int16"
                       when TypeRef::INT32   then "Int32"
                       when TypeRef::INT64   then "Int64"
                       when TypeRef::INT128  then "Int128"
                       when TypeRef::UINT8   then "UInt8"
                       when TypeRef::UINT16  then "UInt16"
                       when TypeRef::UINT32  then "UInt32"
                       when TypeRef::UINT64  then "UInt64"
                       when TypeRef::UINT128 then "UInt128"
                       when TypeRef::FLOAT32 then "Float32"
                       when TypeRef::FLOAT64 then "Float64"
                       when TypeRef::CHAR    then "Char"
                       when TypeRef::STRING  then "String"
                       when TypeRef::SYMBOL  then "Symbol"
                       when TypeRef::POINTER then "Pointer"
                       else nil
                       end
      return primitive_name if primitive_name

      if desc = @module.get_type_descriptor(type_ref)
        return nil if desc.kind.in?(TypeKind::Module, TypeKind::Union)
        return desc.name
      end

      nil
    end

    private def lookup_typeof_local_name(name : String) : String?
      @current_typeof_local_names.try(&.[name]?)
    end

    private def with_arena(arena : CrystalV2::Compiler::Frontend::ArenaLike, &)
      old_arena = @arena
      @arena = arena
      begin
        yield
      ensure
        @arena = old_arena
      end
    end

    private def arena_for_expr?(expr_id : ExprId) : CrystalV2::Compiler::Frontend::ArenaLike?
      return nil if expr_id.index < 0
      return @arena if expr_id.index < @arena.size
      if arenas = @inline_arenas
        arenas.each do |candidate|
          return candidate if expr_id.index < candidate.size
        end
      end
      nil
    end

    private def arena_for_expr(expr_id : ExprId) : CrystalV2::Compiler::Frontend::ArenaLike
      arena_for_expr?(expr_id) || @arena
    end

    private def node_for_expr(expr_id : ExprId) : CrystalV2::Compiler::Frontend::Node?
      arena = arena_for_expr?(expr_id)
      unless arena
        if ENV["DEBUG_INFER_CRASH"]?
          STDERR.puts "[INFER_NODE] missing_arena expr=#{expr_id.index} current=#{@arena.class}:#{@arena.size}"
        end
        return nil
      end
      if expr_id.index >= arena.size
        if ENV["DEBUG_INFER_CRASH"]?
          STDERR.puts "[INFER_NODE] oob expr=#{expr_id.index} arena=#{arena.class}:#{arena.size}"
        end
        return nil
      end
      arena[expr_id]
    end

    private def span_fits_source?(arena : CrystalV2::Compiler::Frontend::ArenaLike, span : CrystalV2::Compiler::Frontend::Span) : Bool
      if source = @sources_by_arena[arena]?
        span.end_offset <= source.bytesize
      else
        true
      end
    end

    private def source_path_for(arena : CrystalV2::Compiler::Frontend::ArenaLike) : String?
      @paths_by_arena[arena]?
    end

    private def record_allocation_location(
      ctx : LoweringContext,
      value_id : ValueId,
      arena : CrystalV2::Compiler::Frontend::ArenaLike,
      node : CrystalV2::Compiler::Frontend::Node
    ) : Nil
      path = source_path_for(arena)
      return unless path
      span = node.span
      ctx.function.record_value_location(value_id, SourceLocation.new(path, span.start_line, span.start_column))
    end

    private def store_extra_source(arena : CrystalV2::Compiler::Frontend::ArenaLike, text : String) : Nil
      return if text.empty?
      arena.retain_source(text)
      list = @extra_sources_by_arena[arena]?
      unless list
        list = [] of String
        @extra_sources_by_arena[arena] = list
      end
      list << text
    end

    private def resolve_arena_for_def(
      func_def : CrystalV2::Compiler::Frontend::DefNode,
      fallback : CrystalV2::Compiler::Frontend::ArenaLike
    ) : CrystalV2::Compiler::Frontend::ArenaLike
      max_index = if body = func_def.body
                    body.empty? ? -1 : body.max_of(&.index)
                  else
                    -1
                  end
      candidates = [] of CrystalV2::Compiler::Frontend::ArenaLike
      candidates << fallback
      if arenas = @inline_arenas
        arenas.each { |arena| candidates << arena }
      end
      @function_def_arenas.each_value { |arena| candidates << arena }

      candidates.each do |arena|
        next if max_index >= 0 && max_index >= arena.size
        next unless span_fits_source?(arena, func_def.span)
        return arena
      end

      fallback
    end

    private def resolve_arena_for_block(
      block : CrystalV2::Compiler::Frontend::BlockNode,
      fallback : CrystalV2::Compiler::Frontend::ArenaLike
    ) : CrystalV2::Compiler::Frontend::ArenaLike?
      if cached = @block_node_arenas[block.object_id]?
        return cached
      end

      max_index = block.body.empty? ? -1 : block.body.max_of(&.index)
      candidates = [] of CrystalV2::Compiler::Frontend::ArenaLike
      candidates << fallback
      if arenas = @inline_arenas
        arenas.each { |arena| candidates << arena }
      end
      @function_def_arenas.each_value { |arena| candidates << arena }

      candidates.each do |arena|
        next if max_index >= 0 && max_index >= arena.size
        next unless span_fits_source?(arena, block.span)
        @block_node_arenas[block.object_id] = arena
        return arena
      end

      nil
    end

    private def with_type_param_map(extra : Hash(String, String), &)
      old_map = @type_param_map
      @type_param_map = old_map.merge(extra)
      begin
        yield
      ensure
        @type_param_map = old_map
      end
    end

    private def with_namespace_override(namespace : String, &)
      old_namespace = @current_namespace_override
      @current_namespace_override = namespace
      begin
        yield
      ensure
        @current_namespace_override = old_namespace
      end
    end

    private def record_pending_type_param_map(name : String, params : Hash(String, String)) : Nil
      return if name.empty? || params.empty?
      if existing = @pending_type_param_maps[name]?
        @pending_type_param_maps[name] = existing.merge(params)
      else
        @pending_type_param_maps[name] = params.dup
      end
    end

    private def consume_pending_type_param_map(name : String) : Hash(String, String)?
      return nil if name.empty?
      map = @pending_type_param_maps[name]?
      @pending_type_param_maps.delete(name) if map
      map
    end

    private def store_function_type_param_map(full_name : String, base_name : String, params : Hash(String, String)) : Nil
      return if params.empty?
      stored = params.dup
      @function_type_param_maps[full_name] = stored
      @function_type_param_maps[base_name] = stored unless @function_type_param_maps.has_key?(base_name)
    end

    private def function_type_param_map_for(*names : String) : Hash(String, String)?
      names.each do |name|
        next if name.empty?
        if map = @function_type_param_maps[name]?
          return map
        end
      end
      nil
    end

    private def store_function_namespace_override(full_name : String, base_name : String, namespace : String) : Nil
      return if namespace.empty?
      @function_namespace_overrides[full_name] = namespace
      @function_namespace_overrides[base_name] = namespace unless @function_namespace_overrides.has_key?(base_name)
    end

    private def function_namespace_override_for(*names : String) : String?
      names.each do |name|
        next if name.empty?
        if ns = @function_namespace_overrides[name]?
          return ns
        end
      end
      nil
    end

    private def include_type_param_map(
      module_node : CrystalV2::Compiler::Frontend::ModuleNode,
      include_target : ExprId,
      include_arena : CrystalV2::Compiler::Frontend::ArenaLike = @arena
    ) : Hash(String, String)
      extra = {} of String => String
      type_params = module_node.type_params
      return extra unless type_params

      arg_strings = [] of String
      target_node = include_arena[include_target]
      unless target_node.is_a?(CrystalV2::Compiler::Frontend::GenericNode)
        if DebugHooks::ENABLED
          module_name = String.new(module_node.name)
          debug_hook("include.param.missing", "module=#{module_name} target=#{target_node.class.name}")
        end
        return extra
      end
      with_arena(include_arena) do
        target_node.type_args.each do |arg|
          if str = stringify_type_expr(arg)
            arg_strings << substitute_type_params_in_type_name(str)
          end
        end
      end
      if arg_strings.empty?
        if DebugHooks::ENABLED
          module_name = String.new(module_node.name)
          base_name = resolve_path_like_name(target_node.base_type) || "unknown"
          debug_hook("include.param.empty", "module=#{module_name} target=#{base_name}")
        end
        return extra
      end

      type_params.each_with_index do |tp, idx|
        break if idx >= arg_strings.size
        extra[String.new(tp)] = arg_strings[idx]
      end
      extra
    end

    private def unwrap_visibility_member(member)
      while member.is_a?(CrystalV2::Compiler::Frontend::VisibilityModifierNode)
        member = @arena[member.expression]
      end
      member
    end

    private def collect_defined_instance_method_full_names(class_name : String, body : Array(ExprId)) : Set(String)
      defined = Set(String).new
      body.each do |expr_id|
        member = unwrap_visibility_member(@arena[expr_id])
        case member
        when CrystalV2::Compiler::Frontend::DefNode
          next if member.is_abstract
          next if (recv = member.receiver) && String.new(recv) == "self"

          method_name = String.new(member.name)
          base_name = "#{class_name}##{method_name}"

          param_types = [] of TypeRef
          has_block = false
          if params = member.params
            params.each do |param|
              next if named_only_separator?(param)
              if param.is_block
                has_block = true
                next
              end
              if ta = param.type_annotation
                param_types << type_ref_for_name(String.new(ta))
              else
                param_types << TypeRef::VOID
              end
            end
          end

          full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
          defined << full_name
        when CrystalV2::Compiler::Frontend::GetterNode
          member.specs.each do |spec|
            accessor_name = accessor_method_name(spec)
            base_name = "#{class_name}##{accessor_name}"
            full_name = mangle_function_name(base_name, [] of TypeRef)
            defined << full_name
          end
        when CrystalV2::Compiler::Frontend::SetterNode
          member.specs.each do |spec|
            accessor_name = accessor_storage_name(spec)
            base_name = "#{class_name}##{accessor_name}="
            param_type = if ta = spec.type_annotation
                           type_ref_for_name(String.new(ta))
                         else
                           TypeRef::VOID
                         end
            full_name = mangle_function_name(base_name, [param_type])
            defined << full_name
          end
        when CrystalV2::Compiler::Frontend::PropertyNode
          member.specs.each do |spec|
            getter_name = accessor_method_name(spec)
            setter_name = accessor_storage_name(spec)
            getter_base = "#{class_name}##{getter_name}"
            setter_base = "#{class_name}##{setter_name}="
            getter_full = mangle_function_name(getter_base, [] of TypeRef)
            param_type = if ta = spec.type_annotation
                           type_ref_for_name(String.new(ta))
                         else
                           TypeRef::VOID
                         end
            setter_full = mangle_function_name(setter_base, [param_type])
            defined << getter_full
            defined << setter_full
          end
        end
      end
      defined
    end

    private def collect_defined_class_method_full_names(class_name : String, body : Array(ExprId)) : Set(String)
      defined = Set(String).new
      body.each do |expr_id|
        member = unwrap_visibility_member(@arena[expr_id])
        case member
        when CrystalV2::Compiler::Frontend::DefNode
          next if member.is_abstract
          next unless (recv = member.receiver) && String.new(recv) == "self"

          method_name = String.new(member.name)
          base_name = "#{class_name}.#{method_name}"

          param_types = [] of TypeRef
          has_block = false
          if params = member.params
            params.each do |param|
              next if named_only_separator?(param)
              if param.is_block
                has_block = true
                next
              end
              if ta = param.type_annotation
                param_types << type_ref_for_name(String.new(ta))
              else
                param_types << TypeRef::VOID
              end
            end
          end

          full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
          defined << full_name
        when CrystalV2::Compiler::Frontend::GetterNode
          next unless member.is_class?
          member.specs.each do |spec|
            accessor_name = accessor_method_name(spec)
            base_name = "#{class_name}.#{accessor_name}"
            full_name = mangle_function_name(base_name, [] of TypeRef)
            defined << full_name
          end
        when CrystalV2::Compiler::Frontend::SetterNode
          next unless member.is_class?
          member.specs.each do |spec|
            accessor_name = accessor_storage_name(spec)
            base_name = "#{class_name}.#{accessor_name}="
            param_type = if ta = spec.type_annotation
                           type_ref_for_name(String.new(ta))
                         else
                           TypeRef::VOID
                         end
            full_name = mangle_function_name(base_name, [param_type])
            defined << full_name
          end
        when CrystalV2::Compiler::Frontend::PropertyNode
          next unless member.is_class?
          member.specs.each do |spec|
            getter_name = accessor_method_name(spec)
            getter_base = "#{class_name}.#{getter_name}"
            defined << mangle_function_name(getter_base, [] of TypeRef)

            setter_name = "#{class_name}.#{accessor_storage_name(spec)}="
            setter_type = if ta = spec.type_annotation
                            type_ref_for_name(String.new(ta))
                          else
                            TypeRef::VOID
                          end
            defined << mangle_function_name(setter_name, [setter_type])
          end
        end
      end
      defined
    end

    private def add_defined_instance_methods_from_expr(
      class_name : String,
      defined_full_names : Set(String),
      expr_id : ExprId
    )
      return if expr_id.invalid?

      member = unwrap_visibility_member(@arena[expr_id])
      case member
      when CrystalV2::Compiler::Frontend::BlockNode
        member.body.each do |child_id|
          add_defined_instance_methods_from_expr(class_name, defined_full_names, child_id)
        end
      when CrystalV2::Compiler::Frontend::DefNode
        return if member.is_abstract
        if recv = member.receiver
          return if String.new(recv) == "self"
        end

        method_name = String.new(member.name)
        base_name = "#{class_name}##{method_name}"

        param_types = [] of TypeRef
        has_block = false
        if params = member.params
          params.each do |param|
            next if named_only_separator?(param)
            if param.is_block
              has_block = true
              next
            end
            if ta = param.type_annotation
              param_types << type_ref_for_name(String.new(ta))
            else
              param_types << TypeRef::VOID
            end
          end
        end

        full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
        defined_full_names << full_name
      when CrystalV2::Compiler::Frontend::GetterNode
        return if member.is_class?
        member.specs.each do |spec|
          accessor_name = accessor_method_name(spec)
          base_name = "#{class_name}##{accessor_name}"
          full_name = mangle_function_name(base_name, [] of TypeRef)
          defined_full_names << full_name
        end
      when CrystalV2::Compiler::Frontend::SetterNode
        return if member.is_class?
        member.specs.each do |spec|
          accessor_name = accessor_storage_name(spec)
          base_name = "#{class_name}##{accessor_name}="
          param_type = if ta = spec.type_annotation
                         type_ref_for_name(String.new(ta))
                       else
                         TypeRef::VOID
                       end
          full_name = mangle_function_name(base_name, [param_type])
          defined_full_names << full_name
        end
      when CrystalV2::Compiler::Frontend::PropertyNode
        return if member.is_class?
        member.specs.each do |spec|
          getter_name = accessor_method_name(spec)
          setter_name = accessor_storage_name(spec)
          getter_base = "#{class_name}##{getter_name}"
          setter_base = "#{class_name}##{setter_name}="
          getter_full = mangle_function_name(getter_base, [] of TypeRef)
          param_type = if ta = spec.type_annotation
                         type_ref_for_name(String.new(ta))
                       else
                         TypeRef::VOID
                       end
          setter_full = mangle_function_name(setter_base, [param_type])
          defined_full_names << getter_full
          defined_full_names << setter_full
        end
      when CrystalV2::Compiler::Frontend::VisibilityModifierNode
        add_defined_instance_methods_from_expr(class_name, defined_full_names, member.expression)
      end
    end

    private def accessor_method_name(spec : CrystalV2::Compiler::Frontend::AccessorSpec) : String
      name = String.new(spec.name)
      spec.predicate ? "#{name}?" : name
    end

    private def accessor_storage_name(spec : CrystalV2::Compiler::Frontend::AccessorSpec) : String
      String.new(spec.name)
    end

    private def register_accessor_from_module(
      class_name : String,
      spec : CrystalV2::Compiler::Frontend::AccessorSpec,
      ivars : Array(IVarInfo),
      offset : Int32,
      defined_full_names : Set(String),
      is_struct : Bool,
      include_getter : Bool,
      include_setter : Bool
    ) : Int32
      storage_name = accessor_storage_name(spec)
      getter_name = accessor_method_name(spec)
      ivar_name = "@#{storage_name}"
      ivar_type = if ta = spec.type_annotation
                    type_ref_for_name(String.new(ta))
                  elsif spec.predicate
                    TypeRef::BOOL
                  elsif default_value = spec.default_value
                    infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                  else
                    TypeRef::VOID
                  end

      unless ivars.any? { |iv| iv.name == ivar_name }
        ivars << IVarInfo.new(ivar_name, ivar_type, offset)
        offset += type_size(ivar_type)
      end

      if include_getter
        getter_base = "#{class_name}##{getter_name}"
        getter_full = mangle_function_name(getter_base, [] of TypeRef)
        unless defined_full_names.includes?(getter_full)
          register_function_type(getter_full, ivar_type)
        end
      end

      if include_setter
        setter_name = "#{class_name}##{storage_name}="
        setter_full = mangle_function_name(setter_name, [ivar_type])
        unless defined_full_names.includes?(setter_full)
          setter_return = is_struct ? TypeRef::VOID : ivar_type
          register_function_type(setter_full, setter_return)
        end
      end

      offset
    end

    private def capture_initialize_params(
      params : Array(CrystalV2::Compiler::Frontend::Parameter),
      ivars : Array(IVarInfo),
      offset_ptr : Pointer(Int32)
    ) : Array({String, TypeRef})
      init_params = [] of {String, TypeRef}
      params.each do |param|
        next if named_only_separator?(param)
        param_name = param.name.nil? ? "_" : String.new(param.name.not_nil!)
        param_type = if ta = param.type_annotation
                       type_ref_for_name(String.new(ta))
                     elsif param.is_double_splat
                       type_ref_for_name("NamedTuple")
                     else
                       TypeRef::VOID
                     end

        if param.is_instance_var
          ivar_name = "@#{param_name}"
          unless ivars.any? { |iv| iv.name == ivar_name }
            ivars << IVarInfo.new(ivar_name, param_type, offset_ptr.value)
            offset_ptr.value += type_size(param_type)
          end
          init_params << {param_name, param_type}
        else
          init_params << {param_name, param_type}
        end
      end
      init_params
    end

    private def register_module_instance_methods_for(
      class_name : String,
      include_node : CrystalV2::Compiler::Frontend::IncludeNode,
      defined_full_names : Set(String),
      defined_class_method_full_names : Set(String),
      visited : Set(String),
      visited_extends : Set(String),
      ivars : Array(IVarInfo),
      offset : Int32,
      is_struct : Bool,
      init_capture : InitParamsCapture?
    ) : Int32
      # Sanitize class_name (fix malformed types with unbalanced parens)
      class_name = sanitize_type_name(class_name)

      module_full_name = resolve_path_like_name(include_node.target)
      return offset unless module_full_name
      # Prefer nested modules under the including class (e.g., Crystal::EventLoop::FileDescriptor).
      if !module_full_name.includes?("::")
        base_owner = class_name.split('(').first
        nested_name = "#{base_owner}::#{module_full_name}"
        module_full_name = nested_name if @module_defs.has_key?(nested_name)
      end

      # INC_DEBUG disabled

      # If module not found directly, try resolving relative to the including class's namespace
      # e.g., BinaryFormat_Float64 includes BinaryFormat -> Float::FastFloat::BinaryFormat
      unless @module_defs.has_key?(module_full_name)
        # Extract namespace from class_name (e.g., Float::FastFloat from Float::FastFloat::BinaryFormat_Float64)
        if class_name.includes?("::")
          parts = class_name.split("::")
          parts.pop  # Remove the class name itself
          # Try progressively shorter namespaces
          while parts.size > 0
            qualified_name = "#{parts.join("::")}::#{module_full_name}"
            if @module_defs.has_key?(qualified_name)
              module_full_name = qualified_name
              break
            end
            parts.pop
          end
        end
        # STDERR.puts "[INC_DEBUG] after resolution: module_full_name=#{module_full_name}"
      end

      module_full_name = resolve_module_alias_for_include(module_full_name)
      record_module_inclusion(module_full_name, class_name)
      return offset if visited.includes?(module_full_name)
      visited << module_full_name

      defs = @module_defs[module_full_name]?
      return offset unless defs
      # INC_DEBUG disabled
      include_arena = @arena
      defs.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          extra_map = include_type_param_map(mod_node, include_node.target, include_arena)
          with_type_param_map(extra_map) do
            if macro_lookup = lookup_macro_entry("included", module_full_name)
              macro_entry, macro_key = macro_lookup
              macro_def, macro_arena = macro_entry
              expanded_id = expand_macro_expr(macro_def, macro_arena, [] of ExprId, nil, nil, macro_key)
              unless expanded_id.invalid?
                old_arena = @arena
                @arena = macro_arena
                begin
                  register_class_members_from_expansion(
                    class_name,
                    expanded_id,
                    defined_class_method_full_names,
                    visited_extends
                  )
                ensure
                  @arena = old_arena
                end
              end
            end
            if body = mod_node.body
              body.each do |member_id|
                member = unwrap_visibility_member(@arena[member_id])
                case member
                when CrystalV2::Compiler::Frontend::IncludeNode
                  offset = register_module_instance_methods_for(
                    class_name,
                    member,
                    defined_full_names,
                    defined_class_method_full_names,
                    visited,
                    visited_extends,
                    ivars,
                    offset,
                    is_struct,
                    init_capture
                  )
                when CrystalV2::Compiler::Frontend::InstanceVarDeclNode
                  ivar_name = String.new(member.name)
                  ivar_type = type_ref_for_name(String.new(member.type))
                  unless ivars.any? { |iv| iv.name == ivar_name }
                    ivars << IVarInfo.new(ivar_name, ivar_type, offset)
                    offset += type_size(ivar_type)
                  end
                when CrystalV2::Compiler::Frontend::AssignNode
                  target_node = @arena[member.target]
                  if target_node.is_a?(CrystalV2::Compiler::Frontend::InstanceVarNode)
                    ivar_name = String.new(target_node.name)
                    value_node = @arena[member.value]
                    inferred = infer_type_from_class_ivar_assign(value_node)
                    if ENV.has_key?("DEBUG_IVAR_INFER")
                      inferred_name = inferred == TypeRef::VOID ? "Void" : get_type_name_from_ref(inferred)
                      detail = ""
                      if value_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                        detail = " member=#{String.new(value_node.member)} obj=#{@arena[value_node.object].class}"
                      end
                      STDERR.puts "[IVAR_INFER] include=#{module_full_name} class=#{class_name} ivar=#{ivar_name} value=#{value_node.class} inferred=#{inferred_name}#{detail}"
                    end
                    inferred = TypeRef::POINTER if inferred == TypeRef::VOID
                    unless ivars.any? { |iv| iv.name == ivar_name }
                      ivars << IVarInfo.new(ivar_name, inferred, offset)
                      offset += type_size(inferred)
                    end
                  end
                when CrystalV2::Compiler::Frontend::DefNode
                  next if (recv = member.receiver) && String.new(recv) == "self"
                  next if member.is_abstract

                  method_name = String.new(member.name)
                  base_name = "#{class_name}##{method_name}"

                  type_literal_name = infer_type_literal_return_name_from_body(member, class_name)
                  return_type = if rt = member.return_type
                                  rt_name = String.new(rt)
                                  inferred = module_like_type_name?(rt_name) ? infer_concrete_return_type_from_body(member, class_name) : nil
                                  inferred || type_ref_for_name(rt_name)
                                elsif method_name.ends_with?("?")
                                  inferred = infer_unannotated_query_return_type(method_name, type_ref_for_name(class_name))
                                  inferred ||= infer_concrete_return_type_from_body(member, class_name)
                                  inferred || TypeRef::BOOL
                                else
                                  inferred = infer_getter_return_type(member, ivars)
                                  inferred = infer_concrete_return_type_from_body(member, class_name) if inferred.nil?
                                  inferred ||= infer_unannotated_search_return_type(method_name, type_ref_for_name(class_name))
                                  inferred || TypeRef::VOID
                                end
                  if type_literal_name
                    literal_ref = type_ref_for_name(type_literal_name)
                    if return_type == TypeRef::VOID || return_type == TypeRef::NIL
                      return_type = literal_ref if literal_ref != TypeRef::VOID
                    end
                  end

                  param_types = [] of TypeRef
                  has_block = false
                  if params = member.params
                    params.each do |param|
                      next if named_only_separator?(param)
                      if param.is_block
                        has_block = true
                        next
                      end
                      param_type = if ta = param.type_annotation
                                     type_ref_for_name(String.new(ta))
                                   elsif param.is_double_splat
                                     type_ref_for_name("NamedTuple")
                                   else
                                     TypeRef::VOID
                                   end
                      param_types << param_type
                    end
                  end

                  if method_name == "initialize"
                    if init_capture && init_capture.source != :class
                      if params = member.params
                        new_params = capture_initialize_params(params, ivars, pointerof(offset))
                        init_capture.params.clear
                        init_capture.params.concat(new_params)
                        init_capture.source = :include
                      end
                    end
                    if body = member.body
                      infer_ivars_from_body(body, ivars, pointerof(offset))
                    end
                  end

                  full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
                  next if defined_full_names.includes?(full_name)

                  store_function_type_param_map(full_name, base_name, extra_map)
                  store_function_namespace_override(full_name, base_name, module_full_name)
                  debug_hook("module.instance_method.register", "class=#{class_name} module=#{module_full_name} method=#{method_name} full=#{full_name}")
                  if type_literal_name
                    literal_ref = type_ref_for_name(type_literal_name)
                    if literal_ref != TypeRef::VOID
                      record_type_literal_return(full_name, base_name)
                    end
                  end
                  register_function_type(full_name, return_type)
                  @function_defs[full_name] = member
                  @function_def_arenas[full_name] = @arena

                  if body = member.body
                    contains_yield = contains_yield?(body)
                    if !contains_yield && @yield_functions.includes?(full_name)
                      @yield_functions.delete(full_name)
                      debug_hook("yield.unregister", full_name)
                    elsif contains_yield
                      @yield_functions.add(full_name)
                      debug_hook("yield.register", full_name)
                      unless @function_defs.has_key?(base_name)
                        @function_defs[base_name] = member
                        @function_def_arenas[base_name] = @arena
                      end
                      @function_defs[full_name] = member
                      @function_def_arenas[full_name] = @arena
                    end
                  end
                when CrystalV2::Compiler::Frontend::GetterNode
                  member.specs.each do |spec|
                    offset = register_accessor_from_module(
                      class_name,
                      spec,
                      ivars,
                      offset,
                      defined_full_names,
                      is_struct,
                      true,
                      false
                    )
                  end
                when CrystalV2::Compiler::Frontend::SetterNode
                  member.specs.each do |spec|
                    offset = register_accessor_from_module(
                      class_name,
                      spec,
                      ivars,
                      offset,
                      defined_full_names,
                      is_struct,
                      false,
                      true
                    )
                  end
                when CrystalV2::Compiler::Frontend::PropertyNode
                  member.specs.each do |spec|
                    offset = register_accessor_from_module(
                      class_name,
                      spec,
                      ivars,
                      offset,
                      defined_full_names,
                      is_struct,
                      true,
                      true
                    )
                  end
                end
              end
            end
          end
        end
      end
      offset
    end

    private def register_module_class_methods_for(
      class_name : String,
      extend_target : ExprId,
      defined_full_names : Set(String),
      visited : Set(String)
    ) : Nil
      class_name = sanitize_type_name(class_name)

      module_full_name = resolve_path_like_name(extend_target)
      return unless module_full_name
      # Prefer nested modules under the extending class.
      if !module_full_name.includes?("::")
        base_owner = class_name.split('(').first
        nested_name = "#{base_owner}::#{module_full_name}"
        module_full_name = nested_name if @module_defs.has_key?(nested_name)
      end
      module_full_name = resolve_module_alias_for_include(module_full_name)
      record_module_inclusion(module_full_name, class_name)
      return if visited.includes?(module_full_name)
      visited << module_full_name

      defs = @module_defs[module_full_name]? || return
      include_arena = @arena
      defs.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          extra_map = include_type_param_map(mod_node, extend_target, include_arena)
          with_type_param_map(extra_map) do
            if body = mod_node.body
              with_namespace_override(module_full_name) do
                body.each do |member_id|
                  member = unwrap_visibility_member(@arena[member_id])
                  case member
                  when CrystalV2::Compiler::Frontend::IncludeNode
                    register_module_class_methods_for(class_name, member.target, defined_full_names, visited)
                  when CrystalV2::Compiler::Frontend::DefNode
                    next if (recv = member.receiver) && String.new(recv) == "self"
                    next if member.is_abstract

                    method_name = String.new(member.name)
                    base_name = "#{class_name}.#{method_name}"

                    type_literal_name = infer_type_literal_return_name_from_body(member, class_name)
                    return_type = if rt = member.return_type
                                    rt_name = String.new(rt)
                                    inferred = module_like_type_name?(rt_name) ? infer_concrete_return_type_from_body(member, class_name) : nil
                                    inferred || type_ref_for_name(rt_name)
                                  elsif method_name.ends_with?("?")
                                    inferred = infer_unannotated_query_return_type(method_name, type_ref_for_name(class_name))
                                    inferred ||= infer_concrete_return_type_from_body(member, class_name)
                                    inferred || TypeRef::BOOL
                                  else
                                    inferred = infer_concrete_return_type_from_body(member, class_name)
                                    inferred ||= infer_unannotated_search_return_type(method_name, type_ref_for_name(class_name))
                                    inferred || TypeRef::VOID
                                  end
                    if type_literal_name
                      literal_ref = type_ref_for_name(type_literal_name)
                      if return_type == TypeRef::VOID || return_type == TypeRef::NIL
                        return_type = literal_ref if literal_ref != TypeRef::VOID
                      end
                    end

                    param_types = [] of TypeRef
                    has_block = false
                    if params = member.params
                      params.each do |param|
                        next if named_only_separator?(param)
                        if param.is_block
                          has_block = true
                          next
                        end
                        param_type = if ta = param.type_annotation
                                       type_ref_for_name(String.new(ta))
                                     elsif param.is_double_splat
                                       type_ref_for_name("NamedTuple")
                                     else
                                       TypeRef::VOID
                                     end
                        param_types << param_type
                      end
                    end

                    full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
                    next if defined_full_names.includes?(full_name)
                    next if @function_types.has_key?(full_name)

                    store_function_type_param_map(full_name, base_name, extra_map)
                    store_function_namespace_override(full_name, base_name, module_full_name)
                    debug_hook("module.class_method.register", "class=#{class_name} module=#{module_full_name} method=#{method_name} full=#{full_name}")
                    if type_literal_name
                      literal_ref = type_ref_for_name(type_literal_name)
                      if literal_ref != TypeRef::VOID
                        record_type_literal_return(full_name, base_name)
                      end
                    end
                    register_function_type(full_name, return_type)
                    @function_defs[full_name] = member
                    @function_def_arenas[full_name] = @arena
                  end
                end
              end
            end
          end
        end
      end
    end

    private def lower_module_instance_methods_for(
      class_name : String,
      class_info : ClassInfo,
      include_node : CrystalV2::Compiler::Frontend::IncludeNode,
      defined_full_names : Set(String),
      visited : Set(String)
    )
      module_full_name = resolve_path_like_name(include_node.target)
      return unless module_full_name
      # Prefer nested modules under the including class.
      if !module_full_name.includes?("::")
        base_owner = class_name.split('(').first
        nested_name = "#{base_owner}::#{module_full_name}"
        module_full_name = nested_name if @module_defs.has_key?(nested_name)
      end
      module_full_name = resolve_module_alias_for_include(module_full_name)
      record_module_inclusion(module_full_name, class_name)
      return if visited.includes?(module_full_name)
      visited << module_full_name

      debug_hook("mixin.lower", "class=#{class_name} module=#{module_full_name}")

      defs = @module_defs[module_full_name]? || return
      include_arena = @arena
      defs.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          extra_map = include_type_param_map(mod_node, include_node.target, include_arena)
          with_type_param_map(extra_map) do
            if macro_lookup = lookup_macro_entry("included", module_full_name)
              macro_entry, macro_key = macro_lookup
              macro_def, macro_arena = macro_entry
              expanded_id = expand_macro_expr(macro_def, macro_arena, [] of ExprId, nil, nil, macro_key)
              unless expanded_id.invalid?
                old_arena = @arena
                @arena = macro_arena
                begin
                  lower_class_body_expr(class_name, class_info, expanded_id, defined_full_names, visited)
                ensure
                  @arena = old_arena
                end
              end
            end
            if body = mod_node.body
              with_namespace_override(module_full_name) do
                body.each do |member_id|
                  member = unwrap_visibility_member(@arena[member_id])
                  if member.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode)
                    remember_effect_annotation(member, @arena)
                    next
                  elsif !member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
                    clear_pending_effect_annotations
                  end
                  case member
                  when CrystalV2::Compiler::Frontend::IncludeNode
                    lower_module_instance_methods_for(class_name, class_info, member, defined_full_names, visited)
                  when CrystalV2::Compiler::Frontend::DefNode
                    next if (recv = member.receiver) && String.new(recv) == "self"
                    next if member.is_abstract

                    method_name = String.new(member.name)
                    base_name = "#{class_name}##{method_name}"

                    if DebugHooks::ENABLED && method_name == "map"
                      block_type = ""
                      if params = member.params
                        if blk = params.find(&.is_block)
                          block_type = blk.type_annotation ? String.new(blk.type_annotation.not_nil!) : ""
                        end
                      end
                      debug_hook("method.lower.inspect", "class=#{class_name} method=#{method_name} block_type=#{block_type} map=#{type_param_map_debug_string}")
                    end

                    block_unbound = false
                    if params = member.params
                      params.each do |param|
                        next unless param.is_block
                        if ta = param.type_annotation
                          if type_param_name = extract_proc_return_type_name(String.new(ta))
                            if type_param_like?(type_param_name) && !@type_param_map.has_key?(type_param_name)
                              block_unbound = true
                              break
                            end
                          end
                        end
                      end
                    end

                    if block_unbound || def_has_unbound_type_params?(member)
                      reason = block_unbound ? "block_return_type_param" : "unbound_type_params"
                      debug_hook("method.lower.defer", "class=#{class_name} method=#{method_name} reason=#{reason}")
                      next
                    end

                    param_types = [] of TypeRef
                    has_block = false
                    if params = member.params
                      params.each do |param|
                        next if named_only_separator?(param)
                        if param.is_block
                          has_block = true
                          next
                        end
                        if ta = param.type_annotation
                          param_types << type_ref_for_name(String.new(ta))
                        else
                          param_types << TypeRef::VOID
                        end
                      end
                    end

                    full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
                    next if defined_full_names.includes?(full_name)
                    next if @module.has_function?(full_name)

                    lower_method(class_name, class_info, member)
                  when CrystalV2::Compiler::Frontend::GetterNode
                    member.specs.each do |spec|
                      generate_getter_method(class_name, class_info, spec)
                    end
                  when CrystalV2::Compiler::Frontend::SetterNode
                    member.specs.each do |spec|
                      generate_setter_method(class_name, class_info, spec)
                    end
                  when CrystalV2::Compiler::Frontend::PropertyNode
                    member.specs.each do |spec|
                      generate_getter_method(class_name, class_info, spec)
                      generate_setter_method(class_name, class_info, spec)
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    private def lower_module_class_methods_for(
      class_name : String,
      class_info : ClassInfo,
      extend_target : ExprId,
      visited : Set(String)
    )
      module_full_name = resolve_path_like_name(extend_target)
      return unless module_full_name
      if !module_full_name.includes?("::")
        base_owner = class_name.split('(').first
        nested_name = "#{base_owner}::#{module_full_name}"
        module_full_name = nested_name if @module_defs.has_key?(nested_name)
      end
      module_full_name = resolve_module_alias_for_include(module_full_name)
      return if visited.includes?(module_full_name)
      visited << module_full_name

      defs = @module_defs[module_full_name]? || return
      include_arena = @arena
      defs.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          extra_map = include_type_param_map(mod_node, extend_target, include_arena)
          with_type_param_map(extra_map) do
            if body = mod_node.body
              with_namespace_override(module_full_name) do
                body.each do |member_id|
                  member = unwrap_visibility_member(@arena[member_id])
                  if member.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode)
                    remember_effect_annotation(member, @arena)
                    next
                  elsif !member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
                    clear_pending_effect_annotations
                  end
                  case member
                  when CrystalV2::Compiler::Frontend::IncludeNode
                    lower_module_class_methods_for(class_name, class_info, member.target, visited)
                  when CrystalV2::Compiler::Frontend::DefNode
                    next if (recv = member.receiver) && String.new(recv) == "self"
                    next if member.is_abstract
                    lower_method(class_name, class_info, member, force_class_method: true)
                  end
                end
              end
            end
          end
        end
      end
    end

    private def module_like_type_name?(name : String) : Bool
      base = if paren = name.index('(')
               name[0, paren]
             else
               name
             end
      @module_defs.has_key?(base)
    end

    private def module_type_ref?(type_ref : TypeRef) : Bool
      return false if type_ref == TypeRef::VOID
      if desc = @module.get_type_descriptor(type_ref)
        return desc.kind == TypeKind::Module
      end
      false
    end

    NILABLE_QUERY_METHODS = ["[]?", "at?", "first?", "last?", "pop?", "shift?"] of String

    # Some stdlib methods end in `?` but return a value (typically `T?` / `V?`) rather than `Bool`.
    # We need correct return types early (during signature registration) so callers lowered before the
    # callee body still get a stable type (avoids emitting `i1` where `i32`/union is expected).
    private def infer_unannotated_query_return_type(method_name : String, self_type : TypeRef) : TypeRef?
      return nil unless NILABLE_QUERY_METHODS.includes?(method_name)

      desc = @module.get_type_descriptor(self_type)
      return nil unless desc

      case desc.kind
      when TypeKind::Array
        elem = desc.type_params.first?
        return nil unless elem
        create_union_type_for_nullable(elem)
      when TypeKind::Hash
        value = desc.type_params[1]?
        return nil unless value
        create_union_type_for_nullable(value)
      when TypeKind::Class, TypeKind::Struct
        elem = desc.type_params.first?
        return nil unless elem
        base = desc.name
        if paren = base.index('(')
          base = base[0, paren]
        end
        case base
        when "Deque", "Slice", "StaticArray", "Set"
          create_union_type_for_nullable(elem)
        else
          nil
        end
      else
        nil
      end
    end

    private def infer_unannotated_search_return_type(method_name : String, self_type : TypeRef) : TypeRef?
      return nil if self_type == TypeRef::VOID
      case method_name
      when "bsearch"
        if desc = @module.get_type_descriptor(self_type)
          if elem_name = element_type_for_type_name(desc.name)
            elem_ref = type_ref_for_name(elem_name)
            return create_union_type_for_nullable(elem_ref) if elem_ref != TypeRef::VOID
          end
        end
      when "bsearch_index"
        return create_union_type_for_nullable(TypeRef::INT32)
      end
      nil
    end

    private def tail_expr_id_for_body(body : Array(ExprId)) : ExprId?
      return nil if body.empty?
      expr_id = body.last
      loop do
        expr_node = @arena[expr_id]
        case expr_node
        when CrystalV2::Compiler::Frontend::GroupingNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::MacroExpressionNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::ReturnNode
          value = expr_node.value
          return nil unless value
          expr_id = value
        else
          break
        end
      end
      expr_id
    end

    private def infer_type_literal_name_from_expr(expr_id : ExprId) : String?
      node = node_for_expr(expr_id)
      return nil unless node

      case node
      when CrystalV2::Compiler::Frontend::PathNode
        raw_path = collect_path_string(node)
        type_name = if path_is_absolute?(node)
                      raw_path.starts_with?("::") ? raw_path[2..] : raw_path
                    else
                      resolve_path_string_in_context(raw_path)
                    end
        type_name = resolve_type_name_in_context(type_name)
        type_name = resolve_type_alias_chain(type_name)
        return type_name if type_name_exists?(type_name) || @module_defs.has_key?(type_name) || @generic_templates.has_key?(type_name)
      when CrystalV2::Compiler::Frontend::GenericNode
        if type_name = stringify_type_expr(expr_id)
          type_name = resolve_type_name_in_context(type_name)
          type_name = resolve_type_alias_chain(type_name)
          return type_name if type_name_exists?(type_name) || @generic_templates.has_key?(type_name)
        end
      end

      nil
    end

    private def infer_type_literal_return_name_from_body(
      node : CrystalV2::Compiler::Frontend::DefNode,
      self_type_name : String? = nil
    ) : String?
      body = node.body
      return nil unless body && !body.empty?
      expr_id = tail_expr_id_for_body(body)
      return nil unless expr_id

      old_class = @current_class
      @current_class = self_type_name if self_type_name
      begin
        infer_type_literal_name_from_expr(expr_id)
      ensure
        @current_class = old_class
      end
    end

    private def infer_concrete_return_type_from_body(
      node : CrystalV2::Compiler::Frontend::DefNode,
      self_type_name : String? = nil
    ) : TypeRef?
      body = node.body
      return nil unless body && !body.empty?

      return_types = [] of TypeRef
      body.each do |expr_id|
        collect_return_types(expr_id, self_type_name, return_types)
      end
      if return_types.any?
        inferred = merge_return_types(return_types)
        # If we have explicit returns, still consider the final expression
        # as a possible implicit return type.
        expr_id = body.last
        loop do
          expr_node = @arena[expr_id]
          case expr_node
          when CrystalV2::Compiler::Frontend::GroupingNode
            expr_id = expr_node.expression
          when CrystalV2::Compiler::Frontend::MacroExpressionNode
            expr_id = expr_node.expression
          when CrystalV2::Compiler::Frontend::ReturnNode
            value = expr_node.value
            break unless value
            expr_id = value
          else
            break
          end
        end
        if inferred && (tail_type = infer_type_from_expr(expr_id, self_type_name))
          inferred = union_type_for_values(inferred, tail_type) if tail_type != inferred
        end
        return inferred
      end

      # Use the last expression as a heuristic return (handles simple multi-line bodies).
      expr_id = body.last
      loop do
        expr_node = @arena[expr_id]
        case expr_node
        when CrystalV2::Compiler::Frontend::GroupingNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::MacroExpressionNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::ReturnNode
          value = expr_node.value
          return nil unless value
          expr_id = value
        else
          break
        end
      end

      if inferred = infer_type_from_expr(expr_id, self_type_name)
        return inferred
      end

      expr_node = @arena[expr_id]
      case expr_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(expr_node.name)
        if inferred = infer_local_type_from_body(body, name, self_type_name)
          return inferred
        end
      when CrystalV2::Compiler::Frontend::AssignNode
        return infer_type_from_expr(expr_node.value, self_type_name)
      when CrystalV2::Compiler::Frontend::TypeDeclarationNode
        return type_ref_for_name(String.new(expr_node.declared_type))
      end

      nil
    end

    private def record_type_literal_return(full_name : String, base_name : String) : Nil
      return if full_name.empty? && base_name.empty?
      @function_return_type_literals.add(full_name) unless full_name.empty?
      @function_return_type_literals.add(base_name) unless base_name.empty?
    end

    private def function_returns_type_literal?(mangled_name : String, base_name : String) : Bool
      return true if @function_return_type_literals.includes?(mangled_name)
      if mangled_base = mangled_name.split("$", 2)[0]?
        return true if @function_return_type_literals.includes?(mangled_base)
      end
      @function_return_type_literals.includes?(base_name)
    end

    private def collect_return_types(
      expr_id : ExprId,
      self_type_name : String?,
      output : Array(TypeRef)
    ) : Nil
      expr_node = @arena[expr_id]
      case expr_node
      when CrystalV2::Compiler::Frontend::ReturnNode
        if value = expr_node.value
          if inferred = infer_type_from_expr(value, self_type_name)
            output << inferred
          end
        else
          output << TypeRef::NIL
        end
      when CrystalV2::Compiler::Frontend::IfNode
        expr_node.then_body.each { |child| collect_return_types(child, self_type_name, output) }
        if elsifs = expr_node.elsifs
          elsifs.each do |branch|
            branch.body.each { |child| collect_return_types(child, self_type_name, output) }
          end
        end
        if else_body = expr_node.else_body
          else_body.each { |child| collect_return_types(child, self_type_name, output) }
        end
      when CrystalV2::Compiler::Frontend::CaseNode
        expr_node.when_branches.each do |branch|
          branch.body.each { |child| collect_return_types(child, self_type_name, output) }
        end
        if else_branch = expr_node.else_branch
          else_branch.each { |child| collect_return_types(child, self_type_name, output) }
        end
        if in_branches = expr_node.in_branches
          in_branches.each do |branch|
            branch.body.each { |child| collect_return_types(child, self_type_name, output) }
          end
        end
      when CrystalV2::Compiler::Frontend::BeginNode
        expr_node.body.each { |child| collect_return_types(child, self_type_name, output) }
        if clauses = expr_node.rescue_clauses
          clauses.each do |clause|
            clause.body.each { |child| collect_return_types(child, self_type_name, output) }
          end
        end
        if else_body = expr_node.else_body
          else_body.each { |child| collect_return_types(child, self_type_name, output) }
        end
        if ensure_body = expr_node.ensure_body
          ensure_body.each { |child| collect_return_types(child, self_type_name, output) }
        end
      when CrystalV2::Compiler::Frontend::BlockNode
        if body = expr_node.body
          body.each { |child| collect_return_types(child, self_type_name, output) }
        end
      when CrystalV2::Compiler::Frontend::LoopNode
        expr_node.body.each { |child| collect_return_types(child, self_type_name, output) }
      when CrystalV2::Compiler::Frontend::ForNode
        expr_node.body.each { |child| collect_return_types(child, self_type_name, output) }
      end
    end

    private def merge_return_types(types : Array(TypeRef)) : TypeRef?
      return nil if types.empty?
      merged = types.first
      types[1..].each do |t|
        merged = union_type_for_values(merged, t)
      end
      merged
    end

    private def infer_type_from_expr(expr_id : ExprId, self_type_name : String?) : TypeRef?
      if ENV["DEBUG_INFER_CRASH"]?
        STDERR.puts "[INFER_CALL] expr=#{expr_id.index} current=#{@arena.class}:#{@arena.size}"
      end
      arena = arena_for_expr?(expr_id)
      return nil unless arena
      return nil if expr_id.index >= arena.size

      old_arena = @arena
      @arena = arena
      key = (arena.object_id.to_u64 << 32) ^ expr_id.index.to_u64
      if @infer_expr_stack.includes?(key)
        @arena = old_arena
        return nil
      end
      @infer_expr_stack.add(key)
      begin
        expr_node = @arena[expr_id]
      case expr_node
      when CrystalV2::Compiler::Frontend::NumberNode
        return type_ref_for_number_kind(expr_node.kind)
      when CrystalV2::Compiler::Frontend::BoolNode
        return TypeRef::BOOL
      when CrystalV2::Compiler::Frontend::NilNode
        return TypeRef::NIL
      when CrystalV2::Compiler::Frontend::StringNode, CrystalV2::Compiler::Frontend::StringInterpolationNode
        return TypeRef::STRING
      when CrystalV2::Compiler::Frontend::CharNode
        return TypeRef::CHAR
      when CrystalV2::Compiler::Frontend::SymbolNode
        return TypeRef::SYMBOL
      when CrystalV2::Compiler::Frontend::PathNode
        full_name = resolve_path_string_in_context(collect_path_string(expr_node))
        parts = full_name.split("::")
        if parts.size >= 2
          member = parts.last
          enum_candidate = parts[0...-1].join("::")
          if enum_name = resolve_enum_name(enum_candidate)
            if enum_info = @enum_info
              if enum_info[enum_name]?.try(&.has_key?(member))
                return enum_base_type(enum_name)
              end
            end
          end
        end
        if type_name_exists?(full_name)
          return type_ref_for_name(full_name)
        end
      when CrystalV2::Compiler::Frontend::GroupingNode
        return infer_type_from_expr(expr_node.expression, self_type_name)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        return infer_type_from_expr(expr_node.expression, self_type_name)
      when CrystalV2::Compiler::Frontend::AsNode
        return type_ref_for_name(String.new(expr_node.target_type))
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        member_name = String.new(expr_node.member)
        if member_name == "size"
          object_node = node_for_expr(expr_node.object)
          if object_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            object_name = String.new(object_node.name)
            # Macro patterns like {{T.size}} use type params; treat as Int32 for signature inference.
            if object_name == "T" || object_name == "U" || object_name == "V" ||
               object_name == "K" || object_name == "E" || object_name == "B" ||
               object_name == "L" || object_name == "W"
              return TypeRef::INT32
            end
          end
        end
      when CrystalV2::Compiler::Frontend::ReturnNode
        value = expr_node.value
        return nil unless value
        return infer_type_from_expr(value, self_type_name)
      when CrystalV2::Compiler::Frontend::SelfNode
        return type_ref_for_name(self_type_name) if self_type_name
      when CrystalV2::Compiler::Frontend::IdentifierNode
        if self_type_name && String.new(expr_node.name) == "self"
          return type_ref_for_name(self_type_name)
        end
        if locals = @current_typeof_locals
          name = String.new(expr_node.name)
          if type_ref = locals[name]?
            return type_ref if type_ref != TypeRef::VOID
          end
        end
        if type_name = lookup_typeof_local_name(String.new(expr_node.name))
          return type_ref_for_name(type_name)
        end
      when CrystalV2::Compiler::Frontend::AssignNode
        value_id = expr_node.value
        value_node = node_for_expr(value_id)
        value_type = nil
        if value_node.is_a?(CrystalV2::Compiler::Frontend::BinaryNode)
          op = value_node.operator_string
          if op == "&&" || op == "||"
            left_type = infer_type_from_expr(value_node.left, self_type_name)
            right_type = infer_type_from_expr(value_node.right, self_type_name)
            if left_type && right_type
              value_type = union_type_for_values(left_type, right_type)
            end
            value_type ||= left_type if left_type && left_type != TypeRef::VOID
            value_type ||= right_type if right_type && right_type != TypeRef::VOID
          end
        end
        value_type ||= infer_type_from_expr(value_id, self_type_name)
        if value_type && value_type != TypeRef::VOID
          if target = node_for_expr(expr_node.target)
            if target.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
              name = String.new(target.name)
              update_typeof_local(name, value_type)
              if concrete_name = concrete_type_name_for(value_type)
                existing_name = lookup_typeof_local_name(name)
                if existing_name.nil? || module_like_type_name?(existing_name)
                  update_typeof_local_name(name, concrete_name)
                end
              end
            end
          end
        end
        return value_type
      when CrystalV2::Compiler::Frontend::InstanceVarNode
        if self_type_name
          if info = @class_info[self_type_name]?
            ivar_name = String.new(expr_node.name)
            if ivar = info.ivars.find { |iv| iv.name == ivar_name }
              return ivar.type
            end
          end
        end
      when CrystalV2::Compiler::Frontend::CallNode
        callee_node = node_for_expr(expr_node.callee)
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          member_name = String.new(callee_node.member)
          if member_name == "unsafe_as"
            if arg = expr_node.args.first?
              if type_str = stringify_type_expr(arg)
                return type_ref_for_name(type_str)
              end
            end
          end
          if member_name == "new"
            if type_str = stringify_type_expr(callee_node.object)
              if type_str == "Range" && expr_node.args.size >= 2
                begin_type = infer_type_from_expr(expr_node.args[0], self_type_name)
                end_type = infer_type_from_expr(expr_node.args[1], self_type_name)
                if begin_type && end_type
                  range_name = "Range(#{get_type_name_from_ref(begin_type)}, #{get_type_name_from_ref(end_type)})"
                  return type_ref_for_name(range_name)
                end
              end
              return type_ref_for_name(type_str)
            end
          elsif member_name.ends_with?("?")
            if obj_type = infer_type_from_expr(callee_node.object, self_type_name)
              if inferred = infer_unannotated_query_return_type(member_name, obj_type)
                return inferred
              end
            end
          end
          if obj_name = stringify_type_expr(callee_node.object)
            obj_name = resolve_type_name_in_context(obj_name)
            base_method = "#{obj_name}.#{member_name}"
            if ret_type = @function_base_return_types[base_method]?
              return ret_type if ret_type != TypeRef::VOID
            end
            if ret_type = @function_types[base_method]?
              return ret_type if ret_type != TypeRef::VOID
            end
          end
        elsif callee_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          method_name = String.new(callee_node.name)
          if self_type_name
            base = resolve_method_with_inheritance(self_type_name, method_name) || "#{self_type_name}##{method_name}"
            if ret_type = @function_base_return_types[base]?
              return ret_type if ret_type != TypeRef::VOID
            end
            if ret_type = @function_types[base]?
              return ret_type if ret_type != TypeRef::VOID
            end
          end
          if ret_type = @function_types[method_name]?
            return ret_type if ret_type != TypeRef::VOID
          end
          if cached = @function_base_return_types[method_name]?
            return cached if cached != TypeRef::VOID
          end
        end
      when CrystalV2::Compiler::Frontend::UnaryNode
        op = String.new(expr_node.operator)
        if op == "!"
          return TypeRef::BOOL
        end
        return infer_type_from_expr(expr_node.operand, self_type_name)
      when CrystalV2::Compiler::Frontend::UninitializedNode
        if type_str = stringify_type_expr(expr_node.type)
          return type_ref_for_name(type_str)
        end
      when CrystalV2::Compiler::Frontend::BinaryNode
        op = expr_node.operator_string
        if op == "&&" || op == "||"
          left_type = infer_type_from_expr(expr_node.left, self_type_name)
          right_type = infer_type_from_expr(expr_node.right, self_type_name)
          if left_type && right_type
            return union_type_for_values(left_type, right_type)
          end
          return left_type if left_type && left_type != TypeRef::VOID
          return right_type if right_type && right_type != TypeRef::VOID
        end
        if op == "==" || op == "!=" || op == "<" || op == "<=" || op == ">" || op == ">="
          return TypeRef::BOOL
        end
        left_type = infer_type_from_expr(expr_node.left, self_type_name)
        right_type = infer_type_from_expr(expr_node.right, self_type_name)
        return left_type if left_type && left_type != TypeRef::VOID
        return right_type if right_type && right_type != TypeRef::VOID
      when CrystalV2::Compiler::Frontend::IfNode
        then_type = infer_type_from_branch(expr_node.then_body, self_type_name)
        else_type = expr_node.else_body ? infer_type_from_branch(expr_node.else_body.not_nil!, self_type_name) : TypeRef::NIL
        if then_type && else_type
          return union_type_for_values(then_type, else_type)
        end
      end

        nil
      ensure
        @infer_expr_stack.delete(key)
        @arena = old_arena
      end
    end

    private def infer_type_from_branch(
      body : Array(ExprId),
      self_type_name : String?
    ) : TypeRef?
      return nil if body.empty?
      expr_id = body.last
      infer_type_from_expr(expr_id, self_type_name)
    end

    private def type_ref_for_number_kind(kind : CrystalV2::Compiler::Frontend::NumberKind) : TypeRef
      case kind
      when CrystalV2::Compiler::Frontend::NumberKind::I8  then TypeRef::INT8
      when CrystalV2::Compiler::Frontend::NumberKind::I16 then TypeRef::INT16
      when CrystalV2::Compiler::Frontend::NumberKind::I32 then TypeRef::INT32
      when CrystalV2::Compiler::Frontend::NumberKind::I64 then TypeRef::INT64
      when CrystalV2::Compiler::Frontend::NumberKind::I128 then TypeRef::INT128
      when CrystalV2::Compiler::Frontend::NumberKind::U8  then TypeRef::UINT8
      when CrystalV2::Compiler::Frontend::NumberKind::U16 then TypeRef::UINT16
      when CrystalV2::Compiler::Frontend::NumberKind::U32 then TypeRef::UINT32
      when CrystalV2::Compiler::Frontend::NumberKind::U64 then TypeRef::UINT64
      when CrystalV2::Compiler::Frontend::NumberKind::U128 then TypeRef::UINT128
      when CrystalV2::Compiler::Frontend::NumberKind::F32 then TypeRef::FLOAT32
      when CrystalV2::Compiler::Frontend::NumberKind::F64 then TypeRef::FLOAT64
      else
        TypeRef::INT32
      end
    end

    private def infer_arg_types_for_call(args : Array(ExprId), self_type_name : String?) : Array(TypeRef)
      args.map { |arg| infer_type_from_expr(arg, self_type_name) || TypeRef::VOID }
    end

    private def infer_local_type_from_body(
      body : Array(ExprId),
      name : String,
      self_type_name : String?
    ) : TypeRef?
      body.reverse_each do |expr_id|
        expr_node = @arena[expr_id]
        case expr_node
        when CrystalV2::Compiler::Frontend::AssignNode
          target = @arena[expr_node.target]
          if target.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
             String.new(target.name) == name
            return infer_type_from_expr(expr_node.value, self_type_name)
          end
        when CrystalV2::Compiler::Frontend::TypeDeclarationNode
          if String.new(expr_node.name) == name
            return type_ref_for_name(String.new(expr_node.declared_type))
          end
        end
      end

      nil
    end

    # Register a module and its methods (pass 1)
    # Modules are like classes but with only class methods (self.method)
    # Also handles nested classes: module Foo; class Bar; end; end -> Foo::Bar
    def register_module(node : CrystalV2::Compiler::Frontend::ModuleNode)
      register_module_with_name(node, String.new(node.name))
    end

    private def register_module_with_name(node : CrystalV2::Compiler::Frontend::ModuleNode, module_name : String)
      module_name = resolve_class_name_for_definition(module_name)
      if ENV.has_key?("DEBUG_NESTED_CLASS") && (module_name == "IO" || module_name.includes?("FileDescriptor"))
        STDERR.puts "[DEBUG_MODULE] Processing module: #{module_name}, body_size=#{node.body.try(&.size) || 0}"
      end

      # Keep module AST around for mixin expansion (`include Foo` in classes/structs).
      existing_defs = @module_defs.has_key?(module_name)
      (@module_defs[module_name] ||= [] of {CrystalV2::Compiler::Frontend::ModuleNode, CrystalV2::Compiler::Frontend::ArenaLike}) << {node, @arena}
      invalidate_type_cache_for_namespace(module_name) if existing_defs
      if ENV.has_key?("DEBUG_MODULE_BINARY_FORMAT") && module_name.includes?("BinaryFormat")
        STDERR.puts "[REG_MODULE_TOP] #{module_name}, now has #{@module_defs[module_name].size} defs"
      end
      if ENV.has_key?("DEBUG_MODULE_THREAD") && module_name.includes?("Thread")
        STDERR.puts "[REG_MODULE_TOP] #{module_name}, body_size=#{node.body.try(&.size) || 0}"
        if body = node.body
          body.each do |expr_id|
            member = @arena[expr_id]
            STDERR.puts "[REG_MODULE_MEMBER] type=#{member.class}"
          end
        end
      end

      # Register module methods (def self.foo) and nested classes
      if body = node.body
        extend_self = false
        extend_nodes = [] of CrystalV2::Compiler::Frontend::ExtendNode
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          next unless member.is_a?(CrystalV2::Compiler::Frontend::ExtendNode)
          extend_nodes << member
          target_node = @arena[member.target]
          case target_node
          when CrystalV2::Compiler::Frontend::SelfNode
            extend_self = true
          when CrystalV2::Compiler::Frontend::IdentifierNode
            extend_self = String.new(target_node.name) == "self"
          end
        end
        @module_extend_self.add(module_name) if extend_self
        defined_class_method_full_names = collect_defined_class_method_full_names(module_name, body)

        # PASS 1: Register aliases and nested modules first (so they're available for function type resolution)
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          if member.is_a?(CrystalV2::Compiler::Frontend::AliasNode)
            alias_name = String.new(member.name)
            old_class = @current_class
            @current_class = module_name
            target_name = resolve_alias_target(String.new(member.value))
            @current_class = old_class
            full_alias_name = "#{module_name}::#{alias_name}"
            register_type_alias(full_alias_name, target_name)
            register_type_alias(alias_name, target_name)
            if ENV.has_key?("DEBUG_ALIAS")
              STDERR.puts "[ALIAS] Registered (module): #{full_alias_name} => #{target_name}, also: #{alias_name} => #{target_name}"
            end
          elsif member.is_a?(CrystalV2::Compiler::Frontend::ModuleNode)
            # Nested module: Foo::Bar (as module)
            nested_name = String.new(member.name)
            full_nested_name = "#{module_name}::#{nested_name}"
            register_module_with_name(member, full_nested_name)
          elsif member.is_a?(CrystalV2::Compiler::Frontend::ClassNode)
            # Register class/struct type alias and any aliases inside the class
            class_name = String.new(member.name)
            full_class_name = "#{module_name}::#{class_name}"
            register_type_alias(full_class_name, full_class_name)
            # Also register short name -> full name for local resolution (for both classes and structs)
            register_type_alias(class_name, full_class_name)
            register_class_aliases(member, full_class_name)
          end
        end
        # PASS 1.5: Register enums BEFORE classes/structs so type resolution works
        # (e.g., IO::Seek must exist before IO::FileDescriptor methods reference "Seek")
        old_class = @current_class
        @current_class = module_name
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          if member.is_a?(CrystalV2::Compiler::Frontend::EnumNode)
            enum_name = String.new(member.name)
            full_enum_name = "#{module_name}::#{enum_name}"
            register_enum_with_name(member, full_enum_name)
          end
        end
        @current_class = old_class
        # PASS 2: Register functions and classes (now that aliases and enums are available)
        old_class = @current_class
        @current_class = module_name
        begin
          record_constants_in_body(module_name, body)
          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            case member
          when CrystalV2::Compiler::Frontend::ClassVarDeclNode
            raw_name = String.new(member.name)
            cvar_name = raw_name.lstrip('@')
            cvar_type = type_ref_for_name(String.new(member.type))
            initial_value : Int64? = nil
            if val_id = member.value
              val_node = @arena[val_id]
              if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
                num_str = String.new(val_node.value)
                initial_value = num_str.to_i64?
              end
            end
            record_class_var_type(module_name, cvar_name, cvar_type, initial_value)
          when CrystalV2::Compiler::Frontend::MacroDefNode
            register_macro(member, module_name)
          when CrystalV2::Compiler::Frontend::AssignNode
            target_node = @arena[member.target]
            if target_node.is_a?(CrystalV2::Compiler::Frontend::ClassVarNode)
              raw_name = String.new(target_node.name)
              cvar_name = raw_name.lstrip('@')
              value_node = @arena[member.value]
              cvar_type = infer_type_from_class_ivar_assign(value_node)
              record_class_var_type(module_name, cvar_name, cvar_type)
            end
          when CrystalV2::Compiler::Frontend::DefNode
            method_name = String.new(member.name)
            # In Crystal, `def self.foo` defines a module (class) method,
            # while `def foo` defines an instance method meant to be mixed in via `include`.
            is_class_method = if recv = member.receiver
                                String.new(recv) == "self"
                              else
                                extend_self
                              end
            next unless is_class_method
            base_name = "#{module_name}.#{method_name}"
            return_type = if rt = member.return_type
                            rt_name = String.new(rt)
                            inferred = module_like_type_name?(rt_name) ? infer_concrete_return_type_from_body(member) : nil
                            inferred || type_ref_for_name(rt_name)
                          elsif method_name.ends_with?("?")
                            TypeRef::BOOL
                          else
                            infer_concrete_return_type_from_body(member) || TypeRef::VOID
                          end
            param_types = [] of TypeRef
            has_block = false
            if params = member.params
              params.each do |param|
                next if named_only_separator?(param)
                if param.is_block
                  has_block = true
                  next
                end
                param_type = if ta = param.type_annotation
                               type_ref_for_name(String.new(ta))
                             elsif param.is_double_splat
                               type_ref_for_name("NamedTuple")
                             else
                               TypeRef::VOID
                             end
                param_types << param_type
              end
            end
            full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
            if ENV.has_key?("DEBUG_MODULE_THREAD") && module_name.includes?("System::Thread")
              STDERR.puts "[REG_MODULE_METHOD] #{module_name}.#{method_name} -> #{full_name}"
            end
            register_function_type(full_name, return_type)
            @function_defs[full_name] = member
            @function_def_arenas[full_name] = @arena

            # Track yield-functions for inline expansion (module methods).
            if body = member.body
              if contains_yield?(body)
                @yield_functions.add(full_name)
                debug_hook("yield.register", full_name)
                unless @function_defs.has_key?(base_name)
                  @function_defs[base_name] = member
                  @function_def_arenas[base_name] = @arena
                end
                @function_defs[full_name] = member
                @function_def_arenas[full_name] = @arena
              end
            end
          when CrystalV2::Compiler::Frontend::GetterNode
            next unless member.is_class?
            member.specs.each do |spec|
              register_class_accessor_entry(module_name, spec, :getter)
            end
          when CrystalV2::Compiler::Frontend::SetterNode
            next unless member.is_class?
            member.specs.each do |spec|
              register_class_accessor_entry(module_name, spec, :setter)
            end
          when CrystalV2::Compiler::Frontend::PropertyNode
            next unless member.is_class?
            member.specs.each do |spec|
              register_class_accessor_entry(module_name, spec, :getter)
              register_class_accessor_entry(module_name, spec, :setter)
            end
          when CrystalV2::Compiler::Frontend::ClassNode
            class_name = String.new(member.name)
            full_class_name = "#{module_name}::#{class_name}"
            if ENV.has_key?("DEBUG_NESTED_CLASS") && full_class_name.includes?("FileDescriptor")
              STDERR.puts "[DEBUG_NESTED_CLASS] Registering nested class: #{full_class_name}"
            end
            register_class_with_name(member, full_class_name)
          when CrystalV2::Compiler::Frontend::EnumNode
            # Already registered in PASS 1.5 - skip
          when CrystalV2::Compiler::Frontend::MacroIfNode
            # Handle macro conditionals inside module body
            process_macro_if_in_module(member, module_name)
          when CrystalV2::Compiler::Frontend::MacroForNode
            # Handle macro for-loops inside module body (e.g., ByteFormat)
            process_macro_for_in_module(member, module_name)
          when CrystalV2::Compiler::Frontend::MacroLiteralNode
            # Handle macro literal (may contain def/class inside)
            process_macro_literal_in_module(member, module_name)
          when CrystalV2::Compiler::Frontend::CallNode
            callee = @arena[member.callee]
            if callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
              method_name = String.new(callee.name)
              if macro_lookup = lookup_macro_entry(method_name, module_name)
                macro_entry, macro_key = macro_lookup
                macro_def, macro_arena = macro_entry
                expanded_id = expand_macro_expr(macro_def, macro_arena, member.args, member.named_args, member.block, macro_key)
                unless expanded_id.invalid?
                  old_arena = @arena
                  @arena = macro_arena
                  begin
                    register_module_members_from_macro_expansion(module_name, expanded_id)
                  ensure
                    @arena = old_arena
                  end
                end
              end
            end
          when CrystalV2::Compiler::Frontend::IdentifierNode
            method_name = String.new(member.name)
            if macro_lookup = lookup_macro_entry(method_name, module_name)
              macro_entry, macro_key = macro_lookup
              macro_def, macro_arena = macro_entry
              expanded_id = expand_macro_expr(macro_def, macro_arena, [] of ExprId, nil, nil, macro_key)
              unless expanded_id.invalid?
                old_arena = @arena
                @arena = macro_arena
                begin
                  register_module_members_from_macro_expansion(module_name, expanded_id)
                ensure
                  @arena = old_arena
                end
              end
            end
          end
        end
          visited_extends = Set(String).new
          extend_nodes.each do |ext|
            register_module_class_methods_for(
              module_name,
              ext.target,
              defined_class_method_full_names,
              visited_extends
            )
          end
        ensure
          @current_class = old_class
        end
      end
    end

    # Process MacroIfNode inside a module body to extract methods
    private def process_macro_if_in_module(node : CrystalV2::Compiler::Frontend::MacroIfNode, module_name : String)
      if raw_text = macro_if_raw_text(node)
        nested_macro_end = raw_text.scan(/\{%\s*end\s*%\}/).size > 1
        unless nested_macro_end
          if expanded = expand_flag_macro_text(raw_text)
            if program = parse_macro_literal_program(expanded)
              with_arena(program.arena) do
                scan_module_extend_self_in_program(program, module_name)
                program.roots.each do |expr_id|
                  expr_node = @arena[expr_id]
                  case expr_node
                  when CrystalV2::Compiler::Frontend::DefNode
                    register_module_method_from_def(expr_node, module_name)
                  when CrystalV2::Compiler::Frontend::ClassNode
                    class_name = String.new(expr_node.name)
                    full_class_name = "#{module_name}::#{class_name}"
                    register_class_with_name(expr_node, full_class_name)
                  when CrystalV2::Compiler::Frontend::ModuleNode
                    nested_name = String.new(expr_node.name)
                    full_nested_name = "#{module_name}::#{nested_name}"
                    register_nested_module(expr_node, full_nested_name)
                  when CrystalV2::Compiler::Frontend::ExtendNode
                    mark_module_extend_self(expr_node, module_name)
                  when CrystalV2::Compiler::Frontend::MacroIfNode
                    process_macro_if_in_module(expr_node, module_name)
                  when CrystalV2::Compiler::Frontend::MacroForNode
                    process_macro_for_in_module(expr_node, module_name)
                  when CrystalV2::Compiler::Frontend::MacroLiteralNode
                    process_macro_literal_in_module(expr_node, module_name)
                  end
                end
              end
              return
            end
          end
        end
      end

      result = try_evaluate_macro_condition(node.condition)
      if result == true
        process_macro_body_in_module(node.then_body, module_name)
      elsif result == false
        if else_node = node.else_body
          else_ast = @arena[else_node]
          case else_ast
          when CrystalV2::Compiler::Frontend::MacroIfNode
            process_macro_if_in_module(else_ast, module_name)
          else
            process_macro_body_in_module(else_node, module_name)
          end
        end
      else
        # Can't evaluate - try both branches
        process_macro_body_in_module(node.then_body, module_name)
        if else_node = node.else_body
          process_macro_body_in_module(else_node, module_name)
        end
      end
    end

    # Process macro body (MacroLiteralNode or expression) to extract module methods
    private def process_macro_body_in_module(body_id : ExprId, module_name : String)
      body_node = @arena[body_id]
      case body_node
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_module(body_node, module_name)
      when CrystalV2::Compiler::Frontend::DefNode
        register_module_method_from_def(body_node, module_name)
      when CrystalV2::Compiler::Frontend::ClassNode
        class_name = String.new(body_node.name)
        full_class_name = "#{module_name}::#{class_name}"
        register_class_with_name(body_node, full_class_name)
      when CrystalV2::Compiler::Frontend::ExtendNode
        mark_module_extend_self(body_node, module_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        process_macro_if_in_module(body_node, module_name)
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_module(body_node, module_name)
      end
    end

    private def process_macro_for_in_module(node : CrystalV2::Compiler::Frontend::MacroForNode, module_name : String)
      iter_vars = node.iter_vars.map { |name| String.new(name) }
      return if iter_vars.empty?

      values = macro_for_iterable_values(node.iterable)
      return unless values

      source = @sources_by_arena[@arena]?
      program = CrystalV2::Compiler::Frontend::Program.new(@arena, [] of ExprId)
      expander = CrystalV2::Compiler::Semantic::MacroExpander.new(
        program,
        @arena,
        CrystalV2::Runtime.target_flags,
        recovery_mode: true,
        macro_source: source
      )
      owner_type = macro_owner_type_for(module_name)

      expanded = String.build do |io|
        values.each_with_index do |value, idx|
          vars = {} of String => CrystalV2::Compiler::Semantic::MacroValue
          vars[iter_vars[0]] = value
          if idx_name = iter_vars[1]?
            vars[idx_name] = CrystalV2::Compiler::Semantic::MacroNumberValue.new(idx.to_i64)
          end
          if body_output = expander.expand_literal(node.body, variables: vars, owner_type: owner_type)
            io << body_output
            io << "\n"
          end
        end
      end

      sanitized = strip_macro_lines(expanded)
      if program = parse_macro_literal_program(sanitized)
        with_arena(program.arena) do
          scan_module_extend_self_in_program(program, module_name)
          program.roots.each do |expr_id|
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::DefNode
              register_module_method_from_def(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::ClassNode
              class_name = String.new(expr_node.name)
              full_class_name = "#{module_name}::#{class_name}"
              register_class_with_name(expr_node, full_class_name)
            when CrystalV2::Compiler::Frontend::ModuleNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{module_name}::#{nested_name}"
              register_nested_module(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::ExtendNode
              mark_module_extend_self(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_module(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroForNode
              process_macro_for_in_module(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_module(expr_node, module_name)
            end
          end
        end
      end
    end

    # Process MacroLiteralNode to extract module methods
    private def process_macro_literal_in_module(node : CrystalV2::Compiler::Frontend::MacroLiteralNode, module_name : String)
      if raw_text = macro_literal_raw_text(node)
        expanded = expand_flag_macro_text(raw_text) || raw_text
        if program = parse_macro_literal_program(expanded)
          with_arena(program.arena) do
            scan_module_extend_self_in_program(program, module_name)
            program.roots.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::DefNode
                register_module_method_from_def(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::ClassNode
                class_name = String.new(expr_node.name)
                full_class_name = "#{module_name}::#{class_name}"
                register_class_with_name(expr_node, full_class_name)
              when CrystalV2::Compiler::Frontend::ModuleNode
                nested_name = String.new(expr_node.name)
                full_nested_name = "#{module_name}::#{nested_name}"
                register_nested_module(expr_node, full_nested_name)
              when CrystalV2::Compiler::Frontend::ExtendNode
                mark_module_extend_self(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                process_macro_if_in_module(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::MacroForNode
                process_macro_for_in_module(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                process_macro_literal_in_module(expr_node, module_name)
              end
            end
          end
          return
        end
      end

      # Fallback: evaluate active text pieces (handles nested macro controls).
      texts = macro_literal_active_texts(node)
      combined = texts.join("\n")
      if program = parse_macro_literal_program(combined)
        with_arena(program.arena) do
          scan_module_extend_self_in_program(program, module_name)
          program.roots.each do |expr_id|
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::DefNode
              register_module_method_from_def(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::ClassNode
              class_name = String.new(expr_node.name)
              full_class_name = "#{module_name}::#{class_name}"
              register_class_with_name(expr_node, full_class_name)
            when CrystalV2::Compiler::Frontend::ModuleNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{module_name}::#{nested_name}"
              register_nested_module(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::ExtendNode
              mark_module_extend_self(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_module(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_module(expr_node, module_name)
            end
          end
        end
        return
      end

      parsed_any = false
      texts.each do |text|
        next if text.strip.empty?
        if program = parse_macro_literal_program(text)
          parsed_any = true
          with_arena(program.arena) do
            program.roots.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::DefNode
                register_module_method_from_def(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::ClassNode
                class_name = String.new(expr_node.name)
                full_class_name = "#{module_name}::#{class_name}"
                register_class_with_name(expr_node, full_class_name)
              when CrystalV2::Compiler::Frontend::ModuleNode
                nested_name = String.new(expr_node.name)
                full_nested_name = "#{module_name}::#{nested_name}"
                register_nested_module(expr_node, full_nested_name)
              when CrystalV2::Compiler::Frontend::ExtendNode
                mark_module_extend_self(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                process_macro_if_in_module(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::MacroForNode
                process_macro_for_in_module(expr_node, module_name)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                process_macro_literal_in_module(expr_node, module_name)
              end
            end
          end
        end
      end
      return if parsed_any

      node.pieces.each do |piece|
        case piece.kind
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::Expression
          if expr_id = piece.expr
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::DefNode
              register_module_method_from_def(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::ClassNode
              class_name = String.new(expr_node.name)
              full_class_name = "#{module_name}::#{class_name}"
              register_class_with_name(expr_node, full_class_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_module(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroForNode
              process_macro_for_in_module(expr_node, module_name)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_module(expr_node, module_name)
            end
          end
        end
      end
    end

    private def scan_module_extend_self_in_program(
      program : CrystalV2::Compiler::Frontend::Program,
      module_name : String
    ) : Nil
      program.roots.each do |expr_id|
        expr_node = @arena[expr_id]
        next unless expr_node.is_a?(CrystalV2::Compiler::Frontend::ExtendNode)
        mark_module_extend_self(expr_node, module_name)
      end
    end

    private def macro_literal_active_texts(node : CrystalV2::Compiler::Frontend::MacroLiteralNode) : Array(String)
      texts = [] of String
      control_stack = [] of {Bool, Bool, Bool} # {parent_active, branch_taken, active}
      active = true
      source = @sources_by_arena[@arena]?
      bytesize = source ? source.bytesize : 0

      node.pieces.each do |piece|
        case piece.kind
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::Text
          next unless active
          if source && (span = piece.span)
            start = span.start_offset
            length = span.end_offset - span.start_offset
            next if length <= 0
            next if start < 0 || start >= bytesize
            if start + length > bytesize
              length = bytesize - start
            end
            texts << source.byte_slice(start, length)
          elsif text = piece.text
            texts << text
          end
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::ControlStart
          keyword = piece.control_keyword || ""
          cond_expr = piece.expr
          cond = cond_expr ? try_evaluate_macro_condition(cond_expr) : nil
          if keyword == "unless"
            cond = cond.nil? ? nil : !cond
          end

          parent_active = active
          branch_active = if cond == true
                            parent_active
                          elsif cond == false
                            false
                          else
                            parent_active
                          end
          branch_taken = cond == true
          control_stack << {parent_active, branch_taken, branch_active}
          active = branch_active
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::ControlElseIf
          next if control_stack.empty?
          parent_active, branch_taken, _ = control_stack[-1]
          cond_expr = piece.expr
          cond = cond_expr ? try_evaluate_macro_condition(cond_expr) : nil
          take = !branch_taken && cond == true
          branch_active = if cond == false
                            false
                          elsif cond == true
                            parent_active && take
                          else
                            parent_active
                          end
          branch_taken = true if cond == true
          control_stack[-1] = {parent_active, branch_taken, branch_active}
          active = branch_active
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::ControlElse
          next if control_stack.empty?
          parent_active, branch_taken, _ = control_stack[-1]
          branch_active = parent_active && !branch_taken
          control_stack[-1] = {parent_active, true, branch_active}
          active = branch_active
        when CrystalV2::Compiler::Frontend::MacroPiece::Kind::ControlEnd
          if control_stack.empty?
            active = true
          else
            parent_active, _, _ = control_stack.pop
            active = parent_active
          end
        else
          # Ignore expression/macro var pieces for module registration.
        end
      end

      texts
    end

    private def strip_macro_lines(code : String) : String
      String.build do |io|
        code.each_line do |line|
          next if line.includes?("{{") || line.includes?("{%")
          io << line
        end
      end
    end

    # Register a class method from a DefNode inside a module
    private def register_module_method_from_def(member : CrystalV2::Compiler::Frontend::DefNode, module_name : String)
      method_name = String.new(member.name)
      is_class_method = if recv = member.receiver
                          String.new(recv) == "self"
                        else
                          @module_extend_self.includes?(module_name)
                        end
      return unless is_class_method
      base_name = "#{module_name}.#{method_name}"
      return_type = if rt = member.return_type
                      rt_name = String.new(rt)
                      inferred = module_like_type_name?(rt_name) ? infer_concrete_return_type_from_body(member) : nil
                      inferred || type_ref_for_name(rt_name)
                    elsif method_name.ends_with?("?")
                      TypeRef::BOOL
                    else
                      infer_concrete_return_type_from_body(member) || TypeRef::VOID
                    end
      param_types = [] of TypeRef
      has_block = false
      if params = member.params
        params.each do |param|
          next if named_only_separator?(param)
          if param.is_block
            has_block = true
            next
          end
          param_type = if ta = param.type_annotation
                         type_ref_for_name(String.new(ta))
                       elsif param.is_double_splat
                         type_ref_for_name("NamedTuple")
                       else
                         TypeRef::VOID
                       end
          param_types << param_type
        end
      end
      full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
      if ENV.has_key?("DEBUG_MODULE_THREAD") && module_name.includes?("System::Thread")
        STDERR.puts "[REG_MODULE_METHOD_MACRO] #{module_name}.#{method_name} -> #{full_name}"
      end
      if @function_defs.has_key?(full_name)
        if body = member.body
          if contains_yield?(body)
            @yield_functions.add(full_name)
            debug_hook("yield.register", full_name)
          end
        end
        if ENV.has_key?("DEBUG_DUP_FUNCTION")
          STDERR.puts "[DEBUG_DUP_FUNCTION] Skipping duplicate module method: #{full_name}"
        end
        return
      end
      register_function_type(full_name, return_type)
      @function_defs[full_name] = member
      @function_def_arenas[full_name] = @arena

      # Track yield-functions for inline expansion
      if body = member.body
        if contains_yield?(body)
          @yield_functions.add(full_name)
          debug_hook("yield.register", full_name)
          unless @function_defs.has_key?(base_name)
            @function_defs[base_name] = member
            @function_def_arenas[base_name] = @arena
          end
          @function_defs[full_name] = member
          @function_def_arenas[full_name] = @arena
        end
      end
    end

    private def register_module_members_from_macro_expansion(module_name : String, expr_id : ExprId)
      return if expr_id.invalid?
      member = unwrap_visibility_member(@arena[expr_id])
      case member
      when CrystalV2::Compiler::Frontend::BlockNode
        member.body.each do |child_id|
          child = unwrap_visibility_member(@arena[child_id])
          next unless child.is_a?(CrystalV2::Compiler::Frontend::ExtendNode)
          mark_module_extend_self(child, module_name)
        end
        member.body.each do |child_id|
          register_module_members_from_macro_expansion(module_name, child_id)
        end
      when CrystalV2::Compiler::Frontend::DefNode
        register_module_method_from_def(member, module_name)
      when CrystalV2::Compiler::Frontend::ClassNode
        class_name = String.new(member.name)
        full_class_name = "#{module_name}::#{class_name}"
        register_class_with_name(member, full_class_name)
      when CrystalV2::Compiler::Frontend::ModuleNode
        nested_name = String.new(member.name)
        full_nested_name = "#{module_name}::#{nested_name}"
        register_nested_module(member, full_nested_name)
      when CrystalV2::Compiler::Frontend::EnumNode
        enum_name = String.new(member.name)
        full_enum_name = "#{module_name}::#{enum_name}"
        register_enum_with_name(member, full_enum_name)
      when CrystalV2::Compiler::Frontend::ExtendNode
        mark_module_extend_self(member, module_name)
      when CrystalV2::Compiler::Frontend::MacroDefNode
        register_macro(member, module_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        process_macro_if_in_module(member, module_name)
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_module(member, module_name)
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_module(member, module_name)
      end
    end

    private def mark_module_extend_self(node : CrystalV2::Compiler::Frontend::ExtendNode, module_name : String) : Nil
      target_node = @arena[node.target]
      case target_node
      when CrystalV2::Compiler::Frontend::SelfNode
        @module_extend_self.add(module_name)
      when CrystalV2::Compiler::Frontend::IdentifierNode
        @module_extend_self.add(module_name) if String.new(target_node.name) == "self"
      end
    end

    private def register_enum_methods(node : CrystalV2::Compiler::Frontend::EnumNode, enum_name : String)
      return unless body = node.body

      body.each do |expr_id|
        member = unwrap_visibility_member(@arena[expr_id])
        case member
        when CrystalV2::Compiler::Frontend::DefNode
          register_type_method_from_def(member, enum_name)
        when CrystalV2::Compiler::Frontend::MacroDefNode
          register_macro(member, enum_name)
        when CrystalV2::Compiler::Frontend::MacroIfNode
          process_macro_if_in_enum(member, enum_name)
        when CrystalV2::Compiler::Frontend::MacroLiteralNode
          process_macro_literal_in_enum(member, enum_name)
        end
      end
    end

    private def register_type_method_from_def(member : CrystalV2::Compiler::Frontend::DefNode, type_name : String)
      method_name = String.new(member.name)
      is_class_method = if recv = member.receiver
                          String.new(recv) == "self"
                        else
                          false
                        end
      base_name = if is_class_method
                    "#{type_name}.#{method_name}"
                  else
                    "#{type_name}##{method_name}"
                  end
      enum_return_name : String? = nil
      if rt = member.return_type
        resolved_return = resolve_type_name_in_context(String.new(rt))
        if enum_name = resolve_enum_name(resolved_return)
          enum_return_name = enum_name
        end
      end
      return_type = if rt = member.return_type
                      type_ref_for_name(String.new(rt))
                    elsif method_name.ends_with?("?")
                      inferred = infer_concrete_return_type_from_body(member, type_name)
                      inferred ||= infer_unannotated_query_return_type(method_name, type_ref_for_name(type_name))
                      inferred || TypeRef::BOOL
                    else
                      infer_concrete_return_type_from_body(member, type_name) || TypeRef::VOID
                    end
      if is_class_method && return_type == TypeRef::VOID
        if enum_name = resolve_enum_name(type_name)
          return_type = enum_base_type(enum_name)
        end
      end
      param_types = [] of TypeRef
      has_block = false
      if params = member.params
        params.each do |param|
          next if named_only_separator?(param)
          if param.is_block
            has_block = true
            next
          end
          param_type = if ta = param.type_annotation
                         type_ref_for_name(String.new(ta))
                       elsif param.is_double_splat
                         type_ref_for_name("NamedTuple")
                       else
                         TypeRef::VOID
                       end
          param_types << param_type
        end
      end
      full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
      if enum_return_name
        @function_enum_return_names[full_name] = enum_return_name
        @function_enum_return_names[base_name] = enum_return_name
      end
      register_function_type(full_name, return_type)
      @function_defs[full_name] = member
      @function_def_arenas[full_name] = @arena

      if body = member.body
        if contains_yield?(body)
          @yield_functions.add(full_name)
          debug_hook("yield.register", full_name)
          unless @function_defs.has_key?(base_name)
            @function_defs[base_name] = member
            @function_def_arenas[base_name] = @arena
          end
          @function_defs[full_name] = member
          @function_def_arenas[full_name] = @arena
        end
      end
    end

    private def process_macro_if_in_enum(node : CrystalV2::Compiler::Frontend::MacroIfNode, enum_name : String)
      if raw_text = macro_if_raw_text(node)
        nested_macro_end = raw_text.scan(/\{%\s*end\s*%\}/).size > 1
        unless nested_macro_end
          if expanded = expand_flag_macro_text(raw_text)
            if program = parse_macro_literal_program(expanded)
              with_arena(program.arena) do
                program.roots.each do |expr_id|
                  expr_node = @arena[expr_id]
                  case expr_node
                  when CrystalV2::Compiler::Frontend::DefNode
                    register_type_method_from_def(expr_node, enum_name)
                  when CrystalV2::Compiler::Frontend::MacroIfNode
                    process_macro_if_in_enum(expr_node, enum_name)
                  when CrystalV2::Compiler::Frontend::MacroLiteralNode
                    process_macro_literal_in_enum(expr_node, enum_name)
                  end
                end
              end
              return
            end
          end
        end
      end

      result = try_evaluate_macro_condition(node.condition)
      if result == true
        process_macro_body_in_enum(node.then_body, enum_name)
      elsif result == false
        if else_node = node.else_body
          else_ast = @arena[else_node]
          case else_ast
          when CrystalV2::Compiler::Frontend::MacroIfNode
            process_macro_if_in_enum(else_ast, enum_name)
          else
            process_macro_body_in_enum(else_node, enum_name)
          end
        end
      else
        process_macro_body_in_enum(node.then_body, enum_name)
        if else_node = node.else_body
          process_macro_body_in_enum(else_node, enum_name)
        end
      end
    end

    private def process_macro_body_in_enum(body_id : ExprId, enum_name : String)
      body_node = @arena[body_id]
      case body_node
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_enum(body_node, enum_name)
      when CrystalV2::Compiler::Frontend::DefNode
        register_type_method_from_def(body_node, enum_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        process_macro_if_in_enum(body_node, enum_name)
      end
    end

    private def process_macro_literal_in_enum(node : CrystalV2::Compiler::Frontend::MacroLiteralNode, enum_name : String)
      if raw_text = macro_literal_raw_text(node)
        expanded = expand_flag_macro_text(raw_text) || raw_text
        if program = parse_macro_literal_program(expanded)
          with_arena(program.arena) do
            program.roots.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::DefNode
                register_type_method_from_def(expr_node, enum_name)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                process_macro_if_in_enum(expr_node, enum_name)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                process_macro_literal_in_enum(expr_node, enum_name)
              end
            end
          end
          return
        end
      end

      texts = macro_literal_active_texts(node)
      combined = texts.join("\n")
      if program = parse_macro_literal_program(combined)
        with_arena(program.arena) do
          program.roots.each do |expr_id|
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::DefNode
              register_type_method_from_def(expr_node, enum_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_enum(expr_node, enum_name)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_enum(expr_node, enum_name)
            end
          end
        end
        return
      end

      parsed_any = false
      texts.each do |text|
        next if text.strip.empty?
        if program = parse_macro_literal_program(text)
          parsed_any = true
          with_arena(program.arena) do
            program.roots.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::DefNode
                register_type_method_from_def(expr_node, enum_name)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                process_macro_if_in_enum(expr_node, enum_name)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                process_macro_literal_in_enum(expr_node, enum_name)
              end
            end
          end
        end
      end
      return if parsed_any
    end

    private def process_macro_if_in_class(
      node : CrystalV2::Compiler::Frontend::MacroIfNode,
      class_name : String,
      ivars : Array(IVarInfo)? = nil,
      offset_ref : Pointer(Int32)? = nil
    )
      if raw_text = macro_if_raw_text(node)
        nested_macro_end = raw_text.scan(/\{%\s*end\s*%\}/).size > 1
        unless nested_macro_end
          if expanded = expand_flag_macro_text(raw_text)
            if parsed = parse_macro_literal_class_body(expanded)
              program, body_ids = parsed
              with_arena(program.arena) do
                body_ids.each do |expr_id|
                  expr_node = @arena[expr_id]
                  case expr_node
                  when CrystalV2::Compiler::Frontend::DefNode
                    register_type_method_from_def(expr_node, class_name)
                  when CrystalV2::Compiler::Frontend::MacroIfNode
                    process_macro_if_in_class(expr_node, class_name, ivars, offset_ref)
                  when CrystalV2::Compiler::Frontend::MacroLiteralNode
                    process_macro_literal_in_class(expr_node, class_name, ivars, offset_ref)
                  when CrystalV2::Compiler::Frontend::ClassNode
                    nested_name = String.new(expr_node.name)
                    full_nested_name = "#{class_name}::#{nested_name}"
                    register_class_with_name(expr_node, full_nested_name)
                  when CrystalV2::Compiler::Frontend::EnumNode
                    nested_name = String.new(expr_node.name)
                    full_nested_name = "#{class_name}::#{nested_name}"
                    register_enum_with_name(expr_node, full_nested_name)
                  when CrystalV2::Compiler::Frontend::ModuleNode
                    nested_name = String.new(expr_node.name)
                    full_nested_name = "#{class_name}::#{nested_name}"
                    register_nested_module(expr_node, full_nested_name)
                  when CrystalV2::Compiler::Frontend::GetterNode
                    register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
                  when CrystalV2::Compiler::Frontend::SetterNode
                    register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
                  when CrystalV2::Compiler::Frontend::PropertyNode
                    register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
                  end
                end
              end
              return
            end
          end
        end
      end

      result = try_evaluate_macro_condition(node.condition)
      if result == true
        process_macro_body_in_class(node.then_body, class_name, ivars, offset_ref)
      elsif result == false
        if else_node = node.else_body
          else_ast = @arena[else_node]
          case else_ast
          when CrystalV2::Compiler::Frontend::MacroIfNode
            process_macro_if_in_class(else_ast, class_name, ivars, offset_ref)
          else
            process_macro_body_in_class(else_node, class_name, ivars, offset_ref)
          end
        end
      else
        process_macro_body_in_class(node.then_body, class_name, ivars, offset_ref)
        if else_node = node.else_body
          process_macro_body_in_class(else_node, class_name, ivars, offset_ref)
        end
      end
    end

    private def process_macro_body_in_class(
      body_id : ExprId,
      class_name : String,
      ivars : Array(IVarInfo)? = nil,
      offset_ref : Pointer(Int32)? = nil
    )
      body_node = @arena[body_id]
      case body_node
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        process_macro_literal_in_class(body_node, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::DefNode
        register_type_method_from_def(body_node, class_name)
      when CrystalV2::Compiler::Frontend::MacroIfNode
        process_macro_if_in_class(body_node, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::MacroForNode
        process_macro_for_in_class(body_node, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::GetterNode
        register_accessors_in_class(body_node, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::SetterNode
        register_accessors_in_class(body_node, class_name, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::PropertyNode
        register_accessors_in_class(body_node, class_name, ivars, offset_ref)
      end
    end

    private def process_macro_literal_in_class(
      node : CrystalV2::Compiler::Frontend::MacroLiteralNode,
      class_name : String,
      ivars : Array(IVarInfo)? = nil,
      offset_ref : Pointer(Int32)? = nil
    )
      if raw_text = macro_literal_raw_text(node)
        expanded = expand_flag_macro_text(raw_text) || raw_text
        if program = parse_macro_literal_program(expanded)
          with_arena(program.arena) do
            program.roots.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::DefNode
                register_type_method_from_def(expr_node, class_name)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                process_macro_if_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::MacroForNode
                process_macro_for_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                process_macro_literal_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::GetterNode
                register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::SetterNode
                register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::PropertyNode
                register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
              end
            end
          end
          return
        end
      end

      texts = macro_literal_active_texts(node)
      combined = texts.join("\n")
      if parsed = parse_macro_literal_class_body(combined)
        program, body_ids = parsed
        with_arena(program.arena) do
          body_ids.each do |expr_id|
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::DefNode
              register_type_method_from_def(expr_node, class_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::MacroForNode
              process_macro_for_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::ClassNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{class_name}::#{nested_name}"
              register_class_with_name(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::EnumNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{class_name}::#{nested_name}"
              register_enum_with_name(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::ModuleNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{class_name}::#{nested_name}"
              register_nested_module(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::GetterNode
              register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::SetterNode
              register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::PropertyNode
              register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
            end
          end
        end
        return
      end

      parsed_any = false
      texts.each do |text|
        next if text.strip.empty?
        if parsed = parse_macro_literal_class_body(text)
          parsed_any = true
          program, body_ids = parsed
          with_arena(program.arena) do
            body_ids.each do |expr_id|
              expr_node = @arena[expr_id]
              case expr_node
              when CrystalV2::Compiler::Frontend::DefNode
                register_type_method_from_def(expr_node, class_name)
              when CrystalV2::Compiler::Frontend::MacroIfNode
                process_macro_if_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::MacroForNode
                process_macro_for_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::MacroLiteralNode
                process_macro_literal_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::ClassNode
                nested_name = String.new(expr_node.name)
                full_nested_name = "#{class_name}::#{nested_name}"
                register_class_with_name(expr_node, full_nested_name)
              when CrystalV2::Compiler::Frontend::EnumNode
                nested_name = String.new(expr_node.name)
                full_nested_name = "#{class_name}::#{nested_name}"
                register_enum_with_name(expr_node, full_nested_name)
              when CrystalV2::Compiler::Frontend::ModuleNode
                nested_name = String.new(expr_node.name)
                full_nested_name = "#{class_name}::#{nested_name}"
                register_nested_module(expr_node, full_nested_name)
              when CrystalV2::Compiler::Frontend::GetterNode
                register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::SetterNode
                register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
              when CrystalV2::Compiler::Frontend::PropertyNode
                register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
              end
            end
          end
        end
      end
      return if parsed_any
    end

    private def process_macro_for_in_class(
      node : CrystalV2::Compiler::Frontend::MacroForNode,
      class_name : String,
      ivars : Array(IVarInfo)? = nil,
      offset_ref : Pointer(Int32)? = nil
    )
      iter_vars = node.iter_vars.map { |name| String.new(name) }
      return if iter_vars.empty?

      values = macro_for_iterable_values(node.iterable)
      return unless values

      source = @sources_by_arena[@arena]?
      program = CrystalV2::Compiler::Frontend::Program.new(@arena, [] of ExprId)
      expander = CrystalV2::Compiler::Semantic::MacroExpander.new(
        program,
        @arena,
        CrystalV2::Runtime.target_flags,
        recovery_mode: true,
        macro_source: source
      )
      owner_type = macro_owner_type_for(class_name)

      expanded = String.build do |io|
        values.each_with_index do |value, idx|
          vars = {} of String => CrystalV2::Compiler::Semantic::MacroValue
          vars[iter_vars[0]] = value
          if idx_name = iter_vars[1]?
            vars[idx_name] = CrystalV2::Compiler::Semantic::MacroNumberValue.new(idx.to_i64)
          end
          if body_output = expander.expand_literal(node.body, variables: vars, owner_type: owner_type)
            io << body_output
            io << "\n"
          end
        end
      end

      sanitized = strip_macro_lines(expanded)
      if parsed = parse_macro_literal_class_body(sanitized)
        program, body_ids = parsed
        with_arena(program.arena) do
          body_ids.each do |expr_id|
            expr_node = @arena[expr_id]
            case expr_node
            when CrystalV2::Compiler::Frontend::DefNode
              register_type_method_from_def(expr_node, class_name)
            when CrystalV2::Compiler::Frontend::MacroIfNode
              process_macro_if_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::MacroForNode
              process_macro_for_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::MacroLiteralNode
              process_macro_literal_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::ClassNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{class_name}::#{nested_name}"
              register_class_with_name(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::EnumNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{class_name}::#{nested_name}"
              register_enum_with_name(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::ModuleNode
              nested_name = String.new(expr_node.name)
              full_nested_name = "#{class_name}::#{nested_name}"
              register_nested_module(expr_node, full_nested_name)
            when CrystalV2::Compiler::Frontend::GetterNode
              register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::SetterNode
              register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
            when CrystalV2::Compiler::Frontend::PropertyNode
              register_accessors_in_class(expr_node, class_name, ivars, offset_ref)
            end
          end
        end
      end
    end

    private def register_accessors_in_class(
      member : CrystalV2::Compiler::Frontend::GetterNode | CrystalV2::Compiler::Frontend::SetterNode | CrystalV2::Compiler::Frontend::PropertyNode,
      class_name : String,
      ivars : Array(IVarInfo)?,
      offset_ref : Pointer(Int32)?
    )
      return unless ivars && offset_ref

      if member.is_class?
        case member
        when CrystalV2::Compiler::Frontend::GetterNode
          member.specs.each { |spec| register_class_accessor_entry(class_name, spec, :getter) }
        when CrystalV2::Compiler::Frontend::SetterNode
          member.specs.each { |spec| register_class_accessor_entry(class_name, spec, :setter) }
        when CrystalV2::Compiler::Frontend::PropertyNode
          member.specs.each do |spec|
            register_class_accessor_entry(class_name, spec, :getter)
            register_class_accessor_entry(class_name, spec, :setter)
          end
        end
        return
      end

      case member
      when CrystalV2::Compiler::Frontend::GetterNode
        member.specs.each do |spec|
          storage_name = accessor_storage_name(spec)
          getter_name = accessor_method_name(spec)
          ivar_name = "@#{storage_name}"
          ivar_type = if ta = spec.type_annotation
                        type_ref_for_name(String.new(ta))
                      elsif spec.predicate
                        TypeRef::BOOL
                      elsif default_value = spec.default_value
                        infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                      else
                        TypeRef::VOID
                      end
          unless ivars.any? { |iv| iv.name == ivar_name }
            ivars << IVarInfo.new(ivar_name, ivar_type, offset_ref.value)
            offset_ref.value += type_size(ivar_type)
          end
          getter_base = "#{class_name}##{getter_name}"
          full_name = mangle_function_name(getter_base, [] of TypeRef)
          register_function_type(full_name, ivar_type)
        end
      when CrystalV2::Compiler::Frontend::SetterNode
        member.specs.each do |spec|
          storage_name = accessor_storage_name(spec)
          ivar_name = "@#{storage_name}"
          ivar_type = if ta = spec.type_annotation
                        type_ref_for_name(String.new(ta))
                      elsif spec.predicate
                        TypeRef::BOOL
                      elsif default_value = spec.default_value
                        infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                      else
                        TypeRef::VOID
                      end
          unless ivars.any? { |iv| iv.name == ivar_name }
            ivars << IVarInfo.new(ivar_name, ivar_type, offset_ref.value)
            offset_ref.value += type_size(ivar_type)
          end
          setter_name = "#{class_name}##{storage_name}="
          full_name = mangle_function_name(setter_name, [ivar_type])
          register_function_type(full_name, ivar_type)
        end
      when CrystalV2::Compiler::Frontend::PropertyNode
        member.specs.each do |spec|
          storage_name = accessor_storage_name(spec)
          getter_name = accessor_method_name(spec)
          ivar_name = "@#{storage_name}"
          ivar_type = if ta = spec.type_annotation
                        type_ref_for_name(String.new(ta))
                      elsif spec.predicate
                        TypeRef::BOOL
                      elsif default_value = spec.default_value
                        infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                      else
                        TypeRef::VOID
                      end
          unless ivars.any? { |iv| iv.name == ivar_name }
            ivars << IVarInfo.new(ivar_name, ivar_type, offset_ref.value)
            offset_ref.value += type_size(ivar_type)
          end
          getter_base = "#{class_name}##{getter_name}"
          getter_full = mangle_function_name(getter_base, [] of TypeRef)
          register_function_type(getter_full, ivar_type)
          setter_name = "#{class_name}##{storage_name}="
          setter_full = mangle_function_name(setter_name, [ivar_type])
          register_function_type(setter_full, ivar_type)
        end
      end
    end

    # Register a nested module with full path
    private def register_nested_module(node : CrystalV2::Compiler::Frontend::ModuleNode, full_name : String)
      # Keep nested module AST around for mixin expansion.
      existing_defs = @module_defs.has_key?(full_name)
      (@module_defs[full_name] ||= [] of {CrystalV2::Compiler::Frontend::ModuleNode, CrystalV2::Compiler::Frontend::ArenaLike}) << {node, @arena}
      invalidate_type_cache_for_namespace(full_name) if existing_defs
      if ENV.has_key?("DEBUG_MODULE_LOOKUP") && full_name == "Crystal::System::Signal"
        body_size = node.body.try(&.size) || 0
        STDERR.puts "[DEBUG_MODULE_LOOKUP] register_nested_module #{full_name} body_size=#{body_size}"
      end
      if full_name.includes?("BinaryFormat") && full_name == "Float::FastFloat::BinaryFormat"
        body_methods = [] of String
        body_size = node.body.try(&.size) || 0
        start_line = node.span.start_line rescue 0
        end_line = node.span.end_line rescue 0
        if b = node.body
          b.each do |id|
            mem = @arena[id]
            while mem.is_a?(CrystalV2::Compiler::Frontend::VisibilityModifierNode)
              mem = @arena[mem.expression]
            end
            if mem.is_a?(CrystalV2::Compiler::Frontend::DefNode)
              param_count = mem.params.try(&.size) || 0
              body_methods << "#{String.new(mem.name)}(#{param_count})"
            end
          end
        end
        # STDERR.puts "[REG_MODULE] #{full_name} (lines #{start_line}-#{end_line}), now has #{@module_defs[full_name].size} defs, body_size=#{body_size}, methods=#{body_methods}"
      end

      if body = node.body
        # PASS 1: Register aliases first (so they're available for function type resolution)
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          if member.is_a?(CrystalV2::Compiler::Frontend::AliasNode)
            alias_name = String.new(member.name)
            old_class = @current_class
            @current_class = full_name
            target_name = resolve_alias_target(String.new(member.value))
            @current_class = old_class
            full_alias_name = "#{full_name}::#{alias_name}"
            register_type_alias(full_alias_name, target_name)
            if ENV.has_key?("DEBUG_ALIAS")
              STDERR.puts "[ALIAS] Registered: #{full_alias_name} => #{target_name}"
            end
          elsif member.is_a?(CrystalV2::Compiler::Frontend::ModuleNode)
            # Recursively register nested module aliases first
            nested_name = String.new(member.name)
            full_nested_name = "#{full_name}::#{nested_name}"
            register_nested_module(member, full_nested_name)
          elsif member.is_a?(CrystalV2::Compiler::Frontend::ClassNode)
            # Register class/struct type alias and any aliases inside the class
            class_name = String.new(member.name)
            full_class_name = "#{full_name}::#{class_name}"
            register_type_alias(full_class_name, full_class_name)
            register_class_aliases(member, full_class_name)
          end
        end
        # PASS 2: Register functions and other members (now that aliases are available)
        old_class = @current_class
        @current_class = full_name
        begin
          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            case member
          when CrystalV2::Compiler::Frontend::DefNode
            method_name = String.new(member.name)
            is_class_method = if recv = member.receiver
                                String.new(recv) == "self"
                              else
                                false
                              end
            next unless is_class_method
            if ENV.has_key?("DEBUG_MODULE_LOOKUP") && full_name == "Crystal::System::Signal"
              STDERR.puts "[DEBUG_MODULE_LOOKUP] register #{full_name}.#{method_name}"
            end
            base_name = "#{full_name}.#{method_name}"
            return_type = if rt = member.return_type
                            rt_name = String.new(rt)
                            inferred = module_like_type_name?(rt_name) ? infer_concrete_return_type_from_body(member) : nil
                            inferred || type_ref_for_name(rt_name)
                          elsif method_name.ends_with?("?")
                            TypeRef::BOOL
                          else
                            infer_concrete_return_type_from_body(member) || TypeRef::VOID
                          end
            param_types = [] of TypeRef
            has_block = false
            if params = member.params
              params.each do |param|
                next if named_only_separator?(param)
                if param.is_block
                  has_block = true
                  next
                end
                param_type = if ta = param.type_annotation
                               type_ref_for_name(String.new(ta))
                             elsif param.is_double_splat
                               type_ref_for_name("NamedTuple")
                             else
                               TypeRef::VOID
                             end
                param_types << param_type
              end
            end
            full_method_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
            register_function_type(full_method_name, return_type)
            @function_defs[full_method_name] = member
            @function_def_arenas[full_method_name] = @arena

            # Track yield-functions for inline expansion (nested module methods).
            if body = member.body
                if contains_yield?(body)
                  @yield_functions.add(full_method_name)
                  debug_hook("yield.register", full_method_name)
                  unless @function_defs.has_key?(base_name)
                    @function_defs[base_name] = member
                    @function_def_arenas[base_name] = @arena
                  end
                  @function_defs[full_method_name] = member
                  @function_def_arenas[full_method_name] = @arena
                end
              end
          when CrystalV2::Compiler::Frontend::ClassNode
            class_name = String.new(member.name)
            full_class_name = "#{full_name}::#{class_name}"
            register_class_with_name(member, full_class_name)
          when CrystalV2::Compiler::Frontend::EnumNode
            enum_name = String.new(member.name)
            full_enum_name = "#{full_name}::#{enum_name}"
            register_enum_with_name(member, full_enum_name)
          when CrystalV2::Compiler::Frontend::MacroIfNode
            process_macro_if_in_module(member, full_name)
          when CrystalV2::Compiler::Frontend::MacroLiteralNode
            process_macro_literal_in_module(member, full_name)
            end
          end
        ensure
          @current_class = old_class
        end
      end
    end

    # Register aliases inside a class (for nested alias-first processing)
    private def register_class_aliases(node : CrystalV2::Compiler::Frontend::ClassNode, class_name : String)
      if body = node.body
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          if member.is_a?(CrystalV2::Compiler::Frontend::AliasNode)
            alias_name = String.new(member.name)
            old_class = @current_class
            @current_class = class_name
            target_name = resolve_alias_target(String.new(member.value))
            @current_class = old_class
            full_alias_name = "#{class_name}::#{alias_name}"
            register_type_alias(full_alias_name, target_name)
            register_type_alias(alias_name, target_name)
            if ENV.has_key?("DEBUG_ALIAS")
              STDERR.puts "[ALIAS] Registered (class): #{full_alias_name} => #{target_name}, also: #{alias_name} => #{target_name}"
            end
          end
        end
      end
    end

    private def record_constants_in_body(owner_name : String, body : Array(ExprId))
      body.each do |expr_id|
        member = unwrap_visibility_member(@arena[expr_id])
        case member
        when CrystalV2::Compiler::Frontend::BlockNode
          record_constants_in_body(owner_name, member.body)
        when CrystalV2::Compiler::Frontend::ConstantNode
          record_constant_definition(owner_name, String.new(member.name), member.value, @arena)
        when CrystalV2::Compiler::Frontend::AssignNode
          target = @arena[member.target]
          if target.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
            record_constant_definition(owner_name, String.new(target.name), member.value, @arena)
          end
        end
      end
    end

    # Lower a module's methods and nested classes (pass 3)
    def lower_module(node : CrystalV2::Compiler::Frontend::ModuleNode)
      module_name = String.new(node.name)
      lower_module_with_name(node, module_name)
    end

    # Lower a module with a specific name prefix
    private def lower_module_with_name(node : CrystalV2::Compiler::Frontend::ModuleNode, module_name : String)
      if ENV.has_key?("DEBUG_NESTED_CLASS") && (module_name == "IO" || module_name.includes?("FileDescriptor"))
        STDERR.puts "[DEBUG_LOWER_MOD] lower_module_with_name: #{module_name}, body_size=#{node.body.try(&.size) || 0}"
      end
      # DEBUG_MODULE_THREAD disabled
      if body = node.body
        old_class = @current_class
        old_pending = @pending_def_annotations
        @current_class = module_name
        begin
          @pending_def_annotations = [] of Tuple(CrystalV2::Compiler::Frontend::AnnotationNode, CrystalV2::Compiler::Frontend::ArenaLike)
          body.each_with_index do |expr_id, idx|
            member = unwrap_visibility_member(@arena[expr_id])
            if member.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode)
              remember_effect_annotation(member, @arena)
              next
            elsif !member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
              clear_pending_effect_annotations
            end
            if ENV.has_key?("DEBUG_NESTED_CLASS") && (module_name == "IO" || module_name.includes?("FileDescriptor"))
              STDERR.puts "[DEBUG_LOWER_MOD] #{module_name} member #{idx}: #{member.class}"
            end
            case member
            when CrystalV2::Compiler::Frontend::DefNode
              method_name = String.new(member.name)
              is_class_method = if recv = member.receiver
                                  String.new(recv) == "self"
                                else
                                  false
                                end
              next unless is_class_method
              STDERR.puts "      [#{module_name}] Method #{idx}: #{method_name}" if ENV["HIR_DEBUG"]?
              STDERR.flush if ENV["HIR_DEBUG"]?
              lower_module_method(module_name, member)
            when CrystalV2::Compiler::Frontend::GetterNode
              next unless member.is_class?
              member.specs.each do |spec|
                generate_class_getter_method(module_name, spec, @arena)
              end
            when CrystalV2::Compiler::Frontend::SetterNode
              next unless member.is_class?
              member.specs.each do |spec|
                generate_class_setter_method(module_name, spec)
              end
            when CrystalV2::Compiler::Frontend::PropertyNode
              next unless member.is_class?
              member.specs.each do |spec|
                generate_class_getter_method(module_name, spec, @arena)
                generate_class_setter_method(module_name, spec)
              end
            when CrystalV2::Compiler::Frontend::ClassNode
              # Lower nested class with full name
              class_name = String.new(member.name)
              full_class_name = "#{module_name}::#{class_name}"
              if ENV.has_key?("DEBUG_NESTED_CLASS") && (module_name == "IO" || class_name.includes?("FileDescriptor"))
                STDERR.puts "[DEBUG_LOWER_MOD] lowering nested class: #{full_class_name}"
              end
              lower_class_with_name(member, full_class_name)
            when CrystalV2::Compiler::Frontend::ModuleNode
              # Recursively lower nested module
              nested_name = String.new(member.name)
              full_nested_name = "#{module_name}::#{nested_name}"
              lower_module_with_name(member, full_nested_name)
            when CrystalV2::Compiler::Frontend::CallNode
              lower_macro_call_in_module_body(module_name, member)
            end
          end
        ensure
          @current_class = old_class
          @pending_def_annotations = old_pending
        end
      end
    end

    private def lower_module_body_expr(module_name : String, expr_id : ExprId)
      return if expr_id.invalid?

      member = unwrap_visibility_member(@arena[expr_id])
      if !member.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode) &&
         !member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
        clear_pending_effect_annotations
      end
      case member
      when CrystalV2::Compiler::Frontend::BlockNode
        member.body.each do |child_id|
          lower_module_body_expr(module_name, child_id)
        end
      when CrystalV2::Compiler::Frontend::AnnotationNode
        remember_effect_annotation(member, @arena)
      when CrystalV2::Compiler::Frontend::DefNode
        is_class_method = if recv = member.receiver
                            String.new(recv) == "self"
                          else
                            false
                          end
        lower_module_method(module_name, member) if is_class_method
      when CrystalV2::Compiler::Frontend::GetterNode
        return unless member.is_class?
        member.specs.each do |spec|
          generate_class_getter_method(module_name, spec, @arena)
        end
      when CrystalV2::Compiler::Frontend::SetterNode
        return unless member.is_class?
        member.specs.each do |spec|
          generate_class_setter_method(module_name, spec)
        end
      when CrystalV2::Compiler::Frontend::PropertyNode
        return unless member.is_class?
        member.specs.each do |spec|
          generate_class_getter_method(module_name, spec, @arena)
          generate_class_setter_method(module_name, spec)
        end
      when CrystalV2::Compiler::Frontend::ClassNode
        class_name = String.new(member.name)
        full_class_name = "#{module_name}::#{class_name}"
        register_class_with_name(member, full_class_name)
        lower_class_with_name(member, full_class_name)
      when CrystalV2::Compiler::Frontend::ModuleNode
        nested_name = String.new(member.name)
        full_nested_name = "#{module_name}::#{nested_name}"
        register_module_with_name(member, full_nested_name)
        lower_module_with_name(member, full_nested_name)
      when CrystalV2::Compiler::Frontend::EnumNode
        enum_name = String.new(member.name)
        full_enum_name = "#{module_name}::#{enum_name}"
        register_enum_with_name(member, full_enum_name)
      when CrystalV2::Compiler::Frontend::CallNode
        lower_macro_call_in_module_body(module_name, member)
      end
    end

    private def lower_macro_call_in_module_body(
      module_name : String,
      node : CrystalV2::Compiler::Frontend::CallNode
    )
      callee_node = @arena[node.callee]
      return unless callee_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)

      method_name = String.new(callee_node.name)
      macro_lookup = lookup_macro_entry(method_name, module_name)
      return unless macro_lookup

      macro_entry, macro_key = macro_lookup
      macro_def, macro_arena = macro_entry
      expanded_id = expand_macro_expr(macro_def, macro_arena, node.args, node.named_args, node.block, macro_key)
      return if expanded_id.invalid?

      old_arena = @arena
      @arena = macro_arena
      begin
        lower_module_body_expr(module_name, expanded_id)
      ensure
        @arena = old_arena
      end
    end

    # Lower a module method (static function)
    private def lower_module_method(
      module_name : String,
      node : CrystalV2::Compiler::Frontend::DefNode,
      call_arg_types : Array(TypeRef)? = nil,
      call_arg_literals : Array(Bool)? = nil,
      full_name_override : String? = nil
    )
      # CRITICAL: Clear enum value tracking at start of each function.
      # ValueIds are local to each function's LoweringContext, so we must not carry over
      # mappings from previous functions.
      @enum_value_types.try(&.clear)

      method_name = String.new(node.name)
      base_name = "#{module_name}.#{method_name}"

      old_class = @current_class
      old_method = @current_method
      old_method_is_class = @current_method_is_class
      @current_class = module_name
      @current_method = method_name
      @current_method_is_class = true

      return_type = if rt = node.return_type
                      type_ref_for_name(String.new(rt))
                    else
                      TypeRef::VOID
                    end

      # Collect parameter types for name mangling
      param_infos = [] of Tuple(String, TypeRef)
      param_type_names = [] of String?  # Track type annotation names for enum detection
      param_literal_flags = [] of Bool
      param_types = [] of TypeRef
      has_block = false
      param_type_map = {} of String => TypeRef
      old_typeof_locals = @current_typeof_locals
      old_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = param_type_map
      @current_typeof_local_names = {} of String => String
      call_types = call_arg_types || [] of TypeRef
      call_literal_flags = call_arg_literals || [] of Bool
      if DebugHooks::ENABLED && base_name.ends_with?("#read_bytes")
        debug_hook(
          "method.callsite_literals",
          "name=#{base_name} types=#{call_types.map(&.id).join(",")} literals=#{call_literal_flags.join(",")}"
        )
      end
      common_numeric = common_numeric_type(call_types)
      call_index = 0
      splat_param_info_index : Int32? = nil
      splat_param_types_index : Int32? = nil
      splat_param_name : String? = nil

      if params = node.params
        params.each do |param|
          next if named_only_separator?(param)
          param_name = param.name.nil? ? "_" : String.new(param.name.not_nil!)
          type_ann_str : String? = nil
          param_type = if ta = param.type_annotation
                         type_ann_str = String.new(ta)
                         type_ref_for_name(type_ann_str)
                       elsif param.is_double_splat
                         type_ref_for_name("NamedTuple")
                       else
                         TypeRef::VOID
                       end
          if param_type == TypeRef::VOID && !param.is_block && !param.is_splat && !param.is_double_splat
            if call_index < call_types.size
              inferred = common_numeric || call_types[call_index]
              param_type = inferred if inferred != TypeRef::VOID
            end
          end
          if !param.is_block && !param.is_splat && !param.is_double_splat && call_index < call_types.size
            param_type = refine_param_type_from_call(param_type, call_types[call_index])
          end
          param_type_map[param_name] = param_type
          param_infos << {param_name, param_type}
          param_type_names << type_ann_str
          if ta = param.type_annotation
            update_typeof_local_name(param_name, String.new(ta))
          end
          param_literal = !param.is_block && !param.is_splat && !param.is_double_splat &&
                          call_index < call_literal_flags.size && call_literal_flags[call_index]
          if param.is_block
            has_block = true
          else
            if param.is_splat
              splat_param_info_index = param_infos.size - 1
              splat_param_types_index = param_types.size
              splat_param_name = param_name
            elsif !param.is_double_splat
              call_index += 1
            end
            param_types << param_type
          end
          param_literal_flags << param_literal
          if DebugHooks::ENABLED && base_name.ends_with?("#read_bytes")
            debug_hook(
              "param.literal",
              "name=#{base_name} param=#{param_name} literal=#{param_literal}"
            )
          end
        end
      end

      if splat_param_name
        splat_type = TypeRef::VOID
        if !call_types.empty?
          remaining = call_types[call_index..-1]? || [] of TypeRef
          splat_type = tuple_type_from_arg_types(remaining)
        end
        if splat_type == TypeRef::VOID
          if elem_type = param_type_map[splat_param_name.not_nil!]?
            if elem_type != TypeRef::VOID
              splat_type = tuple_type_from_arg_types([elem_type])
            end
          end
        end
        if splat_type != TypeRef::VOID
          param_type_map[splat_param_name.not_nil!] = splat_type
          if idx = splat_param_info_index
            param_infos[idx] = {splat_param_name.not_nil!, splat_type}
          end
          if idx = splat_param_types_index
            param_types[idx] = splat_type
          end
        end
      end

      # Mangle function name with parameter types
      full_name = full_name_override || function_full_name_for_def(base_name, param_types, node.params, has_block)

      register_pending_method_effects(full_name, param_types.size)

      func = @module.create_function(full_name, return_type)
      ctx = LoweringContext.new(func, @module, @arena)

      # Lower parameters (no self for module methods)
      param_infos.each_with_index do |(param_name, param_type), idx|
        hir_param = func.add_param(param_name, param_type)
        ctx.register_local(param_name, hir_param.id)
        ctx.register_type(hir_param.id, param_type)
        if param_literal_flags[idx]?
          ctx.mark_type_literal(hir_param.id)
        end
        if module_type_ref?(param_type)
          ctx.mark_type_literal(hir_param.id)
        end
        # Track enum types for predicate method resolution
        if type_name = param_type_names[idx]?
          track_enum_value(hir_param.id, type_name)
        end
      end

      # Lower body
      last_value : ValueId? = nil
      if body = node.body
        body.each do |expr_id|
          last_value = lower_expr(ctx, expr_id)
        end
      end

      # Infer return type from the last expression for unannotated module methods.
      if node.return_type.nil? && last_value
        inferred = ctx.type_of(last_value)
        if inferred != TypeRef::VOID && inferred != return_type
          return_type = inferred
          func.return_type = inferred
        end
      end

      register_function_type(full_name, return_type)

      @current_typeof_locals = old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names

      # Restore current class
      @current_class = old_class
      @current_method = old_method
      @current_method_is_class = old_method_is_class || false

      # Add implicit return if not already terminated
      # BUT don't add return after raise (which sets Unreachable terminator)
      block = ctx.get_block(ctx.current_block)
      block_has_raise = block.instructions.any? { |inst| inst.is_a?(Raise) }
      if block.terminator.is_a?(Unreachable) && !block_has_raise
        block.terminator = Return.new(last_value)
      end
    end

    # Register a class type and its methods (pass 1)
    def register_class(node : CrystalV2::Compiler::Frontend::ClassNode)
      class_name = String.new(node.name)
      if ENV.has_key?("DEBUG_NESTED_CLASS") && (class_name == "IO" || class_name.includes?("FileDescriptor"))
        STDERR.puts "[DEBUG_CLASS_REG] register_class called: #{class_name}"
      end
      register_class_with_name(node, class_name)
    end

    # Register a class with a specific name (for nested classes like Foo::Bar)
    def register_class_with_name(node : CrystalV2::Compiler::Frontend::ClassNode, class_name : String)
      class_name = resolve_class_name_for_definition(class_name)
      if ENV["DEBUG_STRING_CLASS"]? && class_name == "String"
        STDERR.puts "[STRING_CLASS_REG] class=#{class_name} span=#{node.span.start_line}-#{node.span.end_line}"
      end
      if ENV["DEBUG_LIBC_EXTERN"]? && class_name.ends_with?("DlInfo")
        STDERR.puts "[DEBUG_LIBC_EXTERN] register_class #{class_name}"
      end
      if ENV["DEBUG_RECORD_CLASS"]? && class_name.ends_with?("FileEntry")
        STDERR.puts "[DEBUG_RECORD_CLASS] class_name=#{class_name} current=#{@current_class || "(none)"}"
      end
      is_struct = node.is_struct == true

      # Check if this is a generic class (has type parameters)
      if type_params = node.type_params
        if type_params.size > 0
          # Store as generic template - don't create ClassInfo yet.
          # Keep the template with the LARGEST body as primary, but preserve reopenings
          # so additional methods (e.g., Range#bsearch) are not lost.
          new_body_size = node.body.try(&.size) || 0
          if ENV.has_key?("DEBUG_GENERIC_TEMPLATE")
            current_path = @paths_by_arena[@arena]? || "(unknown)"
            STDERR.puts "[GENERIC_TEMPLATE] #{class_name}: body_size=#{new_body_size} file=#{File.basename(current_path)}"
          end
          param_names = type_params.map { |p| String.new(p) }
          new_template = GenericClassTemplate.new(class_name, param_names, node, @arena, is_struct)

          if existing = @generic_templates[class_name]?
            existing_body_size = existing.node.body.try(&.size) || 0
            if new_body_size > existing_body_size
              (@generic_reopenings[class_name] ||= [] of GenericClassTemplate) << existing
              @generic_templates[class_name] = new_template
            else
              (@generic_reopenings[class_name] ||= [] of GenericClassTemplate) << new_template
            end
            invalidate_type_cache_for_namespace(class_name)
          else
            @generic_templates[class_name] = new_template
          end

          # Register nested types inside generic templates under the base namespace.
          if body = node.body
            body.each do |expr_id|
              member = unwrap_visibility_member(@arena[expr_id])
              case member
              when CrystalV2::Compiler::Frontend::ClassNode
                nested_name = String.new(member.name)
                full_nested_name = "#{class_name}::#{nested_name}"
                register_class_with_name(member, full_nested_name)
              when CrystalV2::Compiler::Frontend::EnumNode
                enum_name = String.new(member.name)
                full_enum_name = "#{class_name}::#{enum_name}"
                register_enum_with_name(member, full_enum_name)
              when CrystalV2::Compiler::Frontend::ModuleNode
                nested_name = String.new(member.name)
                full_nested_name = "#{class_name}::#{nested_name}"
                register_nested_module(member, full_nested_name)
              when CrystalV2::Compiler::Frontend::MacroDefNode
                register_macro(member, class_name)
              end
            end
            record_constants_in_body(class_name, body)
          end
          return  # Don't register as concrete class
        end
      end

      # Non-generic class - proceed with normal registration
      register_concrete_class(node, class_name, is_struct)
    end

    # Register a concrete (non-generic or specialized) class
    private def register_concrete_class(node : CrystalV2::Compiler::Frontend::ClassNode, class_name : String, is_struct : Bool)
      # Check if class already exists (class reopening)
      existing_info = @class_info[class_name]?
      mono_debug = ENV.has_key?("DEBUG_MONO") && (class_name.starts_with?("Hash(") || class_name.starts_with?("Set("))
      mono_start = Time.monotonic if mono_debug
      invalidate_type_cache_for_namespace(class_name) if existing_info

      # Collect instance variables and their types
      ivars = [] of IVarInfo
      class_vars = [] of ClassVarInfo
      # Struct has no type_id header (value type), class starts at 8 for header
      offset = is_struct ? 0 : 8

      # If class already exists, preserve existing ivars and class_vars
      if existing_info
        existing_info.ivars.each { |iv| ivars << iv.dup }
        existing_info.class_vars.each { |cv| class_vars << cv.dup }
        offset = existing_info.size
      end

      # Inheritance: copy parent ivars first (to preserve layout)
      # Only do this for new class definitions, not reopened classes
      parent_name : String? = nil
      if !existing_info && (super_name_slice = node.super_name)
        raw_parent = String.new(super_name_slice)
        old_class = @current_class
        @current_class = class_name
        parent_name = resolve_type_name_in_context(raw_parent)
        @current_class = old_class
        if parent_info = @class_info[parent_name]?
          # Copy all ivars from parent, preserving their offsets
          parent_info.ivars.each do |parent_ivar|
            ivars << parent_ivar.dup
          end
          # Start child ivars after parent ivars
          offset = parent_info.size
        end
      elsif existing_info
        parent_name = existing_info.parent_name
      end
      if parent_name.nil?
        parent_name = builtin_parent_for(class_name, is_struct)
      end

      type_kind = is_struct ? TypeKind::Struct : TypeKind::Class
      type_ref = if existing_info
                   existing_info.type_ref
                 else
                   # Check for primitive types - use well-known TypeRefs
                   case class_name
                   when "Bool"    then TypeRef::BOOL
                   when "Int8"    then TypeRef::INT8
                   when "Int16"   then TypeRef::INT16
                   when "Int32"   then TypeRef::INT32
                   when "Int64"   then TypeRef::INT64
                   when "Int128"  then TypeRef::INT128
                   when "UInt8"   then TypeRef::UINT8
                   when "UInt16"  then TypeRef::UINT16
                   when "UInt32"  then TypeRef::UINT32
                   when "UInt64"  then TypeRef::UINT64
                   when "UInt128" then TypeRef::UINT128
                   when "Float32" then TypeRef::FLOAT32
                   when "Float64" then TypeRef::FLOAT64
                   when "Char"    then TypeRef::CHAR
                   when "String"  then TypeRef::STRING
                   when "Symbol"  then TypeRef::SYMBOL
                   when "Nil"     then TypeRef::NIL
                   else
                     # For generic instantiations, reuse type_ref_for_name so the TypeRef id
                     # matches annotations and preserves Hash/Array kinds.
                     if class_name.includes?("(")
                       type_ref_for_name(class_name)
                     else
                       @module.intern_type(TypeDescriptor.new(type_kind, class_name))
                     end
                   end
                 end

      # Also find initialize to get constructor parameters
      init_capture = InitParamsCapture.new
      init_params = init_capture.params

      if body = node.body
        specialized_class = class_name.includes?("(")
        if mono_debug
          STDERR.puts "[MONO] register_concrete_class #{class_name} body_size=#{body.size}"
        end
        old_suppress = @suppress_monomorphization
        @suppress_monomorphization = @suppress_monomorphization || specialized_class
        # PASS 0: Register nested types first so method signatures and bodies can resolve them
        # (e.g., Dir::EntryIterator used as `EntryIterator` inside Dir).
        pass0_start = Time.monotonic if mono_debug
        nested_prefix = if info = split_generic_base_and_args(class_name)
                          info[:base]
                        else
                          class_name
                        end
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          case member
          when CrystalV2::Compiler::Frontend::ClassNode
            nested_name = String.new(member.name)
            full_nested_name = "#{nested_prefix}::#{nested_name}"
            register_class_with_name(member, full_nested_name)
          when CrystalV2::Compiler::Frontend::EnumNode
            enum_name = String.new(member.name)
            full_enum_name = "#{nested_prefix}::#{enum_name}"
            register_enum_with_name(member, full_enum_name)
          when CrystalV2::Compiler::Frontend::ModuleNode
            nested_name = String.new(member.name)
            full_nested_name = "#{nested_prefix}::#{nested_name}"
            register_nested_module(member, full_nested_name)
          when CrystalV2::Compiler::Frontend::MacroDefNode
            register_macro(member, nested_prefix)
          end
        end
        if mono_debug && pass0_start
          elapsed = (Time.monotonic - pass0_start).total_milliseconds
          STDERR.puts "[MONO] #{class_name} pass0 nested types #{elapsed.round(1)}ms"
        end

        # Set current class context BEFORE collecting method signatures
        # so type lookups resolve in the correct namespace
        old_class = @current_class
        @current_class = class_name
        record_constants_in_body(class_name, body)
        # Seed provisional class info so return-type inference can see ivars
        # collected during registration (initialize assignments, ivar decls, etc.).
        @class_info[class_name] = ClassInfo.new(
          class_name,
          type_ref,
          ivars,
          class_vars,
          offset,
          is_struct,
          parent_name
        )

        defined_start = Time.monotonic if mono_debug
        if ENV.has_key?("DEBUG_TYPE_RESOLVE") && class_name == "IO"
          STDERR.puts "[DEBUG_IO] About to collect_defined_instance_method_full_names for IO"
          STDERR.puts "[DEBUG_IO]   enum_info Seek keys: #{@enum_info.try(&.keys.select { |k| k.includes?("Seek") }) || "nil"}"
        end
        defined_instance_method_full_names = collect_defined_instance_method_full_names(class_name, body)
        defined_class_method_full_names = collect_defined_class_method_full_names(class_name, body)
        if mono_debug && defined_start
          elapsed = (Time.monotonic - defined_start).total_milliseconds
          STDERR.puts "[MONO] #{class_name} collect_defined_instance_methods #{elapsed.round(1)}ms"
        end
        include_nodes = [] of CrystalV2::Compiler::Frontend::IncludeNode
        extend_nodes = [] of CrystalV2::Compiler::Frontend::ExtendNode

        begin
        body_start = Time.monotonic if mono_debug
        body.each do |expr_id|
          member = unwrap_visibility_member(@arena[expr_id])
          member_start = mono_debug ? Time.monotonic : nil
          return_elapsed = nil
          param_elapsed = nil
          yield_elapsed = nil
          case member
          when CrystalV2::Compiler::Frontend::IncludeNode
            include_nodes << member
          when CrystalV2::Compiler::Frontend::ExtendNode
            extend_nodes << member
          when CrystalV2::Compiler::Frontend::InstanceVarDeclNode
            # Instance variable declaration: @value : Int32
            ivar_name = String.new(member.name)
            ivar_type = type_ref_for_name(String.new(member.type))
            ivars << IVarInfo.new(ivar_name, ivar_type, offset)
            offset += type_size(ivar_type)

          when CrystalV2::Compiler::Frontend::TypeDeclarationNode
            # Lib struct field declaration: value : Type
            if is_struct
              field_name = String.new(member.name)
              ivar_name = field_name.starts_with?("@") ? field_name : "@#{field_name}"
              ivar_type = type_ref_for_name(String.new(member.declared_type))
              unless ivars.any? { |iv| iv.name == ivar_name }
                ivars << IVarInfo.new(ivar_name, ivar_type, offset)
                offset += type_size(ivar_type)
              end
            end

          when CrystalV2::Compiler::Frontend::ClassVarDeclNode
            # Class variable declaration: @@total : Int32 = 0
            # Name includes @@ prefix, strip it
            raw_name = String.new(member.name)
            cvar_name = raw_name.lstrip('@')
            cvar_type = type_ref_for_name(String.new(member.type))
            # Get initial value if present (only supporting literal integers for now)
            initial_value : Int64? = nil
            if val_id = member.value
              val_node = @arena[val_id]
              if val_node.is_a?(CrystalV2::Compiler::Frontend::NumberNode)
                # Parse the number from its text representation
                num_str = String.new(val_node.value)
                initial_value = num_str.to_i64?
              end
            end
            class_vars << ClassVarInfo.new(cvar_name, cvar_type, initial_value)

          when CrystalV2::Compiler::Frontend::DefNode
            # Register method signature
            method_name = String.new(member.name)
            if ENV["DEBUG_TO_S_CLASS_REG"]? && class_name.includes?("String") && method_name == "to_s"
              span = member.span
              STDERR.puts "[STRING_TO_S_REG] class=#{class_name} span=#{span.start_line}-#{span.end_line} return_type=#{member.return_type ? String.new(member.return_type.not_nil!) : "(nil)"}"
            end
            # Check if this is a class method (def self.method) or instance method (def method)
            is_class_method = if recv = member.receiver
                                String.new(recv) == "self"
                              else
                                false
                              end
            # Use . for class methods, # for instance methods
            base_name = if is_class_method
                          "#{class_name}.#{method_name}"
                        else
                          "#{class_name}##{method_name}"
                        end
            return_start = mono_debug ? Time.monotonic : nil
            type_literal_name = infer_type_literal_return_name_from_body(member, class_name)
            if method_name == "backend_class" &&
               (class_name == "Crystal::EventLoop" || class_name == "EventLoop")
              type_literal_name = preferred_event_loop_backend_class || type_literal_name
            end
            enum_return_name : String? = nil
            return_type = if rt = member.return_type
                            rt_name = String.new(rt)
                            resolved_rt_name = resolve_type_name_in_context(rt_name)
                            enum_return_name = resolve_enum_name(resolved_rt_name)
                            if ENV["DEBUG_ENUM_RETURN"]? && class_name == "File::Info" && method_name == "type"
                              STDERR.puts "[DEBUG_ENUM_RETURN] class=#{class_name} rt=#{rt_name} resolved=#{resolved_rt_name} enum=#{enum_return_name || "(nil)"}"
                            end
                            inferred = module_like_type_name?(rt_name) ? infer_concrete_return_type_from_body(member, class_name) : nil
                            resolved = inferred || type_ref_for_name(rt_name)
                            if resolved == TypeRef::VOID && method_name.ends_with?("?")
                              self_type = type_ref_for_name(class_name)
                              resolved = infer_unannotated_query_return_type(method_name, self_type) || resolved
                            end
                            resolved
                          elsif method_name.ends_with?("?")
                            self_type = type_ref_for_name(class_name)
                            inferred = infer_unannotated_query_return_type(method_name, self_type)
                            inferred ||= infer_concrete_return_type_from_body(member, class_name)
                            inferred || TypeRef::BOOL
                          else
            # Try to infer return type from getter-style methods (single ivar access).
            inferred = infer_getter_return_type(member, ivars)
            inferred = infer_concrete_return_type_from_body(member, class_name) if inferred.nil?
            inferred ||= infer_unannotated_search_return_type(method_name, type_ref_for_name(class_name))
            inferred || TypeRef::VOID
          end
            if type_literal_name
              literal_ref = type_ref_for_name(type_literal_name)
              if return_type == TypeRef::VOID || return_type == TypeRef::NIL
                return_type = literal_ref if literal_ref != TypeRef::VOID
              end
            end
            return_elapsed = return_start ? (Time.monotonic - return_start).total_milliseconds : nil
            # Collect parameter types for mangling
            method_param_types = [] of TypeRef
            has_block = false
            param_start = mono_debug ? Time.monotonic : nil
            if params = member.params
              params.each do |param|
                next if named_only_separator?(param)
                if param.is_block
                  has_block = true
                  next
                end
                param_type = if ta = param.type_annotation
                               type_ref_for_name(String.new(ta))
                             elsif param.is_double_splat
                               type_ref_for_name("NamedTuple")
                             else
                               TypeRef::VOID
                             end
                method_param_types << param_type
              end
            end
            param_elapsed = param_start ? (Time.monotonic - param_start).total_milliseconds : nil
            full_name = function_full_name_for_def(base_name, method_param_types, member.params, has_block)
            if type_literal_name
              literal_ref = type_ref_for_name(type_literal_name)
              if literal_ref != TypeRef::VOID
                record_type_literal_return(full_name, base_name)
              end
            end
            if enum_return_name
              @function_enum_return_names[full_name] = enum_return_name
              @function_enum_return_names[base_name] = enum_return_name
            end
            if ENV.has_key?("DEBUG_NESTED_CLASS") && (class_name.includes?("FileDescriptor") || class_name.includes?("EventLoop"))
              STDERR.puts "[DEBUG_METHOD_REG] #{class_name}: #{method_name} -> #{full_name} (class_method=#{is_class_method})"
            end
            register_function_type(full_name, return_type)
            @function_defs[full_name] = member
            @function_def_arenas[full_name] = @arena

            # Track yield-functions for inline expansion.
            # Note: MIR lowering removes yield-containing functions (inline-only), so we must inline
            # them at call sites. We key by both base and mangled names so resolution can find them.
            yield_start = mono_debug ? Time.monotonic : nil
            if body = member.body
              if contains_yield?(body)
                @yield_functions.add(full_name)
                debug_hook("yield.register", full_name)
                unless @function_defs.has_key?(base_name)
                  @function_defs[base_name] = member
                  @function_def_arenas[base_name] = @arena
                end
                @function_defs[full_name] = member
                @function_def_arenas[full_name] = @arena
              end
            end
            yield_elapsed = yield_start ? (Time.monotonic - yield_start).total_milliseconds : nil

            # Capture initialize parameters for new()
            # Also extract ivars from shorthand: def initialize(@value : T)
            # Note: Only capture from FIRST initialize (for multiple overloads, each gets its own mangled name)
            if method_name == "initialize" && init_params.empty?
              if params = member.params
                new_params = capture_initialize_params(params, ivars, pointerof(offset))
                init_params.clear
                init_params.concat(new_params)
                init_capture.source = :class
              end
            end
            if method_name == "initialize"
              if body = member.body
                infer_ivars_from_body(body, ivars, pointerof(offset))
              end
            end

          when CrystalV2::Compiler::Frontend::MacroIfNode
            process_macro_if_in_class(member, class_name, ivars, pointerof(offset))
          when CrystalV2::Compiler::Frontend::MacroForNode
            process_macro_for_in_class(member, class_name, ivars, pointerof(offset))
          when CrystalV2::Compiler::Frontend::MacroLiteralNode
            process_macro_literal_in_class(member, class_name, ivars, pointerof(offset))
          when CrystalV2::Compiler::Frontend::CallNode
            callee = @arena[member.callee]
            if callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
              method_name = String.new(callee.name)
              if ENV["DEBUG_CLASS_BODY_CALLS"]? && class_name.includes?("LineNumbers")
                STDERR.puts "[DEBUG_CLASS_BODY_CALLS] #{class_name} call=#{method_name}"
              end
              if macro_lookup = lookup_macro_entry(method_name, class_name)
                macro_entry, macro_key = macro_lookup
                macro_def, macro_arena = macro_entry
                if macro_def_maybe_defines_type?(macro_def, macro_arena)
                  if ENV["DEBUG_MACRO_TYPE_REG"]?
                    STDERR.puts "[DEBUG_MACRO_TYPE_REG] expand name=#{method_name} in #{class_name}"
                  end
                  expanded_id = expand_macro_expr(macro_def, macro_arena, member.args, member.named_args, member.block, macro_key)
                  unless expanded_id.invalid?
                    old_arena = @arena
                    @arena = macro_arena
                    begin
                      register_nested_types_from_macro_expansion(class_name, expanded_id)
                    ensure
                      @arena = old_arena
                    end
                  end
                end
              end
            end

          when CrystalV2::Compiler::Frontend::GetterNode
            # Getter declarations: getter name : Type
            # Creates @name ivar and def name; @name; end method
            if member.is_class?
              member.specs.each do |spec|
                register_class_accessor_entry(class_name, spec, :getter)
              end
            else
              specs = member.specs
              specs.each do |spec|
                storage_name = accessor_storage_name(spec)
                getter_name = accessor_method_name(spec)
                ivar_name = "@#{storage_name}"
                ivar_type = if ta = spec.type_annotation
                              type_ref_for_name(String.new(ta))
                            elsif spec.predicate
                              TypeRef::BOOL
                            elsif default_value = spec.default_value
                              infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                            else
                              TypeRef::VOID
                            end
                # Register ivar if not already declared
                unless ivars.any? { |iv| iv.name == ivar_name }
                  ivars << IVarInfo.new(ivar_name, ivar_type, offset)
                  offset += type_size(ivar_type)
                end
                # Register getter method: def name : Type
                getter_base = "#{class_name}##{getter_name}"
                full_name = mangle_function_name(getter_base, [] of TypeRef)
                register_function_type(full_name, ivar_type)
              end
            end

          when CrystalV2::Compiler::Frontend::SetterNode
            # Setter declarations: setter name : Type
            # Creates @name ivar and def name=(value : Type); @name = value; end
            if member.is_class?
              member.specs.each do |spec|
                register_class_accessor_entry(class_name, spec, :setter)
              end
            else
              specs = member.specs
              specs.each do |spec|
                storage_name = accessor_storage_name(spec)
                ivar_name = "@#{storage_name}"
                ivar_type = if ta = spec.type_annotation
                              type_ref_for_name(String.new(ta))
                            elsif spec.predicate
                              TypeRef::BOOL
                            elsif default_value = spec.default_value
                              infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                            else
                              TypeRef::VOID
                            end
                # Register ivar if not already declared
                unless ivars.any? { |iv| iv.name == ivar_name }
                  ivars << IVarInfo.new(ivar_name, ivar_type, offset)
                  offset += type_size(ivar_type)
                end
                # Register setter method: def name=(value : Type) : Type
                setter_name = "#{class_name}##{storage_name}="
                full_name = mangle_function_name(setter_name, [ivar_type])
                register_function_type(full_name, ivar_type)
              end
            end

          when CrystalV2::Compiler::Frontend::PropertyNode
            # Property declarations: property name : Type
            # Creates both getter and setter
            if member.is_class?
              member.specs.each do |spec|
                register_class_accessor_entry(class_name, spec, :getter)
                register_class_accessor_entry(class_name, spec, :setter)
              end
            else
              specs = member.specs
              specs.each do |spec|
                storage_name = accessor_storage_name(spec)
                getter_name = accessor_method_name(spec)
                ivar_name = "@#{storage_name}"
                ivar_type = if ta = spec.type_annotation
                              type_ref_for_name(String.new(ta))
                            elsif spec.predicate
                              TypeRef::BOOL
                            elsif default_value = spec.default_value
                              infer_type_from_expr(default_value, class_name) || TypeRef::VOID
                            else
                              TypeRef::VOID
                            end
                # Register ivar if not already declared
                unless ivars.any? { |iv| iv.name == ivar_name }
                  ivars << IVarInfo.new(ivar_name, ivar_type, offset)
                  offset += type_size(ivar_type)
                end
                # Register getter method
                getter_base = "#{class_name}##{getter_name}"
                getter_full = mangle_function_name(getter_base, [] of TypeRef)
                register_function_type(getter_full, ivar_type)
                # Register setter method
                setter_name = "#{class_name}##{storage_name}="
                setter_full = mangle_function_name(setter_name, [ivar_type])
                register_function_type(setter_full, ivar_type)
              end
            end

          when CrystalV2::Compiler::Frontend::AssignNode
            # Handle ivar assignments at class body level: @vec = SomeType.new
            target_node = @arena[member.target]
            if target_node.is_a?(CrystalV2::Compiler::Frontend::InstanceVarNode)
              ivar_name = String.new(target_node.name)
              # Infer type from the assigned value
              value_node = @arena[member.value]
              if ENV.has_key?("DEBUG_IVAR_REG")
                STDERR.puts "[IVAR_REG] #{class_name}##{ivar_name} value_node=#{value_node.class}"
              end
              ivar_type = infer_type_from_class_ivar_assign(value_node)
              if ENV.has_key?("DEBUG_IVAR_REG")
                STDERR.puts "[IVAR_REG] #{class_name}##{ivar_name} inferred type=#{ivar_type.id}"
              end
              unless ivars.any? { |iv| iv.name == ivar_name }
                ivars << IVarInfo.new(ivar_name, ivar_type, offset)
                offset += type_size(ivar_type)
              end
            elsif target_node.is_a?(CrystalV2::Compiler::Frontend::ClassVarNode)
              raw_name = String.new(target_node.name)
              cvar_name = raw_name.lstrip('@')
              value_node = @arena[member.value]
              cvar_type = infer_type_from_class_ivar_assign(value_node)
              if idx = class_vars.index { |cv| cv.name == cvar_name }
                if class_vars[idx].type == TypeRef::VOID && cvar_type != TypeRef::VOID
                  class_vars[idx] = ClassVarInfo.new(cvar_name, cvar_type, class_vars[idx].initial_value)
                end
              else
                class_vars << ClassVarInfo.new(cvar_name, cvar_type, nil)
              end
            end
          when CrystalV2::Compiler::Frontend::AliasNode
            # Type alias within class: alias Handle = Int32
            alias_name = String.new(member.name)
            target_name = resolve_alias_target(String.new(member.value))
            full_alias_name = "#{class_name}::#{alias_name}"
            register_type_alias(full_alias_name, target_name)
            # Also register short name for local resolution within class
            register_type_alias(alias_name, target_name)
          end
          if mono_debug && member_start
            elapsed = (Time.monotonic - member_start).total_milliseconds
            if elapsed > 50.0
              detail = case member
                       when CrystalV2::Compiler::Frontend::DefNode
                         return_ms = return_elapsed ? return_elapsed.round(1) : 0.0
                         param_ms = param_elapsed ? param_elapsed.round(1) : 0.0
                         yield_ms = yield_elapsed ? yield_elapsed.round(1) : 0.0
                         "def #{String.new(member.name)} (return=#{return_ms}ms params=#{param_ms}ms yield=#{yield_ms}ms)"
                       when CrystalV2::Compiler::Frontend::IncludeNode
                         "include"
                       when CrystalV2::Compiler::Frontend::InstanceVarDeclNode
                         "ivar #{String.new(member.name)}"
                       when CrystalV2::Compiler::Frontend::ClassVarDeclNode
                         "cvar #{String.new(member.name)}"
                       else
                         member.class.to_s
                       end
              STDERR.puts "[MONO] #{class_name} slow member #{detail} #{elapsed.round(1)}ms"
            end
          end
        end
        if mono_debug && body_start
          elapsed = (Time.monotonic - body_start).total_milliseconds
          STDERR.puts "[MONO] #{class_name} body scan #{elapsed.round(1)}ms"
        end

        # Expand module mixins: register included module instance method signatures.
        include_start = Time.monotonic if mono_debug
        visited_modules = Set(String).new
        visited_extends = Set(String).new
        include_nodes.each do |inc|
          offset = register_module_instance_methods_for(
            class_name,
            inc,
            defined_instance_method_full_names,
            defined_class_method_full_names,
            visited_modules,
            visited_extends,
            ivars,
            offset,
            is_struct,
            init_capture
          )
        end
        extend_nodes.each do |ext|
          register_module_class_methods_for(
            class_name,
            ext.target,
            defined_class_method_full_names,
            visited_extends
          )
        end
        if mono_debug && include_start
          elapsed = (Time.monotonic - include_start).total_milliseconds
          STDERR.puts "[MONO] #{class_name} include expansion #{elapsed.round(1)}ms"
        end
        ensure
          @current_class = old_class
          @suppress_monomorphization = old_suppress
        end
        if mono_debug && mono_start
          elapsed = (Time.monotonic - mono_start).total_milliseconds
          STDERR.puts "[MONO] register_concrete_class #{class_name} total #{elapsed.round(1)}ms"
        end
      end

      @class_info[class_name] = ClassInfo.new(class_name, type_ref, ivars, class_vars, offset, is_struct, parent_name)
      if ENV.has_key?("DEBUG_CLASS_PARENTS") && (class_name == "Base" || class_name == "Child")
        STDERR.puts "[CLASS_PARENT] class=#{class_name} parent=#{parent_name || "nil"}"
      end
      @module.register_class_parent(class_name, parent_name)
      if ENV.has_key?("DEBUG_CLASS_INFO") &&
         (class_name == "Crystal::MachO" || class_name == "IO" || class_name.includes?("FileDescriptor"))
        ivar_dump = ivars.map { |iv| "#{iv.name}:#{get_type_name_from_ref(iv.type)}@#{iv.offset}" }.join(", ")
        STDERR.puts "[CLASS_INFO] #{class_name} ivars=[#{ivar_dump}] size=#{offset}"
      end
      if short_name = class_name.split("::").last?
        (@short_type_index[short_name] ||= Set(String).new) << class_name
      end
      # DEBUG: track type_ref.id for problematic types
      if ENV.has_key?("DEBUG_TYPE_ID") &&
         (class_name.includes?("Sequence") || class_name.includes?("LoadCommand") ||
          class_name.includes?("Section") || class_name.includes?("Seek"))
        STDERR.puts "[TYPE_ID] class_info[#{class_name}] type_ref.id=#{type_ref.id}"
      end
      debug_hook_class_register(class_name, parent_name)

      # Store initialize params for allocator generation
      # Preserve existing init params on class reopening; otherwise inherit from parent.
      @init_params ||= {} of String => Array({String, TypeRef})
      if init_params.empty?
        if existing_params = @init_params.not_nil![class_name]?
          init_params = existing_params
        elsif parent_name
          if parent_init_params = @init_params.not_nil![parent_name]?
            init_params = parent_init_params
          end
        end
      end
      @init_params.not_nil![class_name] = init_params

      # Register "new" allocator function
      register_function_type("#{class_name}.new", type_ref)
    end

    # Flush all pending monomorphizations (call after all templates are registered)
    def flush_pending_monomorphizations
      @defer_monomorphization = false
      pending = @pending_monomorphizations.dup
      @pending_monomorphizations.clear
      return unless @eager_monomorphization

      if ENV.has_key?("DEBUG_MONO")
        STDERR.puts "[MONO] Flush pending monomorphizations: #{pending.size}"
      end

      pending.each_with_index do |(base_name, type_args, specialized_name), idx|
        if ENV.has_key?("DEBUG_MONO") && (idx % 100 == 0 || idx == pending.size - 1)
          STDERR.puts "[MONO] #{idx + 1}/#{pending.size}: #{specialized_name}"
        end
        next if @monomorphized.includes?(specialized_name)
        unless concrete_type_args?(type_args)
          STDERR.puts "[MONO] Skipping unresolved: #{specialized_name}" if ENV.has_key?("DEBUG_MONO")
          next
        end
        monomorphize_generic_class(base_name, type_args, specialized_name)
      end
    end

    private def concrete_type_args?(type_args : Array(String)) : Bool
      # NOTE: unions like `String | Nil` are concrete and must be allowed here.
      unresolved_token_re = /(?:^|[^A-Za-z0-9_:])(K2|V2|K|V|T|U|L|W|self)(?:$|[^A-Za-z0-9_:])/
      # Bare generic names without type params (like Array, Hash) are not concrete
      bare_generic_names = {"Array", "Hash", "Set", "Slice", "Pointer", "StaticArray", "Iterator", "Enumerable"}
      type_args.none? do |arg|
        # typeof(...) in type positions is not fully resolved during bootstrap.
        next true if arg.includes?("typeof(")
        # `self` as a standalone type arg is unresolved
        next true if arg == "self"
        # NoReturn type args are effectively placeholders; skip monomorphization.
        next true if arg == "NoReturn"
        # Bare generic class names without type params are not concrete
        next true if bare_generic_names.includes?(arg)
        # Detect remaining generic placeholders as standalone tokens (avoid false positives like "ValueId").
        arg.matches?(unresolved_token_re)
      end
    end

    # Monomorphize a generic class: create specialized version with concrete types
    private def monomorphize_generic_class(base_name : String, type_args : Array(String), specialized_name : String)
      template = @generic_templates[base_name]?
      return unless template

      # Double-check inside the method (belt and suspenders)
      if @monomorphized.includes?(specialized_name)
        debug_hook("mono.skip", "name=#{specialized_name} reason=already_monomorphized")
        return
      end

      # Skip if type_args contain unresolved type parameters.
      if !concrete_type_args?(type_args)
        if ENV.has_key?("DEBUG_MONO")
          STDERR.puts "[MONO] Skipping unresolved: #{specialized_name}"
        end
        debug_hook("mono.skip", "name=#{specialized_name} reason=unresolved_type_args")
        return
      end

      # Mark as monomorphized BEFORE processing to prevent infinite recursion
      # (e.g., Array(String) method calls something that creates Array(String) again)
      @monomorphized.add(specialized_name)
      debug_hook("mono.start", "base=#{base_name} name=#{specialized_name} args=#{type_args}")
      mono_start = nil
      if ENV.has_key?("DEBUG_MONO")
        mono_start = Time.monotonic
        STDERR.puts "[MONO] start #{specialized_name}"
      end

      # Check arity matches
      if template.type_params.size != type_args.size
        raise "Generic #{base_name} expects #{template.type_params.size} type args, got #{type_args.size}"
      end

      # Set up type parameter substitutions: T => Int32, etc.
      old_map = @type_param_map.dup
      template.type_params.each_with_index do |param, i|
        @type_param_map[param] = type_args[i]
      end

      # Switch to the template's arena for AST node lookup
      old_arena = @arena
      @arena = template.arena

      # Register the specialized class using the template's AST node
      # The type_ref_for_name calls will now substitute T => Int32
      register_concrete_class(template.node, specialized_name, template.is_struct)

      if reopenings = @generic_reopenings[base_name]?
        reopenings.each do |reopen|
          @arena = reopen.arena
          register_concrete_class(reopen.node, specialized_name, reopen.is_struct)
        end
      end

      if mono_start && ENV.has_key?("DEBUG_MONO")
        elapsed_ms = (Time.monotonic - mono_start).total_milliseconds
        STDERR.puts "[MONO] done #{specialized_name} in #{elapsed_ms.round(1)}ms"
      end

      # Lowering bodies for monomorphized classes is expensive on prelude.
      # Keep it lazy unless explicitly enabled.
      if @eager_monomorphization
        if class_info = @class_info[specialized_name]?
          # Set current class for ivar lookup
          old_class = @current_class
          @current_class = specialized_name

          generate_allocator(specialized_name, class_info)

          # Lower methods with type substitutions across all template bodies.
          templates = [template] of GenericClassTemplate
          if reopenings = @generic_reopenings[base_name]?
            templates.concat(reopenings)
          end
          templates.each do |tmpl|
            @arena = tmpl.arena
            if body = tmpl.node.body
              body.each do |expr_id|
                member = @arena[expr_id]
                case member
                when CrystalV2::Compiler::Frontend::DefNode
                  lower_method(specialized_name, class_info, member)
                when CrystalV2::Compiler::Frontend::GetterNode
                  # Generate synthetic getter methods
                  member.specs.each do |spec|
                    generate_getter_method(specialized_name, class_info, spec)
                  end
                when CrystalV2::Compiler::Frontend::SetterNode
                  member.specs.each do |spec|
                    generate_setter_method(specialized_name, class_info, spec)
                  end
                when CrystalV2::Compiler::Frontend::PropertyNode
                  # Generate both getter and setter methods
                  member.specs.each do |spec|
                    generate_getter_method(specialized_name, class_info, spec)
                    generate_setter_method(specialized_name, class_info, spec)
                  end
                end
              end
            end
          end

          @current_class = old_class
        end
      end

      debug_hook("mono.done", "base=#{base_name} name=#{specialized_name}")

      # Restore arena and type param map
      @arena = old_arena
      @type_param_map = old_map
      @monomorphized.add(specialized_name)
    end

    # Lower a class and all its methods (pass 3)
    def lower_class(node : CrystalV2::Compiler::Frontend::ClassNode)
      class_name = String.new(node.name)
      lower_class_with_name(node, class_name)
    end

    # Lower a class with a specific name (for nested classes like Foo::Bar)
    def lower_class_with_name(node : CrystalV2::Compiler::Frontend::ClassNode, class_name : String)
      # Skip generic class templates - they're lowered on-demand during monomorphization
      if @generic_templates.has_key?(class_name)
        return
      end

      class_info = @class_info[class_name]? || return
      old_class = @current_class
      old_pending = @pending_def_annotations
      @current_class = class_name
      @pending_def_annotations = [] of Tuple(CrystalV2::Compiler::Frontend::AnnotationNode, CrystalV2::Compiler::Frontend::ArenaLike)

      # Generate allocator function: ClassName.new
      generate_allocator(class_name, class_info)

      begin
        # Lower each method
        if body = node.body
          if ENV["DEBUG_SEQ_LOWER"]? && class_name.includes?("LineNumbers")
            STDERR.puts "[DEBUG_SEQ_LOWER] class=#{class_name} body_size=#{body.size}"
            body.each do |expr_id|
              member_dbg = unwrap_visibility_member(@arena[expr_id])
              label = member_dbg.class.to_s.split("::").last
              if member_dbg.is_a?(CrystalV2::Compiler::Frontend::CallNode)
                callee_dbg = @arena[member_dbg.callee]
                if callee_dbg.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
                  label += " callee=#{String.new(callee_dbg.name)}"
                end
              end
              STDERR.puts "[DEBUG_SEQ_LOWER]   member=#{label}"
            end
          end
          # Lower nested types first (classes/structs/modules inside the class body).
          # These can be referenced unqualified from within the class (e.g., `EntryIterator.new` inside `Dir`).
          nested_prefix = if info = split_generic_base_and_args(class_name)
                            info[:base]
                          else
                            class_name
                          end
          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            case member
            when CrystalV2::Compiler::Frontend::ClassNode
              nested_name = String.new(member.name)
              lower_class_with_name(member, "#{nested_prefix}::#{nested_name}")
            when CrystalV2::Compiler::Frontend::ModuleNode
              nested_name = String.new(member.name)
              lower_module_with_name(member, "#{nested_prefix}::#{nested_name}")
            end
          end

          defined_full_names = collect_defined_instance_method_full_names(class_name, body)
          include_nodes = [] of CrystalV2::Compiler::Frontend::IncludeNode

          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            include_nodes << member if member.is_a?(CrystalV2::Compiler::Frontend::IncludeNode)
          end

          visited_modules = Set(String).new
          include_nodes.each do |inc|
            lower_module_instance_methods_for(class_name, class_info, inc, defined_full_names, visited_modules)
          end

          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            if member.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode)
              remember_effect_annotation(member, @arena)
              next
            elsif !member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
              clear_pending_effect_annotations
            end
            case member
            when CrystalV2::Compiler::Frontend::IncludeNode
              # Handled above via mixin expansion.
            when CrystalV2::Compiler::Frontend::DefNode
              method_name = String.new(member.name)
              is_class_method = if recv = member.receiver
                                  String.new(recv) == "self"
                                else
                                  false
                                end
              base_name = is_class_method ? "#{class_name}.#{method_name}" : "#{class_name}##{method_name}"
              param_types = [] of TypeRef
              has_block = false
              if params = member.params
                params.each do |param|
                  next if named_only_separator?(param)
                  if param.is_block
                    has_block = true
                    next
                  end
                  param_type = if ta = param.type_annotation
                                 type_ref_for_name(String.new(ta))
                               elsif param.is_double_splat
                                 type_ref_for_name("NamedTuple")
                               else
                                 TypeRef::VOID
                               end
                  param_types << param_type
                end
              end
              full_name = function_full_name_for_def(base_name, param_types, member.params, has_block)
              callsite_args = pending_callsite_args_for_def(member, base_name, full_name)
              call_arg_types = callsite_args ? callsite_args.types : nil
              call_arg_literals = callsite_args ? callsite_args.literals : nil
              lower_method(class_name, class_info, member, call_arg_types, call_arg_literals)
              add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
            when CrystalV2::Compiler::Frontend::GetterNode
              # Generate synthetic getter methods
              if member.is_class?
                member.specs.each do |spec|
                  generate_class_getter_method(class_name, spec, @arena)
                end
              else
                member.specs.each do |spec|
                  generate_getter_method(class_name, class_info, spec)
                end
              end
              add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
            when CrystalV2::Compiler::Frontend::SetterNode
              # Generate synthetic setter methods
              if member.is_class?
                member.specs.each do |spec|
                  generate_class_setter_method(class_name, spec)
                end
              else
                member.specs.each do |spec|
                  generate_setter_method(class_name, class_info, spec)
                end
              end
              add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
            when CrystalV2::Compiler::Frontend::PropertyNode
              # Generate both getter and setter methods
              if member.is_class?
                member.specs.each do |spec|
                  generate_class_getter_method(class_name, spec, @arena)
                  generate_class_setter_method(class_name, spec)
                end
              else
                member.specs.each do |spec|
                  generate_getter_method(class_name, class_info, spec)
                  generate_setter_method(class_name, class_info, spec)
                end
              end
              add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
            when CrystalV2::Compiler::Frontend::CallNode
              if ENV["DEBUG_RECORD_LOWER"]?
                callee = @arena[member.callee]
                if callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
                   String.new(callee.name) == "record"
                  STDERR.puts "[DEBUG_RECORD_LOWER] class=#{class_name}"
                end
              end
              lower_macro_call_in_class_body(class_name, class_info, member, defined_full_names, visited_modules)
            end
          end
        end
      ensure
        @current_class = old_class
        @pending_def_annotations = old_pending
      end
    end

    private def lower_class_body_expr(
      class_name : String,
      class_info : ClassInfo,
      expr_id : ExprId,
      defined_full_names : Set(String),
      visited_modules : Set(String)
    )
      return if expr_id.invalid?

      member = unwrap_visibility_member(@arena[expr_id])
      case member
      when CrystalV2::Compiler::Frontend::AnnotationNode
        remember_effect_annotation(member, @arena)
      when CrystalV2::Compiler::Frontend::DefNode
        lower_method(class_name, class_info, member)
        add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
      when CrystalV2::Compiler::Frontend::BlockNode
        member.body.each do |child_id|
          lower_class_body_expr(class_name, class_info, child_id, defined_full_names, visited_modules)
        end
      when CrystalV2::Compiler::Frontend::IncludeNode
        lower_module_instance_methods_for(class_name, class_info, member, defined_full_names, visited_modules)
      when CrystalV2::Compiler::Frontend::ExtendNode
        visited_extends = Set(String).new
        lower_module_class_methods_for(class_name, class_info, member.target, visited_extends)
      when CrystalV2::Compiler::Frontend::GetterNode
        if member.is_class?
          member.specs.each do |spec|
            generate_class_getter_method(class_name, spec, @arena)
          end
        else
          member.specs.each do |spec|
            generate_getter_method(class_name, class_info, spec)
          end
        end
        add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
      when CrystalV2::Compiler::Frontend::SetterNode
        if member.is_class?
          member.specs.each do |spec|
            generate_class_setter_method(class_name, spec)
          end
        else
          member.specs.each do |spec|
            generate_setter_method(class_name, class_info, spec)
          end
        end
        add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
      when CrystalV2::Compiler::Frontend::PropertyNode
        if member.is_class?
          member.specs.each do |spec|
            generate_class_getter_method(class_name, spec, @arena)
            generate_class_setter_method(class_name, spec)
          end
        else
          member.specs.each do |spec|
            generate_getter_method(class_name, class_info, spec)
            generate_setter_method(class_name, class_info, spec)
          end
        end
        add_defined_instance_methods_from_expr(class_name, defined_full_names, expr_id)
      when CrystalV2::Compiler::Frontend::ClassNode
        nested_name = String.new(member.name)
        full_name = "#{class_name}::#{nested_name}"
        register_class_with_name(member, full_name)
        lower_class_with_name(member, full_name)
      when CrystalV2::Compiler::Frontend::ModuleNode
        nested_name = String.new(member.name)
        full_name = "#{class_name}::#{nested_name}"
        register_module_with_name(member, full_name)
        lower_module_with_name(member, full_name)
      when CrystalV2::Compiler::Frontend::EnumNode
        nested_name = String.new(member.name)
        full_name = "#{class_name}::#{nested_name}"
        register_enum_with_name(member, full_name)
      when CrystalV2::Compiler::Frontend::MacroDefNode
        register_macro(member, class_name)
      when CrystalV2::Compiler::Frontend::CallNode
        if ENV["DEBUG_RECORD_LOWER"]?
          callee = @arena[member.callee]
          if callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
             String.new(callee.name) == "record"
            STDERR.puts "[DEBUG_RECORD_LOWER] class=#{class_name}"
          end
        end
        lower_macro_call_in_class_body(class_name, class_info, member, defined_full_names, visited_modules)
      end
    end

    private def lower_macro_call_in_class_body(
      class_name : String,
      class_info : ClassInfo,
      node : CrystalV2::Compiler::Frontend::CallNode,
      defined_full_names : Set(String),
      visited_modules : Set(String)
    )
      callee_node = @arena[node.callee]
      return unless callee_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)

      method_name = String.new(callee_node.name)
      macro_lookup = lookup_macro_entry(method_name, class_name)
      return unless macro_lookup

      macro_entry, macro_key = macro_lookup
      macro_def, macro_arena = macro_entry
      expanded_id = expand_macro_expr(macro_def, macro_arena, node.args, node.named_args, node.block, macro_key)
      return if expanded_id.invalid?

      old_arena = @arena
      @arena = macro_arena
      begin
        lower_class_body_expr(class_name, class_info, expanded_id, defined_full_names, visited_modules)
      ensure
        @arena = old_arena
      end
    end

    # Generate allocator: ClassName.new(...) -> allocates and returns instance
    private def generate_allocator(class_name : String, class_info : ClassInfo)
      func_name = "#{class_name}.new"

      # Debug disabled for performance
      # if class_name.includes?("Slice(UInt8)")
      #   init_params_debug = @init_params[class_name]? || [] of {String, TypeRef}
      #   param_strs = init_params_debug.map { |name, type_ref| "#{name}:#{type_ref.id}" }
      #   already = @generated_allocators.includes?(class_name)
      #   has_func = @module.has_function?(func_name)
      #   STDERR.puts "[ALLOC_GEN] class=#{class_name}, init_params=[#{param_strs.join(", ")}], already=#{already}, has_func=#{has_func}"
      # end

      # Skip Pointer types - they're primitive types with no allocator
      if class_name.starts_with?("Pointer(") || class_name.starts_with?("Pointer_")
        return
      end

      # Skip primitive number types - they don't need allocators
      # (their .new methods convert from other types, not allocate)
      case class_name
      when "Int8", "Int16", "Int32", "Int64", "Int128",
           "UInt8", "UInt16", "UInt32", "UInt64", "UInt128",
           "Float32", "Float64", "Bool", "Char"
        return
      end

      # Skip if allocator already generated (for reopened classes)
      return if @generated_allocators.includes?(class_name)
      @generated_allocators.add(class_name)

      # Also check if function already exists in HIR module (belt and suspenders)
      return if @module.has_function?(func_name)

      # Get initialize parameters for this class
      init_params = @init_params[class_name]? || [] of {String, TypeRef}
      if DebugHooks::ENABLED
        debug_hook("allocator.generate", "class=#{class_name} init_params=#{init_params.size}")
      end

      # Return type is the class type (semantically)
      # LLVM backend converts to ptr for ABI
      func = @module.create_function(func_name, class_info.type_ref)
      ctx = LoweringContext.new(func, @module, @arena)

      # Add parameters to new() that match initialize()
      param_ids = [] of ValueId
      # if class_name.includes?("Slice")
      #   STDERR.puts "[ALLOC_PARAMS] func=#{func_name}, init_params.size=#{init_params.size}"
      #   init_params.each_with_index do |(name, type_ref), idx|
      #     STDERR.puts "  [#{idx}] #{name}: #{type_ref.id}"
      #   end
      # end
      init_params.each do |param_name, param_type|
        hir_param = func.add_param(param_name, param_type)
        ctx.register_local(param_name, hir_param.id)
        ctx.register_type(hir_param.id, param_type)
        param_ids << hir_param.id
      end

      # Allocate object (struct=stack, class=heap determined by escape analysis)
      alloc = Allocate.new(ctx.next_id, class_info.type_ref, [] of ValueId, class_info.is_struct)
      ctx.emit(alloc)
      ctx.register_type(alloc.id, class_info.type_ref)

      # Initialize instance variables to zero/default
      class_info.ivars.each do |ivar|
        # Check if this is a union type by looking up the type descriptor
        type_desc = @module.get_type_descriptor(ivar.type)
        if type_desc && type_desc.kind == TypeKind::Union
          # Union types will be initialized in initialize()
          # We can't create a simple zero literal for unions
          next
        end

        # Use nil for pointer types, 0 for others
        # Note: Pointer types might be registered as Class kind but with name starting with "Pointer"
        is_pointer = ivar.type == TypeRef::POINTER ||
                     (type_desc && type_desc.kind == TypeKind::Pointer) ||
                     (type_desc && type_desc.name.starts_with?("Pointer"))
        default_value : (Int64 | Nil) = if is_pointer
                                          nil
                                        else
                                          0_i64
                                        end
        default_val = Literal.new(ctx.next_id, ivar.type, default_value)
        ctx.emit(default_val)
        ivar_store = FieldSet.new(ctx.next_id, TypeRef::VOID, alloc.id, ivar.name, default_val.id, ivar.offset)
        ctx.emit(ivar_store)
      end

      # Call initialize if it exists, passing through the parameters
      # Use inheritance-aware resolution to find initialize in parent classes
      init_base_name = resolve_method_with_inheritance(class_name, "initialize")
      if init_base_name
        # Mangle the initialize call with parameter types
        init_param_types = init_params.map { |_, t| t }
        init_name = mangle_function_name(init_base_name, init_param_types)
        lower_function_if_needed(init_name)
        init_call = Call.new(ctx.next_id, TypeRef::VOID, alloc.id, init_name, param_ids)
        ctx.emit(init_call)
      end

      # Return allocated object
      ctx.terminate(Return.new(alloc.id))

      # Generate instance #new wrapper for cases where type literals are lowered as receivers.
      instance_name = "#{class_name}#new"
      unless @module.has_function?(instance_name) || @function_types.has_key?(instance_name) || has_function_base?(instance_name)
        instance_func = @module.create_function(instance_name, class_info.type_ref)
        instance_ctx = LoweringContext.new(instance_func, @module, @arena)

        self_param = instance_func.add_param("self", class_info.type_ref)
        instance_ctx.register_local("self", self_param.id)
        instance_ctx.register_type(self_param.id, class_info.type_ref)

        wrapper_param_ids = [] of ValueId
        init_params.each do |param_name, param_type|
          hir_param = instance_func.add_param(param_name, param_type)
          instance_ctx.register_local(param_name, hir_param.id)
          instance_ctx.register_type(hir_param.id, param_type)
          wrapper_param_ids << hir_param.id
        end

        new_call = Call.new(instance_ctx.next_id, class_info.type_ref, nil, "#{class_name}.new", wrapper_param_ids)
        instance_ctx.emit(new_call)
        instance_ctx.register_type(new_call.id, class_info.type_ref)
        instance_ctx.terminate(Return.new(new_call.id))
      end
    end

    private def allocator_supported?(class_name : String) : Bool
      return false if class_name.starts_with?("Pointer(") || class_name.starts_with?("Pointer_")
      return false if primitive_self_type(class_name)
      true
    end

    # Generate synthetic getter method: def name; @name; end
    private def generate_getter_method(class_name : String, class_info : ClassInfo, spec : CrystalV2::Compiler::Frontend::AccessorSpec)
      storage_name = accessor_storage_name(spec)
      getter_name = accessor_method_name(spec)
      ivar_name = "@#{storage_name}"
      ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
      return unless ivar_info

      generate_getter_method_for_ivar(class_name, class_info, ivar_info, getter_name)
    end

    # Generate synthetic setter method: def name=(value); @name = value; end
    private def generate_setter_method(class_name : String, class_info : ClassInfo, spec : CrystalV2::Compiler::Frontend::AccessorSpec)
      accessor_name = String.new(spec.name)
      ivar_name = "@#{accessor_name}"
      ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
      return unless ivar_info

      generate_setter_method_for_ivar(class_name, class_info, ivar_info)
    end

    private def generate_getter_method_for_ivar(
      class_name : String,
      class_info : ClassInfo,
      ivar_info : IVarInfo,
      accessor_name : String? = nil
    )
      accessor_name = accessor_name || ivar_info.name.lstrip('@')
      ivar_type = ivar_info.type

      base_name = "#{class_name}##{accessor_name}"
      func_name = mangle_function_name(base_name, [] of TypeRef)
      return if @module.has_function?(func_name)

      func = @module.create_function(func_name, ivar_type)
      ctx = LoweringContext.new(func, @module, @arena)

      self_param = func.add_param("self", class_info.type_ref)
      ctx.register_local("self", self_param.id)
      ctx.register_type(self_param.id, class_info.type_ref)

      field_get = FieldGet.new(ctx.next_id, ivar_type, self_param.id, ivar_info.name, ivar_info.offset)
      ctx.emit(field_get)
      ctx.register_type(field_get.id, ivar_type)

      ctx.terminate(Return.new(field_get.id))
    end

    private def generate_setter_method_for_ivar(class_name : String, class_info : ClassInfo, ivar_info : IVarInfo)
      accessor_name = ivar_info.name.lstrip('@')
      ivar_type = ivar_info.type

      base_name = "#{class_name}##{accessor_name}="
      func_name = mangle_function_name(base_name, [ivar_type])
      return if @module.has_function?(func_name)

      func = @module.create_function(func_name, ivar_type)
      ctx = LoweringContext.new(func, @module, @arena)

      self_param = func.add_param("self", class_info.type_ref)
      ctx.register_local("self", self_param.id)
      ctx.register_type(self_param.id, class_info.type_ref)

      value_param = func.add_param("value", ivar_type)
      ctx.register_local("value", value_param.id)
      ctx.register_type(value_param.id, ivar_type)

      field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, self_param.id, ivar_info.name, value_param.id, ivar_info.offset)
      ctx.emit(field_set)

      ctx.terminate(Return.new(value_param.id))
    end

    private def generate_class_getter_method(owner_name : String, spec : CrystalV2::Compiler::Frontend::AccessorSpec, arena : CrystalV2::Compiler::Frontend::ArenaLike)
      storage_name = accessor_storage_name(spec)
      method_name = accessor_method_name(spec)
      old_class = @current_class
      old_method = @current_method
      old_method_is_class = @current_method_is_class

      base_name = "#{owner_name}.#{method_name}"
      full_name = mangle_function_name(base_name, [] of TypeRef)
      return if @module.has_function?(full_name)

      @current_class = owner_name
      @current_method = method_name
      @current_method_is_class = true

      return_type = begin
        if ta = spec.type_annotation
          type_ref_for_name(String.new(ta))
        elsif spec.predicate
          TypeRef::BOOL
        elsif default_value = spec.default_value
          inferred = infer_type_from_expr(default_value, owner_name)
          inferred || TypeRef::VOID
        else
          TypeRef::VOID
        end
      end

      func = @module.create_function(full_name, return_type)
      ctx = LoweringContext.new(func, @module, arena)

      if default_value = spec.default_value
        flag_name = class_accessor_init_flag_name(storage_name)
        flag_get = ClassVarGet.new(ctx.next_id, TypeRef::BOOL, owner_name, flag_name)
        ctx.emit(flag_get)

        then_block = ctx.create_block
        else_block = ctx.create_block
        merge_block = ctx.create_block
        ctx.terminate(Branch.new(flag_get.id, then_block, else_block))

        ctx.switch_to_block(then_block)
        cached_get = ClassVarGet.new(ctx.next_id, return_type, owner_name, storage_name)
        ctx.emit(cached_get)
        ctx.terminate(Jump.new(merge_block))

        ctx.switch_to_block(else_block)
        init_value = with_arena(arena) { lower_accessor_default_value(ctx, default_value) }
        class_var_set = ClassVarSet.new(ctx.next_id, return_type, owner_name, storage_name, init_value)
        ctx.emit(class_var_set)
        flag_lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
        ctx.emit(flag_lit)
        flag_set = ClassVarSet.new(ctx.next_id, TypeRef::BOOL, owner_name, flag_name, flag_lit.id)
        ctx.emit(flag_set)
        ctx.terminate(Jump.new(merge_block))

        ctx.switch_to_block(merge_block)
        phi = Phi.new(ctx.next_id, return_type)
        phi.add_incoming(then_block, cached_get.id)
        phi.add_incoming(else_block, init_value)
        ctx.emit(phi)
        ctx.terminate(Return.new(phi.id))
      else
        value_id = ClassVarGet.new(ctx.next_id, return_type, owner_name, storage_name)
        ctx.emit(value_id)
        ctx.terminate(Return.new(value_id.id))
      end
    ensure
      @current_class = old_class
      @current_method = old_method
      @current_method_is_class = old_method_is_class || false
    end

    private def generate_class_setter_method(owner_name : String, spec : CrystalV2::Compiler::Frontend::AccessorSpec)
      storage_name = accessor_storage_name(spec)
      param_type = if ta = spec.type_annotation
                     type_ref_for_name(String.new(ta))
                   else
                     TypeRef::VOID
                   end
      base_name = "#{owner_name}.#{storage_name}="
      full_name = mangle_function_name(base_name, [param_type])
      return if @module.has_function?(full_name)

      func = @module.create_function(full_name, param_type)
      ctx = LoweringContext.new(func, @module, @arena)
      value_param = func.add_param("value", param_type)
      ctx.register_local("value", value_param.id)
      ctx.register_type(value_param.id, param_type)

      class_var_set = ClassVarSet.new(ctx.next_id, param_type, owner_name, storage_name, value_param.id)
      ctx.emit(class_var_set)
      flag_name = class_accessor_init_flag_name(storage_name)
      flag_lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
      ctx.emit(flag_lit)
      flag_set = ClassVarSet.new(ctx.next_id, TypeRef::BOOL, owner_name, flag_name, flag_lit.id)
      ctx.emit(flag_set)
      ctx.terminate(Return.new(value_param.id))
    end

    private def class_accessor_init_flag_name(accessor_name : String) : String
      "__class_accessor_init_#{accessor_name}"
    end

    private def lower_accessor_default_value(ctx : LoweringContext, default_value : CrystalV2::Compiler::Frontend::ExprId) : ValueId
      default_node = @arena[default_value]
      case default_node
      when CrystalV2::Compiler::Frontend::BlockNode
        if default_node.body.empty?
          nil_value(ctx)
        else
          lower_body(ctx, default_node.body)
        end
      else
        lower_expr(ctx, default_value)
      end
    end

    private def default_literal_for_type(ctx : LoweringContext, type_ref : TypeRef) : ValueId
      case type_ref
      when TypeRef::BOOL
        lit = Literal.new(ctx.next_id, type_ref, false)
        ctx.emit(lit)
        lit.id
      when TypeRef::INT8, TypeRef::INT16, TypeRef::INT32, TypeRef::INT64, TypeRef::INT128,
           TypeRef::UINT8, TypeRef::UINT16, TypeRef::UINT32, TypeRef::UINT64, TypeRef::UINT128
        lit = Literal.new(ctx.next_id, type_ref, 0_i64)
        ctx.emit(lit)
        lit.id
      when TypeRef::FLOAT32, TypeRef::FLOAT64
        lit = Literal.new(ctx.next_id, type_ref, 0.0_f64)
        ctx.emit(lit)
        lit.id
      when TypeRef::CHAR
        lit = Literal.new(ctx.next_id, type_ref, '\0')
        ctx.emit(lit)
        lit.id
      when TypeRef::NIL
        nil_value(ctx)
      else
        type_desc = @module.get_type_descriptor(type_ref)
        if type_desc && type_desc.kind == TypeKind::Struct
          alloc = Allocate.new(ctx.next_id, type_ref, [] of ValueId, true)
          ctx.emit(alloc)
          alloc.id
        else
          lit = Literal.new(ctx.next_id, type_ref, nil)
          ctx.emit(lit)
          lit.id
        end
      end
    end

    # Lower a method within a class
    private def lower_method(
      class_name : String,
      class_info : ClassInfo,
      node : CrystalV2::Compiler::Frontend::DefNode,
      call_arg_types : Array(TypeRef)? = nil,
      call_arg_literals : Array(Bool)? = nil,
      full_name_override : String? = nil,
      force_class_method : Bool = false
    )
      # CRITICAL: Clear enum value tracking at start of each function.
      # ValueIds are local to each function's LoweringContext, so we must not carry over
      # mappings from previous functions.
      @enum_value_types.try(&.clear)

      method_name = String.new(node.name)
      if ENV.has_key?("DEBUG_LOWER_BYTE") && (method_name == "byte_begin" || method_name == "byte_range")
        STDERR.puts "[LOWER_METHOD] START class=#{class_name} method=#{method_name} override=#{full_name_override || "nil"} arena=#{@arena.class}:#{@arena.size} modules=#{@class_included_modules[class_name]?.try(&.to_a.join(",")) || "nil"}"
      end

      # Check if this is a class method (def self.method_name)
      is_class_method = force_class_method || if recv = node.receiver
        String.new(recv) == "self"
      else
        false
      end

      if ENV.has_key?("DEBUG_NESTED_CLASS") && (class_name.includes?("FileDescriptor") && method_name.includes?("from_stdio"))
        sep = is_class_method ? "." : "#"
        STDERR.puts "[DEBUG_LOWER_METHOD] #{class_name}#{sep}#{method_name} (class_method=#{is_class_method}, receiver=#{node.receiver})"
      end
      if DebugHooks::ENABLED && class_name.includes?("(") && @type_param_map.empty?
        debug_hook("method.lower.missing_type_params", "class=#{class_name} method=#{method_name} override=#{full_name_override || ""}")
      end
      if ENV.has_key?("DEBUG_STRING_METHOD_LOWER") && class_name == "String" && (method_name == "[]" || method_name == "char_index_to_byte_index")
        sep = is_class_method ? "." : "#"
        STDERR.puts "[DEBUG_LOWER_METHOD] #{class_name}#{sep}#{method_name} override=#{full_name_override || "(none)"}"
      end
      if DebugHooks::ENABLED && class_name.starts_with?("Array(") && method_name == "new" && is_class_method
        debug_hook("method.lower.array_new", "class=#{class_name} map=#{type_param_map_debug_string} override=#{full_name_override || ""}")
      end
      if DebugHooks::ENABLED && method_name == "map" && !is_class_method
        debug_hook("method.lower.map", "class=#{class_name} map=#{type_param_map_debug_string} override=#{full_name_override || ""}")
      end

      # Class methods use "." separator, instance methods use "#"
      base_name = if is_class_method
                    "#{class_name}.#{method_name}"
                  else
                    "#{class_name}##{method_name}"
                  end

      # Skip abstract methods - they have no implementation
      if node.is_abstract
        return
      end

      # Skip pointer primitives with no body (handled via call-site intrinsics).
      if class_name.starts_with?("Pointer(") || class_name.starts_with?("Pointer_")
        return if node.body.nil?
      end

      # Track current method for super calls
      old_class = @current_class
      old_method = @current_method
      old_method_is_class = @current_method_is_class
      @current_class = class_name
      @current_method = method_name
      @current_method_is_class = is_class_method

      # Collect parameter types first for name mangling
      param_infos = [] of Tuple(String, TypeRef, Bool)  # (name, type, is_instance_var)
      param_type_names = [] of String?  # Track type annotation names for enum detection
      param_literal_flags = [] of Bool
      param_types = [] of TypeRef
      has_block = false
      param_type_map = {} of String => TypeRef
      old_typeof_locals = @current_typeof_locals
      old_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = param_type_map
      @current_typeof_local_names = {} of String => String
      call_types = call_arg_types || [] of TypeRef
      call_literal_flags = call_arg_literals || [] of Bool
      if DebugHooks::ENABLED && base_name.ends_with?("#read_bytes")
        debug_hook(
          "method.callsite_literals",
          "name=#{base_name} types=#{call_types.map(&.id).join(",")} literals=#{call_literal_flags.join(",")}"
        )
      end
      common_numeric = common_numeric_type(call_types)
      call_index = 0
      splat_param_info_index : Int32? = nil
      splat_param_types_index : Int32? = nil
      splat_param_name : String? = nil

      if params = node.params
        params.each do |param|
          next if named_only_separator?(param)
          param_name = param.name.nil? ? "_" : String.new(param.name.not_nil!)
          type_ann_str : String? = nil
          param_type = if ta = param.type_annotation
                         type_ann_str = String.new(ta)
                         type_ref_for_name(type_ann_str)
                       elsif param.is_double_splat
                         type_ref_for_name("NamedTuple")
                       else
                         TypeRef::VOID
                       end
          if param_type == TypeRef::VOID && !param.is_block && !param.is_splat && !param.is_double_splat
            if call_index < call_types.size
              inferred = common_numeric || call_types[call_index]
              param_type = inferred if inferred != TypeRef::VOID
            end
          end
          if !param.is_block && !param.is_splat && !param.is_double_splat && call_index < call_types.size
            param_type = refine_param_type_from_call(param_type, call_types[call_index])
          end
          if module_type_ref?(param_type) && (default_value = param.default_value)
            call_type = call_index < call_types.size ? call_types[call_index] : TypeRef::VOID
            if call_type == TypeRef::VOID || call_type == param_type
              if inferred_default = infer_type_from_expr(default_value, class_name)
                if module_type_ref?(inferred_default) && inferred_default != TypeRef::VOID
                  param_type = inferred_default
                end
              end
            end
          end
          param_literal = !param.is_block && !param.is_splat && !param.is_double_splat &&
                          call_index < call_literal_flags.size && call_literal_flags[call_index]
          param_type_map[param_name] = param_type
          param_infos << {param_name, param_type, param.is_instance_var}
          param_type_names << type_ann_str
          if ta = param.type_annotation
            update_typeof_local_name(param_name, String.new(ta))
          end
          if param.is_block
            has_block = true
          else
            if param.is_splat
              splat_param_info_index = param_infos.size - 1
              splat_param_types_index = param_types.size
              splat_param_name = param_name
            elsif !param.is_double_splat
              call_index += 1
            end
            param_types << param_type
          end
          param_literal_flags << param_literal
          if DebugHooks::ENABLED && base_name.ends_with?("#read_bytes")
            debug_hook(
              "param.literal",
              "name=#{base_name} param=#{param_name} literal=#{param_literal}"
            )
          end
        end
      end

      if splat_param_name
        splat_type = TypeRef::VOID
        if !call_types.empty?
          remaining = call_types[call_index..-1]? || [] of TypeRef
          splat_type = tuple_type_from_arg_types(remaining)
        end
        if splat_type == TypeRef::VOID
          if elem_type = param_type_map[splat_param_name.not_nil!]?
            if elem_type != TypeRef::VOID
              splat_type = tuple_type_from_arg_types([elem_type])
            end
          end
        end
        if splat_type != TypeRef::VOID
          param_type_map[splat_param_name.not_nil!] = splat_type
          if idx = splat_param_info_index
            param_infos[idx] = {splat_param_name.not_nil!, splat_type, param_infos[idx][2]}
          end
          if idx = splat_param_types_index
            param_types[idx] = splat_type
          end
        end
      end

      return_type = if rt = node.return_type
                      rt_name = String.new(rt)
                      # "self" in return type means "the current class type"
                      if rt_name == "self"
                        class_info.type_ref
                      elsif module_like_type_name?(rt_name)
                        inferred = infer_concrete_return_type_from_body(node, class_name)
                        inferred || type_ref_for_name(rt_name)
                      else
                        type_ref_for_name(rt_name)
                      end
                    elsif method_name.ends_with?("?")
                      infer_unannotated_query_return_type(method_name, class_info.type_ref) || TypeRef::BOOL
                    else
                      # Try to infer return type from getter-style methods (single ivar access)
                      inferred = infer_getter_return_type(node, class_info.ivars)
                      inferred || TypeRef::VOID
                    end
      if (return_type == TypeRef::VOID || return_type == TypeRef::NIL) &&
         is_class_method &&
         method_name == "backend_class" &&
         (class_name == "Crystal::EventLoop" || class_name == "EventLoop")
        if preferred = preferred_event_loop_backend_class
          preferred_ref = type_ref_for_name(preferred)
          return_type = preferred_ref unless preferred_ref == TypeRef::VOID
        end
      end

      # Mangle function name with parameter types for overloading
      full_name = full_name_override || function_full_name_for_def(base_name, param_types, node.params, has_block)

      register_pending_method_effects(full_name, param_types.size)

      if base_name.includes?("from_chars")
        STDERR.puts "[LOWER_METHOD] base_name=#{base_name}, full_name=#{full_name}, param_types=#{param_types.map(&.to_s)}, override=#{full_name_override}"
      end
      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[LOWER_METHOD] enter class=#{class_name} full=#{full_name}"
      end

      func = @module.create_function(full_name, return_type)
      ctx = LoweringContext.new(func, @module, @arena)

      # Add implicit 'self' parameter first
      # For primitive types (Int32, Bool, etc.), use primitive TypeRef so LLVM passes by value
      # For structs with fields, use class_info.type_ref (passed as pointer)
      self_type = primitive_self_type(class_name) || class_info.type_ref
      self_param = func.add_param("self", self_type)
      ctx.register_local("self", self_param.id)
      ctx.register_type(self_param.id, self_type)

      # Lower explicit parameters
      # Track @param style for auto-assignment
      auto_assign_params = [] of Tuple(String, ValueId, Int32)  # (ivar_name, param_value_id, offset)

      param_infos.each_with_index do |(param_name, param_type, is_instance_var), idx|
        # If a method parameter references a concrete generic instantiation (e.g., `Hash(String, ValueId)`),
        # ensure it is monomorphized before lowering the method body so calls on the value can resolve.
        ensure_monomorphized_type(param_type) unless param_type == TypeRef::VOID

        hir_param = func.add_param(param_name, param_type)
        ctx.register_local(param_name, hir_param.id)
        ctx.register_type(hir_param.id, param_type)
        if param_literal_flags[idx]?
          ctx.mark_type_literal(hir_param.id)
        end
        if module_type_ref?(param_type)
          ctx.mark_type_literal(hir_param.id)
        end
        if type_name = param_type_names[idx]?
          track_enum_value(hir_param.id, type_name)
        end

        # Check for @param syntax (auto-assignment to ivar via is_instance_var flag)
        if is_instance_var
          ivar_name = "@#{param_name}"  # Add @ prefix for ivar lookup
          ivar_offset = get_ivar_offset(ivar_name)
          auto_assign_params << {ivar_name, hir_param.id, ivar_offset}
        end
      end

      # Emit auto-assignments for @param style parameters
      auto_assign_params.each do |(ivar_name, param_id, offset)|
        self_id = emit_self(ctx)
        param_type = ctx.type_of(param_id)
        field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, self_id, ivar_name, param_id, offset)
        ctx.emit(field_set)
      end

      # Lower body
      last_value : ValueId? = nil
      if body = node.body
        progress_filter = ENV["DEBUG_LOWER_PROGRESS"]?
        progress_match = false
        if progress_filter
          progress_match = progress_filter == "1" || base_name.includes?(progress_filter)
        end
        if ENV.has_key?("DEBUG_LOWER_BYTE") && (method_name == "byte_begin" || method_name == "byte_range")
          STDERR.puts "[LOWER_METHOD] BODY size=#{body.size} expressions"
          body.each_with_index do |expr_id, i|
            begin
              expr_node = @arena[expr_id]
              STDERR.puts "[LOWER_METHOD]   [#{i}] expr=#{expr_id.index} type=#{expr_node.class.name.split("::").last}"
            rescue
              STDERR.puts "[LOWER_METHOD]   [#{i}] expr=#{expr_id.index} (OOB)"
            end
          end
        end
        body.each_with_index do |expr_id, idx|
          if progress_match
            begin
              expr_node = @arena[expr_id]
              STDERR.puts "[LOWER_PROGRESS] method=#{base_name} idx=#{idx} node=#{expr_node.class.name}"
            rescue
              STDERR.puts "[LOWER_PROGRESS] method=#{base_name} idx=#{idx} node=(OOB)"
            end
          end
          if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
            STDERR.puts "[LOWER_METHOD] expr=#{expr_id.index} idx=#{idx} arena=#{@arena.size}"
            begin
              expr_node = @arena[expr_id]
              if source = @sources_by_arena[@arena]?
                span = expr_node.span
                start = span.start_offset
                length = span.end_offset - span.start_offset
                if length > 0 && start >= 0 && start < source.bytesize
                  slice_len = length > 120 ? 120 : length
                  snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
                  STDERR.puts "[LOWER_METHOD] node=#{expr_node.class} span=#{start}..#{span.end_offset} \"#{snippet}\""
                else
                  STDERR.puts "[LOWER_METHOD] node=#{expr_node.class} span=#{start}..#{span.end_offset}"
                end
              else
                STDERR.puts "[LOWER_METHOD] node=#{expr_node.class} span=#{expr_node.span.start_offset}..#{expr_node.span.end_offset}"
              end
            rescue ex
              STDERR.puts "[LOWER_METHOD] inspect_failed expr=#{expr_id.index} error=#{ex.message}"
            end
          end
          last_value = lower_expr(ctx, expr_id)
        end
      end

      # Infer return type from the last expression for unannotated methods.
      # This is a pragmatic bootstrap improvement for stdlib-style combinators and nilable query methods
      # that often omit return annotations (e.g., `Hash#[]?`, `Array#first?`).
      if node.return_type.nil? && last_value
        inferred = ctx.type_of(last_value)
        if inferred != TypeRef::VOID && inferred != return_type
          return_type = inferred
          func.return_type = inferred
        end
      end

      # Ensure the return type map matches the lowered function.
      register_function_type(full_name, return_type)

      # Add implicit return if not already terminated
      # BUT don't add return after raise (which sets Unreachable terminator)
      block = ctx.get_block(ctx.current_block)
      block_has_raise = block.instructions.any? { |inst| inst.is_a?(Raise) }
      if block.terminator.is_a?(Unreachable) && !block_has_raise
        block.terminator = Return.new(last_value)
      end

      @current_typeof_locals = old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names

      # Restore previous method context
      @current_class = old_class
      @current_method = old_method
      @current_method_is_class = old_method_is_class || false
    end

    # Get primitive TypeRef for self if class_name is a primitive type
    # Returns nil if class_name is not a primitive (use class_info.type_ref instead)
    private def primitive_self_type(class_name : String) : TypeRef?
      case class_name
      when "Bool"    then TypeRef::BOOL
      when "Int8"    then TypeRef::INT8
      when "Int16"   then TypeRef::INT16
      when "Int32"   then TypeRef::INT32
      when "Int64"   then TypeRef::INT64
      when "Int128"  then TypeRef::INT128
      when "UInt8"   then TypeRef::UINT8
      when "UInt16"  then TypeRef::UINT16
      when "UInt32"  then TypeRef::UINT32
      when "UInt64"  then TypeRef::UINT64
      when "UInt128" then TypeRef::UINT128
      when "Float32" then TypeRef::FLOAT32
      when "Float64" then TypeRef::FLOAT64
      when "Char"    then TypeRef::CHAR
      else                nil
      end
    end

    private def builtin_alias_target?(name : String) : Bool
      return true if primitive_self_type(name)

      case name
      when "Nil", "Void", "NoReturn", "String", "Symbol", "Pointer", "Slice", "Array",
           "Hash", "Tuple", "NamedTuple", "Proc", "Range", "Regex", "IO", "Bytes",
           "Object", "Reference", "Class", "Struct", "Enum", "Module"
        true
      else
        false
      end
    end

    private def primitive_class_name(type_ref : TypeRef) : String?
      case type_ref
      when TypeRef::NIL     then "Nil"
      when TypeRef::BOOL    then "Bool"
      when TypeRef::INT8    then "Int8"
      when TypeRef::INT16   then "Int16"
      when TypeRef::INT32   then "Int32"
      when TypeRef::INT64   then "Int64"
      when TypeRef::INT128  then "Int128"
      when TypeRef::UINT8   then "UInt8"
      when TypeRef::UINT16  then "UInt16"
      when TypeRef::UINT32  then "UInt32"
      when TypeRef::UINT64  then "UInt64"
      when TypeRef::UINT128 then "UInt128"
      when TypeRef::FLOAT32 then "Float32"
      when TypeRef::FLOAT64 then "Float64"
      when TypeRef::CHAR    then "Char"
      when TypeRef::STRING  then "String"
      when TypeRef::SYMBOL  then "Symbol"
      when TypeRef::POINTER then "Pointer(UInt8)"
      else                      nil
      end
    end

    private def numeric_primitive_class_name?(name : String) : Bool
      case name
      when "Int8", "Int16", "Int32", "Int64", "Int128",
           "UInt8", "UInt16", "UInt32", "UInt64", "UInt128",
           "Float32", "Float64", "Char"
        true
      else
        false
      end
    end

    private def primitive_template_owner(class_name : String) : String?
      case class_name
      when "Int8", "Int16", "Int32", "Int64", "Int128",
           "UInt8", "UInt16", "UInt32", "UInt64", "UInt128"
        "Int"
      when "Float32", "Float64"
        "Float"
      else
        nil
      end
    end

    private def primitive_template_type_map(template_owner : String, primitive_owner : String) : Hash(String, String)
      case template_owner
      when "Int"
        {"Int" => "Int32"}
      when "Float"
        {"Float" => primitive_owner}
      else
        {} of String => String
      end
    end

    private def builtin_parent_for(class_name : String, is_struct : Bool) : String?
      base = class_name.split("(", 2)[0]
      case base
      when "Int8", "Int16", "Int32", "Int64", "Int128",
           "UInt8", "UInt16", "UInt32", "UInt64", "UInt128"
        "Int"
      when "Float32", "Float64"
        "Float"
      when "Int"
        "Number"
      when "Float"
        "Number"
      when "Number"
        "Value"
      when "Bool", "Char", "Symbol", "Pointer", "Tuple", "NamedTuple", "StaticArray"
        "Value"
      when "Nil", "Enum", "Struct"
        "Value"
      when "String"
        "Reference"
      when "Reference"
        "Object"
      when "Value"
        "Object"
      when "Object"
        nil
      else
        is_struct ? "Value" : "Reference"
      end
    end

    # Get type name for mangling (converts TypeRef to short string)
    private def type_name_for_mangling(type : TypeRef) : String
      case type
      when TypeRef::VOID    then "Void"
      when TypeRef::NIL     then "Nil"
      when TypeRef::BOOL    then "Bool"
      when TypeRef::INT8    then "Int8"
      when TypeRef::INT16   then "Int16"
      when TypeRef::INT32   then "Int32"
      when TypeRef::INT64   then "Int64"
      when TypeRef::INT128  then "Int128"
      when TypeRef::UINT8   then "UInt8"
      when TypeRef::UINT16  then "UInt16"
      when TypeRef::UINT32  then "UInt32"
      when TypeRef::UINT64  then "UInt64"
      when TypeRef::UINT128 then "UInt128"
      when TypeRef::FLOAT32 then "Float32"
      when TypeRef::FLOAT64 then "Float64"
      when TypeRef::CHAR    then "Char"
      when TypeRef::STRING  then "String"
      when TypeRef::SYMBOL  then "Symbol"
      when TypeRef::POINTER then "Pointer"
      else
        # User-defined type - look up name from module's type descriptors
        if desc = @module.get_type_descriptor(type)
          desc.name
        else
          "T#{type.id}"  # Fallback to type ID
        end
      end
    end

    private def tuple_type_from_arg_types(arg_types : Array(TypeRef)) : TypeRef
      return TypeRef::VOID if arg_types.empty?
      return TypeRef::VOID if arg_types.any? { |t| t == TypeRef::VOID }

      parts = arg_types.map { |t| type_name_for_mangling(t) }
      type_ref_for_name("Tuple(#{parts.join(", ")})")
    end

    private def tuple_element_type(receiver_type : TypeRef, index : Int32?) : TypeRef?
      desc = @module.get_type_descriptor(receiver_type)
      return nil unless desc
      return nil unless desc.kind == TypeKind::Tuple || desc.name.starts_with?("Tuple(")

      types = desc.type_params.reject { |t| t == TypeRef::VOID }
      return nil if types.empty?

      if index
        idx = index
        idx += types.size if idx < 0
        return nil if idx < 0 || idx >= types.size
        return types[idx]
      end

      merged = types.first
      types[1..].each do |t|
        merged = union_type_for_values(merged, t)
      end
      merged
    end

    private def tuple_return_type_for_method(receiver_type : TypeRef, method_name : String) : TypeRef?
      if ENV["DEBUG_TUPLE_RETURN"]? && (method_name == "first" || method_name == "last" || method_name == "first?" || method_name == "last?")
        desc = @module.get_type_descriptor(receiver_type)
        STDERR.puts "[TUPLE_RETURN] method=#{method_name} recv=#{desc.try(&.name) || receiver_type.id}"
      end
      case method_name
      when "first"
        tuple_element_type(receiver_type, 0)
      when "last"
        tuple_element_type(receiver_type, -1)
      when "first?"
        if elem = tuple_element_type(receiver_type, 0)
          create_union_type_for_nullable(elem)
        else
          TypeRef::NIL
        end
      when "last?"
        if elem = tuple_element_type(receiver_type, -1)
          create_union_type_for_nullable(elem)
        else
          TypeRef::NIL
        end
      else
        nil
      end
    end

    private def tuple_size_from_type_name(type_name : String) : Int32?
      return nil unless type_name.starts_with?("Tuple(") && type_name.ends_with?(")")

      inner = type_name[6...-1]
      tuple_size = 0
      depth = 0
      unless inner.empty?
        tuple_size = 1
        inner.each_char do |c|
          case c
          when '(' then depth += 1
          when ')' then depth -= 1
          when ',' then tuple_size += 1 if depth == 0
          end
        end
      end
      tuple_size
    end

    private def refine_param_type_from_call(param_type : TypeRef, call_type : TypeRef) : TypeRef
      return param_type if call_type == TypeRef::VOID
      return param_type if param_type == call_type

      param_desc = @module.get_type_descriptor(param_type)
      call_desc = @module.get_type_descriptor(call_type)
      return param_type unless param_desc && call_desc

      if param_desc.kind == TypeKind::Module && call_desc.kind == TypeKind::Module
        param_name = resolve_type_alias_chain(param_desc.name)
        call_name = resolve_type_alias_chain(call_desc.name)
        return call_type if param_name == call_name
        includers = @module_includers[param_name]?
        if includers.nil? || includers.empty?
          short_name = param_name.split("::").last
          includers = @module_includers[short_name]?
        end
        if includers
          return call_type if includers.includes?(call_name) ||
                               includers.any? { |inc| inc.ends_with?("::#{call_name}") }
        end
      end

      param_name = param_desc.name
      return param_type if param_name.includes?("(")

      call_base = call_desc.name.split("(", 2).first
      return call_type if call_base == param_name && call_desc.name.includes?("(")

      param_type
    end

    # Refine VOID arg types by looking at overload parameter annotations.
    # When an arg has VOID type but the target method has overloads with type
    # restrictions for that parameter, infer the type from those restrictions.
    private def refine_void_args_from_overloads(base_method_name : String, arg_types : Array(TypeRef)) : Array(TypeRef)
      return arg_types unless arg_types.any? { |t| t == TypeRef::VOID }

      # Look for function definitions with this base name (may have multiple overloads)
      overload_prefix = "#{base_method_name}$"
      candidates = [] of CrystalV2::Compiler::Frontend::DefNode

      # Direct match
      if func_def = @function_defs[base_method_name]?
        candidates << func_def
      end

      # Mangled variants
      @function_defs.each_key do |key|
        if key.starts_with?(overload_prefix)
          if def_node = @function_defs[key]?
            candidates << def_node
          end
        end
      end

      return arg_types if candidates.empty?

      known_types = arg_types.reject { |t| t == TypeRef::VOID }
      common_numeric = common_numeric_type(known_types)

      # For each VOID position, try to find a consistent type from overloads
      refined = arg_types.dup
      void_positions = arg_types.each_index.select { |i| arg_types[i] == TypeRef::VOID }.to_a

      void_positions.each do |pos|
        inferred_types = Set(TypeRef).new
        untyped_position = false

        candidates.each do |func_def|
          next unless params = func_def.params

          # Map position to param (accounting for block params)
          param_index = 0
          params.each do |param|
            next if named_only_separator?(param)
            next if param.is_block

            if param_index == pos
              if ta = param.type_annotation
                type_str = String.new(ta)
                # Skip generic type parameters like T, E, B
                if type_str.size == 1 && type_str[0].uppercase?
                  untyped_position = true
                else
                  inferred_type = type_ref_for_name(type_str)
                  if inferred_type == TypeRef::VOID
                    untyped_position = true
                  else
                    inferred_types << inferred_type
                  end
                end
              else
                untyped_position = true
              end
              break
            end

            param_index += 1 unless param.is_splat || param.is_double_splat
          end
        end

        if untyped_position
          refined[pos] = common_numeric if common_numeric
          next
        end

        # If all overloads agree on a single type, use it
        if inferred_types.size == 1
          refined[pos] = inferred_types.first
        elsif inferred_types.size > 1
          # Multiple types - prefer Float64 over Float32 (common pattern)
          if inferred_types.includes?(TypeRef::FLOAT64)
            refined[pos] = TypeRef::FLOAT64
          elsif inferred_types.includes?(TypeRef::FLOAT32)
            refined[pos] = TypeRef::FLOAT32
          end
        end
      end

      refined
    end

    # Map operator method name to BinaryOp for primitive inlining
    # Returns nil if the method is not a binary operator
    private def binary_op_for_method(method_name : String) : BinaryOp?
      case method_name
      when "+"   then BinaryOp::Add
      when "-"   then BinaryOp::Sub
      when "*"   then BinaryOp::Mul
      when "/"   then BinaryOp::Div
      when "%"   then BinaryOp::Mod
      when "&"   then BinaryOp::BitAnd
      when "|"   then BinaryOp::BitOr
      when "^"   then BinaryOp::BitXor
      when "<<"  then BinaryOp::Shl
      when ">>"  then BinaryOp::Shr
      when "=="  then BinaryOp::Eq
      when "!="  then BinaryOp::Ne
      when "<"   then BinaryOp::Lt
      when "<="  then BinaryOp::Le
      when ">"   then BinaryOp::Gt
      when ">="  then BinaryOp::Ge
      when "&&"  then BinaryOp::And
      when "||"  then BinaryOp::Or
      # Wrapping operators - map to same ops (LLVM integer ops already wrap)
      when "&+"  then BinaryOp::Add
      when "&-"  then BinaryOp::Sub
      when "&*"  then BinaryOp::Mul
      else            nil
      end
    end

    # Check if a TypeRef is a numeric primitive type (supports binary ops)
    private def numeric_primitive?(type : TypeRef) : Bool
      case type
      when TypeRef::INT8, TypeRef::INT16, TypeRef::INT32, TypeRef::INT64, TypeRef::INT128,
           TypeRef::UINT8, TypeRef::UINT16, TypeRef::UINT32, TypeRef::UINT64, TypeRef::UINT128,
           TypeRef::FLOAT32, TypeRef::FLOAT64, TypeRef::CHAR
        true
      else
        false
      end
    end

    private def common_numeric_type(types : Array(TypeRef)) : TypeRef?
      return nil if types.empty?
      return nil unless types.all? { |t| numeric_primitive?(t) }

      return TypeRef::FLOAT64 if types.any? { |t| t == TypeRef::FLOAT64 }
      return TypeRef::FLOAT32 if types.any? { |t| t == TypeRef::FLOAT32 }

      max_bits = types.map { |t| integer_bit_width(t) }.compact.max?
      return nil unless max_bits

      has_unsigned = types.any? do |t|
        t == TypeRef::UINT8 || t == TypeRef::UINT16 || t == TypeRef::UINT32 ||
          t == TypeRef::UINT64 || t == TypeRef::UINT128
      end
      has_signed = types.any? do |t|
        t == TypeRef::INT8 || t == TypeRef::INT16 || t == TypeRef::INT32 ||
          t == TypeRef::INT64 || t == TypeRef::INT128 || t == TypeRef::CHAR
      end

      has_unsigned && !has_signed ? unsigned_integer_type_for_width(max_bits) : signed_integer_type_for_width(max_bits)
    end

    # Extract element type from Pointer(T) class name or method name
    # "Pointer(Int32)" or "Pointer(Int32).malloc" -> TypeRef::INT32
    private def pointer_element_type(class_name : String) : TypeRef
      # Extract type argument from "Pointer(T)" format (may have .method suffix)
      if match = class_name.match(/^Pointer\(([^)]+)\)/)
        type_arg = match[1]
        case type_arg
        when "Int8"    then TypeRef::INT8
        when "Int16"   then TypeRef::INT16
        when "Int32"   then TypeRef::INT32
        when "Int64"   then TypeRef::INT64
        when "Int128"  then TypeRef::INT128
        when "UInt8"   then TypeRef::UINT8
        when "UInt16"  then TypeRef::UINT16
        when "UInt32"  then TypeRef::UINT32
        when "UInt64"  then TypeRef::UINT64
        when "UInt128" then TypeRef::UINT128
        when "Float32" then TypeRef::FLOAT32
        when "Float64" then TypeRef::FLOAT64
        when "Bool"    then TypeRef::BOOL
        when "Char"    then TypeRef::CHAR
        when "Pointer" then TypeRef::POINTER
        else
          # User-defined type - look it up in class_info
          if info = @class_info[type_arg]?
            info.type_ref
          else
            TypeRef::VOID  # Unknown type
          end
        end
      else
        TypeRef::VOID
      end
    end

    private def unwrap_pointer_union(
      ctx : LoweringContext,
      receiver_id : ValueId,
      receiver_type : TypeRef,
      value_type : TypeRef? = nil
    ) : {ValueId, TypeRef}?
      desc = @module.get_type_descriptor(receiver_type)
      return nil unless desc && desc.kind == TypeKind::Union

      variants = split_union_type_name(desc.name)
      best_idx : Int32? = nil
      best_type : TypeRef? = nil

      variants.each_with_index do |variant, idx|
        next unless variant.starts_with?("Pointer")
        variant_type = type_ref_for_name(variant)
        if value_type
          elem_type = pointer_element_type(variant)
          next if elem_type == TypeRef::VOID
          if elem_type == value_type
            best_idx = idx
            best_type = variant_type
            break
          end
        end
        if best_idx.nil?
          best_idx = idx
          best_type = variant_type
        end
      end

      return nil unless best_idx && best_type

      unwrap = UnionUnwrap.new(ctx.next_id, best_type, receiver_id, best_idx, false)
      ctx.emit(unwrap)
      ctx.register_type(unwrap.id, best_type)
      {unwrap.id, best_type}
    end

    # Mangle function name with parameter types for overloading.
    #
    # Examples:
    # - "IO.print" + [String] -> "IO.print$String"
    # - "Int32#+ " + [Int32] -> "Int32#+$Int32"
    # - "Int32#downto" + [] + has_block=true -> "Int32#downto$block"
    #
    # Note: Using $ instead of : because LLVM doesn't support : in identifiers.
    private def mangle_function_name(base_name : String, param_types : Array(TypeRef), has_block : Bool = false) : String
      # Filter out VOID types (untyped parameters don't provide overload info)
      typed_params = param_types.reject { |t| t == TypeRef::VOID }

      suffix = typed_params.map { |t| type_name_for_mangling(t) }.join("_")
      if has_block
        suffix = suffix.empty? ? "block" : "#{suffix}_block"
      end

      suffix.empty? ? base_name : "#{base_name}$#{suffix}"
    end

    private def function_full_name_for_def(
      base_name : String,
      param_types : Array(TypeRef),
      params : Array(CrystalV2::Compiler::Frontend::Parameter)?,
      has_block : Bool
    ) : String
      full_name = mangle_function_name(base_name, param_types, has_block)
      return full_name unless params

      param_count = 0
      has_splat = false
      has_double_splat = false
      has_untyped = param_types.any? { |t| t == TypeRef::VOID }
      params.each do |param|
        next if param.is_block || named_only_separator?(param)
        param_count += 1
        has_splat = true if param.is_splat
        has_double_splat = true if param.is_double_splat
      end

      if has_double_splat
        full_name = full_name.includes?("$") ? "#{full_name}_double_splat" : "#{base_name}$double_splat"
      elsif has_splat
        full_name = full_name.includes?("$") ? "#{full_name}_splat" : "#{base_name}$splat"
      end

      if @function_defs.has_key?(full_name) && (full_name == base_name || has_untyped)
        full_name = "#{base_name}$arity#{param_count}"
      end

      full_name
    end

    private def split_union_type_name(type_name : String) : Array(String)
      type_name.split("|").map(&.strip).reject(&.empty?)
    end

    private def resolve_union_method_call(type_name : String, method_name : String, arg_types : Array(TypeRef)) : String?
      variants = split_union_type_name(type_name)
      return nil if variants.empty?

      # Prefer non-nil variants when selecting a concrete method target.
      ordered = variants.sort_by { |v| v == "Nil" ? 1 : 0 }
      ordered.each do |variant|
        resolved_variant = resolve_type_alias_chain(variant)
        candidates = resolved_variant == variant ? [variant] : [resolved_variant, variant]
        candidates.uniq.each do |candidate|
          base_name = resolve_method_with_inheritance(candidate, method_name) || "#{candidate}##{method_name}"
          mangled = mangle_function_name(base_name, arg_types)
          if @function_types.has_key?(mangled)
            return mangled
          elsif has_function_base?(base_name)
            if resolved = resolve_untyped_overload(base_name, arg_types.size, false)
              return resolved
            end
          end
        end
      end

      nil
    end

    # Resolve method call for a receiver type and method name
    # Returns the properly mangled method name that should be used in the Call node
    private def normalize_method_owner_name(name : String) : String
      return name if name.empty?
      return "Tuple" if name.starts_with?("Tuple(")
      return "NamedTuple" if name.starts_with?("NamedTuple(")
      name
    end

    private def resolve_method_call(ctx : LoweringContext, receiver_id : ValueId, method_name : String, arg_types : Array(TypeRef)) : String
      receiver_type = ctx.type_of(receiver_id)
      type_desc = @module.get_type_descriptor(receiver_type)

      # Get the class name from the type descriptor
      enum_type_name = @enum_value_types.try(&.[receiver_id]?)
      class_name = enum_type_name || type_desc.try(&.name) || primitive_class_name(receiver_type) || ""
      if !class_name.empty? && !@type_param_map.empty?
        substituted = substitute_type_params_in_type_name(class_name)
        if substituted != class_name
          debug_hook("method.resolve.substitute", "before=#{class_name} after=#{substituted} method=#{method_name}")
          class_name = substituted
        end
      end
      class_name = normalize_method_owner_name(class_name)
      if DebugHooks::ENABLED && unresolved_generic_receiver?(class_name)
        debug_hook("method.resolve.unresolved", "method=#{method_name} receiver=#{class_name} args=#{arg_types.map { |t| type_name_for_mangling(t) }.join(",")} current=#{@current_class || ""}")
      end

      # DEBUG: Track where short names come from in method resolution
      if ENV.has_key?("DEBUG_METHOD_RESOLVE") && !class_name.includes?("::") &&
         (method_name == "file_names" || method_name == "version" || method_name == "include_directories" ||
          class_name == "LoadCommand" || class_name == "Seek" || class_name == "Section")
        STDERR.puts "[METHOD_RESOLVE] method=#{method_name}, receiver_id=#{receiver_id}, receiver_type.id=#{receiver_type.id}, type_desc_name=#{type_desc.try(&.name) || "nil"}, class_name=#{class_name}"
      end

      # RESOLVE_CALL debug disabled

      # DEBUG: Trace empty class names for specific methods
      if ENV.has_key?("DEBUG_EMPTY_CLASS") && class_name.empty?
        STDERR.puts "[EMPTY_CLASS] method=#{method_name} receiver_id=#{receiver_id} receiver_type.id=#{receiver_type.id} type_desc=#{type_desc.try(&.name) || "nil"} enum_type=#{enum_type_name || "nil"}"
      end

      # Build the base method name as ClassName#method
      base_method_name = class_name.empty? ? method_name : "#{class_name}##{method_name}"
      base_method_name = rewrite_event_loop_method_name(base_method_name)
      if ENV["DEBUG_TO_S_RESOLVE"]? && method_name == "to_s"
        recv_name = type_desc ? "#{type_desc.name}(#{type_desc.kind})" : "id=#{receiver_type.id}"
        STDERR.puts "[TO_S_RESOLVE] recv=#{recv_name} class_name=#{class_name} base=#{base_method_name}"
      end

      # Mangle with argument types
      mangled_name = mangle_function_name(base_method_name, arg_types)
      preferred_module_class = preferred_module_typed_class_for(class_name)
      type_is_module = type_desc.try(&.kind) == TypeKind::Module
      module_like_receiver = !class_name.empty? && (type_is_module || module_like_type_name?(class_name) || module_includers_match?(class_name) || !preferred_module_class.nil?)

      # Try to find the function in the module.
      #
      # IMPORTANT: Don't use return type as an existence check.
      # Many valid methods return `Nil` (VOID) in our IR, and treating VOID as "missing"
      # causes qualified calls to degrade into unqualified extern calls.
      if @function_types.has_key?(mangled_name) && !(module_like_receiver && abstract_def?(mangled_name))
        debug_hook("method.resolve", "base=#{base_method_name} resolved=#{mangled_name} reason=mangled_exact")
        return mangled_name
      end
      if (@function_defs.has_key?(mangled_name) && !(module_like_receiver && abstract_def?(mangled_name))) ||
         @module.has_function?(mangled_name)
        debug_hook("method.resolve", "base=#{base_method_name} resolved=#{mangled_name} reason=mangled_def")
        return mangled_name
      end

      if !class_name.empty? && method_name.ends_with?("=")
        if info = @class_info[class_name]?
          accessor = method_name[0, method_name.size - 1]
          ivar_name = "@#{accessor}"
          if ivar_info = info.ivars.find { |iv| iv.name == ivar_name }
            expected_name = mangle_function_name(base_method_name, [ivar_info.type])
            if @function_types.has_key?(expected_name)
              debug_hook("method.resolve", "base=#{base_method_name} resolved=#{expected_name} reason=setter_accessor")
              return expected_name
            end
          end
        end
      end

      if !class_name.empty? && class_name.includes?("|")
        if resolved = resolve_union_method_call(class_name, method_name, arg_types)
          if ENV["DEBUG_TO_S_RESOLVE"]? && method_name == "to_s"
            STDERR.puts "[TO_S_RESOLVE] union resolved=#{resolved}"
          end
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=union")
          return resolved
        end
      end

      # If the receiver is module-like (e.g., Iterator(T)) or maps to a known includer,
      # resolve only when a unique includer matches the call signature.
      if module_like_receiver
        if resolved = resolve_module_typed_method(method_name, arg_types, class_name, false, @current_class)
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=module_typed")
          return resolved
        end
      end

      # If any overload exists for the base name, return the base name and let
      # the MIR lowering do fuzzy matching to pick a concrete overload.
      if !class_name.empty? && has_function_base?(base_method_name)
        if resolved = resolve_untyped_overload(base_method_name, arg_types.size, false)
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=base_overload_arity")
          return resolved
        end
        if resolved = resolve_ancestor_overload(class_name, method_name, arg_types.size)
          debug_hook("method.resolve", "base=#{base_method_name} resolved=#{resolved} reason=ancestor_overload_arity")
          return resolved
        end
        debug_hook("method.resolve", "base=#{base_method_name} resolved=#{base_method_name} reason=base_overload")
        return base_method_name
      end

      # Search through all class info for matching method (O(n) fallback).
      # Only do this when the receiver type is unknown (no descriptor name).
      if class_name.empty?
        @class_info.each do |klass_name, info|
          test_base = "#{klass_name}##{method_name}"
          test_mangled = mangle_function_name(test_base, arg_types)
          if @function_types.has_key?(test_mangled)
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{test_mangled} reason=fallback_scan")
            return test_mangled
          elsif has_function_base?(test_base)
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{test_base} reason=fallback_scan_base")
            return test_base
          end
        end
      end

      # For special operators like <<, try common receivers with relaxed type matching
      if method_name == "<<" && class_name.empty?
        # Try Array(T)#<< with various element types
        ["String", "Int32", "Pointer"].each do |elem_type|
          array_class = "Array(#{elem_type})"
          test_base = "#{array_class}#<<"
          test_mangled = mangle_function_name(test_base, arg_types)
          if @function_types[test_mangled]?
            debug_hook("method.resolve", "base=#{base_method_name} resolved=#{test_mangled} reason=operator_array")
            return test_mangled
          end
          # Also try without arg types mangling
          @function_types.each_key do |key|
            if key.starts_with?("#{test_base}$")
              debug_hook("method.resolve", "base=#{base_method_name} resolved=#{key} reason=operator_array_prefix")
              return key
            end
          end
        end
        # Try IO#<<
        ["IO", "IO::Memory", "String::Builder"].each do |io_class|
          test_base = "#{io_class}#<<"
          @function_types.each_key do |key|
            if key.starts_with?("#{test_base}$") || key == test_base
              debug_hook("method.resolve", "base=#{base_method_name} resolved=#{key} reason=operator_io")
              return key
            end
          end
        end
      end

      # Fallback to mangled name
      debug_hook("method.resolve", "base=#{base_method_name} resolved=#{mangled_name} reason=fallback")
      mangled_name
    end

    # Resolve a single overload when argument types are unknown (all VOID).
    # Uses arity + block presence to avoid calling an unmangled base name.
    private def resolve_untyped_overload(base_method_name : String, arg_count : Int32, has_block_call : Bool) : String?
      return nil if base_method_name.empty?

      if base_method_name.includes?("#") || base_method_name.includes?(".")
        sep = base_method_name.includes?("#") ? "#" : "."
        owner, _method_part = base_method_name.split(sep, 2)
        if info = generic_owner_info(owner)
          if !@monomorphized.includes?(info[:owner]) && concrete_type_args?(info[:args]) && !@suppress_monomorphization
            monomorphize_generic_class(info[:base], info[:args], info[:owner])
          end
        end
      end

      best_name : String? = nil
      best_param_count = Int32::MAX
      best_score = Int32::MIN

      @function_defs.each do |name, def_node|
        next unless name == base_method_name || name.starts_with?("#{base_method_name}$")
        params = def_node.params
        next unless params

        param_count = 0
        required = 0
        has_splat = false
        has_double_splat = false
        def_has_block = false
        params.each do |param|
          next if named_only_separator?(param)
          if param.is_block
            def_has_block = true
            next
          end
          param_count += 1
          has_splat ||= param.is_splat
          has_double_splat ||= param.is_double_splat
          if param.default_value.nil? && !param.is_splat && !param.is_double_splat
            required += 1
          end
        end

        next if has_block_call && !def_has_block
        next if !has_block_call && def_has_block
        next if arg_count < required
        next if arg_count > param_count && !has_splat && !has_double_splat

        score = 0
        score += 2 if param_count == arg_count
        score -= 1 if has_splat
        score -= 1 if has_double_splat
        score += 1 if name.includes?("$")

        if param_count < best_param_count || (param_count == best_param_count && score > best_score)
          best_name = name
          best_param_count = param_count
          best_score = score
        end
      end

      best_name
    end

    private def non_nil_type_for_union(type_ref : TypeRef) : TypeRef?
      type_desc = @module.get_type_descriptor(type_ref)
      return nil unless type_desc && type_desc.kind == TypeKind::Union

      variants = split_union_type_name(type_desc.name)
      non_nil = variants.reject { |name| name == "Nil" }
      return nil if non_nil.empty?
      return type_ref_for_name(non_nil.first) if non_nil.size == 1

      create_union_type(non_nil.join(" | "))
    end

    private def resolve_ancestor_overload(owner : String, method_name : String, arg_count : Int32) : String?
      visited = Set(String).new
      current = @class_info[owner]?.try(&.parent_name)
      while current
        break if visited.includes?(current)
        visited.add(current)
        base = "#{current}##{method_name}"
        if has_function_base?(base)
          if resolved = resolve_untyped_overload(base, arg_count, false)
            return resolved
          end
        end
        current = @class_info[current]?.try(&.parent_name)
      end
      nil
    end

    private def module_receiver_type_name(node : CrystalV2::Compiler::Frontend::MemberAccessNode) : String?
      obj_node = @arena[node.object]
      case obj_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(obj_node.name)
        if type_name = lookup_typeof_local_name(name)
          return type_name if module_like_type_name?(type_name)
        end
        if locals = @current_typeof_locals
          if type_ref = locals[name]?
            resolved = get_type_name_from_ref(type_ref)
            return resolved if module_like_type_name?(resolved)
          end
        end
      end
      nil
    end

    private def preferred_module_typed_class_for(module_type_name : String) : String?
      base = if paren = module_type_name.index('(')
               module_type_name[0, paren]
             else
               module_type_name
             end
      case base
      when "Crystal::EventLoop", "EventLoop"
        preferred_event_loop_backend_class
      when "Crystal::EventLoop::FileDescriptor", "EventLoop::FileDescriptor",
           "Crystal::EventLoop::Socket", "EventLoop::Socket"
        preferred_event_loop_interface_class
      else
        nil
      end
    end

    private def preferred_event_loop_backend_class : String?
      flags = CrystalV2::Runtime.target_flags
      return "Crystal::EventLoop::Wasi" if flags.includes?("wasi")
      return "Crystal::EventLoop::IOCP" if flags.includes?("win32") || flags.includes?("windows")

      return nil unless flags.includes?("unix") || flags.includes?("linux") || flags.includes?("android") ||
                        flags.includes?("darwin") || flags.includes?("freebsd") || flags.includes?("openbsd") ||
                        flags.includes?("netbsd") || flags.includes?("dragonfly")

      if evloop = flags.find { |flag| flag.starts_with?("evloop=") }
        case evloop
        when "evloop=libevent"
          return "Crystal::EventLoop::LibEvent"
        when "evloop=epoll"
          return "Crystal::EventLoop::Epoll"
        when "evloop=kqueue"
          return "Crystal::EventLoop::Kqueue"
        end
      end

      return "Crystal::EventLoop::Epoll" if flags.includes?("linux") || flags.includes?("android")
      return "Crystal::EventLoop::Kqueue" if flags.includes?("darwin") || flags.includes?("freebsd")

      "Crystal::EventLoop::LibEvent"
    end

    private def preferred_event_loop_interface_class : String?
      flags = CrystalV2::Runtime.target_flags
      return "Crystal::EventLoop::Wasi" if flags.includes?("wasi")
      return "Crystal::EventLoop::IOCP" if flags.includes?("win32") || flags.includes?("windows")

      if flags.includes?("unix") || flags.includes?("linux") || flags.includes?("android") ||
         flags.includes?("darwin") || flags.includes?("freebsd") || flags.includes?("openbsd") ||
         flags.includes?("netbsd") || flags.includes?("dragonfly")
        return "Crystal::EventLoop::Polling"
      end
      nil
    end

    private def event_loop_interface_module_name?(name : String) : Bool
      name.ends_with?("EventLoop::FileDescriptor") || name.ends_with?("EventLoop::Socket")
    end

    private def rewrite_event_loop_method_name(base_method_name : String) : String
      parts = base_method_name.split("#", 2)
      return base_method_name if parts.size != 2

      owner = parts[0]
      method = parts[1]

      file_descriptor_method = case method
                               when "pipe", "open", "read", "wait_readable", "write", "wait_writable", "reopened", "close"
                                 true
                               else
                                 false
                               end
      socket_method = case method
                      when "socket", "socketpair", "read", "wait_readable", "write", "wait_writable",
                           "accept", "connect", "send_to", "receive_from", "close"
                        true
                      else
                        false
                      end

      if owner == "Crystal::EventLoop::FileDescriptor"
        if impl = preferred_event_loop_interface_class
          return "#{impl}##{method}"
        end
      elsif owner == "Crystal::EventLoop::Socket"
        if impl = preferred_event_loop_interface_class
          return "#{impl}##{method}"
        end
      elsif owner == "Crystal::EventLoop"
        if file_descriptor_method || socket_method
          if impl = preferred_event_loop_interface_class
            return "#{impl}##{method}"
          end
        else
          if impl = preferred_event_loop_backend_class
            return "#{impl}##{method}"
          end
        end
      end

      base_method_name
    end

    private def resolve_module_typed_method(
      method_name : String,
      arg_types : Array(TypeRef),
      module_type_name : String,
      has_block : Bool,
      prefer_class : String?
    ) : String?
      if preferred = preferred_module_typed_class_for(module_type_name)
        prefer_class = preferred
      end
      module_base = if paren = module_type_name.index('(')
                      module_type_name[0, paren]
                    else
                      module_type_name
                    end
      includers = @module_includers[module_base]?
      if includers.nil? || includers.empty?
        matches = @module_includers.keys.select { |key| key.ends_with?("::#{module_base}") }
        module_base = matches.first if matches.size == 1
        includers = @module_includers[module_base]?
      end
      # Fallback: try short name if full name has no includers
      # e.g., "Crystal::EventLoop::FileDescriptor" -> "FileDescriptor"
      if includers.nil? || includers.empty?
        short_name = module_base.split("::").last
        if short_name != module_base
          includers = @module_includers[short_name]?
          if includers.nil? || includers.empty?
            matches = @module_includers.keys.select { |key| key.ends_with?("::#{short_name}") }
            if matches.size == 1
              module_base = matches.first
              includers = @module_includers[module_base]?
            end
          end
        end
      end
      if includers.nil? || includers.empty?
        if prefer_class
          includers = Set(String).new
          includers << prefer_class
        else
          # RESOLVE_DEBUG disabled
          return nil
        end
      end

      arg_count = arg_types.size
      module_method_base = "#{module_base}.#{method_name}"
      if entry = lookup_function_def_for_call(module_method_base, arg_count, has_block, arg_types)
        def_node = entry[1]
        func_context = function_context_from_name(entry[0])
        if params_compatible_with_args?(def_node, arg_types, func_context)
          mangled = mangle_function_name(module_method_base, arg_types, has_block)
          if @function_types.has_key?(mangled) || @module.has_function?(mangled)
            return mangled unless abstract_def?(mangled)
          elsif has_function_base?(module_method_base)
            return module_method_base unless abstract_def?(module_method_base)
          end
        end
      end

      candidates = includers.to_a
      if module_like_type_name?(module_base) && !candidates.includes?(module_base)
        candidates << module_base
      end
      if prefer_class && !candidates.includes?(prefer_class)
        candidates << prefer_class
      end
      # Also add subclasses of includers (for abstract classes like Crystal::EventLoop)
      # The concrete implementation may be in a subclass (e.g., Polling, Kqueue)
      subclasses = [] of String
      # Debug disabled
      # if method_name == "write"
      #   ev_classes = @class_info.select { |k, _| k.includes?("EventLoop") || k.includes?("Polling") || k.includes?("Kqueue") }
      #   STDERR.puts "[SUBCLASS_DEBUG] Checking parents: #{ev_classes.map { |k, v| "#{k}->#{v.parent_name}" }}"
      # end
      includers.each do |inc|
        # Get short name (e.g., "Crystal::EventLoop" -> "EventLoop")
        inc_short = inc.split("::").last
        @class_info.each do |name, ci|
          parent = ci.parent_name
          next unless parent
          # Match if parent equals full name, short name, or ends with short name
          if parent == inc || parent == inc_short || inc.ends_with?("::#{parent}")
            subclasses << name
          end
        end
      end
      # Recursively find subclasses of subclasses (e.g., Kqueue < Polling < EventLoop)
      prev_size = 0
      while subclasses.size > prev_size
        prev_size = subclasses.size
        subclasses.dup.each do |sub|
          sub_short = sub.split("::").last
          @class_info.each do |name, ci|
            parent = ci.parent_name
            next unless parent
            if parent == sub || parent == sub_short || sub.ends_with?("::#{parent}")
              unless subclasses.includes?(name)
                subclasses << name
              end
            end
          end
        end
      end
      candidates.concat(subclasses)
      candidates.uniq!
      if DebugHooks::ENABLED && module_base.includes?("ByteFormat") && method_name == "decode"
        debug_hook(
          "module.resolve",
          "module=#{module_base} includers=#{includers.to_a.join(",")} candidates=#{candidates.join(",")}"
        )
      end
      if ENV["DEBUG_MODULE_RESOLVE"]? && module_base.includes?("EventLoop::FileDescriptor")
        STDERR.puts "[DEBUG_MODULE_RESOLVE] module=#{module_base} method=#{method_name} includers=#{includers.to_a.sort.join(",")} candidates=#{candidates.sort.join(",")}"
      end
      # RESOLVE_DEBUG2 disabled
      if prefer_class
        candidates.delete(prefer_class)
        candidates.sort!
        candidates.unshift(prefer_class)
      else
        candidates.sort!
      end

      matches = [] of String
      candidates.each do |candidate|
        sep = module_like_type_name?(candidate) ? "." : "#"
        base = "#{candidate}#{sep}#{method_name}"
        # Filter by arity/defaults first to avoid picking mismatched overloads.
        if entry = lookup_function_def_for_call(base, arg_count, has_block, arg_types)
          def_node = entry[1]
          func_context = function_context_from_name(entry[0])
          next unless params_compatible_with_args?(def_node, arg_types, func_context)
          mangled = mangle_function_name(base, arg_types, has_block)
          if @function_types.has_key?(mangled) || @module.has_function?(mangled)
            matches << mangled
          elsif has_function_base?(base)
            matches << base
          end
        end
      end

      return matches.first if matches.size == 1
      if prefer_class
        preferred = matches.find do |name|
          name.starts_with?("#{prefer_class}#") || name.starts_with?("#{prefer_class}.")
        end
        return preferred if preferred
      end
      if matches.empty? && arg_count > 0
        # Fallback: retry without arg type filtering to avoid false negatives
        # when module-typed parameters don't match concrete includers.
        candidates.each do |candidate|
          sep = module_like_type_name?(candidate) ? "." : "#"
          base = "#{candidate}#{sep}#{method_name}"
          if lookup_function_def_for_call(base, arg_count, has_block, nil)
            mangled = mangle_function_name(base, arg_types, has_block)
            if @function_types.has_key?(mangled) || @module.has_function?(mangled)
              matches << mangled
            elsif has_function_base?(base)
              matches << base
            end
          end
        end
        return matches.first if matches.size == 1
        if prefer_class
          preferred = matches.find { |name| name.starts_with?("#{prefer_class}#") }
          return preferred if preferred
        end
      end
      nil
    end

    private def module_includers_match?(name : String) : Bool
      return true if @module_includers.has_key?(name)

      if @module_includers.keys.any? { |key| key.ends_with?("::#{name}") }
        return true
      end

      short_name = name.split("::").last
      return true if @module_includers.has_key?(short_name)

      @module_includers.keys.any? { |key| key.ends_with?("::#{short_name}") }
    end

    private def resolve_module_typed_ivar(
      module_type_name : String,
      ivar_name : String,
      prefer_class : String? = nil
    ) : {ClassInfo, IVarInfo}?
      if preferred = preferred_module_typed_class_for(module_type_name)
        prefer_class = preferred
      end
      module_base = if paren = module_type_name.index('(')
                      module_type_name[0, paren]
                    else
                      module_type_name
                    end
      includers = @module_includers[module_base]?
      if includers.nil? || includers.empty?
        matches = @module_includers.keys.select { |key| key.ends_with?("::#{module_base}") }
        module_base = matches.first if matches.size == 1
        includers = @module_includers[module_base]?
      end
      if includers.nil? || includers.empty?
        short_name = module_base.split("::").last
        if short_name != module_base
          includers = @module_includers[short_name]?
          if includers.nil? || includers.empty?
            matches = @module_includers.keys.select { |key| key.ends_with?("::#{short_name}") }
            if matches.size == 1
              module_base = matches.first
              includers = @module_includers[module_base]?
            end
          end
        end
      end
      if includers.nil? || includers.empty?
        if prefer_class
          includers = Set(String).new
          includers << prefer_class
        else
          return nil
        end
      end

      candidates = includers.to_a
      subclasses = [] of String
      includers.each do |inc|
        inc_short = inc.split("::").last
        @class_info.each do |name, ci|
          parent = ci.parent_name
          next unless parent
          if parent == inc || parent == inc_short || inc.ends_with?("::#{parent}")
            subclasses << name unless subclasses.includes?(name)
          end
        end
      end

      prev_size = 0
      while subclasses.size > prev_size
        prev_size = subclasses.size
        subclasses.dup.each do |sub|
          sub_short = sub.split("::").last
          @class_info.each do |name, ci|
            parent = ci.parent_name
            next unless parent
            if parent == sub || parent == sub_short || sub.ends_with?("::#{parent}")
              subclasses << name unless subclasses.includes?(name)
            end
          end
        end
      end
      subclasses.each { |name| candidates << name unless candidates.includes?(name) }
      if prefer_class && !candidates.includes?(prefer_class)
        candidates << prefer_class
      end

      if prefer_class
        candidates.delete(prefer_class)
        candidates.sort!
        candidates.unshift(prefer_class)
      else
        candidates.sort!
      end

      matches = [] of {ClassInfo, IVarInfo}
      candidates.each do |name|
        next unless info = @class_info[name]?
        if ivar_info = info.ivars.find { |iv| iv.name == ivar_name }
          matches << {info, ivar_info}
        end
      end

      return matches.first if matches.size == 1
      nil
    end

    private def params_compatible_with_args?(
      def_node : CrystalV2::Compiler::Frontend::DefNode,
      arg_types : Array(TypeRef),
      context : String? = nil
    ) : Bool
      params = def_node.params
      return true unless params

      arg_idx = 0
      params.each do |param|
        next if param.is_block
        next if named_only_separator?(param)
        if param.is_splat || param.is_double_splat
          return true
        end
        break if arg_idx >= arg_types.size

        param_type_name = param.type_annotation ? String.new(param.type_annotation.not_nil!) : ""
        if !param_type_name.empty? && context
          param_type_name = normalize_declared_type_name(param_type_name, context)
        end
        arg_type = arg_types[arg_idx]

        # "_" is a wildcard type in Crystal (matches any argument).
        if param_type_name == "_"
          arg_idx += 1
          next
        end

        if !param_type_name.empty?
          # Resolve type alias chain FIRST, then get type ref
          resolved_name = resolve_type_alias_chain(param_type_name)
          if module_like_type_name?(resolved_name)
            return false if primitive_type?(arg_type)
            arg_idx += 1
            next
          end
          # Use resolved name for type lookup
          param_type = type_ref_for_name(resolved_name)
        else
          param_type = TypeRef::VOID
        end

        if param_type != TypeRef::VOID && arg_type != TypeRef::VOID
          if param_type != arg_type && !needs_union_coercion?(arg_type, param_type)
            if numeric_compatible?(arg_type, param_type)
              arg_idx += 1
              next
            end
            if !param_type_name.empty?
              if numeric_param_target_type(param_type_name, arg_type)
                arg_idx += 1
                next
              end
            end
            # Also check if arg type's name matches after alias resolution
            arg_desc = @module.get_type_descriptor(arg_type)
            # PARAMS_COMPAT debug disabled
            if arg_desc && resolve_type_alias_chain(arg_desc.name) == resolve_type_alias_chain(param_type_name)
              # They're the same type after alias resolution, allow
              arg_idx += 1
              next
            end
            # Check if arg type includes the param type (for module methods)
            # e.g., IO::FileDescriptor includes Crystal::System::FileDescriptor
            if arg_desc
              arg_class = arg_desc.name
              param_base = param_type_name.split("(").first
              if @class_included_modules[arg_class]?.try(&.any? { |m| m.includes?(param_base) || param_base.includes?(m.split("::").last) })
                arg_idx += 1
                next
              end
            end
            return false
          end
        end

        arg_idx += 1
      end

      true
    end

    private def params_match_score(
      def_node : CrystalV2::Compiler::Frontend::DefNode,
      arg_types : Array(TypeRef),
      context : String? = nil
    ) : Int32
      params = def_node.params
      return 0 unless params

      score = 0
      arg_idx = 0
      params.each do |param|
        next if param.is_block
        next if named_only_separator?(param)
        break if arg_idx >= arg_types.size
        if param.is_splat || param.is_double_splat
          arg_idx += 1
          next
        end

        param_type_name = param.type_annotation ? String.new(param.type_annotation.not_nil!) : ""
        if !param_type_name.empty? && context
          param_type_name = normalize_declared_type_name(param_type_name, context)
        end

        arg_type = arg_types[arg_idx]
        if param_type_name == "_"
          arg_idx += 1
          next
        end
        if !param_type_name.empty? && arg_type != TypeRef::VOID
          resolved_name = resolve_type_alias_chain(param_type_name)
          param_type = type_ref_for_name(resolved_name)
          if param_type != TypeRef::VOID
            if param_type == arg_type
              score += 2
            elsif needs_union_coercion?(arg_type, param_type)
              score += 1
            elsif numeric_compatible?(arg_type, param_type)
              score += 1
            else
              numeric_target = numeric_param_target_type(param_type_name, arg_type)
              score += 1 if numeric_target
            end
          end
        end

        arg_idx += 1
      end

      score
    end

    private def primitive_type?(type : TypeRef) : Bool
      case type
      when TypeRef::VOID, TypeRef::NIL, TypeRef::BOOL, TypeRef::CHAR,
           TypeRef::INT8, TypeRef::INT16, TypeRef::INT32, TypeRef::INT64, TypeRef::INT128,
           TypeRef::UINT8, TypeRef::UINT16, TypeRef::UINT32, TypeRef::UINT64, TypeRef::UINT128,
           TypeRef::FLOAT32, TypeRef::FLOAT64
        true
      else
        false
      end
    end

    private def integer_bit_width(type : TypeRef) : Int32?
      case type
      when TypeRef::INT8, TypeRef::UINT8
        8
      when TypeRef::INT16, TypeRef::UINT16
        16
      when TypeRef::INT32, TypeRef::UINT32, TypeRef::CHAR
        32
      when TypeRef::INT64, TypeRef::UINT64
        64
      when TypeRef::INT128, TypeRef::UINT128
        128
      else
        nil
      end
    end

    private def signed_integer_type_for_width(bits : Int32) : TypeRef
      case bits
      when 8
        TypeRef::INT8
      when 16
        TypeRef::INT16
      when 32
        TypeRef::INT32
      when 64
        TypeRef::INT64
      when 128
        TypeRef::INT128
      else
        TypeRef::VOID
      end
    end

    private def unsigned_integer_type_for_width(bits : Int32) : TypeRef
      case bits
      when 8
        TypeRef::UINT8
      when 16
        TypeRef::UINT16
      when 32
        TypeRef::UINT32
      when 64
        TypeRef::UINT64
      when 128
        TypeRef::UINT128
      else
        TypeRef::VOID
      end
    end

    private def numeric_compatible?(arg_type : TypeRef, param_type : TypeRef) : Bool
      arg_bits = integer_bit_width(arg_type)
      param_bits = integer_bit_width(param_type)
      return false unless arg_bits && param_bits
      arg_bits == param_bits
    end

    private def numeric_param_target_type(param_type_name : String, arg_type : TypeRef) : TypeRef?
      bits = integer_bit_width(arg_type)
      case param_type_name
      when "Int::Primitive", "Int::Signed"
        return signed_integer_type_for_width(bits) if bits
      when "Int::Unsigned"
        return unsigned_integer_type_for_width(bits) if bits
      end

      short_name = param_type_name.split("::").last
      case short_name
      when "Int"
        return signed_integer_type_for_width(bits) if bits
      when "UInt"
        return unsigned_integer_type_for_width(bits) if bits
      when "Float"
        return arg_type if arg_type == TypeRef::FLOAT32 || arg_type == TypeRef::FLOAT64
      when "Number"
        return arg_type if numeric_primitive?(arg_type)
      end
      nil
    end

    # Fallback for yield-function inlining when receiver type is unknown (often due to untyped params).
    # Tries to find a unique yield method by name + arity.
    private def find_yield_method_fallback(method_name : String, arg_count : Int32) : String?
      instance_suffix = "##{method_name}"
      class_suffix = ".#{method_name}"

      candidates = [] of String
      seen_defs = Set(UInt64).new
      @yield_functions.each do |name|
        base = name.split("$").first
        next unless base.ends_with?(instance_suffix) || base.ends_with?(class_suffix)
        func_def = @function_defs[name]?
        func_def ||= @function_defs[base]?
        next unless func_def
        def_id = func_def.object_id
        next if seen_defs.includes?(def_id)
        non_block_params = if params = func_def.params
                             params.count { |p| !p.is_block && !named_only_separator?(p) }
                           else
                             0
                           end
        next unless non_block_params == arg_count
        candidates << name
        seen_defs << def_id
      end

      return candidates.first if candidates.size == 1

      # Multiple candidates - prefer Object methods (base class) over more specialized ones
      # This handles cases like Object#tap vs Iterator#tap
      if candidates.size > 1
        object_candidate = candidates.find { |c| c.starts_with?("Object#") }
        return object_candidate if object_candidate
        # Fallback: return first candidate anyway (better than nothing)
        return candidates.first
      end
      nil
    end

    # Infer return type for getter-style methods (single ivar access in body)
    # Returns the ivar type if the method body is just "@x", nil otherwise
    private def infer_getter_return_type(node : CrystalV2::Compiler::Frontend::DefNode, ivars : Array(IVarInfo)) : TypeRef?
      body = node.body
      return nil unless body && body.size == 1

      # Single expression in body - check if it's an ivar access
      body_node = @arena[body[0]]
      case body_node
      when CrystalV2::Compiler::Frontend::InstanceVarNode
        # Body is just "@x" - find the ivar type
        ivar_name = String.new(body_node.name)
        ivar_info = ivars.find { |iv| iv.name == ivar_name }
        return ivar_info.type if ivar_info && ivar_info.type != TypeRef::VOID
      end
      nil
    end

    # Helper to get type size in bytes
    private def type_size(type : TypeRef) : Int32
      case type
      when TypeRef::BOOL, TypeRef::INT8, TypeRef::UINT8
        1
      when TypeRef::INT16, TypeRef::UINT16
        2
      when TypeRef::INT32, TypeRef::UINT32, TypeRef::FLOAT32, TypeRef::CHAR
        4
      when TypeRef::INT64, TypeRef::UINT64, TypeRef::FLOAT64
        8
      when TypeRef::INT128, TypeRef::UINT128
        16
      when TypeRef::VOID, TypeRef::NIL
        0  # Nil/Void has no storage size
      else
        # Check if it's a union type we've registered
        mir_type_ref = MIR::TypeRef.new(type.id)
        if descriptor = @union_descriptors[mir_type_ref]?
          descriptor.total_size
        else
          8  # Pointer size for reference types
        end
      end
    end

    # Register a function signature (for forward reference support)
    # Call this for all functions before lowering any function bodies
    def register_function(node : CrystalV2::Compiler::Frontend::DefNode)
      base_name = String.new(node.name)
      if ENV["DEBUG_PUTS_REGISTER"]? && base_name == "puts"
        params_debug = node.params.try &.map do |param|
          name = param.name ? String.new(param.name.not_nil!) : "(anon)"
          type_name = param.type_annotation ? String.new(param.type_annotation.not_nil!) : ""
          flags = [] of String
          flags << "splat" if param.is_splat
          flags << "double_splat" if param.is_double_splat
          flags << "block" if param.is_block
          "#{name}:#{type_name}#{flags.empty? ? "" : "[#{flags.join(",")}]" }"
        end
        params_debug_str = params_debug ? params_debug.join("|") : ""
        STDERR.puts "[DEBUG_PUTS_REGISTER] name=#{base_name} params=#{params_debug_str}"
      end
      if ENV.has_key?("DEBUG_STRING_METHOD_LOWER") && (base_name == "[]" || base_name == "char_index_to_byte_index")
        STDERR.puts "[DEBUG_REGISTER_FUNCTION] name=#{base_name} receiver=#{node.receiver ? String.new(node.receiver.not_nil!) : "(none)"} span=#{node.span.start_line}-#{node.span.end_line}"
      end
      if base_name == "main" && @current_class.nil? && !fun_def?(node)
        base_name = TOP_LEVEL_MAIN_BASE
        @top_level_main_defined = true
      end
      param_types = [] of TypeRef
      param_type_map = {} of String => TypeRef
      has_block = false

      old_typeof_locals = @current_typeof_locals
      @current_typeof_locals = param_type_map
      if params = node.params
        params.each do |param|
          next if named_only_separator?(param)
          if param.is_block
            has_block = true
            next
          end
          param_name = param.name.nil? ? "_" : String.new(param.name.not_nil!)
          param_type = if ta = param.type_annotation
                         type_ref_for_name(String.new(ta))
                       elsif param.is_double_splat
                         type_ref_for_name("NamedTuple")
                       else
                         TypeRef::VOID
                       end
          param_type_map[param_name] = param_type
          param_types << param_type
        end
      end

      return_type = if rt = node.return_type
                      type_ref_for_name(String.new(rt))
                    else
                      TypeRef::VOID
                    end
      @current_typeof_locals = old_typeof_locals

      # Register with mangled name.
      full_name = function_full_name_for_def(base_name, param_types, node.params, has_block)
      register_function_type(full_name, return_type)

      # Also register with base name for fallback lookup
      # (when function is not overloaded, we look up by base name)
      register_function_type(base_name, return_type)

      # Store AST for potential inline expansion (use mangled name)
      @function_defs[full_name] = node
      @function_def_arenas[full_name] = @arena
      unless @function_defs.has_key?(base_name)
        @function_defs[base_name] = node
        @function_def_arenas[base_name] = @arena
      end

      # Check if function contains yield
      if body = node.body
        if contains_yield?(body)
          @yield_functions.add(full_name)
          debug_hook("yield.register", full_name)
        end
      end
    end

    # Check if expression list contains yield
    private def contains_yield?(body : Array(ExprId)) : Bool
      body.any? { |expr_id| contains_yield_in_expr?(expr_id) }
    end

    private def def_contains_yield?(node : CrystalV2::Compiler::Frontend::DefNode, arena : CrystalV2::Compiler::Frontend::ArenaLike) : Bool
      return false unless body = node.body
      with_arena(arena) { contains_yield?(body) }
    end

    # Check if expression list contains a return
    private def contains_return?(body : Array(ExprId)) : Bool
      body.any? { |expr_id| contains_return_in_expr?(expr_id) }
    end

    private def yield_return_only?(body : Array(ExprId)) : Bool
      return false if body.empty?
      return false unless tail_is_return?(body)
      saw_return = false
      ok = true
      body.each do |expr_id|
        saw, good = scan_return_yield(expr_id)
        saw_return ||= saw
        ok &&= good
        break unless ok
      end
      saw_return && ok
    end

    private def tail_is_return?(body : Array(ExprId)) : Bool
      return false if body.empty?
      expr_id = body.last
      loop do
        expr_node = @arena[expr_id]
        case expr_node
        when CrystalV2::Compiler::Frontend::GroupingNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::MacroExpressionNode
          expr_id = expr_node.expression
        else
          return expr_node.is_a?(CrystalV2::Compiler::Frontend::ReturnNode)
        end
      end
    end

    private def yield_return_expr?(expr_id : ExprId) : Bool
      loop do
        expr_node = @arena[expr_id]
        case expr_node
        when CrystalV2::Compiler::Frontend::GroupingNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::MacroExpressionNode
          expr_id = expr_node.expression
        when CrystalV2::Compiler::Frontend::YieldNode
          return true
        when CrystalV2::Compiler::Frontend::CallNode
          callee = @arena[expr_node.callee]
          return callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
                   String.new(callee.name) == "yield"
        else
          return false
        end
      end
    end

    private def scan_return_yield(expr_id : ExprId) : {Bool, Bool}
      expr_node = @arena[expr_id]
      case expr_node
      when CrystalV2::Compiler::Frontend::ReturnNode
        if value = expr_node.value
          return {true, yield_return_expr?(value)}
        end
        return {true, false}
      when CrystalV2::Compiler::Frontend::IfNode
        saw = false
        ok = true
        expr_node.then_body.each do |child|
          child_saw, child_ok = scan_return_yield(child)
          saw ||= child_saw
          ok &&= child_ok
        end
        if elsifs = expr_node.elsifs
          elsifs.each do |branch|
            branch.body.each do |child|
              child_saw, child_ok = scan_return_yield(child)
              saw ||= child_saw
              ok &&= child_ok
            end
          end
        end
        if else_body = expr_node.else_body
          else_body.each do |child|
            child_saw, child_ok = scan_return_yield(child)
            saw ||= child_saw
            ok &&= child_ok
          end
        end
        return {saw, ok}
      when CrystalV2::Compiler::Frontend::CaseNode
        saw = false
        ok = true
        expr_node.when_branches.each do |branch|
          branch.body.each do |child|
            child_saw, child_ok = scan_return_yield(child)
            saw ||= child_saw
            ok &&= child_ok
          end
        end
        if else_branch = expr_node.else_branch
          else_branch.each do |child|
            child_saw, child_ok = scan_return_yield(child)
            saw ||= child_saw
            ok &&= child_ok
          end
        end
        if in_branches = expr_node.in_branches
          in_branches.each do |branch|
            branch.body.each do |child|
              child_saw, child_ok = scan_return_yield(child)
              saw ||= child_saw
              ok &&= child_ok
            end
          end
        end
        return {saw, ok}
      when CrystalV2::Compiler::Frontend::BeginNode
        saw = false
        ok = true
        expr_node.body.each do |child|
          child_saw, child_ok = scan_return_yield(child)
          saw ||= child_saw
          ok &&= child_ok
        end
        if clauses = expr_node.rescue_clauses
          clauses.each do |clause|
            clause.body.each do |child|
              child_saw, child_ok = scan_return_yield(child)
              saw ||= child_saw
              ok &&= child_ok
            end
          end
        end
        if else_body = expr_node.else_body
          else_body.each do |child|
            child_saw, child_ok = scan_return_yield(child)
            saw ||= child_saw
            ok &&= child_ok
          end
        end
        if ensure_body = expr_node.ensure_body
          ensure_body.each do |child|
            child_saw, child_ok = scan_return_yield(child)
            saw ||= child_saw
            ok &&= child_ok
          end
        end
        return {saw, ok}
      when CrystalV2::Compiler::Frontend::BlockNode
        if body = expr_node.body
          saw = false
          ok = true
          body.each do |child|
            child_saw, child_ok = scan_return_yield(child)
            saw ||= child_saw
            ok &&= child_ok
          end
          return {saw, ok}
        end
      when CrystalV2::Compiler::Frontend::LoopNode
        saw = false
        ok = true
        expr_node.body.each do |child|
          child_saw, child_ok = scan_return_yield(child)
          saw ||= child_saw
          ok &&= child_ok
        end
        return {saw, ok}
      when CrystalV2::Compiler::Frontend::ForNode
        saw = false
        ok = true
        expr_node.body.each do |child|
          child_saw, child_ok = scan_return_yield(child)
          saw ||= child_saw
          ok &&= child_ok
        end
        return {saw, ok}
      end
      {false, true}
    end

    private def yield_return_function?(name : String) : Bool
      return true if @yield_return_functions.includes?(name)
      return false if @yield_return_checked.includes?(name)
      @yield_return_checked.add(name)
      if def_node = @function_defs[name]?
        if body = def_node.body
          arena = @function_def_arenas[name]? || @arena
          with_arena(arena) do
            if yield_return_only?(body)
              @yield_return_functions.add(name)
              STDERR.puts "[YIELD_RETURN] mark=#{name}" if ENV["DEBUG_YIELD_RETURN"]?
            end
          end
        end
      end
      @yield_return_functions.includes?(name)
    end

    private def yield_return_function_for_call(mangled_name : String, base_name : String) : Bool
      result = yield_return_function?(mangled_name) || yield_return_function?(base_name)
      if mangled_base = mangled_name.split("$", 2)[0]?
        result ||= yield_return_function?(mangled_base)
      end
      STDERR.puts "[YIELD_RETURN] call mangled=#{mangled_name} base=#{base_name} result=#{result}" if ENV["DEBUG_YIELD_RETURN"]?
      result
    end

    private def infer_ivars_from_body(body : Array(ExprId), ivars : Array(IVarInfo), offset_ref : Pointer(Int32)) : Nil
      body.each { |expr_id| infer_ivars_from_expr(expr_id, ivars, offset_ref) }
    end

    private def infer_ivars_from_expr(expr_id : ExprId, ivars : Array(IVarInfo), offset_ref : Pointer(Int32)) : Nil
      return if expr_id.invalid?
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::AssignNode
        target_node = @arena[node.target]
        if target_node.is_a?(CrystalV2::Compiler::Frontend::InstanceVarNode)
          ivar_name = String.new(target_node.name)
          value_node = @arena[node.value]
          inferred = infer_type_from_class_ivar_assign(value_node)
          if ENV.has_key?("DEBUG_IVAR_INFER")
            inferred_name = inferred == TypeRef::VOID ? "Void" : get_type_name_from_ref(inferred)
            STDERR.puts "[IVAR_INFER] class=#{@current_class || ""} ivar=#{ivar_name} inferred=#{inferred_name}"
          end
          if inferred != TypeRef::VOID
            if idx = ivars.index { |iv| iv.name == ivar_name }
              if ivars[idx].type == TypeRef::VOID
                ivars[idx] = IVarInfo.new(ivar_name, inferred, ivars[idx].offset)
              end
            else
              ivars << IVarInfo.new(ivar_name, inferred, offset_ref.value)
              offset_ref.value += type_size(inferred)
            end
          end
        end
        infer_ivars_from_expr(node.value, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::ReturnNode
        node.value ? infer_ivars_from_expr(node.value.not_nil!, ivars, offset_ref) : nil
      when CrystalV2::Compiler::Frontend::IfNode
        infer_ivars_from_expr(node.condition, ivars, offset_ref)
        infer_ivars_from_body(node.then_body, ivars, offset_ref)
        infer_ivars_from_body(node.else_body.not_nil!, ivars, offset_ref) if node.else_body
      when CrystalV2::Compiler::Frontend::UnlessNode
        infer_ivars_from_expr(node.condition, ivars, offset_ref)
        infer_ivars_from_body(node.then_branch, ivars, offset_ref)
        infer_ivars_from_body(node.else_branch.not_nil!, ivars, offset_ref) if node.else_branch
      when CrystalV2::Compiler::Frontend::WhileNode
        infer_ivars_from_expr(node.condition, ivars, offset_ref)
        infer_ivars_from_body(node.body, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::UntilNode
        infer_ivars_from_expr(node.condition, ivars, offset_ref)
        infer_ivars_from_body(node.body, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::LoopNode
        infer_ivars_from_body(node.body, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::BlockNode
        infer_ivars_from_body(node.body, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::ProcLiteralNode
        infer_ivars_from_body(node.body, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::CaseNode
        node.when_branches.each { |w| infer_ivars_from_body(w.body, ivars, offset_ref) }
        infer_ivars_from_body(node.else_branch.not_nil!, ivars, offset_ref) if node.else_branch
      when CrystalV2::Compiler::Frontend::CallNode
        node.args.each { |arg| infer_ivars_from_expr(arg, ivars, offset_ref) }
        if block_id = node.block
          infer_ivars_from_expr(block_id, ivars, offset_ref)
        end
        if named = node.named_args
          named.each { |na| infer_ivars_from_expr(na.value, ivars, offset_ref) }
        end
      when CrystalV2::Compiler::Frontend::GroupingNode
        infer_ivars_from_expr(node.expression, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        infer_ivars_from_expr(node.expression, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::UnaryNode
        infer_ivars_from_expr(node.operand, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::BinaryNode
        infer_ivars_from_expr(node.left, ivars, offset_ref)
        infer_ivars_from_expr(node.right, ivars, offset_ref)
      when CrystalV2::Compiler::Frontend::IndexNode
        infer_ivars_from_expr(node.object, ivars, offset_ref)
        node.indexes.each { |idx| infer_ivars_from_expr(idx, ivars, offset_ref) }
      when CrystalV2::Compiler::Frontend::RangeNode
        infer_ivars_from_expr(node.begin_expr, ivars, offset_ref)
        infer_ivars_from_expr(node.end_expr, ivars, offset_ref)
      end
    end

    private def contains_yield_in_expr?(expr_id : ExprId) : Bool
      return false if expr_id.invalid?
      node = node_for_expr(expr_id)
      return false unless node
      case node
      when CrystalV2::Compiler::Frontend::YieldNode
        true
      when CrystalV2::Compiler::Frontend::AssignNode
        contains_yield_in_expr?(node.target) || contains_yield_in_expr?(node.value)
      when CrystalV2::Compiler::Frontend::ReturnNode
        node.value ? contains_yield_in_expr?(node.value.not_nil!) : false
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        contains_yield_in_expr?(node.object)
      when CrystalV2::Compiler::Frontend::CallNode
        if callee_id = node.callee
          callee_node = node_for_expr(callee_id)
          if callee_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            return true if String.new(callee_node.name) == "yield"
          end
          return true if contains_yield_in_expr?(callee_id)
        end
        node.args.each do |arg|
          return true if contains_yield_in_expr?(arg)
        end
        if block_id = node.block
          return true if contains_yield_in_expr?(block_id)
        end
        if named = node.named_args
          named.each do |na|
            return true if contains_yield_in_expr?(na.value)
          end
        end
        false
      when CrystalV2::Compiler::Frontend::UnaryNode
        contains_yield_in_expr?(node.operand)
      when CrystalV2::Compiler::Frontend::BinaryNode
        contains_yield_in_expr?(node.left) || contains_yield_in_expr?(node.right)
      when CrystalV2::Compiler::Frontend::GroupingNode
        contains_yield_in_expr?(node.expression)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        contains_yield_in_expr?(node.expression)
      when CrystalV2::Compiler::Frontend::ConstantNode
        contains_yield_in_expr?(node.value)
      when CrystalV2::Compiler::Frontend::IfNode
        contains_yield_in_expr?(node.condition) ||
          contains_yield?(node.then_body) ||
          (node.else_body ? contains_yield?(node.else_body.not_nil!) : false)
      when CrystalV2::Compiler::Frontend::UnlessNode
        contains_yield_in_expr?(node.condition) ||
          contains_yield?(node.then_branch) ||
          (node.else_branch ? contains_yield?(node.else_branch.not_nil!) : false)
      when CrystalV2::Compiler::Frontend::WhileNode
        contains_yield_in_expr?(node.condition) || contains_yield?(node.body)
      when CrystalV2::Compiler::Frontend::UntilNode
        contains_yield_in_expr?(node.condition) || contains_yield?(node.body)
      when CrystalV2::Compiler::Frontend::LoopNode
        contains_yield?(node.body)
      when CrystalV2::Compiler::Frontend::BlockNode
        contains_yield?(node.body)
      when CrystalV2::Compiler::Frontend::ProcLiteralNode
        contains_yield?(node.body)
      when CrystalV2::Compiler::Frontend::CaseNode
        node.when_branches.any? { |w| contains_yield?(w.body) } ||
          (node.else_branch ? contains_yield?(node.else_branch.not_nil!) : false)
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        return true if node.elements.any? { |el| contains_yield_in_expr?(el) }
        node.of_type ? contains_yield_in_expr?(node.of_type.not_nil!) : false
      when CrystalV2::Compiler::Frontend::TupleLiteralNode
        node.elements.any? { |el| contains_yield_in_expr?(el) }
      when CrystalV2::Compiler::Frontend::HashLiteralNode
        node.entries.any? do |entry|
          contains_yield_in_expr?(entry.key) || contains_yield_in_expr?(entry.value)
        end
      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        node.entries.any? { |entry| contains_yield_in_expr?(entry.value) }
      when CrystalV2::Compiler::Frontend::StringInterpolationNode
        node.pieces.any? do |piece|
          piece.kind == CrystalV2::Compiler::Frontend::StringPiece::Kind::Expression &&
            piece.expr && contains_yield_in_expr?(piece.expr.not_nil!)
        end
      when CrystalV2::Compiler::Frontend::IndexNode
        return true if contains_yield_in_expr?(node.object)
        node.indexes.any? { |idx| contains_yield_in_expr?(idx) }
      when CrystalV2::Compiler::Frontend::RangeNode
        contains_yield_in_expr?(node.begin_expr) || contains_yield_in_expr?(node.end_expr)
      when CrystalV2::Compiler::Frontend::BeginNode
        return true if contains_yield?(node.body)
        if clauses = node.rescue_clauses
          return true if clauses.any? { |cl| contains_yield?(cl.body) }
        end
        return true if node.else_body && contains_yield?(node.else_body.not_nil!)
        return true if node.ensure_body && contains_yield?(node.ensure_body.not_nil!)
        false
      else
        false
      end
    end

    private def contains_return_in_expr?(expr_id : ExprId) : Bool
      return false if expr_id.invalid?
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::ReturnNode
        true
      when CrystalV2::Compiler::Frontend::AssignNode
        contains_return_in_expr?(node.target) || contains_return_in_expr?(node.value)
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        contains_return_in_expr?(node.object)
      when CrystalV2::Compiler::Frontend::CallNode
        if callee_id = node.callee
          return true if contains_return_in_expr?(callee_id)
        end
        if args = node.args
          args.each do |arg|
            return true if contains_return_in_expr?(arg)
          end
        end
        if block_id = node.block
          return true if contains_return_in_expr?(block_id)
        end
        if named = node.named_args
          named.each do |na|
            return true if contains_return_in_expr?(na.value)
          end
        end
        false
      when CrystalV2::Compiler::Frontend::UnaryNode
        contains_return_in_expr?(node.operand)
      when CrystalV2::Compiler::Frontend::BinaryNode
        contains_return_in_expr?(node.left) || contains_return_in_expr?(node.right)
      when CrystalV2::Compiler::Frontend::GroupingNode
        contains_return_in_expr?(node.expression)
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        contains_return_in_expr?(node.expression)
      when CrystalV2::Compiler::Frontend::IfNode
        contains_return_in_expr?(node.condition) ||
          contains_return?(node.then_body) ||
          (node.else_body ? contains_return?(node.else_body.not_nil!) : false)
      when CrystalV2::Compiler::Frontend::UnlessNode
        contains_return_in_expr?(node.condition) ||
          contains_return?(node.then_branch) ||
          (node.else_branch ? contains_return?(node.else_branch.not_nil!) : false)
      when CrystalV2::Compiler::Frontend::WhileNode
        contains_return_in_expr?(node.condition) || contains_return?(node.body)
      when CrystalV2::Compiler::Frontend::UntilNode
        contains_return_in_expr?(node.condition) || contains_return?(node.body)
      when CrystalV2::Compiler::Frontend::LoopNode
        contains_return?(node.body)
      when CrystalV2::Compiler::Frontend::BlockNode
        contains_return?(node.body)
      when CrystalV2::Compiler::Frontend::ProcLiteralNode
        contains_return?(node.body)
      when CrystalV2::Compiler::Frontend::CaseNode
        node.when_branches.any? { |w| contains_return?(w.body) } ||
          (node.else_branch ? contains_return?(node.else_branch.not_nil!) : false)
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        return true if node.elements.any? { |el| contains_return_in_expr?(el) }
        node.of_type ? contains_return_in_expr?(node.of_type.not_nil!) : false
      when CrystalV2::Compiler::Frontend::TupleLiteralNode
        node.elements.any? { |el| contains_return_in_expr?(el) }
      when CrystalV2::Compiler::Frontend::HashLiteralNode
        node.entries.any? do |entry|
          contains_return_in_expr?(entry.key) || contains_return_in_expr?(entry.value)
        end
      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        node.entries.any? { |entry| contains_return_in_expr?(entry.value) }
      when CrystalV2::Compiler::Frontend::StringInterpolationNode
        node.pieces.any? do |piece|
          piece.kind == CrystalV2::Compiler::Frontend::StringPiece::Kind::Expression &&
            piece.expr && contains_return_in_expr?(piece.expr.not_nil!)
        end
      when CrystalV2::Compiler::Frontend::IndexNode
        return true if contains_return_in_expr?(node.object)
        node.indexes.any? { |idx| contains_return_in_expr?(idx) }
      when CrystalV2::Compiler::Frontend::RangeNode
        contains_return_in_expr?(node.begin_expr) || contains_return_in_expr?(node.end_expr)
      when CrystalV2::Compiler::Frontend::BeginNode
        return true if contains_return?(node.body)
        if clauses = node.rescue_clauses
          return true if clauses.any? { |cl| contains_return?(cl.body) }
        end
        return true if node.else_body && contains_return?(node.else_body.not_nil!)
        return true if node.ensure_body && contains_return?(node.ensure_body.not_nil!)
        false
      else
        false
      end
    end

    # Check if a module method exists (with any signature - for module detection)
    private def is_module_method?(module_name : String, method_name : String) : Bool
      base_name = "#{module_name}.#{method_name}"
      # O(1) lookup: check exact match or mangled version exists
      @function_types.has_key?(base_name) || has_function_base?(base_name)
    end

    # Look up return type of a function by name
    private def get_function_return_type(name : String) : TypeRef
      # First check pre-registered signatures (for forward references)
      if type = @function_types[name]?
        # For base names (no $ suffix), treat VOID/NIL as unknown and fall back
        # to cached base return types from other overloads.
        if name.includes?("$")
          return type
        end
        return type unless type == TypeRef::VOID || type == TypeRef::NIL
      end
      # If this is a base name (no $ suffix), use cached return type if available.
      if cached = @function_base_return_types[name]?
        return cached
      end
      # Fall back to already-lowered functions
      @module.functions.each do |func|
        return func.return_type if func.name == name
      end
      TypeRef::VOID
    end

    # Get instance variable offset from current class
    private def get_ivar_offset(name : String) : Int32
      if class_name = @current_class
        if class_info = @class_info[class_name]?
          class_info.ivars.each do |ivar|
            return ivar.offset if ivar.name == name
          end
        end
      end
      0  # Default offset
    end

    # Get instance variable type from current class
    private def get_ivar_type(name : String) : TypeRef?
      if class_name = @current_class
        if class_info = @class_info[class_name]?
          class_info.ivars.each do |ivar|
            return ivar.type if ivar.name == name
          end
        end
      end
      nil
    end

    private def class_info_for_type(receiver_type : TypeRef) : ClassInfo?
      return nil if receiver_type == TypeRef::VOID

      @class_info.each_value do |info|
        return info if info.type_ref.id == receiver_type.id
      end

      if desc = @module.get_type_descriptor(receiver_type)
        if info = @class_info[desc.name]?
          return info
        end
        @class_info.each do |name, info|
          return info if name.ends_with?("::#{desc.name}") || name == desc.name
        end
      end

      nil
    end

    private def type_name_exists?(name : String) : Bool
      @class_info.has_key?(name) ||
        @generic_templates.has_key?(name) ||
        @type_aliases.has_key?(name) ||
        (@enum_info && @enum_info.not_nil!.has_key?(name)) ||
        @module_defs.has_key?(name) ||
        @module.is_lib?(name)
    end

    private def constant_name_exists?(name : String) : Bool
      @constant_defs.includes?(name)
    end

    private def constant_full_name(owner_name : String?, name : String) : String
      if owner_name && !owner_name.empty?
        "#{owner_name}::#{name}"
      else
        name
      end
    end

    private def constant_storage_info(full_name : String) : Tuple(String, String)
      if idx = full_name.rindex("::")
        owner = full_name[0, idx]
        const_name = full_name[(idx + 2)..-1]
      else
        owner = "Object"
        const_name = full_name
      end
      {owner, const_name}
    end

    private def resolve_constant_name_in_context(name : String) : String?
      return nil if name.empty?
      return name if constant_name_exists?(name)

      if name.includes?("::")
        resolved = resolve_path_string_in_context(name)
        return resolved if constant_name_exists?(resolved)
        return name if constant_name_exists?(name)
        return nil
      end

      namespaces = [] of String
      if override = @current_namespace_override
        namespaces << override
        if info = split_generic_base_and_args(override)
          namespaces << info[:base] unless namespaces.includes?(info[:base])
        end
      end
      if current = @current_class
        namespaces << current unless namespaces.includes?(current)
        if info = split_generic_base_and_args(current)
          namespaces << info[:base] unless namespaces.includes?(info[:base])
        end
      end

      namespaces.each do |namespace|
        parts = namespace.split("::")
        while parts.size > 0
          qualified_name = (parts + [name]).join("::")
          return qualified_name if constant_name_exists?(qualified_name)
          parts.pop
        end
      end

      nil
    end

    private def record_constant_definition(owner_name : String?, name : String, value_id : ExprId, arena : CrystalV2::Compiler::Frontend::ArenaLike)
      full_name = constant_full_name(owner_name, name)
      @constant_defs.add(full_name)
      return if @constant_types.has_key?(full_name)

      old_arena = @arena
      old_class = @current_class
      @arena = arena
      @current_class = owner_name
      inferred = infer_type_from_expr(value_id, owner_name) || TypeRef::VOID
      @current_class = old_class
      @arena = old_arena

      @constant_types[full_name] = inferred
    end

    private def emit_constant_get(ctx : LoweringContext, full_name : String) : ValueId
      owner, const_name = constant_storage_info(full_name)
      const_type = @constant_types[full_name]? || TypeRef::VOID
      get = ClassVarGet.new(ctx.next_id, const_type, owner, const_name)
      ctx.emit(get)
      ctx.register_type(get.id, const_type)
      get.id
    end

    private def resolve_type_name_in_context(name : String) : String
      return name if name.empty?
      if name.starts_with?("::")
        return name.size > 2 ? name[2..] : ""
      end

      if name == "self"
        return @current_class || name
      end

      if info = split_generic_base_and_args(name)
        resolved_base = resolve_type_name_in_context(info[:base])
        resolved_args = split_generic_type_args(info[:args]).map do |arg|
          normalize_tuple_literal_type_name(resolve_type_name_in_context(arg.strip))
        end.join(", ")
        return resolved_base == info[:base] && resolved_args == info[:args] ? name : "#{resolved_base}(#{resolved_args})"
      end

      return resolve_class_name_in_context(name) unless name.includes?("::")
      return name if type_name_exists?(name)

      if current = @current_class
        parts = current.split("::")
        while parts.size > 0
          qualified_name = (parts + [name]).join("::")
          return qualified_name if type_name_exists?(qualified_name)
          parts.pop
        end
      end

      name
    end

    private def resolve_path_string_in_context(path : String) : String
      return path if path.empty?
      if path.starts_with?("::")
        return path.size > 2 ? path[2..] : ""
      end
      return resolve_type_name_in_context(path) unless path.includes?("::")

      parts = path.split("::")
      return path if parts.empty?

      resolved_head = resolve_class_name_in_context(parts.first)
      return path if resolved_head == parts.first

      resolved = ([resolved_head] + parts[1..]).join("::")
      return resolved if type_name_exists?(resolved)
      return path if type_name_exists?(path)
      resolved
    end

    private def function_context_from_name(name : String) : String?
      base = name
      if dollar = base.index('$')
        base = base[0, dollar]
      end

      if hash = base.index('#')
        return base[0, hash]
      elsif dot = base.index('.')
        return base[0, dot]
      end

      nil
    end

    # Resolve method name with inheritance: look in class and all parent classes
    # Resolve a short class name to its fully qualified name using current context
    # E.g., if @current_class is "CrystalV2::Compiler::Frontend::Span" and name is "Span",
    # returns "CrystalV2::Compiler::Frontend::Span"
    private def resolve_class_name_in_context(name : String) : String
      # If this is a generic type name, resolve the base in context and
      # reconstruct with the original type args.
      if info = split_generic_base_and_args(name)
        resolved_base = resolve_class_name_in_context(info[:base])
        result = resolved_base == info[:base] ? name : "#{resolved_base}(#{info[:args]})"
        debug_hook_type_resolve(name, @current_class || "", result)
        return result
      end

      result = name  # Default fallback

      namespaces = [] of String
      if override = @current_namespace_override
        namespaces << override
        if info = split_generic_base_and_args(override)
          namespaces << info[:base] unless namespaces.includes?(info[:base])
        end
      end
      if current = @current_class
        namespaces << current unless namespaces.includes?(current)
        if info = split_generic_base_and_args(current)
          namespaces << info[:base] unless namespaces.includes?(info[:base])
        end
      end

      found = false
      # Prefer the override namespace (module mixins), then the current class namespace.
      namespaces.each do |namespace|
        # Extract namespace: "Foo::Bar::Baz" -> "Foo::Bar"
        parts = namespace.split("::")

        # Try full namespace first (e.g., Foo::Bar::Baz::Name), then increasingly shorter
        # This handles cases where we're inside module Foo::Bar and reference Name
        # which should resolve to Foo::Bar::Name before trying Foo::Name
        while parts.size > 0
          qualified_name = (parts + [name]).join("::")
          if type_name_exists?(qualified_name)
            result = qualified_name
            found = true
            break
          end
          parts.pop
        end
        break if found
      end

      unless found
        # Fall back to a top-level type
        if type_name_exists?(name)
          result = name
        # Resolve to the override namespace if it matches the short name.
        elsif (override = @current_namespace_override) && (last_part = override.split("::").last) && last_part == name && type_name_exists?(override)
          result = override
        # Also try the exact class name if current class matches
        # E.g., inside Span, "Span" should resolve to the same class
        elsif (current = @current_class) && (last_part = current.split("::").last) && last_part == name && type_name_exists?(current)
          result = current
        end
      end

      # Last-resort: if we are inside a generic class, try matching nested generic templates
      # by short name under the current class namespace (stripping generic args if needed).
      if result == name && (current = @current_class)
        prefixes = [] of String
        prefixes << current
        if info = split_generic_base_and_args(current)
          prefixes << info[:base] unless prefixes.includes?(info[:base])
        end
        candidates = [] of String
        @generic_templates.each_key do |key|
          next unless key.ends_with?("::#{name}")
          next unless prefixes.any? { |prefix| key.starts_with?(prefix) }
          candidates << key
        end
        if candidates.size == 1
          result = candidates.first
        end
      end

      # Final fallback: resolve unique short-name matches (avoids short-name leakage)
      if result == name && (candidates = @short_type_index[name]?)
        if candidates.size == 1
          result = candidates.first
        end
      end

      debug_hook_type_resolve(name, @current_class || "", result)
      result
    end

    private def resolve_class_name_for_definition(name : String) : String
      if name.starts_with?("::")
        name = name.size > 2 ? name[2..] : ""
      end
      return name if name.includes?("::")
      if current = @current_class
        return "#{current}::#{name}"
      end
      name
    end

    private def resolve_type_alias_chain(name : String) : String
      resolved = @type_aliases[name]? || LIBC_TYPE_ALIASES[name]? || name
      depth = 0
      while (next_resolved = @type_aliases[resolved]? || LIBC_TYPE_ALIASES[resolved]?) && next_resolved != resolved && depth < 10
        resolved = next_resolved
        depth += 1
      end
      resolved
    end

    # Split a generic type argument list like "String, Array(Int32), Hash(K, V)"
    # into top-level arguments, respecting nested parentheses.
    private def split_generic_type_args(params_str : String) : Array(String)
      args = [] of String
      depth = 0
      start = 0
      i = 0
      while i < params_str.bytesize
        ch = params_str.byte_at(i).unsafe_chr
        case ch
        when '(', '{', '['
          depth += 1
        when ')', '}', ']'
          depth -= 1 if depth > 0
        when ','
          if depth == 0
            part = params_str[start, i - start].strip
            args << part unless part.empty?
            start = i + 1
          end
        end
        i += 1
      end
      tail = params_str[start, params_str.size - start].strip
      args << tail unless tail.empty?
      args
    end

    # Split a full generic type name into base and args, handling nested parens in the base.
    # Example: "Foo(Bar, Baz)::Entry(Qux)" -> base="Foo(Bar, Baz)::Entry", args="Qux"
    private def split_generic_base_and_args(name : String) : NamedTuple(base: String, args: String)?
      return nil unless name.ends_with?(")")

      depth = 0
      i = name.bytesize - 1
      while i >= 0
        ch = name.byte_at(i).unsafe_chr
        case ch
        when ')'
          depth += 1
        when '('
          depth -= 1
          if depth == 0
            base = name[0, i]
            args = name[i + 1, name.size - i - 2]
            return {base: base, args: args}
          end
        end
        i -= 1
      end

      nil
    end

    private def substitute_type_params_in_type_name(name : String) : String
      if substitution = @type_param_map[name]?
        return substitution
      end

      if name.includes?("|")
        parts = name.split("|").map(&.strip)
        return parts.map { |part| substitute_type_params_in_type_name(part) }.join(" | ")
      end

      if name.ends_with?("?")
        base = name[0, name.size - 1]
        return "#{substitute_type_params_in_type_name(base)}?"
      end

      if info = split_generic_base_and_args(name)
        args = split_generic_type_args(info[:args])
        new_args = args.map do |arg|
          normalize_tuple_literal_type_name(substitute_type_params_in_type_name(arg.strip))
        end
        return "#{info[:base]}(#{new_args.join(", ")})"
      end

      name
    end

    private def find_top_level_arrow(name : String) : Int32?
      depth = 0
      i = 0
      while i + 1 < name.bytesize
        ch = name.byte_at(i).unsafe_chr
        case ch
        when '(', '{', '['
          depth += 1
        when ')', '}', ']'
          depth -= 1 if depth > 0
        when '-'
          if depth == 0 && name.byte_at(i + 1).unsafe_chr == '>'
            return i
          end
        end
        i += 1
      end
      nil
    end

    private def extract_proc_return_type_name(type_name : String) : String?
      stripped = type_name.strip
      if stripped.starts_with?("Proc(") && stripped.ends_with?(")")
        inner = stripped[5, stripped.size - 6]
        args = split_generic_type_args(inner)
        if ret = args.last?
          ret = ret.strip
          return ret unless ret.empty?
        end
      end
      if arrow_index = find_top_level_arrow(stripped)
        right = stripped[arrow_index + 2, stripped.size - arrow_index - 2].strip
        return right unless right.empty?
      end
      nil
    end

    private def proc_input_type_names(type_name : String) : Array(String)?
      stripped = type_name.strip
      return nil if stripped.empty?

      if stripped.starts_with?("Proc(") && stripped.ends_with?(")")
        inner = stripped[5, stripped.size - 6]
        args = split_generic_type_args(inner)
        return [] of String if args.size <= 1
        return args[0...-1]
      end

      if arrow_index = find_top_level_arrow(stripped)
        left = stripped[0, arrow_index].strip
        return [] of String if left.empty?
        return split_generic_type_args(left)
      end

      nil
    end

    private def substitute_type_param(type_name : String, param_name : String, actual_name : String) : String
      return type_name if param_name.empty? || actual_name.empty?
      pattern = /(^|[^A-Za-z0-9_:])#{Regex.escape(param_name)}([^A-Za-z0-9_:]|$)/
      type_name.gsub(pattern, "\\1#{actual_name}\\2")
    end

    private def type_param_map_debug_string : String
      return "" if @type_param_map.empty?
      @type_param_map.map { |param, actual| "#{param}=#{actual}" }.join(",")
    end

    private def type_param_like?(name : String) : Bool
      return false if name.empty?
      return false if name.includes?("::")
      return false unless name.matches?(/\A[A-Z][A-Za-z0-9_]*\z/)
      return false if primitive_self_type(name)
      return false if builtin_alias_target?(name)
      return false if @class_info.has_key?(name)
      return false if @short_type_index.has_key?(name)
      return false if @module_defs.has_key?(name)
      return false if @type_aliases.has_key?(name)
      return false if LIBC_TYPE_ALIASES.has_key?(name)
      true
    end

    private def known_type_name?(name : String) : Bool
      return true if name.empty?
      return true if primitive_self_type(name)
      return true if @class_info.has_key?(name)
      return true if @module_defs.has_key?(name)
      return true if @type_aliases.has_key?(name)
      return true if LIBC_TYPE_ALIASES.has_key?(name)
      false
    end

    private def unbound_type_params_from_type_name(type_name : String) : Set(String)
      return Set(String).new if type_name.empty?
      tokens = [] of String
      type_name.scan(/[A-Z][A-Za-z0-9_]*/) do |match|
        tokens << match[0]
      end
      return Set(String).new if tokens.empty?

      unbound = Set(String).new
      tokens.each do |token|
        next if @type_param_map.has_key?(token)
        next if known_type_name?(token)
        unbound.add(token)
      end

      unbound
    end

    private def def_has_unbound_type_params?(node : CrystalV2::Compiler::Frontend::DefNode) : Bool
      if params = node.params
        params.each do |param|
          if ta = param.type_annotation
            if param.is_block
              if type_param_name = extract_proc_return_type_name(String.new(ta))
                if type_param_like?(type_param_name) && !@type_param_map.has_key?(type_param_name)
                  return true
                end
              end
            end
            return true unless unbound_type_params_from_type_name(String.new(ta)).empty?
          end
        end
      end

      if rt = node.return_type
        return true unless unbound_type_params_from_type_name(String.new(rt)).empty?
      end

      false
    end

    private def type_name_includes_param?(type_name : String, param_name : String) : Bool
      return false if param_name.empty?
      pattern = /(^|[^A-Za-z0-9_:])#{Regex.escape(param_name)}([^A-Za-z0-9_:]|$)/
      !!type_name.match(pattern)
    end

    private def unresolved_generic_receiver?(type_name : String) : Bool
      info = split_generic_base_and_args(type_name)
      return false unless info

      template = @generic_templates[info[:base]]?
      return false unless template

      args = split_generic_type_args(info[:args]).map(&.strip)
      return false unless args.size == template.type_params.size

      template.type_params.any? do |param|
        args.any? { |arg| type_name_includes_param?(arg, param) }
      end
    end

    private def substitute_type_params(type_name : String, param_map : Hash(String, String)) : String
      result = type_name
      param_map.each do |param, actual|
        result = substitute_type_param(result, param, actual)
      end
      result
    end

    private def receiver_name_from_method_name(method_name : String) : String?
      if idx = method_name.index('#')
        return method_name[0, idx]
      elsif idx = method_name.index('.')
        return method_name[0, idx]
      end
      nil
    end

    private def type_param_map_for_receiver_name(method_name : String) : Hash(String, String)
      receiver = receiver_name_from_method_name(method_name)
      return {} of String => String unless receiver

      info = split_generic_base_and_args(receiver)
      return {} of String => String unless info

      base = info[:base]
      args = split_generic_type_args(info[:args]).map do |arg|
        normalize_tuple_literal_type_name(arg.strip)
      end
      template = @generic_templates[base]?
      return {} of String => String unless template && template.type_params.size == args.size

      mapping = {} of String => String
      template.type_params.each_with_index do |param, i|
        mapping[param] = args[i].strip
      end
      mapping
    end

    private def block_return_type_name(ctx : LoweringContext, block_id : BlockId) : String?
      block = ctx.get_block(block_id)
      term = block.terminator
      return nil unless term.is_a?(Return)
      value_id = term.value
      return nil unless value_id
      type_ref = ctx.type_of(value_id)
      return nil if type_ref == TypeRef::VOID
      type_name = get_type_name_from_ref(type_ref)
      return nil if type_name == "Void" || type_name == "Unknown"
      type_name
    end

    private def resolve_block_dependent_return_type(
      mangled_method_name : String,
      base_method_name : String,
      block_return_name : String
    ) : TypeRef?
      return nil if block_return_name.empty?

      func_def = @function_defs[mangled_method_name]? || @function_defs[base_method_name]?
      return nil unless func_def

      return_type_slice = func_def.return_type
      return nil unless return_type_slice
      return_type_name = String.new(return_type_slice)
      return nil if return_type_name.empty?

      block_param = func_def.params.try(&.find(&.is_block))
      return nil unless block_param

      block_type = block_param.type_annotation
      return nil unless block_type

      block_type_name = String.new(block_type)
      type_param_name = extract_proc_return_type_name(block_type_name)
      return nil unless type_param_name && !type_param_name.empty?

      substituted = substitute_type_param(return_type_name, type_param_name, block_return_name)
      return nil if substituted == return_type_name

      type_ref_for_name(substituted)
    end

    private def block_return_type_param_name(
      mangled_method_name : String,
      base_method_name : String
    ) : String?
      func_def = @function_defs[mangled_method_name]? || @function_defs[base_method_name]?
      return nil unless func_def

      block_param = func_def.params.try(&.find(&.is_block))
      return nil unless block_param

      block_type = block_param.type_annotation
      return nil unless block_type

      type_param_name = extract_proc_return_type_name(String.new(block_type))
      return nil unless type_param_name && type_param_like?(type_param_name)

      type_param_name
    end

    private def block_param_types_for_call(
      mangled_method_name : String,
      base_method_name : String,
      receiver_type : TypeRef?
    ) : Array(TypeRef)?
      func_def = @function_defs[mangled_method_name]? || @function_defs[base_method_name]?
      return nil unless func_def

      block_param = func_def.params.try(&.find(&.is_block))
      return nil unless block_param

      type_slice = block_param.type_annotation
      return nil unless type_slice

      input_names = proc_input_type_names(String.new(type_slice))
      return nil unless input_names && !input_names.empty?

      param_map = function_type_param_map_for(mangled_method_name, base_method_name)
      if param_map && !param_map.empty?
        param_map = param_map.dup
      else
        param_map = nil
      end

      receiver_map = type_param_map_for_receiver_name(base_method_name)
      if param_map.nil? || param_map.empty?
        param_map = receiver_map
      end

      if !@type_param_map.empty?
        if param_map && !param_map.empty?
          param_map = @type_param_map.merge(param_map)
        else
          param_map = @type_param_map.dup
        end
      end

      if receiver_type && receiver_type != TypeRef::VOID
        needs_fallback = param_map.nil? || param_map.empty? ||
                         input_names.any? { |name| type_param_like?(name) && !param_map.try(&.has_key?(name)) }
        if needs_fallback
          if type_desc = @module.get_type_descriptor(receiver_type)
            if element_name = element_type_for_type_name(type_desc.name)
              param_map = param_map ? param_map.not_nil!.dup : {} of String => String
              input_names.each do |name|
                next unless type_param_like?(name)
                param_map[name] ||= element_name
              end
            end
          end
        end
      end

      resolved_names = if param_map.nil? || param_map.empty?
                         input_names
                       else
                         input_names.map { |name| substitute_type_params(name, param_map.not_nil!) }
                       end

      if DebugHooks::ENABLED && (base_method_name.includes?("map") || mangled_method_name.includes?("map"))
        map_str = param_map ? param_map.not_nil!.map { |k, v| "#{k}=#{v}" }.join(",") : ""
        debug_hook(
          "block.param.types",
          "method=#{base_method_name} mangled=#{mangled_method_name} inputs=#{input_names.join(",")} resolved=#{resolved_names.join(",")} map=#{map_str}"
        )
      end

      resolved_names.map { |name| type_ref_for_name(name) }
    end

    private def intern_proc_type(type_names : Array(String)) : TypeRef
      names = type_names
      names = ["Nil"] if names.empty?
      type_refs = names.map { |tn| type_ref_for_name(tn) }
      @module.intern_type(TypeDescriptor.new(TypeKind::Proc, "Proc", type_refs))
    end

    private def proc_type_ref_for_name(name : String) : TypeRef?
      stripped = name.strip
      return nil if stripped.empty?

      if stripped.starts_with?("Proc(") && stripped.ends_with?(")")
        inner = stripped[5, stripped.size - 6]
        return intern_proc_type(split_generic_type_args(inner))
      end

      if arrow_index = find_top_level_arrow(stripped)
        left = stripped[0, arrow_index].strip
        right = stripped[arrow_index + 2, stripped.size - arrow_index - 2].strip
        args = left.empty? ? [] of String : split_generic_type_args(left)
        ret_name = right.empty? ? "Nil" : right
        return intern_proc_type(args + [ret_name])
      end

      nil
    end

    # Ensure a generic instantiation referenced via a type annotation (e.g. `Hash(String, ValueId)`)
    # is monomorphized before lowering code that calls methods on it.
    private def ensure_monomorphized_type(type_ref : TypeRef) : Nil
      type_desc = @module.get_type_descriptor(type_ref)
      return unless type_desc

      name = type_desc.name
      info = split_generic_base_and_args(name)
      return unless info

      base = info[:base]
      return if base == "Pointer"
      template = @generic_templates[base]?
      return unless template
      return if @monomorphized.includes?(name)

      type_args = split_generic_type_args(info[:args])
      return unless template.type_params.size == type_args.size

      monomorphize_generic_class(base, type_args, name)
    end

    # Returns the fully qualified method name (e.g., "Animal#age" or "Animal#age:Int32") or nil if not found
    # Note: Returns the base name without mangling - caller should mangle with actual arg types
    private def resolve_method_with_inheritance(class_name : String, method_name : String) : String?
      class_name = normalize_method_owner_name(class_name)
      current = class_name
      visited = Set(String).new
      while true
        break if visited.includes?(current)
        visited << current
        test_name = "#{current}##{method_name}"
        # O(1) lookup: check exact match first, then check if base name exists
        if @function_types.has_key?(test_name) || has_function_base?(test_name)
          return test_name  # Return base name - caller will mangle
        end
        # Also check included modules for this class
        if included = @class_included_modules[current]?
          included.each do |module_name|
            # Strip generic params for module lookup (Indexable(T) -> Indexable)
            base_module = module_name.split('(').first
            module_method = "#{base_module}##{method_name}"
            if @function_types.has_key?(module_method) || has_function_base?(module_method)
              # Return with class prefix so it gets lowered for this class
              return test_name
            end
          end
        end
        # Try parent class
        if info = @class_info[current]?
          if parent = info.parent_name
            current = parent
          else
            break
          end
        else
          break
        end
      end
      if template_owner = primitive_template_owner(class_name)
        template_method = "#{template_owner}##{method_name}"
        if @function_types.has_key?(template_method) || has_function_base?(template_method)
          return "#{class_name}##{method_name}"
        end
      end
      if class_name != "Object"
        object_method = "Object##{method_name}"
        if @function_types.has_key?(object_method) || has_function_base?(object_method)
          return "#{class_name}##{method_name}"
        end
      end
      nil
    end

    # Resolve class method name (Class.method) with inheritance.
    # Returns base name without mangling or nil if not found.
    private def resolve_class_method_with_inheritance(class_name : String, method_name : String) : String?
      class_name = normalize_method_owner_name(class_name)
      current = class_name
      visited = Set(String).new
      while true
        break if visited.includes?(current)
        visited << current
        test_name = "#{current}.#{method_name}"
        if @function_types.has_key?(test_name) || has_function_base?(test_name)
          return test_name
        end
        if info = @class_info[current]?
          if parent = info.parent_name
            current = parent
            next
          end
        end
        break
      end
      nil
    end

    # Infer type argument for generic class constructor call
    # E.g., Array.new(size, value) -> infer T from value's type
    #       Array.new(size) { block } -> infer T from block's return type
    private def infer_generic_type_arg(class_name : String, args : Array(CrystalV2::Compiler::Frontend::ExprId)?, block : CrystalV2::Compiler::Frontend::ExprId?, ctx : LoweringContext) : String?
      # For Array.new(size, initial_value), infer from initial_value (second arg)
      if class_name == "Array" && args && args.size >= 2
        value_arg = @arena[args[1]]
        return infer_type_from_expr(value_arg)
      end

      # For Array.new(size) { block }, infer from block's return type
      if class_name == "Array" && block
        block_node = @arena[block]
        if block_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
          if body = block_node.body
            # Look at last expression in block to infer return type
            last_expr_id = body.last?
            if last_expr_id
              last_expr = @arena[last_expr_id]
              return infer_type_from_expr(last_expr)
            end
          end
        end
      end

      # For Slice.new(pointer, size, ...), infer from first arg's pointed-to type
      if class_name == "Slice" && args && args.size >= 1
        pointer_arg_id = args[0]
        pointer_arg = @arena[pointer_arg_id]
        # Try to get the pointer's element type
        # First check if it's an ivar access (like @buffer which is Pointer(UInt8))
        if pointer_arg.is_a?(CrystalV2::Compiler::Frontend::InstanceVarNode)
          ivar_name = String.new(pointer_arg.name)
          # Look up ivar type in current class
          if current_class_name = @current_class
            if class_info = @class_info[current_class_name]?
              if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
                ivar_type = ivar_info.type
                # If it's a Pointer type, extract element type
                if type_desc = @module.get_type_descriptor(ivar_type)
                  type_str = type_desc.name
                  if type_str.starts_with?("Pointer(") && type_str.ends_with?(")")
                    element_type = type_str[8...-1]  # Extract "UInt8" from "Pointer(UInt8)"
                    return element_type
                  end
                end
              end
            end
          end
        end
        # Default to UInt8 for Slice (Bytes is Slice(UInt8))
        # This is the most common case and avoids side effects from lower_expr
        return "UInt8"
      end

      # For Atomic.new(value), infer from the value's type.
      if class_name == "Atomic" && args && args.size >= 1
        if inferred_ref = infer_type_from_expr(args[0], @current_class)
          inferred_name = get_type_name_from_ref(inferred_ref)
          return inferred_name unless inferred_name.empty? || inferred_name == "Void" || inferred_name == "Unknown"
        end
        value_node = @arena[args[0]]
        if inferred_name = infer_type_from_expr(value_node)
          return inferred_name
        end
      end

      # For Hash.new, return nil (needs two type params - more complex)
      nil
    end

    # Infer type name from an expression AST node
    private def infer_type_from_expr(node) : String?
      case node
      when CrystalV2::Compiler::Frontend::StringNode, CrystalV2::Compiler::Frontend::StringInterpolationNode
        "String"
      when CrystalV2::Compiler::Frontend::NumberNode
        # Check if it's a float (has decimal point or exponent)
        num_str = String.new(node.value)
        if num_str.includes?('.') || num_str.includes?('e') || num_str.includes?('E')
          "Float64"
        else
          "Int32"
        end
      when CrystalV2::Compiler::Frontend::BoolNode
        "Bool"
      when CrystalV2::Compiler::Frontend::CharNode
        "Char"
      when CrystalV2::Compiler::Frontend::SymbolNode
        "Symbol"
      when CrystalV2::Compiler::Frontend::NilNode
        "Nil"
      when CrystalV2::Compiler::Frontend::PathNode
        resolve_path_string_in_context(collect_path_string(node))
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(node.name)
        if locals = @current_typeof_locals
          if type_ref = locals[name]?
            if type_name = concrete_type_name_for(type_ref)
              return type_name
            end
            type_name = get_type_name_from_ref(type_ref)
            return type_name unless type_name.empty? || type_name == "Void" || type_name == "Unknown"
          end
        end
        if type_name = lookup_typeof_local_name(name)
          return type_name
        end
        nil
      when CrystalV2::Compiler::Frontend::InstanceVarNode
        if current_class_name = @current_class
          if info = @class_info[current_class_name]?
            ivar_name = String.new(node.name)
            if ivar = info.ivars.find { |entry| entry.name == ivar_name }
              if type_name = concrete_type_name_for(ivar.type)
                return type_name
              end
              type_name = get_type_name_from_ref(ivar.type)
              return type_name unless type_name.empty? || type_name == "Void" || type_name == "Unknown"
            end
          end
        end
        nil
      when CrystalV2::Compiler::Frontend::CallNode
        # For calls like String.new(...), try to get return type
        callee = node.callee
        callee_node = @arena[callee]
        case callee_node
        when CrystalV2::Compiler::Frontend::MemberAccessNode
          obj_node = @arena[callee_node.object]
          member_name = String.new(callee_node.member)
          if obj_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode) && member_name == "new"
            # ClassName.new() returns ClassName
            return String.new(obj_node.name)
          elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) && member_name == "new"
            name = String.new(obj_node.name)
            if name[0].uppercase?
              return name
            end
          end
        end
        nil
      else
        nil
      end
    end

    # Infer type from class-level ivar assignment: @vec = SomeType.new
    # Used during class registration (pass 2) to handle implicit ivars
    private def infer_type_from_class_ivar_assign(value_node) : TypeRef
      case value_node
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # Direct member access: SomeType.new (without call parens)
        obj_node = @arena[value_node.object]
        member_name = String.new(value_node.member)
        if ENV.has_key?("DEBUG_TYPE_INFER")
          STDERR.puts "[TYPE_INFER] Direct MemberAccess member=#{member_name}, obj_node type: #{obj_node.class}"
        end
        if member_name == "new" || member_name == "empty" || member_name == "null" || member_name == "malloc"
          type_name = extract_type_name_from_node(obj_node)
          if ENV.has_key?("DEBUG_TYPE_INFER")
            STDERR.puts "[TYPE_INFER] extracted type_name=#{type_name || "nil"}"
          end
          if type_name
            resolved = resolve_type_alias_chain(type_name)
            if ENV.has_key?("DEBUG_TYPE_INFER")
              STDERR.puts "[TYPE_INFER] resolved type_name=#{resolved}"
            end
            return type_ref_for_name(resolved)
          end
        end
      when CrystalV2::Compiler::Frontend::CallNode
        # For calls like SomeClass.new() or GenericClass(T).new()
        callee = value_node.callee
        callee_node = @arena[callee]
        if ENV.has_key?("DEBUG_TYPE_INFER")
          STDERR.puts "[TYPE_INFER] CallNode callee_node type: #{callee_node.class}"
        end
        case callee_node
        when CrystalV2::Compiler::Frontend::MemberAccessNode
          obj_node = @arena[callee_node.object]
          member_name = String.new(callee_node.member)
          if ENV.has_key?("DEBUG_TYPE_INFER")
            STDERR.puts "[TYPE_INFER] MemberAccess member=#{member_name}, obj_node type: #{obj_node.class}"
          end
          if member_name == "new" || member_name == "empty" || member_name == "null" || member_name == "malloc"
            type_name = extract_type_name_from_node(obj_node)
            if ENV.has_key?("DEBUG_TYPE_INFER")
              STDERR.puts "[TYPE_INFER] extracted type_name=#{type_name || "nil"}"
            end
            if type_name
              resolved = resolve_type_alias_chain(type_name)
              if ENV.has_key?("DEBUG_TYPE_INFER")
                STDERR.puts "[TYPE_INFER] resolved type_name=#{resolved}"
              end
              return type_ref_for_name(resolved)
            end
          end
        end
      when CrystalV2::Compiler::Frontend::StringNode, CrystalV2::Compiler::Frontend::StringInterpolationNode
        return TypeRef::STRING
      when CrystalV2::Compiler::Frontend::NumberNode
        num_str = String.new(value_node.value)
        if num_str.includes?('.') || num_str.includes?('e') || num_str.includes?('E')
          return TypeRef::FLOAT64
        else
          return TypeRef::INT32
        end
      when CrystalV2::Compiler::Frontend::BoolNode
        return TypeRef::BOOL
      when CrystalV2::Compiler::Frontend::CharNode
        return TypeRef::CHAR
      when CrystalV2::Compiler::Frontend::NilNode
        return TypeRef::VOID
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        # Array literal - infer element type from first element
        if of_type = value_node.of_type
          if type_name = stringify_type_expr(of_type)
            return type_ref_for_name("Array(#{normalize_declared_type_name(type_name)})")
          end
        end
        if elements = value_node.elements
          if first_id = elements.first?
            first_node = @arena[first_id]
            if elem_type = infer_type_from_expr(first_node)
              return type_ref_for_name("Array(#{elem_type})")
            end
          end
        end
        return type_ref_for_name("Array(String)")  # Default
      when CrystalV2::Compiler::Frontend::HashLiteralNode
        if key_type = value_node.of_key_type
          value_type = value_node.of_value_type
          if value_type
            key_name = normalize_declared_type_name(String.new(key_type))
            value_name = normalize_declared_type_name(String.new(value_type))
            value_name = "NamedTuple" if value_name.starts_with?("NamedTuple")
            return type_ref_for_name("Hash(#{key_name}, #{value_name})")
          end
        end
        if entries = value_node.entries
          if first_entry = entries.first?
            key_node = @arena[first_entry.key]
            value_node_inner = @arena[first_entry.value]
            key_type = infer_type_from_expr(key_node)
            value_type = infer_type_from_expr(value_node_inner)
            if key_type && value_type
              return type_ref_for_name("Hash(#{key_type}, #{value_type})")
            end
          end
        end
        return type_ref_for_name("Hash(String, String)")
      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        return type_ref_for_name("NamedTuple")
      when CrystalV2::Compiler::Frontend::UninitializedNode
        if type_str = stringify_type_expr(value_node.type)
          return type_ref_for_name(normalize_declared_type_name(type_str))
        end
      end
      TypeRef::VOID  # Default to VOID if we can't infer
    end

    # Extract type name from AST node (ConstantNode, GenericNode, etc.)
    private def extract_type_name_from_node(node) : String?
      case node
      when CrystalV2::Compiler::Frontend::ConstantNode
        String.new(node.name)
      when CrystalV2::Compiler::Frontend::IdentifierNode
        # Identifiers can be type names (uppercase) or constants used as type args
        String.new(node.name)
      when CrystalV2::Compiler::Frontend::GenericNode
        # GenericClass(T, U) -> "GenericClass(T, U)"
        base_node = @arena[node.base_type]
        base_name = extract_type_name_from_node(base_node)
        if base_name && (type_args = node.type_args)
          # Resolve type args (may be type params like T that need substitution)
          arg_names = type_args.map do |arg_id|
            arg_node = @arena[arg_id]
            extract_type_name_from_node(arg_node) || "UNKNOWN"
          end
          "#{base_name}(#{arg_names.join(", ")})"
        else
          base_name
        end
      when CrystalV2::Compiler::Frontend::PathNode
        resolve_path_string_in_context(collect_path_string(node))
      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # Nested::Class - reconstruct qualified name
        obj_node = @arena[node.object]
        member_name = String.new(node.member)
        if obj_name = extract_type_name_from_node(obj_node)
          "#{obj_name}::#{member_name}"
        else
          member_name
        end
      else
        nil
      end
    end

    # Check if a type is a union type
    private def is_union_type?(type_ref : TypeRef) : Bool
      if type_desc = @module.get_type_descriptor(type_ref)
        type_desc.kind == TypeKind::Union
      else
        false
      end
    end

    # Get variant type_id for a value being assigned to union
    # Returns the index of the matching variant, or -1 if not found
    private def get_union_variant_id(union_type : TypeRef, value_type : TypeRef) : Int32
      mir_union_ref = hir_to_mir_type_ref(union_type)
      if descriptor = @union_descriptors[mir_union_ref]?
        mir_value_ref = hir_to_mir_type_ref(value_type)
        descriptor.variants.each_with_index do |variant, idx|
          if variant.type_ref == mir_value_ref
            return idx
          end
        end
      end
      -1
    end

    # Find an existing union type in the module that can represent all required types.
    # Prefer the smallest matching union (fewest variants) to avoid needlessly wide phis.
    private def find_covering_union_type(required_types : Array(TypeRef)) : TypeRef?
      required_mir = required_types.map { |t| hir_to_mir_type_ref(t) }.uniq

      best_ref : TypeRef? = nil
      best_variant_count = Int32::MAX

      @module.types.each_with_index do |desc, idx|
        next unless desc.kind == TypeKind::Union || desc.name.includes?("___")

        hir_union_ref = TypeRef.new(TypeRef::FIRST_USER_TYPE + idx.to_u32)
        mir_union_ref = hir_to_mir_type_ref(hir_union_ref)
        descriptor = @union_descriptors[mir_union_ref]?
        next unless descriptor

        variants = descriptor.variants.map(&.type_ref)
        next unless required_mir.all? { |rt| variants.includes?(rt) }

        if variants.size < best_variant_count
          best_variant_count = variants.size
          best_ref = hir_union_ref
        end
      end

      best_ref
    end

    # Get class variable type from current class
    private def get_class_var_type(name : String) : TypeRef
      if class_name = @current_class
        if class_info = @class_info[class_name]?
          class_info.class_vars.each do |cvar|
            return cvar.type if cvar.name == name
          end
        end
        if module_vars = @module_class_vars[class_name]?
          module_vars.each do |cvar|
            return cvar.type if cvar.name == name
          end
        end
      end
      TypeRef::VOID
    end

    private def record_class_var_type(owner_name : String, cvar_name : String, cvar_type : TypeRef, initial_value : Int64? = nil) : Nil
      return if owner_name.empty?
      return if cvar_type == TypeRef::VOID

      if class_info = @class_info[owner_name]?
        if idx = class_info.class_vars.index { |cv| cv.name == cvar_name }
          if class_info.class_vars[idx].type == TypeRef::VOID
            class_info.class_vars[idx] = ClassVarInfo.new(cvar_name, cvar_type, class_info.class_vars[idx].initial_value)
          end
        else
          class_info.class_vars << ClassVarInfo.new(cvar_name, cvar_type, initial_value)
        end
        return
      end

      return unless @module_defs.has_key?(owner_name)
      vars = @module_class_vars[owner_name]? || begin
        new_vars = [] of ClassVarInfo
        @module_class_vars[owner_name] = new_vars
        new_vars
      end
      if idx = vars.index { |cv| cv.name == cvar_name }
        if vars[idx].type == TypeRef::VOID
          vars[idx] = ClassVarInfo.new(cvar_name, cvar_type, vars[idx].initial_value)
        end
      else
        vars << ClassVarInfo.new(cvar_name, cvar_type, initial_value)
      end
    end

    # Lower a function definition
    def lower_def(
      node : CrystalV2::Compiler::Frontend::DefNode,
      call_arg_types : Array(TypeRef)? = nil,
      call_arg_literals : Array(Bool)? = nil,
      full_name_override : String? = nil
    ) : Function
      base_name = String.new(node.name)
      if ENV.has_key?("DEBUG_STRING_METHOD_LOWER") && (base_name == "[]" || base_name == "char_index_to_byte_index")
        STDERR.puts "[DEBUG_LOWER_DEF] name=#{base_name} override=#{full_name_override || "(none)"} current_class=#{@current_class || "(none)"}"
      end
      if base_name == "main" && @current_class.nil? && !fun_def?(node)
        base_name = TOP_LEVEL_MAIN_BASE
        @top_level_main_defined = true
      end

      # Lower parameters
      param_infos = [] of Tuple(String, TypeRef)
      param_types = [] of TypeRef
      param_type_names = [] of String?  # Track type annotation names for enum detection
      param_literal_flags = [] of Bool
      has_block = false
      param_type_map = {} of String => TypeRef
      old_typeof_locals = @current_typeof_locals
      old_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = param_type_map
      @current_typeof_local_names = {} of String => String
      call_types = call_arg_types || [] of TypeRef
      call_literal_flags = call_arg_literals || [] of Bool
      common_numeric = common_numeric_type(call_types)
      call_index = 0
      splat_param_info_index : Int32? = nil
      splat_param_types_index : Int32? = nil
      splat_param_name : String? = nil

      if params = node.params
        params.each do |param|
          next if named_only_separator?(param)
          param_name = param.name.nil? ? "_" : String.new(param.name.not_nil!)
          param_type = if ta = param.type_annotation
                         type_ref_for_name(String.new(ta))
                       elsif param.is_double_splat
                         type_ref_for_name("NamedTuple")
                       else
                         TypeRef::VOID  # Unknown type
                       end
          if param_type == TypeRef::VOID && !param.is_block && !param.is_splat && !param.is_double_splat
            if call_index < call_types.size
              inferred = common_numeric || call_types[call_index]
              param_type = inferred if inferred != TypeRef::VOID
            end
          end
          if !param.is_block && !param.is_splat && !param.is_double_splat && call_index < call_types.size
            param_type = refine_param_type_from_call(param_type, call_types[call_index])
          end

          param_type_map[param_name] = param_type
          param_infos << {param_name, param_type}
          # Track type annotation name for enum detection
          param_type_names << (param.type_annotation ? String.new(param.type_annotation.not_nil!) : nil)
          if ta = param.type_annotation
            update_typeof_local_name(param_name, String.new(ta))
          end
          param_literal = !param.is_block && !param.is_splat && !param.is_double_splat &&
                          call_index < call_literal_flags.size && call_literal_flags[call_index]
          if param.is_block
            has_block = true
          else
            if param.is_splat
              splat_param_info_index = param_infos.size - 1
              splat_param_types_index = param_types.size
              splat_param_name = param_name
            elsif !param.is_double_splat
              call_index += 1
            end
            param_types << param_type
          end
          param_literal_flags << param_literal
        end
      end

      if splat_param_name
        splat_type = TypeRef::VOID
        if !call_types.empty?
          remaining = call_types[call_index..-1]? || [] of TypeRef
          splat_type = tuple_type_from_arg_types(remaining)
        end
        if splat_type == TypeRef::VOID
          if elem_type = param_type_map[splat_param_name.not_nil!]?
            if elem_type != TypeRef::VOID
              splat_type = tuple_type_from_arg_types([elem_type])
            end
          end
        end
        if splat_type != TypeRef::VOID
          param_type_map[splat_param_name.not_nil!] = splat_type
          if idx = splat_param_info_index
            param_infos[idx] = {splat_param_name.not_nil!, splat_type}
          end
          if idx = splat_param_types_index
            param_types[idx] = splat_type
          end
        end
      end

      # Determine return type (default to Void if not specified)
      return_type = if rt = node.return_type
                      rt_string = String.new(rt)
                      type_ref_for_name(rt_string)
                    elsif base_name.ends_with?("?")
                      TypeRef::BOOL
                    else
                      TypeRef::VOID
                    end
      if return_type == TypeRef::VOID && node.return_type.nil?
        if inferred = infer_concrete_return_type_from_body(node, @current_class)
          return_type = inferred
        end
      end
      if (return_type == TypeRef::VOID || return_type == TypeRef::NIL) && base_name == "backend_class"
        if @current_class == "Crystal::EventLoop" || @current_class == "EventLoop"
          if preferred = preferred_event_loop_backend_class
            preferred_ref = type_ref_for_name(preferred)
            return_type = preferred_ref unless preferred_ref == TypeRef::VOID
          end
        end
      end

      # Top-level functions support overloading, so use mangled names consistently.
      full_name = full_name_override || function_full_name_for_def(base_name, param_types, node.params, has_block)

      if registered = @function_types[full_name]?
        if (return_type == TypeRef::VOID || return_type == TypeRef::NIL) &&
           registered != TypeRef::VOID && registered != TypeRef::NIL
          return_type = registered
        end
      end

      # Idempotency: avoid lowering the same function twice (can happen with conditional defs).
      if existing = @module.functions.find { |f| f.name == full_name }
        return existing
      end

      # Ensure function type is registered even when caller skipped register_function (e.g. conditional defs).
      if existing = @function_types[full_name]?
        if existing == TypeRef::VOID || (existing == TypeRef::NIL && return_type != TypeRef::NIL)
          register_function_type(full_name, return_type)
        end
      else
        register_function_type(full_name, return_type)
      end
      if existing = @function_types[base_name]?
        if existing == TypeRef::VOID || (existing == TypeRef::NIL && return_type != TypeRef::NIL)
          register_function_type(base_name, return_type)
        end
      else
        register_function_type(base_name, return_type)
      end

      # Keep AST around for signatureHelp/named args and for yield inlining.
      unless @function_defs.has_key?(base_name)
        @function_defs[base_name] = node
        @function_def_arenas[base_name] = @arena
      end
      @function_defs[full_name] = node
      @function_def_arenas[full_name] = @arena

      func = @module.create_function(full_name, return_type)
      ctx = LoweringContext.new(func, @module, @arena)

      param_infos.each_with_index do |(param_name, param_type), idx|
        hir_param = func.add_param(param_name, param_type)
        ctx.register_local(param_name, hir_param.id)
        ctx.register_type(hir_param.id, param_type)  # Track param type for inference
        if param_literal_flags[idx]?
          ctx.mark_type_literal(hir_param.id)
        end
        if module_type_ref?(param_type)
          ctx.mark_type_literal(hir_param.id)
        end
        # Track enum type for predicate method inlining
        if type_name = param_type_names[idx]?
          track_enum_value(hir_param.id, type_name)
        end
      end

      # Lower body
      last_value : ValueId? = nil
      if body = node.body
        body.each do |expr_id|
          last_value = lower_expr(ctx, expr_id)
        end
      end

      # Add implicit return if not already terminated
      # BUT don't add return after raise (which sets Unreachable terminator)
      block = ctx.get_block(ctx.current_block)
      block_has_raise = block.instructions.any? { |inst| inst.is_a?(Raise) }
      if block.terminator.is_a?(Unreachable) && !block_has_raise
        block.terminator = Return.new(last_value)
      end

      # Infer return type from last expression if not explicitly specified
      # This handles methods with implicit returns like `def root_buffer; @buffer - @offset; end`
      if return_type == TypeRef::VOID && last_value
        inferred_type = ctx.type_of(last_value)
        if inferred_type != TypeRef::VOID
          func.return_type = inferred_type
          # Update function type registry to match
          register_function_type(full_name, inferred_type)
          register_function_type(base_name, inferred_type)
        end
      end

      @current_typeof_locals = old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names

      func
    end

    # Lower top-level expressions into a synthetic main function
    # Note: Named __crystal_main because stdlib's fun main calls LibCrystalMain.__crystal_main
    def lower_main(main_exprs : Array(Tuple(CrystalV2::Compiler::Frontend::ExprId, CrystalV2::Compiler::Frontend::ArenaLike))) : Function
      # Create __crystal_main function with void return type
      # Signature: fun __crystal_main(argc : Int32, argv : UInt8**)
      func = @module.create_function("__crystal_main", TypeRef::VOID)

      # Add parameters to match lib declaration
      argc_param = func.add_param("argc", TypeRef::INT32)
      # UInt8** = pointer to pointer to UInt8, use generic POINTER type
      argv_param = func.add_param("argv", TypeRef::POINTER)

      ctx = LoweringContext.new(func, @module, @arena)

      # Register parameters in context for potential use
      ctx.register_local("argc", argc_param.id)
      ctx.register_local("argv", argv_param.id)

      # Lower each top-level expression in order
      last_value : ValueId? = nil
      debug_main = ENV.has_key?("DEBUG_MAIN")
      if debug_main
        STDERR.puts "[MAIN] lower_main exprs=#{main_exprs.size}"
      end
      main_exprs.each_with_index do |(expr_id, arena), idx|
        # Switch arena context for this expression
        @arena = arena
        if debug_main
          node = @arena[expr_id]
          snippet = nil
          if source = @sources_by_arena[@arena]?
            span = node.span
            start = span.start_offset
            length = span.end_offset - span.start_offset
            if length > 0 && start >= 0 && start < source.bytesize
              max_len = 80
              slice_len = length > max_len ? max_len : length
              snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
            end
          end
          if snippet
            STDERR.puts "[MAIN] start #{idx + 1}/#{main_exprs.size} #{node.class} offs=#{node.span.start_offset} \"#{snippet}\""
          else
            STDERR.puts "[MAIN] start #{idx + 1}/#{main_exprs.size} #{node.class}"
          end
        end
        expr_start = debug_main ? Time.monotonic : nil
        last_value = lower_expr(ctx, expr_id)
        if debug_main && expr_start
          elapsed = (Time.monotonic - expr_start).total_milliseconds
          if elapsed > 50.0
            node = @arena[expr_id]
            STDERR.puts "[MAIN] expr #{idx + 1}/#{main_exprs.size} #{node.class} #{elapsed.round(1)}ms"
          elsif (idx % 500 == 0) || (idx + 1 == main_exprs.size)
            STDERR.puts "[MAIN] progress #{idx + 1}/#{main_exprs.size}"
          end
        end
      end

      # Return void (stdlib's fun main handles the return value)
      block = ctx.get_block(ctx.current_block)
      if block.terminator.is_a?(Unreachable)
        block.terminator = Return.new(nil)
      end

      func
    end

    # Lower a synthetic __crystal_main that calls a user-defined main.
    # Used when there are no top-level expressions (no implicit main body).
    def lower_main_from_def(node : CrystalV2::Compiler::Frontend::DefNode) : Function
      if existing = @module.functions.find { |f| f.name == "__crystal_main" }
        return existing
      end

      # Ensure user main is lowered (lazy lowering in CLI).
      lower_def(node)

      # Create __crystal_main(argc, argv)
      func = @module.create_function("__crystal_main", TypeRef::VOID)
      argc_param = func.add_param("argc", TypeRef::INT32)
      argv_param = func.add_param("argv", TypeRef::POINTER)

      ctx = LoweringContext.new(func, @module, @arena)
      ctx.register_local("argc", argc_param.id)
      ctx.register_local("argv", argv_param.id)
      ctx.register_type(argc_param.id, TypeRef::INT32)
      ctx.register_type(argv_param.id, TypeRef::POINTER)

      # Build the call to main with argc/argv if requested by the signature.
      param_types = [] of TypeRef
      has_block = false
      if params = node.params
        params.each do |param|
          next if named_only_separator?(param)
          if param.is_block
            has_block = true
            next
          end
          param_types << (param.type_annotation ? type_ref_for_name(String.new(param.type_annotation.not_nil!)) : TypeRef::VOID)
        end
      end

      main_base = if String.new(node.name) == "main" && @current_class.nil? && !fun_def?(node)
                    @top_level_main_defined = true
                    TOP_LEVEL_MAIN_BASE
                  else
                    "main"
                  end
      main_name = mangle_function_name(main_base, param_types, has_block)
      return_type = get_function_return_type(main_name)
      args = [] of ValueId
      args << argc_param.id if param_types.size >= 1
      args << argv_param.id if param_types.size >= 2
      call = Call.new(ctx.next_id, return_type, nil, main_name, args)
      ctx.emit(call)

      ctx.terminate(Return.new(nil))
      func
    end

    # Lower a single expression, returns ValueId of result
    def lower_expr(ctx : LoweringContext, expr_id : ExprId) : ValueId
      if ENV["DEBUG_INLINE_CRASH"]?
        if @inline_yield_name_stack.any? { |name| name.includes?("Char::Reader#decode_char_at") }
          stack = @inline_yield_name_stack.join(" -> ")
          if ctx.current_block >= ctx.function.blocks.size
            STDERR.puts "[INLINE_CRASH] block_oob expr=#{expr_id.index} block=#{ctx.current_block} size=#{ctx.function.blocks.size} stack=#{stack}"
          end
          STDERR.puts "[INLINE_CRASH] lower_expr id=#{expr_id.index} arena=#{@arena.class} size=#{@arena.size} stack=#{stack}"
          if expr_id.index >= 300 && expr_id.index <= 306
            begin
              node = @arena[expr_id]
              if source = @sources_by_arena[@arena]?
                span = node.span
                start = span.start_offset
                length = span.end_offset - span.start_offset
                if length > 0 && start >= 0 && start < source.bytesize
                  slice_len = length > 120 ? 120 : length
                  snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
                  STDERR.puts "[INLINE_CRASH] node=#{node.class} span=#{start}..#{span.end_offset} \"#{snippet}\""
                else
                  STDERR.puts "[INLINE_CRASH] node=#{node.class} span=#{start}..#{span.end_offset}"
                end
              else
                STDERR.puts "[INLINE_CRASH] node=#{node.class} span=#{node.span.start_offset}..#{node.span.end_offset}"
              end
            rescue ex
              STDERR.puts "[INLINE_CRASH] failed to inspect expr=#{expr_id.index} error=#{ex.message}"
            end
          end
        end
      end
      arena = arena_for_expr?(expr_id) || @arena
      if expr_id.index < 0 || expr_id.index >= arena.size
        if ENV["DEBUG_EXPR_OOB"]?
          stack = @inline_yield_name_stack.join(" -> ")
          block_debug = ""
          if blk = @inline_yield_block_stack.last?
            invalid_body = blk.body.count(&.invalid?) rescue 0
            block_debug = " block_invalid=#{invalid_body}"
          end
          STDERR.puts "[EXPR_OOB] expr=#{expr_id.index} arena=#{arena.class}:#{arena.size} func=#{ctx.function.name} current=#{@current_class || ""} method=#{@current_method || ""} inline=#{stack}#{block_debug}"
          caller.first(10).each { |line| STDERR.puts "  #{line}" }
        end
        raise "ExprId out of bounds: #{expr_id.index} (arena=#{arena.class}:#{arena.size})"
      end
      if arena == @arena
        node = @arena[expr_id]
        lower_node(ctx, node)
      else
        with_arena(arena) do
          node = @arena[expr_id]
          lower_node(ctx, node)
        end
      end
    end

    # Lower an AST node to HIR
    def lower_node(ctx : LoweringContext, node : AstNode) : ValueId
      if !@pending_def_annotations.empty? &&
         !node.is_a?(CrystalV2::Compiler::Frontend::AnnotationNode) &&
         !node.is_a?(CrystalV2::Compiler::Frontend::DefNode)
        clear_pending_effect_annotations
      end

      case node
      # ═══════════════════════════════════════════════════════════════════
      # LITERALS
      # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::NumberNode
        lower_number(ctx, node)

      when CrystalV2::Compiler::Frontend::StringNode
        lower_string(ctx, node)

      when CrystalV2::Compiler::Frontend::StringInterpolationNode
        lower_string_interpolation(ctx, node)

      when CrystalV2::Compiler::Frontend::RegexNode
        lower_regex(ctx, node)

      when CrystalV2::Compiler::Frontend::CharNode
        lower_char(ctx, node)

      when CrystalV2::Compiler::Frontend::BoolNode
        lower_bool(ctx, node)

      when CrystalV2::Compiler::Frontend::NilNode
        lower_nil(ctx, node)

      when CrystalV2::Compiler::Frontend::SymbolNode
        lower_symbol(ctx, node)

      # ═══════════════════════════════════════════════════════════════════
      # VARIABLES
      # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::IdentifierNode
        lower_identifier(ctx, node)

      when CrystalV2::Compiler::Frontend::InstanceVarNode
        lower_instance_var(ctx, node)

      when CrystalV2::Compiler::Frontend::ClassVarNode
        lower_class_var(ctx, node)

      when CrystalV2::Compiler::Frontend::SelfNode
        lower_self(ctx, node)

      when CrystalV2::Compiler::Frontend::ImplicitObjNode
        # Implicit object (like .foo) is treated as self in current context
        lower_self_implicit(ctx, node)

      when CrystalV2::Compiler::Frontend::SuperNode
        lower_super(ctx, node)

      when CrystalV2::Compiler::Frontend::PreviousDefNode
        lower_previous_def(ctx, node)

      when CrystalV2::Compiler::Frontend::GlobalNode
        lower_global(ctx, node)

      # ═══════════════════════════════════════════════════════════════════
      # OPERATIONS
      # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::BinaryNode
        lower_binary(ctx, node)

      when CrystalV2::Compiler::Frontend::UnaryNode
        lower_unary(ctx, node)

      # ═══════════════════════════════════════════════════════════════════
      # CONTROL FLOW
      # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::IfNode
        lower_if(ctx, node)

      when CrystalV2::Compiler::Frontend::UnlessNode
        lower_unless(ctx, node)

      when CrystalV2::Compiler::Frontend::WhileNode
        lower_while(ctx, node)

      when CrystalV2::Compiler::Frontend::UntilNode
        lower_until(ctx, node)

      when CrystalV2::Compiler::Frontend::TernaryNode
        lower_ternary(ctx, node)

      when CrystalV2::Compiler::Frontend::CaseNode
        lower_case(ctx, node)

      # ═══════════════════════════════════════════════════════════════════
      # FUNCTION-RELATED
      # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::ReturnNode
        lower_return(ctx, node)

      when CrystalV2::Compiler::Frontend::YieldNode
        if blk = @inline_yield_block_stack.last?
          inline_block_body(ctx, node, blk)
        else
          lower_yield(ctx, node)
        end

      when CrystalV2::Compiler::Frontend::BreakNode
        lower_break(ctx, node)

      when CrystalV2::Compiler::Frontend::NextNode
        lower_next(ctx, node)

      when CrystalV2::Compiler::Frontend::BeginNode
        lower_begin(ctx, node)

      when CrystalV2::Compiler::Frontend::RaiseNode
        lower_raise(ctx, node)

      # ═══════════════════════════════════════════════════════════════════
      # CALLS
      # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::CallNode
        lower_call(ctx, node)

      when CrystalV2::Compiler::Frontend::IndexNode
        lower_index(ctx, node)

      when CrystalV2::Compiler::Frontend::MemberAccessNode
        lower_member_access(ctx, node)

      # ═══════════════════════════════════════════════════════════════════
      # ASSIGNMENT
      # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::AssignNode
        lower_assign(ctx, node)

      when CrystalV2::Compiler::Frontend::MultipleAssignNode
        lower_multiple_assign(ctx, node)

      # ═══════════════════════════════════════════════════════════════════
      # CLOSURES
      # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::BlockNode
        lower_block(ctx, node)

      when CrystalV2::Compiler::Frontend::ProcLiteralNode
        lower_proc_literal(ctx, node)

      # ═══════════════════════════════════════════════════════════════════
      # COLLECTIONS
      # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        lower_array_literal(ctx, node)

      when CrystalV2::Compiler::Frontend::HashLiteralNode
        lower_hash_literal(ctx, node)

      when CrystalV2::Compiler::Frontend::TupleLiteralNode
        lower_tuple_literal(ctx, node)

      when CrystalV2::Compiler::Frontend::NamedTupleLiteralNode
        lower_named_tuple_literal(ctx, node)

      when CrystalV2::Compiler::Frontend::RangeNode
        lower_range(ctx, node)

      # ═══════════════════════════════════════════════════════════════════
      # TYPE OPERATIONS
      # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::AsNode
        lower_as(ctx, node)

      when CrystalV2::Compiler::Frontend::AsQuestionNode
        lower_as_question(ctx, node)

      when CrystalV2::Compiler::Frontend::IsANode
        lower_is_a(ctx, node)

      when CrystalV2::Compiler::Frontend::RespondsToNode
        lower_responds_to(ctx, node)

      # ═══════════════════════════════════════════════════════════════════
      # MISC
      # ═══════════════════════════════════════════════════════════════════

      when CrystalV2::Compiler::Frontend::GroupingNode
        # Just unwrap grouping
        lower_expr(ctx, node.expression)

      when CrystalV2::Compiler::Frontend::SplatNode
        # Lower the inner expression (splat semantics handled at call site)
        lower_expr(ctx, node.expr)

      when CrystalV2::Compiler::Frontend::PathNode
        lower_path(ctx, node)

      when CrystalV2::Compiler::Frontend::GenericNode
        # Generic type like Array(Int32) - lower as type reference for use as receiver
        lower_generic_type_ref(ctx, node)

      when CrystalV2::Compiler::Frontend::UninitializedNode
        # uninitialized Type - returns undefined value of given type
        lower_uninitialized(ctx, node)

      when CrystalV2::Compiler::Frontend::TypeDeclarationNode
        # x : Type = value - local variable with type annotation
        lower_type_declaration(ctx, node)

      when CrystalV2::Compiler::Frontend::LoopNode
        # loop do ... end - infinite loop (exits via break)
        lower_loop(ctx, node)

      when CrystalV2::Compiler::Frontend::MacroIfNode
        # Handle macro conditionals like {% if flag?(:darwin) %}
        lower_macro_if(ctx, node)

      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        # Handle macro literals with text pieces that may contain {% if flag?() %}
        lower_macro_literal(ctx, node)

      when CrystalV2::Compiler::Frontend::MacroVarNode,
           CrystalV2::Compiler::Frontend::MacroForNode,
           CrystalV2::Compiler::Frontend::MacroExpressionNode
        # Macro nodes are not lowered directly - they are expanded first
        # Return nil for any macro content encountered
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id

      when CrystalV2::Compiler::Frontend::PointerofNode
        lower_pointerof(ctx, node)

      when CrystalV2::Compiler::Frontend::AnnotationNode
        # Annotations like @[Link("c")] - store for later processing
        # For now, just return nil (annotations are metadata, not values)
        remember_effect_annotation(node, @arena)
        lower_annotation(ctx, node)

      when CrystalV2::Compiler::Frontend::LibNode
        # lib LibC ... end - C library bindings
        lower_lib(ctx, node)

      when CrystalV2::Compiler::Frontend::FunNode
        # fun malloc(size : Int64) : Void* - external C function
        lower_fun(ctx, node)

      when CrystalV2::Compiler::Frontend::DefNode
        # Top-level method definition
        lower_top_level_def(ctx, node)

      when CrystalV2::Compiler::Frontend::TypeofNode
        # typeof(x) - returns type at compile time, for runtime just return nil
        lower_typeof(ctx, node)

      when CrystalV2::Compiler::Frontend::SizeofNode
        # sizeof(T) - returns size of type
        lower_sizeof(ctx, node)

      when CrystalV2::Compiler::Frontend::OffsetofNode
        # offsetof(T, @field) - returns field offset
        lower_offsetof(ctx, node)

      when CrystalV2::Compiler::Frontend::MacroDefNode
        # Macro definitions - skip at runtime, just return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id

      when CrystalV2::Compiler::Frontend::ModuleNode
        # Module definitions inside expressions - skip, just return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id

      when CrystalV2::Compiler::Frontend::ClassNode
        # Class definitions inside expressions - skip, just return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id

      when CrystalV2::Compiler::Frontend::RequireNode
        # Require directives - already processed, return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id

      when CrystalV2::Compiler::Frontend::GlobalVarDeclNode
        # Global variable declaration ($name : Type) - declaration only, return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id

      when CrystalV2::Compiler::Frontend::AnnotationDefNode
        # Annotation definition (annotation Foo) - declaration only, return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id

      when CrystalV2::Compiler::Frontend::ConstantNode
        # Constant definition (FOO = value) - evaluate and return the value
        const_name = String.new(node.name)
        full_name = constant_full_name(@current_class, const_name)
        value_id = lower_expr(ctx, node.value)
        value_type = ctx.type_of(value_id)
        @constant_defs.add(full_name)
        if value_type != TypeRef::VOID
          if existing = @constant_types[full_name]?
            @constant_types[full_name] = value_type if existing == TypeRef::VOID
          else
            @constant_types[full_name] = value_type
          end
        end
        owner, short_name = constant_storage_info(full_name)
        const_set = ClassVarSet.new(ctx.next_id, value_type, owner, short_name, value_id)
        ctx.emit(const_set)
        ctx.register_type(const_set.id, value_type)
        value_id

      when CrystalV2::Compiler::Frontend::VisibilityModifierNode
        # Visibility modifier (private, protected) - just lower the target expression
        lower_expr(ctx, node.expression)

      when CrystalV2::Compiler::Frontend::OutNode
        # out x - creates a pointer to a local variable for C functions
        # The variable name is in node.identifier
        var_name = String.new(node.identifier)
        # Create the local variable if it doesn't exist
        var_id = ctx.lookup_local(var_name)
        if var_id.nil?
          # Create uninitialized variable
          alloc = Allocate.new(ctx.next_id, TypeRef::POINTER, [] of ValueId, true)
          ctx.emit(alloc)
          record_allocation_location(ctx, alloc.id, @arena, node)
          ctx.register_local(var_name, alloc.id)
          var_id = alloc.id
        end
        # Get address of the variable
        ptr = AddressOf.new(ctx.next_id, TypeRef::POINTER, var_id)
        ctx.emit(ptr)
        ptr.id

      when CrystalV2::Compiler::Frontend::EnumNode
        # Enum declarations are processed during registration phase
        # Just return nil literal during lowering
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id

      when CrystalV2::Compiler::Frontend::GetterNode,
           CrystalV2::Compiler::Frontend::SetterNode,
           CrystalV2::Compiler::Frontend::PropertyNode
        # Accessor declarations are processed during class registration/generation
        # If encountered during expression lowering, return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id

      when CrystalV2::Compiler::Frontend::SpawnNode
        lower_spawn(ctx, node)

      else
        raise LoweringError.new("Unsupported AST node type: #{node.class}", node)
      end
    end

    # ═══════════════════════════════════════════════════════════════════════
    # LITERAL LOWERING
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_number(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::NumberNode) : ValueId
      type = case node.kind
             when .i8?   then TypeRef::INT8
             when .i16?  then TypeRef::INT16
             when .i32?  then TypeRef::INT32
             when .i64?  then TypeRef::INT64
             when .i128? then TypeRef::INT128
             when .u8?   then TypeRef::UINT8
             when .u16?  then TypeRef::UINT16
             when .u32?  then TypeRef::UINT32
             when .u64?  then TypeRef::UINT64
             when .u128? then TypeRef::UINT128
             when .f32?  then TypeRef::FLOAT32
             when .f64?  then TypeRef::FLOAT64
             else             TypeRef::INT32
             end

      # Remove underscores and type suffixes (42_000i64 -> 42000)
      value_str = String.new(node.value).gsub('_', "")
      # Strip type suffix (i8, i16, i32, i64, i128, u8, u16, u32, u64, u128, f32, f64)
      value_str = value_str.gsub(/[iuf]\d+$/, "")

      # Handle empty string case (malformed number)
      if value_str.empty?
        value = 0_i64
      elsif node.kind.f32? || node.kind.f64?
        value = value_str.to_f64
      else
        # Handle hex (0x), binary (0b), and octal (0o)
        # Use UInt64 for parsing to handle large hex values, then cast to Int64
        raw = if value_str.starts_with?("0x") || value_str.starts_with?("0X")
                digits = value_str[2..]
                digits.empty? ? 0_u64 : digits.to_u64(16)
              elsif value_str.starts_with?("0b") || value_str.starts_with?("0B")
                digits = value_str[2..]
                digits.empty? ? 0_u64 : digits.to_u64(2)
              elsif value_str.starts_with?("0o") || value_str.starts_with?("0O")
                digits = value_str[2..]
                digits.empty? ? 0_u64 : digits.to_u64(8)
              else
                # Try to parse as UInt64 first (handles numbers > Int64::MAX)
                value_str.to_u64? || value_str.to_i64?.try(&.to_u64!) || 0_u64
              end
        value = raw.to_i64!  # Bitcast to Int64
      end

      lit = Literal.new(ctx.next_id, type, value)
      ctx.emit(lit)
      lit.id
    end

    private def lower_string(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::StringNode) : ValueId
      str = String.new(node.value)
      lit = Literal.new(ctx.next_id, TypeRef::STRING, str)
      ctx.emit(lit)
      lit.id
    end

    private def lower_regex(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::RegexNode) : ValueId
      # Regex literal /pattern/
      # For now, store as a string pattern - full regex support requires PCRE bindings
      pattern = String.new(node.pattern)
      regex_type = ctx.get_type("Regex")
      lit = Literal.new(ctx.next_id, regex_type, pattern)
      ctx.emit(lit)
      lit.id
    end

    private def lower_type_declaration(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::TypeDeclarationNode) : ValueId
      # x : Type = value - local variable declaration with type annotation
      var_name = String.new(node.name)
      type_name = String.new(node.declared_type)
      type_ref = type_ref_for_name(type_name)

      if value_id = node.value
        # Has initial value: x : Type = value
        value = lower_expr(ctx, value_id)
        # Register as local variable
        ctx.register_local(var_name, value)
        value_type = ctx.type_of(value)
        # If the declared type is module-like and the initializer is concrete,
        # keep the concrete type for call resolution to avoid includer heuristics.
        if module_like_type_name?(type_name) && value_type != TypeRef::VOID
          ctx.register_type(value, value_type)
          update_typeof_local(var_name, value_type)
          if concrete_name = concrete_type_name_for(value_type)
            update_typeof_local_name(var_name, concrete_name)
          else
            update_typeof_local_name(var_name, type_name)
          end
        else
          ctx.register_type(value, type_ref)
          update_typeof_local(var_name, type_ref)
          update_typeof_local_name(var_name, type_name)
        end
        value
      else
        # No initial value: x : Type (uninitialized)
        # Create undefined value for the type
        undefined_value : Int64 | Float64 | String | Bool | Nil = case type_ref
          when TypeRef::BOOL then false
          when TypeRef::FLOAT32, TypeRef::FLOAT64 then 0.0
          when TypeRef::STRING, TypeRef::POINTER then nil
          else 0_i64
        end

        lit = Literal.new(ctx.next_id, type_ref, undefined_value)
        ctx.emit(lit)
        ctx.register_local(var_name, lit.id)
        ctx.register_type(lit.id, type_ref)
        update_typeof_local(var_name, type_ref)
        update_typeof_local_name(var_name, type_name)
        lit.id
      end
    end

    private def lower_uninitialized(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::UninitializedNode) : ValueId
      # uninitialized Type - returns undefined value of given type
      # Extract type name from the type expression
      type_node = @arena[node.type]
      type_name = case type_node
                  when CrystalV2::Compiler::Frontend::IdentifierNode
                    String.new(type_node.name)
                  when CrystalV2::Compiler::Frontend::ConstantNode
                    String.new(type_node.name)
                  when CrystalV2::Compiler::Frontend::PathNode
                    resolve_path_string_in_context(collect_path_string(type_node))
                  when CrystalV2::Compiler::Frontend::GenericNode
                    # Generic type - extract base and type args
                    base = @arena[type_node.base_type]
                    base_name = case base
                                when CrystalV2::Compiler::Frontend::IdentifierNode
                                  String.new(base.name)
                                when CrystalV2::Compiler::Frontend::ConstantNode
                                  String.new(base.name)
                                else
                                  "Unknown"
                                end
                    type_args = type_node.type_args.map do |arg_id|
                      arg = @arena[arg_id]
                      case arg
                      when CrystalV2::Compiler::Frontend::IdentifierNode
                        String.new(arg.name)
                      when CrystalV2::Compiler::Frontend::ConstantNode
                        String.new(arg.name)
                      else
                        "Unknown"
                      end
                    end
                    "#{base_name}(#{type_args.join(", ")})"
                  when CrystalV2::Compiler::Frontend::IndexNode
                    # Static array type: UInt8[256] -> StaticArray(UInt8, 256)
                    base = @arena[type_node.object]
                    base_name = case base
                                when CrystalV2::Compiler::Frontend::IdentifierNode
                                  String.new(base.name)
                                when CrystalV2::Compiler::Frontend::ConstantNode
                                  String.new(base.name)
                                else
                                  "Unknown"
                                end
                    # Get size from first index
                    if type_node.indexes.size > 0
                      size_node = @arena[type_node.indexes[0]]
                      size_str = case size_node
                                 when CrystalV2::Compiler::Frontend::NumberNode
                                   String.new(size_node.value)
                                 else
                                   "0"
                                 end
                      "StaticArray(#{base_name}, #{size_str})"
                    else
                      "StaticArray(#{base_name}, 0)"
                    end
                  else
                    "Unknown"
                  end

      type_ref = type_ref_for_name(type_name)

      # Create an undefined literal (value doesn't matter, it's uninitialized)
      # For numeric types, use 0; for pointers, use null
      undefined_value : Int64 | Float64 | String | Bool | Nil = case type_ref
        when TypeRef::BOOL then false
        when TypeRef::FLOAT32, TypeRef::FLOAT64 then 0.0
        when TypeRef::STRING, TypeRef::POINTER then nil
        else 0_i64
      end

      lit = Literal.new(ctx.next_id, type_ref, undefined_value)
      ctx.emit(lit)
      ctx.register_type(lit.id, type_ref)
      lit.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # LIB BINDINGS (C FFI)
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_annotation(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::AnnotationNode) : ValueId
      # Annotations like @[Link("c")] are metadata
      # Store Link annotations for the linker
      register_link_libraries_from_annotation(node)

      # Annotations don't produce values
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def register_link_libraries_from_annotation(node : CrystalV2::Compiler::Frontend::AnnotationNode) : Nil
      # node.name is an ExprId pointing to IdentifierNode or PathNode
      annotation_name = resolve_annotation_name(node.name)
      return unless annotation_name == "Link"

      # Positional args: @[Link("c")]
      node.args.each do |arg_id|
        arg_node = @arena[arg_id]
        if arg_node.is_a?(CrystalV2::Compiler::Frontend::StringNode)
          lib_name = String.new(arg_node.value)
          @module.add_link_library(lib_name)
        end
      end

      # Named args: @[Link(framework: "Cocoa")] or @[Link(pkg_config: "libfoo")]
      if named_args = node.named_args
        named_args.each do |named_arg|
          value_node = @arena[named_arg.value]
          if value_node.is_a?(CrystalV2::Compiler::Frontend::StringNode)
            named_lib_name = String.new(value_node.value)
            named_key = String.new(named_arg.name)
            prefix = case named_key
                     when "pkg_config" then "pkg_config:"
                     when "framework"  then "framework:"
                     when "dll"        then "dll:"
                     else "#{named_key}:"
                     end
            @module.add_link_library("#{prefix}#{named_lib_name}")
          end
        end
      end
    end

    private def lower_lib(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::LibNode) : ValueId
      # lib LibC ... end - C library bindings
      # Process the body to register external functions
      lib_name = String.new(node.name)

      if body = node.body
        # Pass 1: process annotations and register lib-local types before externs.
        body.each do |expr_id|
          body_node = @arena[expr_id]
          case body_node
          when CrystalV2::Compiler::Frontend::AnnotationNode
            # Process annotations within lib (e.g., @[Link])
            lower_annotation(ctx, body_node)
          when CrystalV2::Compiler::Frontend::AliasNode
            # type aliases within lib - register for later resolution
            alias_name = String.new(body_node.name)
            old_class = @current_class
            @current_class = lib_name
            target_name = resolve_alias_target(String.new(body_node.value))
            @current_class = old_class
            full_alias_name = "#{lib_name}::#{alias_name}"
            register_type_alias(full_alias_name, target_name)
            register_type_alias(alias_name, target_name)
          when CrystalV2::Compiler::Frontend::EnumNode
            # Enums within lib - register with lib prefix
            enum_name = String.new(body_node.name)
            full_enum_name = "#{lib_name}::#{enum_name}"
            register_enum_with_name(body_node, full_enum_name)
          when CrystalV2::Compiler::Frontend::ClassNode
            # Struct/union within lib are parsed as ClassNode with flags.
            struct_name = String.new(body_node.name)
            full_struct_name = "#{lib_name}::#{struct_name}"
            register_class_with_name(body_node, full_struct_name)
            lower_class_with_name(body_node, full_struct_name)
            @lib_structs.add(full_struct_name)
          end
        end

        # Pass 2: register externs after types are available.
        body.each do |expr_id|
          body_node = @arena[expr_id]
          case body_node
          when CrystalV2::Compiler::Frontend::FunNode
            # Register external function
            register_extern_fun(lib_name, body_node)
          when CrystalV2::Compiler::Frontend::AnnotationNode,
               CrystalV2::Compiler::Frontend::AliasNode,
               CrystalV2::Compiler::Frontend::EnumNode,
               CrystalV2::Compiler::Frontend::ClassNode
            # Already handled in pass 1.
          else
            # Other declarations - process recursively
            lower_node(ctx, body_node)
          end
        end
      end

      # Lib declarations don't produce values
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_fun(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::FunNode) : ValueId
      # fun malloc(size : Int64) : Void* - external C function
      # Register in current lib context (or global if not in lib)
      register_extern_fun(nil, node)

      # Fun declarations don't produce values
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def register_extern_fun(lib_name : String?, node : CrystalV2::Compiler::Frontend::FunNode)
      fun_name = String.new(node.name)
      real_name = node.real_name ? String.new(node.real_name.not_nil!) : fun_name

      # Top-level `fun main` in the stdlib is a C-ABI entrypoint in the real compiler.
      # Our bootstrap uses a synthetic wrapper main, so skip registering it as an extern
      # to avoid LLVM redefinition (declare + define).
      if lib_name.nil? && fun_name == "main"
        return
      end

      old_class = @current_class
      @current_class = lib_name if lib_name
      # Build parameter types
      param_types = [] of TypeRef
      return_type = TypeRef::VOID
      begin
        if params = node.params
          params.each do |param|
            if type_ann = param.type_annotation
              type_name = String.new(type_ann)
              param_types << type_ref_for_c_type(type_name)
            else
              param_types << TypeRef::POINTER  # Default to pointer for untyped params
            end
          end
        end

        # Return type
        return_type = if ret = node.return_type
                        type_ref_for_c_type(String.new(ret))
                      else
                        TypeRef::VOID
                      end
      ensure
        @current_class = old_class
      end

      if ENV["DEBUG_LIBC_EXTERN"]? && lib_name == "LibC" && fun_name == "dladdr"
        param_names = param_types.map { |t| get_type_name_from_ref(t) }.join(", ")
        STDERR.puts "[DEBUG_LIBC_EXTERN] #{lib_name}.#{fun_name} params=[#{param_names}] return=#{get_type_name_from_ref(return_type)}"
      end

      # Register the external function
      @module.add_extern_function(ExternFunction.new(
        name: fun_name,
        real_name: real_name,
        lib_name: lib_name,
        param_types: param_types,
        return_type: return_type,
        varargs: node.varargs
      ))

      if ENV["DEBUG_LIB_REG"]? && lib_name == "LibUnwind" && fun_name == "raise_exception"
        STDERR.puts "[LIB_REG] extern lib=#{lib_name} fun=#{fun_name} real=#{real_name}"
      end
    end

    # Convert Crystal type notation to C-compatible TypeRef
    private def type_ref_for_c_type(type_name : String) : TypeRef
      type_name = type_name.strip

      if type_name.ends_with?("*")
        base_name = type_name
        star_count = 0
        while base_name.ends_with?("*")
          base_name = base_name[0...-1]
          star_count += 1
        end
        base_name = base_name.strip
        base_ref = type_ref_for_c_type(base_name)
        pointer_name = get_type_name_from_ref(base_ref)
        star_count.times { pointer_name = "Pointer(#{pointer_name})" }
        return type_ref_for_name(pointer_name)
      end

      if type_name.starts_with?("Pointer(")
        return type_ref_for_name(type_name)
      end

      case type_name
      when "Void"
        TypeRef::VOID
      when "Int8", "SChar"
        TypeRef::INT8
      when "UInt8", "Char", "UChar"
        TypeRef::UINT8
      when "Int16", "Short"
        TypeRef::INT16
      when "UInt16", "UShort"
        TypeRef::UINT16
      when "Int32", "Int"
        TypeRef::INT32
      when "UInt32", "UInt"
        TypeRef::UINT32
      when "Int64", "Long", "LongLong"
        TypeRef::INT64
      when "UInt64", "ULong", "ULongLong", "SizeT"
        TypeRef::UINT64
      when "Float32", "Float"
        TypeRef::FLOAT32
      when "Float64", "Double"
        TypeRef::FLOAT64
      when "Bool"
        TypeRef::BOOL
      when "NoReturn"
        TypeRef::VOID  # NoReturn functions still have void return in LLVM
      when "Pointer"
        TypeRef::POINTER
      else
        resolved = type_ref_for_name(type_name)
        resolved == TypeRef::VOID ? TypeRef::POINTER : resolved
      end
    end

    # ═══════════════════════════════════════════════════════════════════════
    # MACRO EXPANSION
    # ═══════════════════════════════════════════════════════════════════════

    # Compile-time flags for platform detection
    COMPILE_FLAGS = Set{
      # Platform
      "darwin", "unix", "linux", "freebsd", "openbsd", "netbsd", "dragonfly",
      "win32", "windows", "android", "wasi",
      # Architecture
      "x86_64", "aarch64", "arm64", "i386", "arm",
      # Build config
      "release", "debug",
      # Crystal-specific
      "preview_mt",
    }

    # Evaluate a macro flag condition at compile time
    private def evaluate_macro_flag(flag_name : String) : Bool
      # Remove leading/trailing quotes and colons
      clean_name = flag_name.strip.gsub(/^[:"']|["']$/, "")
      # Check against known compile flags - use macOS defaults for now
      case clean_name
      when "darwin", "unix"
        true  # macOS is darwin and unix
      when "kqueue"
        true  # macOS uses kqueue for event loop
      when "linux", "win32", "windows", "android", "wasi", "epoll", "libevent", "openbsd", "freebsd", "netbsd", "dragonfly"
        false  # Not linux/windows/android/bsd
      when "x86_64", "aarch64", "arm64"
        # Assume arm64 for modern Macs
        clean_name == "aarch64" || clean_name == "arm64"
      when "release"
        true  # Assume release build
      when "execution_context", "preview_mt"
        false  # Not using execution context by default
      else
        # Check using macro-style syntax flag?("evloop=kqueue")
        if clean_name.starts_with?("evloop=")
          clean_name == "evloop=kqueue"  # macOS uses kqueue
        else
          COMPILE_FLAGS.includes?(clean_name)
        end
      end
    end

    private def merge_macro_or(left : Bool?, right : Bool?) : Bool?
      return true if left == true || right == true
      return false if left == false && right == false
      nil
    end

    private def merge_macro_and(left : Bool?, right : Bool?) : Bool?
      return false if left == false || right == false
      return true if left == true && right == true
      nil
    end

    # Try to evaluate a macro condition expression at compile time
    # Returns true/false if evaluable, nil if not
    private def try_evaluate_macro_condition(condition_id : ExprId) : Bool?
      cond_node = @arena[condition_id]
      case cond_node
      when CrystalV2::Compiler::Frontend::BoolNode
        cond_node.value
      when CrystalV2::Compiler::Frontend::NilNode
        false
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        try_evaluate_macro_condition(cond_node.expression)
      when CrystalV2::Compiler::Frontend::CallNode
        # Check for flag?(:name) or flag?("name")
        callee = @arena[cond_node.callee]
        if callee.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          callee_name = String.new(callee.name)
          if callee_name == "flag?"
            if cond_node.args.size >= 1
              arg_node = @arena[cond_node.args[0]]
              flag_name = case arg_node
                          when CrystalV2::Compiler::Frontend::SymbolNode
                            String.new(arg_node.name)
                          when CrystalV2::Compiler::Frontend::StringNode
                            String.new(arg_node.value)
                          else
                            nil
                          end
              if flag_name
                return evaluate_macro_flag(flag_name)
              end
            end
          end
        end
      when CrystalV2::Compiler::Frontend::UnaryNode
        # Handle !flag?(:name)
        op_str = String.new(cond_node.operator)
        if op_str == "!"
          inner = try_evaluate_macro_condition(cond_node.operand)
          return inner.nil? ? nil : !inner
        end
      when CrystalV2::Compiler::Frontend::BinaryNode
        # Handle flag?(:a) || flag?(:b) or flag?(:a) && flag?(:b)
        left = try_evaluate_macro_condition(cond_node.left)
        right = try_evaluate_macro_condition(cond_node.right)
        op_str = String.new(cond_node.operator)
        case op_str
        when "||"
          return merge_macro_or(left, right)
        when "&&"
          return merge_macro_and(left, right)
        end
      end
      nil  # Can't evaluate
    end

    private def macro_for_iterable_values(iterable_id : ExprId) : Array(CrystalV2::Compiler::Semantic::MacroValue)?
      node = @arena[iterable_id]
      if node.is_a?(CrystalV2::Compiler::Frontend::MacroExpressionNode)
        return macro_for_iterable_values(node.expression)
      end

      case node
      when CrystalV2::Compiler::Frontend::ArrayLiteralNode
        values = [] of CrystalV2::Compiler::Semantic::MacroValue
        node.elements.each do |elem_id|
          value = macro_value_for_expr(elem_id)
          return nil unless value
          values << value
        end
        values
      when CrystalV2::Compiler::Frontend::RangeNode
        start_val = macro_int_literal_for_expr(node.begin_expr)
        end_val = macro_int_literal_for_expr(node.end_expr)
        return nil unless start_val && end_val
        limit = CrystalV2::Compiler::Semantic::MacroExpander::MAX_RANGE_SIZE
        last_val = node.exclusive ? end_val - 1 : end_val
        count = last_val - start_val + 1
        return nil if count < 0 || count > limit
        values = [] of CrystalV2::Compiler::Semantic::MacroValue
        current = start_val
        while current <= last_val
          values << CrystalV2::Compiler::Semantic::MacroNumberValue.new(current)
          current += 1
        end
        values
      else
        nil
      end
    end

    private def macro_value_for_expr(expr_id : ExprId) : CrystalV2::Compiler::Semantic::MacroValue?
      expr_node = @arena[expr_id]
      case expr_node
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        macro_value_for_expr(expr_node.expression)
      when CrystalV2::Compiler::Frontend::StringNode
        CrystalV2::Compiler::Semantic::MacroStringValue.new(String.new(expr_node.value))
      when CrystalV2::Compiler::Frontend::SymbolNode
        CrystalV2::Compiler::Semantic::MacroSymbolValue.new(String.new(expr_node.name))
      when CrystalV2::Compiler::Frontend::NumberNode
        num_str = String.new(expr_node.value).gsub("_", "")
        if num_str.includes?(".") || num_str.includes?("e") || num_str.includes?("E")
          CrystalV2::Compiler::Semantic::MacroNumberValue.new(num_str.to_f64)
        else
          CrystalV2::Compiler::Semantic::MacroNumberValue.new(num_str.to_i64)
        end
      when CrystalV2::Compiler::Frontend::IdentifierNode
        CrystalV2::Compiler::Semantic::MacroIdValue.new(String.new(expr_node.name))
      when CrystalV2::Compiler::Frontend::PathNode
        CrystalV2::Compiler::Semantic::MacroIdValue.new(collect_path_string(expr_node))
      else
        nil
      end
    end

    private def macro_int_literal_for_expr(expr_id : ExprId) : Int64?
      expr_node = @arena[expr_id]
      case expr_node
      when CrystalV2::Compiler::Frontend::MacroExpressionNode
        macro_int_literal_for_expr(expr_node.expression)
      when CrystalV2::Compiler::Frontend::NumberNode
        num_str = String.new(expr_node.value).gsub("_", "")
        num_str.to_i64?
      else
        nil
      end
    end

    # Lower macro if/elsif/else at compile time
    private def lower_macro_if(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::MacroIfNode) : ValueId
      # Try to evaluate condition at compile time
      result = try_evaluate_macro_condition(node.condition)
      if ENV.has_key?("DEBUG_MACRO_IF")
        STDERR.puts "[MACRO_IF] condition_id=#{node.condition}, result=#{result.inspect}"
      end

      if result == true
        # Condition is true - lower the then branch
        lower_macro_body(ctx, node.then_body)
      elsif result == false
        # Condition is false - check else branch
        if else_node = node.else_body
          else_ast = @arena[else_node]
          case else_ast
          when CrystalV2::Compiler::Frontend::MacroIfNode
            # elsif - recursive evaluation
            lower_macro_if(ctx, else_ast)
          else
            # else branch (MacroLiteralNode containing body)
            lower_macro_body(ctx, else_node)
          end
        else
          # No else - return nil
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(nil_lit)
          nil_lit.id
        end
      else
        # Can't evaluate at compile time - return nil with warning
        # STDERR.puts "[WARN] Cannot evaluate macro condition at compile time"
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      end
    end

    # Lower the body of a macro branch (MacroLiteralNode or expression)
    private def lower_macro_body(ctx : LoweringContext, body_id : ExprId) : ValueId
      body_node = @arena[body_id]
      case body_node
      when CrystalV2::Compiler::Frontend::MacroLiteralNode
        if raw_text = macro_literal_raw_text(body_node)
          if parsed = parse_macro_literal_method_body(raw_text)
            return lower_parsed_macro_body(ctx, parsed)
          elsif raw_text.includes?("{%")
            if expanded = expand_flag_macro_text(raw_text)
              if parsed = parse_macro_literal_method_body(expanded)
                return lower_parsed_macro_body(ctx, parsed)
              end
            end
          end
        end

        # Macro literal contains pieces (text and expressions)
        last_value : ValueId? = nil
        if pieces = body_node.pieces
          pieces.each do |piece|
            case piece.kind
            when CrystalV2::Compiler::Frontend::MacroPiece::Kind::Expression
              # Expression piece - lower the expression
              if expr_id = piece.expr
                last_value = lower_expr(ctx, expr_id)
              end
            when CrystalV2::Compiler::Frontend::MacroPiece::Kind::Text
              # Text piece - skip (just literal text, not code)
              nil
            else
              # Other control pieces - skip
              nil
            end
          end
        end
        last_value || begin
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(nil_lit)
          nil_lit.id
        end
      else
        # Direct expression
        lower_expr(ctx, body_id)
      end
    end

    private def lower_parsed_macro_body(
      ctx : LoweringContext,
      parsed : Tuple(CrystalV2::Compiler::Frontend::Program, Array(ExprId))
    ) : ValueId
      program, body = parsed
      parsed_value : ValueId? = nil
      with_arena(program.arena) do
        body.each do |expr_id|
          parsed_value = lower_expr(ctx, expr_id)
        end
      end
      parsed_value || begin
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      end
    end

    # Lower a MacroLiteralNode that may contain text with {% if flag?() %} patterns
    private def lower_macro_literal(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::MacroLiteralNode) : ValueId
      # Prefer raw source text (includes control tags and whitespace).
      if raw_text = macro_literal_raw_text(node)
        if expanded = expand_flag_macro_text(raw_text)
          # Parse and lower the expanded code
          result = lower_expanded_macro_code(ctx, expanded)
          return result if result
        end
      else
        # Fallback to piece text when source is unavailable.
        node.pieces.each do |piece|
          next unless piece.kind == CrystalV2::Compiler::Frontend::MacroPiece::Kind::Text
          if text = piece.text
            expanded = expand_flag_macro_text(text)
            if expanded
              result = lower_expanded_macro_code(ctx, expanded)
              return result if result
            end
          end
        end
      end

      # Fall back to expression pieces only.
      node.pieces.each do |piece|
        next unless piece.kind == CrystalV2::Compiler::Frontend::MacroPiece::Kind::Expression
        if expr_id = piece.expr
          return lower_expr(ctx, expr_id)
        end
      end

      # No expansion possible - return nil
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Expand {% if flag?(:name) %} ... {% else %} ... {% end %} patterns in text
    private def expand_flag_macro_text(text : String) : String?
      trimmed = strip_macro_leading_comments(text)
      if parsed = parse_flag_macro_branches(trimmed)
        branches, else_body = parsed
        branches.each do |(cond, body)|
          verdict = evaluate_flag_condition_string(cond)
          return nil if verdict.nil?
          next unless verdict
          chosen = body.strip
          return nil if chosen.empty?
          return expand_flag_macro_text(chosen) || chosen
        end
        if else_body
          chosen = else_body.strip
          return nil if chosen.empty?
          return expand_flag_macro_text(chosen) || chosen
        end
        return nil
      end

      nil
    end

    private def parse_flag_macro_branches(text : String) : Tuple(Array(Tuple(String, String)), String?)?
      return nil unless text.includes?("{%")
      tag_re = /\{%\s*(if|elsif|else|end|unless)\b(.*?)%\}/m
      first = tag_re.match(text)
      return nil unless first
      return nil unless text[0, first.begin].strip.empty?
      tag = first[1]? || ""
      return nil unless tag == "if" || tag == "unless"

      cond = (first[2]? || "").strip
      cond = "!#{cond}" if tag == "unless"

      branches = [] of Tuple(String, String)
      depth = 0
      pos = first.end
      current_start = pos
      current_cond = cond
      else_body : String? = nil

      while match = tag_re.match(text, pos)
        tag = match[1]? || ""
        case tag
        when "if", "unless"
          depth += 1
        when "end"
          if depth == 0
            body = text[current_start, match.begin - current_start]
            if else_body
              else_body = body
            else
              branches << {current_cond, body}
            end
            return {branches, else_body}
          end
          depth -= 1
        when "elsif"
          if depth == 0 && else_body.nil?
            body = text[current_start, match.begin - current_start]
            branches << {current_cond, body}
            current_cond = (match[2]? || "").strip
            current_start = match.end
          end
        when "else"
          if depth == 0 && else_body.nil?
            body = text[current_start, match.begin - current_start]
            branches << {current_cond, body}
            else_body = ""
            current_start = match.end
          end
        end
        pos = match.end
      end
      nil
    end

    private def evaluate_flag_condition_string(cond : String) : Bool?
      cleaned = cond.strip
      return nil if cleaned.empty?
      if cleaned.starts_with?("!")
        inner = evaluate_flag_condition_string(cleaned[1..])
        return inner.nil? ? nil : !inner
      end
      if cleaned.includes?("||")
        parts = cleaned.split("||")
        results = [] of Bool?
        parts.each do |part|
          results << evaluate_flag_condition_string(part)
        end
        return nil if results.any?(&.nil?)
        return results.any? { |res| res == true }
      end
      if cleaned.includes?("&&")
        parts = cleaned.split("&&")
        results = [] of Bool?
        parts.each do |part|
          results << evaluate_flag_condition_string(part)
        end
        return nil if results.any?(&.nil?)
        return results.all? { |res| res == true }
      end
      if match = cleaned.match(/flag\?\s*\(\s*(?::([A-Za-z0-9_]+)|"([^"]+)"|'([^']+)')\s*\)/)
        flag_name = match[1]? || match[2]? || match[3]? || ""
        return evaluate_macro_flag(flag_name)
      end
      nil
    end

    private def flag_name_from_match(match : Regex::MatchData) : String
      match[1]? || match[2]? || match[3]? || ""
    end

    private def strip_macro_leading_comments(text : String) : String
      idx = 0
      while idx < text.size
        while idx < text.size && text[idx].ascii_whitespace?
          idx += 1
        end
        break unless idx < text.size && text.byte_at(idx) == '#'.ord
        newline = text.index('\n', idx) || text.size
        idx = newline + 1
      end
      text[idx, text.size - idx]
    end

    private def macro_literal_raw_text(node : CrystalV2::Compiler::Frontend::MacroLiteralNode) : String?
      return nil if node.pieces.empty?

      source = @sources_by_arena[@arena]?
      bytesize = source ? source.bytesize : 0
      builder = String::Builder.new

      node.pieces.each do |piece|
        if source && (span = piece.span)
          start = span.start_offset
          length = span.end_offset - span.start_offset
          next if length <= 0
          next if start < 0 || start >= bytesize
          if start + length > bytesize
            length = bytesize - start
          end
          builder << source.byte_slice(start, length)
        elsif text = piece.text
          builder << text
        end
      end

      text = builder.to_s
      text.empty? ? nil : text
    end

    private def macro_if_raw_text(node : CrystalV2::Compiler::Frontend::MacroIfNode) : String?
      source = @sources_by_arena[@arena]?
      return nil unless source
      span = node.span
      start = span.start_offset
      length = span.end_offset - span.start_offset
      return nil if length <= 0
      return nil if start < 0 || start >= source.bytesize
      if start + length > source.bytesize
        length = source.bytesize - start
      end
      source.byte_slice(start, length)
    end

    private def parse_macro_literal_program(code : String) : CrystalV2::Compiler::Frontend::Program?
      trimmed = code.strip
      return nil if trimmed.empty?
      return nil if trimmed.includes?("{%") || trimmed.includes?("{{")

      lexer = CrystalV2::Compiler::Frontend::Lexer.new(trimmed)
      parser = CrystalV2::Compiler::Frontend::Parser.new(lexer, recovery_mode: true)
      program = parser.parse_program
      return nil if program.roots.empty?
      @sources_by_arena[program.arena] = trimmed
      program
    end

    private def parse_macro_literal_lib_body(code : String) : Tuple(CrystalV2::Compiler::Frontend::Program, Array(ExprId))?
      trimmed = code.strip
      return nil if trimmed.empty?
      return nil if trimmed.includes?("{%") || trimmed.includes?("{{")

      wrapped = "lib __MacroContext__\n#{trimmed}\nend\n"
      lexer = CrystalV2::Compiler::Frontend::Lexer.new(wrapped)
      parser = CrystalV2::Compiler::Frontend::Parser.new(lexer, recovery_mode: true)
      program = parser.parse_program
      return nil if program.roots.empty?
      @sources_by_arena[program.arena] = wrapped

      lib_node = program.roots.map { |id| program.arena[id] }
        .find(&.is_a?(CrystalV2::Compiler::Frontend::LibNode))
      return nil unless lib_node

      body = lib_node.as(CrystalV2::Compiler::Frontend::LibNode).body
      return nil unless body

      {program, body}
    end

    private def parse_macro_literal_class_body(code : String) : Tuple(CrystalV2::Compiler::Frontend::Program, Array(ExprId))?
      trimmed = code.strip
      return nil if trimmed.empty?
      return nil if trimmed.includes?("{%") || trimmed.includes?("{{")

      wrapped = "class __MacroContext__\n#{trimmed}\nend\n"
      lexer = CrystalV2::Compiler::Frontend::Lexer.new(wrapped)
      parser = CrystalV2::Compiler::Frontend::Parser.new(lexer, recovery_mode: true)
      program = parser.parse_program
      return nil if program.roots.empty?
      @sources_by_arena[program.arena] = wrapped

      class_node = program.roots.map { |id| program.arena[id] }
        .find(&.is_a?(CrystalV2::Compiler::Frontend::ClassNode))
      return nil unless class_node

      body = class_node.as(CrystalV2::Compiler::Frontend::ClassNode).body
      return nil unless body

      {program, body}
    end

    private def parse_macro_literal_method_body(code : String) : Tuple(CrystalV2::Compiler::Frontend::Program, Array(ExprId))?
      trimmed = code.strip
      return nil if trimmed.empty?
      return nil if trimmed.includes?("{%") || trimmed.includes?("{{")

      wrapped = "def __MacroContext__\n#{trimmed}\nend\n"
      lexer = CrystalV2::Compiler::Frontend::Lexer.new(wrapped)
      parser = CrystalV2::Compiler::Frontend::Parser.new(lexer, recovery_mode: true)
      program = parser.parse_program
      return nil if program.roots.empty?
      @sources_by_arena[program.arena] = wrapped

      def_node = program.roots.map { |id| program.arena[id] }
        .find(&.is_a?(CrystalV2::Compiler::Frontend::DefNode))
      return nil unless def_node

      body = def_node.as(CrystalV2::Compiler::Frontend::DefNode).body
      return nil unless body

      {program, body}
    end

    # Lower expanded macro code by parsing and lowering it
    private def lower_expanded_macro_code(ctx : LoweringContext, code : String) : ValueId?
      return nil if code.empty?

      # Create a mini-parser for simple Crystal expressions
      # Handle common patterns: Path.method, method_call, Path
      code = code.strip

      # Pattern: Namespace::Path.method_call (handles Crystal::Scheduler.event_loop)
      if match = code.match(/^([A-Z][A-Za-z0-9_]*(?:::[A-Z][A-Za-z0-9_]*)*)\.(\w+)$/)
        type_path = match[1]
        method_name = match[2]
        # Generate call to type.method()
        full_name = "#{type_path}.#{method_name}"
        lower_function_if_needed(full_name)
        if @module.has_function?(full_name)
          return_type = @function_base_return_types[full_name]? || TypeRef::VOID
          call = Call.new(ctx.next_id, return_type, nil, full_name, [] of ValueId)
          ctx.emit(call)
          return call.id
        end
      end

      # Pattern: Simple path reference (constant)
      if match = code.match(/^([A-Z][A-Za-z0-9_]*(?:::[A-Z][A-Za-z0-9_]*)*)$/)
        type_path = match[1]
        type_ref = type_ref_for_name(type_path)
        if type_ref != TypeRef::VOID
          lit = Literal.new(ctx.next_id, type_ref, nil)
          ctx.emit(lit)
          return lit.id
        end
      end

      nil
    end

    # ═══════════════════════════════════════════════════════════════════════
    # METAPROGRAMMING (typeof, sizeof, etc.)
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_typeof(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::TypeofNode) : ValueId
      # typeof(x) returns the type of x at compile time
      # At runtime, we evaluate the expressions for side effects and return a type placeholder
      # For now, just lower the args and return a nil (type info is compile-time only)
      node.args.each do |arg_id|
        lower_expr(ctx, arg_id)
      end
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_sizeof(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::SizeofNode) : ValueId
      # sizeof(T) returns the size of type T in bytes
      # For basic types, we can compute this at compile time
      size = 8_i64  # Default pointer size
      if node.args.size > 0
        type_node = @arena[node.args.first]
        size = compute_type_size(type_node)
      end
      lit = Literal.new(ctx.next_id, TypeRef::INT32, size)
      ctx.emit(lit)
      lit.id
    end

    private def lower_offsetof(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::OffsetofNode) : ValueId
      # offsetof(T, @field) returns the byte offset of a field
      offset = 0_i64  # Default
      lit = Literal.new(ctx.next_id, TypeRef::INT32, offset)
      ctx.emit(lit)
      lit.id
    end

    private def compute_type_size(type_node : CrystalV2::Compiler::Frontend::Node) : Int64
      case type_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(type_node.name)
        case name
        when "Int8", "UInt8", "Bool" then 1_i64
        when "Int16", "UInt16"       then 2_i64
        when "Int32", "UInt32", "Float32", "Char" then 4_i64
        when "Int64", "UInt64", "Float64" then 8_i64
        when "Int128", "UInt128"     then 16_i64
        else 8_i64  # Pointer/reference size
        end
      when CrystalV2::Compiler::Frontend::ConstantNode
        name = String.new(type_node.name)
        case name
        when "Int8", "UInt8", "Bool" then 1_i64
        when "Int16", "UInt16"       then 2_i64
        when "Int32", "UInt32", "Float32", "Char" then 4_i64
        when "Int64", "UInt64", "Float64" then 8_i64
        when "Int128", "UInt128"     then 16_i64
        else 8_i64
        end
      else
        8_i64  # Default pointer size
      end
    end

    # Lower top-level method definition
    private def lower_top_level_def(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::DefNode) : ValueId
      # Top-level methods are global functions
      method_name = String.new(node.name)
      param_types = [] of TypeRef
      has_block = false
      if params = node.params
        params.each do |param|
          next if named_only_separator?(param)
          if param.is_block
            has_block = true
            next
          end
          param_type = if ta = param.type_annotation
                         type_ref_for_name(String.new(ta))
                       elsif param.is_double_splat
                         type_ref_for_name("NamedTuple")
                       else
                         TypeRef::VOID
                       end
          param_types << param_type
        end
      end

      full_name = function_full_name_for_def(method_name, param_types, node.params, has_block)
      register_pending_method_effects(full_name, param_types.size)
      if @function_defs.has_key?(full_name)
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      # Determine return type
      return_type = if rt = node.return_type
                      type_ref_for_name(String.new(rt))
                    elsif method_name.ends_with?("?")
                      TypeRef::BOOL
                    else
                      TypeRef::VOID
                    end

      register_function_type(full_name, return_type) unless @function_types[full_name]?
      register_function_type(method_name, return_type) unless @function_types[method_name]?

      @function_defs[full_name] = node
      @function_def_arenas[full_name] = @arena
      unless @function_defs.has_key?(method_name)
        @function_defs[method_name] = node
        @function_def_arenas[method_name] = @arena
      end

      # Method definitions don't produce a value
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Lower pointerof(x) to get address of a variable
    private def lower_pointerof(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::PointerofNode) : ValueId
      # pointerof takes one argument - the variable/expression to get address of
      if node.args.empty?
        # Return null pointer if no args
        nil_lit = Literal.new(ctx.next_id, TypeRef::POINTER, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      # Lower the operand (the thing we're getting a pointer to)
      operand_id = lower_expr(ctx, node.args.first)

      # Create AddressOf instruction
      addr_of = AddressOf.new(ctx.next_id, TypeRef::POINTER, operand_id)
      ctx.emit(addr_of)
      ctx.register_type(addr_of.id, TypeRef::POINTER)
      addr_of.id
    end

    # Emit a call to an external C function
    private def emit_extern_call(ctx : LoweringContext, extern_func : ExternFunction, arg_ids : Array(ValueId)) : ValueId
      # Emit an ExternCall instruction with the real C function name
      extern_call = ExternCall.new(
        ctx.next_id,
        extern_func.return_type,
        extern_func.real_name,  # Use the real C name
        arg_ids,
        extern_func.varargs
      )
      ctx.emit(extern_call)
      ctx.register_type(extern_call.id, extern_func.return_type)
      extern_call.id
    end

    private def emit_mem_intrinsic(ctx : LoweringContext, method_name : String, arg_ids : Array(ValueId)) : ValueId
      if arg_ids.size < 4
        if ENV["DEBUG_MEM_INTRINSIC"]?
          STDERR.puts "[MEM_INTRINSIC] emit method=#{method_name} args=#{arg_ids.size} func=#{ctx.function.name}"
        end
        return emit_extern_call(ctx, ExternFunction.new(method_name, method_name, nil, Array(TypeRef).new, TypeRef::VOID), arg_ids)
      end

      len_id = arg_ids[2]
      len_type = ctx.type_of(len_id)
      use_i32 = len_type == TypeRef::UINT32 || len_type == TypeRef::INT32 ||
                len_type == TypeRef::UINT16 || len_type == TypeRef::INT16 ||
                len_type == TypeRef::UINT8 || len_type == TypeRef::INT8
      target_len_type = use_i32 ? TypeRef::UINT32 : TypeRef::UINT64

      if len_type != target_len_type && len_type != TypeRef::VOID
        cast = Cast.new(ctx.next_id, target_len_type, len_id, target_len_type)
        ctx.emit(cast)
        ctx.register_type(cast.id, target_len_type)
        len_id = cast.id
      end

      intrinsic_name = case method_name
                       when "memcpy"
                         use_i32 ? "llvm.memcpy.p0.p0.i32" : "llvm.memcpy.p0.p0.i64"
                       when "memmove"
                         use_i32 ? "llvm.memmove.p0.p0.i32" : "llvm.memmove.p0.p0.i64"
                       else
                         use_i32 ? "llvm.memset.p0.i32" : "llvm.memset.p0.i64"
                       end

      extern_call = ExternCall.new(
        ctx.next_id,
        TypeRef::VOID,
        intrinsic_name,
        [arg_ids[0], arg_ids[1], len_id, arg_ids[3]],
        false
      )
      ctx.emit(extern_call)
      ctx.register_type(extern_call.id, TypeRef::VOID)
      extern_call.id
    end

    private def lower_pointer_new_intrinsic(ctx : LoweringContext, arg_ids : Array(ValueId)) : ValueId?
      return nil unless arg_ids.size == 1

      addr_id = arg_ids[0]
      addr_type = ctx.type_of(addr_id)
      if addr_type == TypeRef::VOID
        addr_cast = Cast.new(ctx.next_id, TypeRef::UINT64, addr_id, TypeRef::UINT64)
        ctx.emit(addr_cast)
        ctx.register_type(addr_cast.id, TypeRef::UINT64)
        addr_id = addr_cast.id
        addr_type = TypeRef::UINT64
      end

      return addr_id if addr_type == TypeRef::POINTER

      if numeric_primitive?(addr_type)
        cast = Cast.new(ctx.next_id, TypeRef::POINTER, addr_id, TypeRef::POINTER)
        ctx.emit(cast)
        ctx.register_type(cast.id, TypeRef::POINTER)
        return cast.id
      end

      nil
    end

    # Resolve annotation name from ExprId to string
    private def resolve_annotation_name(name_expr : CrystalV2::Compiler::Frontend::ExprId) : String
      name_node = @arena[name_expr]
      case name_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        String.new(name_node.name)
      when CrystalV2::Compiler::Frontend::PathNode
        # For paths like JSON::Field, extract the last part
        resolve_annotation_name(name_node.right)
      else
        "Unknown"
      end
    end

    private def lower_string_interpolation(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::StringInterpolationNode) : ValueId
      # String interpolation "Hello #{x}!" becomes:
      # 1. Build string by concatenating parts
      # 2. For each Text piece: create string literal
      # 3. For each Expression piece: convert to string and concat
      #
      # For now, implement simple version that calls __crystal_v2_string_interpolate
      # with all parts as arguments

      parts = [] of ValueId

      node.pieces.each do |piece|
        case piece.kind
        when .text?
          # Simple text piece - create string literal
          text = piece.text || ""
          lit = Literal.new(ctx.next_id, TypeRef::STRING, text)
          ctx.emit(lit)
          parts << lit.id
        when .expression?
          # Expression piece - lower the expression
          if expr_id = piece.expr
            next if expr_id.invalid?
            val_id = lower_expr(ctx, expr_id)
            parts << val_id
          end
        end
      end

      # For simple case with one text part, return it directly
      if parts.size == 1 && node.pieces.first?.try(&.kind.text?)
        return parts.first
      end

      # Create StringInterpolation HIR instruction
      interp = StringInterpolation.new(ctx.next_id, parts)
      ctx.emit(interp)
      interp.id
    end

    private def lower_char(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::CharNode) : ValueId
      # Convert Slice(UInt8) to Char - first char of the slice
      char_value = String.new(node.value)[0]? || '\0'
      lit = Literal.new(ctx.next_id, TypeRef::CHAR, char_value)
      ctx.emit(lit)
      lit.id
    end

    private def lower_bool(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::BoolNode) : ValueId
      lit = Literal.new(ctx.next_id, TypeRef::BOOL, node.value)
      ctx.emit(lit)
      lit.id
    end

    private def lower_nil(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::NilNode) : ValueId
      lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(lit)
      lit.id
    end

    private def lower_symbol(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::SymbolNode) : ValueId
      str = String.new(node.name)
      lit = Literal.new(ctx.next_id, TypeRef::SYMBOL, str)
      ctx.emit(lit)
      lit.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # VARIABLE LOWERING
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_identifier(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::IdentifierNode) : ValueId
      name = String.new(node.name)

      # Check if it's a local variable first
      if local_id = ctx.lookup_local(name)
        # Return a copy/reference to the local
        copy = Copy.new(ctx.next_id, ctx.type_of(local_id), local_id)
        ctx.emit(copy)
        ctx.mark_type_literal(copy.id) if ctx.type_literal?(local_id)
        if enum_name = @enum_value_types.try(&.[local_id]?)
          enum_map = @enum_value_types ||= {} of ValueId => String
          enum_map[copy.id] = enum_name
        end
        return copy.id
      end

      if name[0].uppercase?
        resolved = resolve_type_name_in_context(name)
        resolved = resolve_type_alias_chain(resolved)
        return lower_type_literal_from_name(ctx, resolved) if type_name_exists?(resolved)
      end

      if full_name = resolve_constant_name_in_context(name)
        return emit_constant_get(ctx, full_name)
      end

      if macro_lookup = lookup_macro_entry(name, @current_class)
        macro_entry, macro_key = macro_lookup
        macro_def, macro_arena = macro_entry
        return expand_macro(ctx, macro_def, macro_arena, [] of ExprId, nil, nil, macro_key)
      end

      # Inside a class: check if it's a method call on self (e.g., getter without parens)
      if current_class = @current_class
        if name == "ord" && current_class == "Char"
          self_id = emit_self(ctx)
          cast = Cast.new(ctx.next_id, TypeRef::INT32, self_id, TypeRef::INT32)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT32)
          return cast.id
        end

        if name == "unsafe_chr"
          case current_class
          when "Int8", "Int16", "Int32", "Int64", "Int128",
               "UInt8", "UInt16", "UInt32", "UInt64", "UInt128"
            self_id = emit_self(ctx)
            cast = Cast.new(ctx.next_id, TypeRef::CHAR, self_id, TypeRef::CHAR)
            ctx.emit(cast)
            ctx.register_type(cast.id, TypeRef::CHAR)
            return cast.id
          end
        end

        # Check if method exists in current class (with inheritance)
        class_method_base = resolve_method_with_inheritance(current_class, name)
        if class_method_base
          # This is a method call on self with no arguments
          self_id = emit_self(ctx)
          full_name = mangle_function_name(class_method_base, [] of TypeRef)
          return_type = @function_types[full_name]? || TypeRef::VOID
          lower_function_if_needed(full_name)
          if return_type == TypeRef::VOID
            return_type = get_function_return_type(full_name)
            if return_type == TypeRef::VOID && full_name != class_method_base
              return_type = get_function_return_type(class_method_base)
            end
          end
          call = Call.new(ctx.next_id, return_type, self_id, full_name, [] of ValueId)
          ctx.emit(call)
          ctx.register_type(call.id, return_type)
          if function_returns_type_literal?(full_name, class_method_base)
            ctx.mark_type_literal(call.id)
          end
          return call.id
        end

        # Module/class method call without parens (e.g., class_getter inside module)
        module_method_base = "#{current_class}.#{name}"
        if @function_types.has_key?(module_method_base) || has_function_base?(module_method_base) || @class_accessor_entries.has_key?(module_method_base)
          full_name = mangle_function_name(module_method_base, [] of TypeRef)
          return_type = @function_types[full_name]? || @function_types[module_method_base]? || TypeRef::VOID
          lower_function_if_needed(full_name)
          if return_type == TypeRef::VOID
            return_type = get_function_return_type(full_name)
            if return_type == TypeRef::VOID && full_name != module_method_base
              return_type = get_function_return_type(module_method_base)
            end
          end
          call = Call.new(ctx.next_id, return_type, nil, full_name, [] of ValueId)
          ctx.emit(call)
          ctx.register_type(call.id, return_type)
          if function_returns_type_literal?(full_name, module_method_base)
            ctx.mark_type_literal(call.id)
          end
          return call.id
        end
      end

      # Top-level: treat `main` as a function call when a top-level main is defined.
      if @current_class.nil? && name == "main" && @top_level_main_defined
        full_name = mangle_function_name(TOP_LEVEL_MAIN_BASE, [] of TypeRef)
        return_type = @function_types[full_name]? || TypeRef::VOID
        lower_function_if_needed(full_name)
        call = Call.new(ctx.next_id, return_type, nil, full_name, [] of ValueId)
        ctx.emit(call)
        ctx.register_type(call.id, return_type)
        return call.id
      end

      # Otherwise create a new local (first use)
      local = Local.new(ctx.next_id, TypeRef::VOID, name, ctx.current_scope)
      ctx.emit(local)
      ctx.register_local(name, local.id)
      local.id
    end

    private def lower_instance_var(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::InstanceVarNode) : ValueId
      name = String.new(node.name)

      # Get the type and offset of the instance variable from current class
      ivar_type = TypeRef::VOID
      ivar_offset = 0
      if class_name = @current_class
        if class_info = @class_info[class_name]?
          class_info.ivars.each do |ivar|
            if ivar.name == name
              ivar_type = ivar.type
              ivar_offset = ivar.offset
              break
            end
          end
          # Debug: log ivar lookup results (commented out for performance)
          # if ENV.has_key?("DEBUG_IVAR") && ivar_type == TypeRef::VOID
          #   ivar_names = class_info.ivars.map { |iv| "#{iv.name}:#{iv.type.id}" }.join(", ")
          #   found_ivar = class_info.ivars.find { |iv| iv.name == name }
          #   if found_ivar
          #     STDERR.puts "[IVAR] #{class_name}##{name} FOUND but type is VOID (id=#{found_ivar.type.id})"
          #   else
          #     STDERR.puts "[IVAR] #{class_name}##{name} NOT FOUND in ivars: [#{ivar_names}]"
          #   end
          # end
        end
      end

      # If ivar type is still VOID, try to find a getter method as fallback
      # This handles cases where ivars are defined implicitly (e.g., @ivar = value in initialize)
      if ivar_type == TypeRef::VOID && (class_name = @current_class)
        # Try to find getter method: @bytesize -> bytesize()
        accessor_name = name.lchop('@')
        # IMPORTANT: Don't call getter if we're inside that getter method!
        # This prevents infinite recursion in `def x; @x; end`
        current_method_name = @current_method
        is_inside_getter = current_method_name && current_method_name == accessor_name

        unless is_inside_getter
          getter_base = resolve_method_with_inheritance(class_name, accessor_name)
          if getter_base
            # Found a getter method - emit as method call instead of field get
            self_id = emit_self(ctx)
            full_name = mangle_function_name(getter_base, [] of TypeRef)
            return_type = @function_types[full_name]? || TypeRef::VOID
            # Ensure the getter method is lowered
            remember_callsite_arg_types(full_name, [] of TypeRef)
            lower_function_if_needed(full_name)
            call = Call.new(ctx.next_id, return_type, self_id, full_name, [] of ValueId)
            ctx.emit(call)
            ctx.register_type(call.id, return_type)
            return call.id
          end
        end
      end

      # Instance var access is a field get on self
      self_id = emit_self(ctx)
      field_get = FieldGet.new(ctx.next_id, ivar_type, self_id, name, ivar_offset)
      ctx.emit(field_get)
      ctx.register_type(field_get.id, ivar_type)  # Register type for is_a?/case checks
      field_get.id
    end

    private def lower_class_var(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::ClassVarNode) : ValueId
      # Name includes @@ prefix, strip it
      raw_name = String.new(node.name)
      name = raw_name.lstrip('@')
      cvar_type = get_class_var_type(name)
      class_name = @current_class || ""
      class_var_get = ClassVarGet.new(ctx.next_id, cvar_type, class_name, name)
      ctx.emit(class_var_get)
      ctx.register_type(class_var_get.id, cvar_type)
      class_var_get.id
    end

    private def lower_self(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::SelfNode) : ValueId
      emit_self(ctx)
    end

    # Lower implicit object (like .foo syntax) - treated as self
    private def lower_self_implicit(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::ImplicitObjNode) : ValueId
      emit_self(ctx)
    end

    # Lower super call - calls parent class method with same name
    private def lower_super(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::SuperNode) : ValueId
      class_name = @current_class
      method_name = @current_method

      unless class_name && method_name
        # Fallback: return void
        void_lit = Literal.new(ctx.next_id, TypeRef::VOID, 0_i64)
        ctx.emit(void_lit)
        return void_lit.id
      end

      # Find parent class
      class_info = @class_info[class_name]?
      parent_name = class_info.try(&.parent_name)

      unless parent_name
        # No parent - return void
        void_lit = Literal.new(ctx.next_id, TypeRef::VOID, 0_i64)
        ctx.emit(void_lit)
        return void_lit.id
      end

      # Lower arguments first to get their types
      args = if node_args = node.args
               node_args.reject(&.invalid?).map { |arg| lower_expr(ctx, arg) }
             else
               # If no args, forward current method's parameters
               # Get them from the function context (skip 'self' param at index 0)
               ctx.function.params[1..].map(&.id)
             end

      # Get argument types for mangling
      arg_types = args.map { |arg| ctx.type_of(arg) }

      # Find the method in parent class with proper mangling
      base_method_name = "#{parent_name}##{method_name}"
      super_method_name = mangle_function_name(base_method_name, arg_types)

      # Try to find the actual function definition - it might have more parameters with defaults
      actual_func_name = super_method_name
      actual_func_def : CrystalV2::Compiler::Frontend::DefNode? = nil

      # First try exact match
      if func_def = @function_defs[super_method_name]?
        actual_func_def = func_def
      elsif func_def = @function_defs[base_method_name]?
        actual_func_def = func_def
        actual_func_name = base_method_name
      else
        # Search for mangled variant (method with more params than we're passing)
        mangled_prefix = "#{base_method_name}$"
        @function_defs.each_key do |key|
          if key.starts_with?(mangled_prefix)
            actual_func_def = @function_defs[key]
            actual_func_name = key
            break
          end
        end
      end

      # If we found a method with more parameters, fill in defaults for missing args
      if actual_func_def && actual_func_name != super_method_name
        if params = actual_func_def.params
          # Count non-block, non-separator parameters
          param_count = params.count { |p| !p.is_block && !named_only_separator?(p) }

          if param_count > args.size
            # Need to fill in default values for missing arguments
            param_idx = 0
            params.each do |param|
              next if param.is_block || named_only_separator?(param)
              if param_idx >= args.size
                # This parameter needs a default value
                if default_val = param.default_value
                  default_id = lower_expr(ctx, default_val)
                  args << default_id
                else
                  # No default - use nil
                  nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                  ctx.emit(nil_lit)
                  ctx.register_type(nil_lit.id, TypeRef::NIL)
                  args << nil_lit.id
                end
              end
              param_idx += 1
            end
          end
        end
        super_method_name = actual_func_name
      end

      # Get return type from mangled name
      return_type = @function_types[super_method_name]? || TypeRef::VOID

      # Get self for the call
      self_id = emit_self(ctx)

      # Ensure parent method is lowered
      if ENV.has_key?("DEBUG_SUPER")
        STDERR.puts "[DEBUG_SUPER] lower_super: class=#{class_name} method=#{method_name}"
        STDERR.puts "[DEBUG_SUPER]   parent=#{parent_name}"
        STDERR.puts "[DEBUG_SUPER]   base_method_name=#{base_method_name}"
        STDERR.puts "[DEBUG_SUPER]   super_method_name=#{super_method_name}"
        STDERR.puts "[DEBUG_SUPER]   function_defs.has_key?(super)=#{@function_defs.has_key?(super_method_name)}"
        STDERR.puts "[DEBUG_SUPER]   function_defs.has_key?(base)=#{@function_defs.has_key?(base_method_name)}"
      end
      lower_function_if_needed(super_method_name)

      # Call parent method
      call = Call.new(ctx.next_id, return_type, self_id, super_method_name, args)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      call.id
    end

    private def lower_previous_def(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::PreviousDefNode) : ValueId
      # previous_def calls the previous definition of the current method
      # This is used when reopening classes/methods
      class_name = @current_class
      method_name = @current_method

      unless class_name && method_name
        # No current method context - return nil
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      # Lower arguments first to get their types
      args = if node_args = node.args
               node_args.reject(&.invalid?).map { |arg| lower_expr(ctx, arg) }
             else
               # If no args, forward current method's parameters
               # Get them from the function context (skip 'self' param at index 0)
               ctx.function.params[1..].map(&.id)
             end

      # Get argument types for mangling
      arg_types = args.map { |arg| ctx.type_of(arg) }

      # For previous_def, we call the same method with a _previous suffix
      # The actual linking will resolve this (or fail if no previous def exists)
      base_method_name = "#{class_name}##{method_name}_previous"
      previous_method_name = mangle_function_name(base_method_name, arg_types)

      # Get return type (fallback to VOID if unknown)
      return_type = @function_types[previous_method_name]? || TypeRef::VOID

      # Get self for the call
      self_id = emit_self(ctx)

      # Call previous method definition
      call = Call.new(ctx.next_id, return_type, self_id, previous_method_name, args)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      call.id
    end

    private def path_is_absolute?(node : CrystalV2::Compiler::Frontend::PathNode) : Bool
      source = @sources_by_arena[@arena]?
      if source
        span = node.span
        if span.start_offset >= 0 && span.start_offset + 1 < source.bytesize
          return true if source.byte_slice(span.start_offset, 2) == "::"
        end
        if span.start_offset >= 2
          return true if source.byte_slice(span.start_offset - 2, 2) == "::"
        end
      end

      left_id = node.left
      return true unless left_id

      left_node = @arena[left_id]
      if left_node.is_a?(CrystalV2::Compiler::Frontend::PathNode)
        return path_is_absolute?(left_node)
      end

      if source.nil? &&
         (left_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) ||
          left_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode))
        gap = left_node.span.start_offset - node.span.start_offset
        return true if gap >= 2
      end

      !(left_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) ||
        left_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode))
    end

    # Collect full path string from PathNode (e.g., Foo::Bar::Baz -> "Foo::Bar::Baz")
    private def collect_path_string(node : CrystalV2::Compiler::Frontend::PathNode) : String
      parts = [] of String
      absolute = path_is_absolute?(node)

      # Get left part recursively
      if left_id = node.left
        left_node = @arena[left_id]
        case left_node
        when CrystalV2::Compiler::Frontend::PathNode
          # Recursively collect left path
          left_path = collect_path_string(left_node)
          if left_path.starts_with?("::")
            absolute = true
            left_path = left_path.size > 2 ? left_path[2..] : ""
          end
          parts << left_path unless left_path.empty?
        when CrystalV2::Compiler::Frontend::IdentifierNode
          parts << String.new(left_node.name)
        when CrystalV2::Compiler::Frontend::ConstantNode
          parts << String.new(left_node.name)
        else
          # Unexpected left node: treat as absolute path to avoid namespace capture.
          absolute = true
        end
      else
        # A PathNode without a left part represents an absolute path (::Foo::Bar).
        absolute = true
      end

      # Get right part
      right_node = @arena[node.right]
      case right_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        parts << String.new(right_node.name)
      when CrystalV2::Compiler::Frontend::ConstantNode
        parts << String.new(right_node.name)
      when CrystalV2::Compiler::Frontend::PathNode
        right_path = collect_path_string(right_node)
        if right_path.starts_with?("::")
          absolute = true
          right_path = right_path.size > 2 ? right_path[2..] : ""
        end
        parts << right_path unless right_path.empty?
      end

      path = parts.join("::")
      absolute ? "::#{path}" : path
    end

    # Lower path expression (e.g., Color::Green for enums, or Module::Constant)
    private def lower_path(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::PathNode) : ValueId
      # Extract left and right parts
      # For Color::Green: left = Color (IdentifierNode), right = Green (IdentifierNode)
      left_name : String? = nil
      if left_id = node.left
        left_node = @arena[left_id]
        left_name = case left_node
                    when CrystalV2::Compiler::Frontend::IdentifierNode
                      String.new(left_node.name)
                    when CrystalV2::Compiler::Frontend::ConstantNode
                      String.new(left_node.name)
                    when CrystalV2::Compiler::Frontend::PathNode
                      collect_path_string(left_node)
                    else
                      nil
                    end
      end

      right_node = @arena[node.right]
      right_name = case right_node
                   when CrystalV2::Compiler::Frontend::IdentifierNode
                     String.new(right_node.name)
                   when CrystalV2::Compiler::Frontend::ConstantNode
                     String.new(right_node.name)
                   else
                     nil
                   end

      # Check if this is an enum value access
      if left_name && right_name
        resolved_left = resolve_path_string_in_context(left_name)
        if enum_info = @enum_info
          if members = enum_info[resolved_left]?
            if right_name[0]?.try(&.uppercase?)
              value = members[right_name]? || 0_i64
              # Found enum value - emit as Int32 literal but remember enum type.
              enum_type = enum_base_type(resolved_left)
              lit = Literal.new(ctx.next_id, enum_type, value)
              ctx.emit(lit)
              (@enum_value_types ||= {} of ValueId => String)[lit.id] = resolved_left
              return lit.id
            end
          end
        end
      end

      full_path = resolve_path_string_in_context(collect_path_string(node))
      if type_name_exists?(full_path) || @type_aliases.has_key?(full_path) || @generic_templates.has_key?(full_path)
        return lower_type_literal_from_name(ctx, full_path)
      end

      if full_name = resolve_constant_name_in_context(full_path)
        return emit_constant_get(ctx, full_name)
      end

      # If we're inside a function that returns a type literal, treat unresolved
      # constant paths as type literals to avoid falling back to Int32.
      if right_name && right_name[0]?.try(&.uppercase?)
        if current_method = @current_method
          if current_class = @current_class
            sep = @current_method_is_class ? "." : "#"
            base_name = "#{current_class}#{sep}#{current_method}"
            if @function_return_type_literals.includes?(base_name)
              return lower_type_literal_from_name(ctx, full_path)
            end
          end
        end
      end

      # Fallback: treat as constant or module access (for future expansion)
      # For now, just return 0
      lit = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(lit)
      lit.id
    end

    private def lower_global(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::GlobalNode) : ValueId
      name = String.new(node.name)
      # Global variables are like class vars at top level
      class_var_get = ClassVarGet.new(ctx.next_id, TypeRef::VOID, "$", name)
      class_var_get.lifetime = LifetimeTag::GlobalEscape
      ctx.emit(class_var_get)
      class_var_get.id
    end

    private def emit_self(ctx : LoweringContext) : ValueId
      # Check if we have a 'self' local
      if self_id = ctx.lookup_local("self")
        return self_id
      end

      # Create implicit self parameter
      local = Local.new(ctx.next_id, TypeRef::VOID, "self", ctx.current_scope, mutable: false)
      ctx.emit(local)
      ctx.register_local("self", local.id)
      local.id
    end

    # Lower a generic type reference like Array(Int32), Hash(String, Int32)
    # This is used when calling static methods like Array(Int32).new
    private def lower_generic_type_ref(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::GenericNode) : ValueId
      # Extract base type name
      base_name = resolve_path_like_name(node.base_type) || "Unknown"
      base_name = resolve_type_name_in_context(base_name)
      base_name = resolve_type_alias_chain(base_name)

      # Extract type arguments, substituting any type parameters
      normalize_typeof_name = ->(type_name : String) : String {
        if type_name == "Void" || type_name == "Unknown" || type_name.includes?("|")
          "Pointer(Void)"
        else
          type_name
        end
      }

      type_args = node.type_args.map do |arg_id|
        arg_node = @arena[arg_id]
        arg_name = case arg_node
                   when CrystalV2::Compiler::Frontend::TypeofNode
                     inner = arg_node.args.first?
                     inner ? resolve_typeof_expr(inner) : "Pointer(Void)"
                   else
                     stringify_type_expr(arg_id) || "Unknown"
                   end
        arg_name = resolve_typeof_in_type_string(arg_name)
        arg_name = normalize_typeof_name.call(arg_name)
        arg_name = resolve_type_name_in_context(arg_name)
        arg_name = substitute_type_params_in_type_name(arg_name)
        normalize_tuple_literal_type_name(arg_name)
      end

      # Create specialized class name like Array(Int32)
      class_name = "#{base_name}(#{type_args.join(", ")})"
      class_name = substitute_type_params_in_type_name(class_name)

      # Monomorphize if needed
      if !@monomorphized.includes?(class_name)
        monomorphize_generic_class(base_name, type_args, class_name)
      end

      # Return a type reference literal (for use as receiver in static calls)
      # We use a nil literal with special type tracking
      type_ref = @class_info[class_name]?.try(&.type_ref) || TypeRef::VOID
      if class_info = @class_info[class_name]?
        generate_allocator(class_name, class_info)
      end
      lit = Literal.new(ctx.next_id, type_ref, nil)
      ctx.emit(lit)
      ctx.register_type(lit.id, type_ref)
      ctx.mark_type_literal(lit.id)
      @type_literal_values.add(lit.id)
      lit.id
    end

    private def lower_type_literal_from_name(ctx : LoweringContext, type_name : String) : ValueId
      type_name = resolve_type_name_in_context(type_name)
      type_name = substitute_type_params_in_type_name(type_name)
      if info = split_generic_base_and_args(type_name)
        base_name = resolve_type_alias_chain(info[:base])
        type_args = split_generic_type_args(info[:args]).map do |arg|
          arg = substitute_type_params_in_type_name(arg)
          normalize_tuple_literal_type_name(arg)
        end
        type_name = "#{base_name}(#{type_args.join(", ")})"
        if base_name != "Proc" && !@monomorphized.includes?(type_name)
          monomorphize_generic_class(base_name, type_args, type_name)
        end
      else
        type_name = resolve_type_alias_chain(type_name)
      end
      if class_info = @class_info[type_name]?
        generate_allocator(type_name, class_info)
      end
      type_ref = type_ref_for_name(type_name)
      lit = Literal.new(ctx.next_id, type_ref, nil)
      ctx.emit(lit)
      ctx.register_type(lit.id, type_ref)
      ctx.mark_type_literal(lit.id)
      @type_literal_values.add(lit.id)
      lit.id
    end

    private def resolve_type_literal_class_name(type_name : String) : String?
      return nil unless type_name.ends_with?(".class") || type_name.ends_with?(".metaclass")

      base_name = type_name
      base_name = base_name.sub(/\.class$/, "")
      base_name = base_name.sub(/\.metaclass$/, "")
      return nil if base_name.empty?

      base_name = resolve_type_name_in_context(base_name)
      base_name = substitute_type_params_in_type_name(base_name)
      if info = split_generic_base_and_args(base_name)
        generic_base = resolve_type_alias_chain(info[:base])
        type_args = split_generic_type_args(info[:args]).map do |arg|
          arg = substitute_type_params_in_type_name(arg)
          normalize_tuple_literal_type_name(arg)
        end
        class_name = "#{generic_base}(#{type_args.join(", ")})"
        class_name = substitute_type_params_in_type_name(class_name)
        if generic_base != "Proc" && !@monomorphized.includes?(class_name)
          monomorphize_generic_class(generic_base, type_args, class_name)
        end
        return class_name
      end

      resolve_type_alias_chain(base_name)
    end

    # ═══════════════════════════════════════════════════════════════════════
    # BINARY/UNARY OPERATIONS
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_binary(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::BinaryNode) : ValueId
      op_str = node.operator_string
      if op_str == "&&" || op_str == "||"
        return lower_short_circuit(ctx, node, op_str)
      end

      left_id = lower_expr(ctx, node.left)
      right_id = lower_expr(ctx, node.right)

      # Check for pointer arithmetic: ptr + n or ptr - n
      left_type = ctx.type_of(left_id)
      left_desc = @module.get_type_descriptor(left_type)
      is_pointer_type = left_type == TypeRef::POINTER || (left_desc && left_desc.kind == TypeKind::Pointer)
      right_type = ctx.type_of(right_id)
      right_desc = @module.get_type_descriptor(right_type)
      right_is_pointer = right_type == TypeRef::POINTER || (right_desc && right_desc.kind == TypeKind::Pointer)

      # Pointer difference: ptr - ptr -> element count
      if is_pointer_type && right_is_pointer && op_str == "-"
        element_type = if left_desc && left_desc.kind == TypeKind::Pointer
                         pointer_element_type(left_desc.name)
                       else
                         TypeRef::INT32
                       end
        element_size = type_size(element_type)
        element_size = 1 if element_size <= 0

        left_int = Cast.new(ctx.next_id, TypeRef::INT64, left_id, TypeRef::INT64)
        ctx.emit(left_int)
        ctx.register_type(left_int.id, TypeRef::INT64)
        right_int = Cast.new(ctx.next_id, TypeRef::INT64, right_id, TypeRef::INT64)
        ctx.emit(right_int)
        ctx.register_type(right_int.id, TypeRef::INT64)

        diff = BinaryOperation.new(ctx.next_id, TypeRef::INT64, BinaryOp::Sub, left_int.id, right_int.id)
        ctx.emit(diff)
        ctx.register_type(diff.id, TypeRef::INT64)
        return diff.id if element_size == 1

        size_lit = Literal.new(ctx.next_id, TypeRef::INT64, element_size.to_i64)
        ctx.emit(size_lit)
        ctx.register_type(size_lit.id, TypeRef::INT64)
        div = BinaryOperation.new(ctx.next_id, TypeRef::INT64, BinaryOp::Div, diff.id, size_lit.id)
        ctx.emit(div)
        ctx.register_type(div.id, TypeRef::INT64)
        return div.id
      end
      if is_pointer_type && (op_str == "+" || op_str == "-")
        offset_id = right_id
        # For subtraction, negate the offset
        if op_str == "-"
          neg_one = Literal.new(ctx.next_id, TypeRef::INT32, -1_i64)
          ctx.emit(neg_one)
          ctx.register_type(neg_one.id, TypeRef::INT32)
          neg_offset = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Mul, offset_id, neg_one.id)
          ctx.emit(neg_offset)
          ctx.register_type(neg_offset.id, TypeRef::INT32)
          offset_id = neg_offset.id
        end
        element_type = if left_desc && left_desc.kind == TypeKind::Pointer
                         pointer_element_type(left_desc.name)
                       else
                         TypeRef::INT32
                       end
        element_type = TypeRef::INT32 if element_type == TypeRef::VOID
        result_type = left_desc && left_desc.kind == TypeKind::Pointer ? left_type : TypeRef::POINTER
        add_node = PointerAdd.new(ctx.next_id, result_type, left_id, offset_id, element_type)
        ctx.emit(add_node)
        ctx.register_type(add_node.id, result_type)
        return add_node.id
      end

      # Check for string concatenation: String + String -> StringConcat
      left_type = ctx.type_of(left_id)
      if left_type == TypeRef::STRING && op_str == "+"
        # String concatenation - emit as StringInterpolation with two parts
        interp = StringInterpolation.new(ctx.next_id, [left_id, right_id])
        ctx.emit(interp)
        return interp.id
      end

      # Check for string repetition: String * Int -> __crystal_v2_string_repeat
      if (left_type == TypeRef::STRING || left_type == TypeRef::POINTER) && op_str == "*"
        # String repetition - emit as runtime call
        call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_string_repeat", [left_id, right_id])
        ctx.emit(call)
        ctx.register_type(call.id, TypeRef::POINTER)
        return call.id
      end

      # Check for shovel operator << on non-integer types (IO, Array, etc.)
      # If left operand is pointer or union type and operator is <<, emit as method call
      # This handles io << value and arr << elem, which are NOT bit-shift but append
      is_integer_type = (left_type.id >= TypeRef::INT8.id && left_type.id <= TypeRef::INT128.id) ||
                        (left_type.id >= TypeRef::UINT8.id && left_type.id <= TypeRef::UINT128.id)
      if !is_integer_type && op_str == "<<"
        if right_type == TypeRef::VOID && left_desc && left_desc.kind == TypeKind::Array
          if inferred = left_desc.type_params.first?
            if inferred != TypeRef::VOID
              right_type = inferred
              ctx.register_type(right_id, right_type)
            end
          end
        end
        # Emit as method call: left.<<(right)
        # The method is registered as "#<<" in the function_types
        ensure_monomorphized_type(left_type) unless left_type == TypeRef::VOID
        right_type = ctx.type_of(right_id)
        type_desc = @module.get_type_descriptor(left_type)
        class_name = type_desc.try(&.name) || ""
        class_name = normalize_method_owner_name(class_name)
        base_method_name = class_name.empty? ? "<<" : "#{class_name}#<<"
        primary_mangled_name = mangle_function_name(base_method_name, [right_type])
        # Debug: log the resolution attempt
        if ENV.has_key?("DEBUG_SHOVEL")
          type_desc = @module.get_type_descriptor(left_type)
          STDERR.puts "[SHOVEL] left_type=#{left_type.id}, type_desc=#{type_desc.try(&.name) || "nil"}, right_type=#{right_type.id}"
        end
        method_name = resolve_method_call(ctx, left_id, "<<", [right_type])
        if ENV.has_key?("DEBUG_SHOVEL")
          STDERR.puts "[SHOVEL] resolved to: #{method_name}"
        end
        remember_callsite_arg_types(primary_mangled_name, [right_type])
        if method_name != primary_mangled_name
          remember_callsite_arg_types(method_name, [right_type])
        end
        callsite_label = nil
        if DebugHooks::ENABLED
          span = node.span
          receiver_name = type_name_for_mangling(left_type)
          callsite_label = "func=#{ctx.function.name} method=<< full=#{method_name} class=#{@current_class || ""} recv=#{receiver_name} span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column}"
        end
        with_debug_callsite(callsite_label) do
          lower_function_if_needed(primary_mangled_name)
          if method_name != primary_mangled_name
            lower_function_if_needed(method_name)
          end
        end
        call = Call.new(ctx.next_id, left_type, left_id, method_name, [right_id])
        ctx.emit(call)
        ctx.register_type(call.id, left_type)
        return call.id
      end

      op = case op_str
           when "+"   then BinaryOp::Add
           when "-"   then BinaryOp::Sub
           when "*"   then BinaryOp::Mul
           when "/"   then BinaryOp::Div
           when "//"  then BinaryOp::Div  # Floor division - use Div (truncation) for now
           when "%"   then BinaryOp::Mod
           when "&"   then BinaryOp::BitAnd
           when "|"   then BinaryOp::BitOr
           when "^"   then BinaryOp::BitXor
           when "<<"  then BinaryOp::Shl
           when ">>"  then BinaryOp::Shr
           when "=="  then BinaryOp::Eq
           when "!="  then BinaryOp::Ne
           when "<"   then BinaryOp::Lt
           when "<="  then BinaryOp::Le
           when ">"   then BinaryOp::Gt
           when ">="  then BinaryOp::Ge
           # Wrapping operators - map to same ops (LLVM integer ops already wrap)
           when "&+"  then BinaryOp::Add
           when "&-"  then BinaryOp::Sub
           when "&*"  then BinaryOp::Mul
           else
             # Unknown operator - emit as method call
             return emit_binary_call(ctx, left_id, op_str, right_id)
           end

      result_type = if op.eq? || op.ne? || op.lt? || op.le? || op.gt? || op.ge? || op.and? || op.or?
                      TypeRef::BOOL
                    else
                      # For arithmetic ops, infer type from left operand
                      ctx.type_of(left_id)
                    end

      binop = BinaryOperation.new(ctx.next_id, result_type, op, left_id, right_id)
      ctx.emit(binop)
      binop.id
    end

    # Lower short-circuiting || and && with value semantics (returns last evaluated value).
    private def lower_short_circuit(
      ctx : LoweringContext,
      node : CrystalV2::Compiler::Frontend::BinaryNode,
      op_str : String
    ) : ValueId
      left_id = lower_expr(ctx, node.left)
      left_type = ctx.type_of(left_id)

      cond_id = lower_truthy_check(ctx, left_id, left_type)

      pre_branch_locals = ctx.save_locals

      then_block = ctx.create_block
      else_block = ctx.create_block
      merge_block = ctx.create_block

      ctx.terminate(Branch.new(cond_id, then_block, else_block))

      # then: left is truthy
      ctx.current_block = then_block
      ctx.restore_locals(pre_branch_locals)
      then_value = if op_str == "||"
                     left_id
                   else
                     lower_expr(ctx, node.right)
                   end
      then_exit = ctx.current_block
      then_locals = ctx.save_locals
      then_block_data = ctx.get_block(ctx.current_block)
      then_has_noreturn = then_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
      then_flows_to_merge = then_block_data.terminator.is_a?(Unreachable) && !then_has_noreturn
      if then_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      # else: left is falsy
      ctx.current_block = else_block
      ctx.restore_locals(pre_branch_locals)
      else_value = if op_str == "||"
                     lower_expr(ctx, node.right)
                   else
                     left_id
                   end
      else_exit = ctx.current_block
      else_locals = ctx.save_locals
      else_block_data = ctx.get_block(ctx.current_block)
      else_has_noreturn = else_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
      else_flows_to_merge = else_block_data.terminator.is_a?(Unreachable) && !else_has_noreturn
      if else_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      ctx.current_block = merge_block

      if then_flows_to_merge || else_flows_to_merge
        if then_flows_to_merge && else_flows_to_merge
          # Merge locals and result value
          merge_branch_locals(ctx, pre_branch_locals, then_locals, else_locals, then_exit, else_exit)

          then_type = ctx.type_of(then_value)
          else_type = ctx.type_of(else_value)
          phi_type = union_type_for_values(then_type, else_type)

          if phi_type == TypeRef::VOID || phi_type == TypeRef::NIL
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            return nil_lit.id
          end

          phi = Phi.new(ctx.next_id, phi_type)
          phi.add_incoming(then_exit, then_value)
          phi.add_incoming(else_exit, else_value)
          ctx.emit(phi)
          ctx.register_type(phi.id, phi_type)
          return phi.id
        elsif then_flows_to_merge
          then_locals.each { |name, val| ctx.register_local(name, val) }
          return then_value
        else
          else_locals.each { |name, val| ctx.register_local(name, val) }
          return else_value
        end
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def truthy_narrowing_targets(condition_id : ExprId) : Array(String)
      return [] of String if condition_id.invalid?

      node = @arena[condition_id]
      case node
      when CrystalV2::Compiler::Frontend::GroupingNode
        truthy_narrowing_targets(node.expression)
      when CrystalV2::Compiler::Frontend::IdentifierNode
        [String.new(node.name)]
      when CrystalV2::Compiler::Frontend::AssignNode
        target = @arena[node.target]
        if target.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          [String.new(target.name)]
        else
          [] of String
        end
      when CrystalV2::Compiler::Frontend::BinaryNode
        op = String.new(node.operator)
        if op == "&&"
          left = truthy_narrowing_targets(node.left)
          right = truthy_narrowing_targets(node.right)
          left.concat(right)
        else
          [] of String
        end
      else
        [] of String
      end
    end

    private def is_a_narrowing_targets(condition_id : ExprId) : Array(Tuple(String, TypeRef))
      return [] of Tuple(String, TypeRef) if condition_id.invalid?

      node = @arena[condition_id]
      case node
      when CrystalV2::Compiler::Frontend::GroupingNode
        is_a_narrowing_targets(node.expression)
      when CrystalV2::Compiler::Frontend::BinaryNode
        op = String.new(node.operator)
        if op == "&&"
          left = is_a_narrowing_targets(node.left)
          right = is_a_narrowing_targets(node.right)
          left.concat(right)
        else
          [] of Tuple(String, TypeRef)
        end
      when CrystalV2::Compiler::Frontend::IsANode
        target_name = resolve_typeof_in_type_string(String.new(node.target_type))
        target_type = type_ref_for_name(target_name)
        expr_node = @arena[node.expression]
        if expr_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          [{String.new(expr_node.name), target_type}]
        else
          [] of Tuple(String, TypeRef)
        end
      when CrystalV2::Compiler::Frontend::CallNode
        callee_node = @arena[node.callee]
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
           String.new(callee_node.member) == "is_a?" &&
           node.args.size == 1
          obj_node = @arena[callee_node.object]
          if obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            if type_str = stringify_type_expr(node.args.first)
              type_str = resolve_typeof_in_type_string(type_str)
              target_type = type_ref_for_name(type_str)
              return [{String.new(obj_node.name), target_type}]
            end
          end
        end
        [] of Tuple(String, TypeRef)
      else
        [] of Tuple(String, TypeRef)
      end
    end

    private def apply_truthy_narrowing(ctx : LoweringContext, targets : Array(String)) : Nil
      return if targets.empty?

      targets.each do |name|
        local_id = ctx.lookup_local(name)
        next unless local_id
        local_type = ctx.type_of(local_id)
        next unless is_union_or_nilable_type?(local_type)

        unwrapped = lower_not_nil_intrinsic(ctx, local_id, local_type)
        next if unwrapped == local_id

        ctx.register_local(name, unwrapped)
      end
    end

    private def apply_is_a_narrowing(ctx : LoweringContext, targets : Array(Tuple(String, TypeRef))) : Nil
      return if targets.empty?

      targets.each do |(name, target_type)|
        next if target_type == TypeRef::VOID
        local_id = ctx.lookup_local(name)
        next unless local_id
        local_type = ctx.type_of(local_id)
        next if local_type == target_type

        if is_union_type?(local_type)
          variant_id = get_union_variant_id(local_type, target_type)
          if variant_id >= 0
            unwrap = UnionUnwrap.new(ctx.next_id, target_type, local_id, variant_id, false)
            ctx.emit(unwrap)
            ctx.register_type(unwrap.id, target_type)
            ctx.register_local(name, unwrap.id)
            next
          end
        end

        cast = Cast.new(ctx.next_id, target_type, local_id, target_type, safe: false)
        ctx.emit(cast)
        ctx.register_type(cast.id, target_type)
        ctx.register_local(name, cast.id)
      end
    end

    private def emit_is_a_check(ctx : LoweringContext, value_id : ValueId, type_name : String) : ValueId
      resolved = resolve_typeof_in_type_string(type_name)
      if resolved.includes?("|")
        emit_is_a_check_for_type(ctx, value_id, type_ref_for_name(resolved))
      else
        resolved = resolve_type_name_in_context(resolved)
        resolved = resolve_type_alias_chain(resolved)
        emit_is_a_check_for_type(ctx, value_id, type_ref_for_name(resolved))
      end
    end

    private def emit_is_a_check_for_type(ctx : LoweringContext, value_id : ValueId, check_type : TypeRef) : ValueId
      if is_union_type?(check_type)
        if type_desc = @module.get_type_descriptor(check_type)
          checks = type_desc.type_params.map { |variant| emit_is_a_check_for_type(ctx, value_id, variant) }
          return combine_boolean_checks(ctx, checks)
        end
      end

      value_type = ctx.type_of(value_id)
      if is_union_type?(value_type)
        variant_id = get_union_variant_id(value_type, check_type)
        if variant_id >= 0
          union_is = UnionIs.new(ctx.next_id, value_id, variant_id)
          ctx.emit(union_is)
          ctx.register_type(union_is.id, TypeRef::BOOL)
          return union_is.id
        end
      end

      static = statically_is_a_type?(value_type, check_type)
      unless static.nil?
        lit = Literal.new(ctx.next_id, TypeRef::BOOL, static)
        ctx.emit(lit)
        return lit.id
      end

      is_a = IsA.new(ctx.next_id, value_id, check_type)
      ctx.emit(is_a)
      is_a.id
    end

    private def statically_is_a_type?(value_type : TypeRef, check_type : TypeRef) : Bool?
      return true if value_type == check_type
      return nil if value_type == TypeRef::VOID || check_type == TypeRef::VOID

      if value_type == TypeRef::NIL
        return check_type == TypeRef::NIL
      end
      if check_type == TypeRef::NIL
        return false
      end

      if value_type.primitive? && check_type.primitive?
        return value_type == check_type
      end

      value_desc = @module.get_type_descriptor(value_type)
      check_desc = @module.get_type_descriptor(check_type)
      return nil unless value_desc && check_desc
      return nil if value_desc.kind == TypeKind::Union || check_desc.kind == TypeKind::Union
      return false if value_desc.kind == TypeKind::Primitive && check_desc.kind == TypeKind::Primitive

      value_name = value_desc.name
      check_name = check_desc.name
      return true if value_name == check_name

      current = @class_info[value_name]?
      while current
        parent = current.parent_name
        return false unless parent
        return true if parent == check_name
        current = @class_info[parent]?
      end

      false
    end

    private def combine_boolean_checks(ctx : LoweringContext, checks : Array(ValueId)) : ValueId
      if checks.empty?
        lit = Literal.new(ctx.next_id, TypeRef::BOOL, false)
        ctx.emit(lit)
        return lit.id
      end

      result = checks.first
      checks[1..].each do |check_id|
        merged = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Or, result, check_id)
        ctx.emit(merged)
        ctx.register_type(merged.id, TypeRef::BOOL)
        result = merged.id
      end
      result
    end

    private def union_type_for_values(left_type : TypeRef, right_type : TypeRef) : TypeRef
      return left_type if left_type == right_type
      left_name = get_type_name_from_ref(left_type)
      right_name = get_type_name_from_ref(right_type)
      create_union_type("#{left_name} | #{right_name}")
    end

    private def lower_truthy_check(ctx : LoweringContext, value_id : ValueId, value_type : TypeRef) : ValueId
      if value_type == TypeRef::BOOL
        return value_id
      end

      if value_type == TypeRef::NIL || value_type == TypeRef::VOID
        lit = Literal.new(ctx.next_id, TypeRef::BOOL, false)
        ctx.emit(lit)
        return lit.id
      end

      if value_type == TypeRef::POINTER
        nil_val = Literal.new(ctx.next_id, TypeRef::POINTER, 0_i64)
        ctx.emit(nil_val)
        ne_check = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Ne, value_id, nil_val.id)
        ctx.emit(ne_check)
        return ne_check.id
      end

      if is_union_or_nilable_type?(value_type)
        is_nil = lower_nil_check_intrinsic(ctx, value_id, value_type)
        not_nil = UnaryOperation.new(ctx.next_id, TypeRef::BOOL, UnaryOp::Not, is_nil)
        ctx.emit(not_nil)
        ctx.register_type(not_nil.id, TypeRef::BOOL)
        return not_nil.id
      end

      # Non-nilable, non-bool types are always truthy.
      lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
      ctx.emit(lit)
      lit.id
    end

    private def emit_binary_call(ctx : LoweringContext, left : ValueId, op : String, right : ValueId) : ValueId
      # Qualify method name with receiver's class
      right_type = ctx.type_of(right)
      left_type = ctx.type_of(left)
      ensure_monomorphized_type(left_type) unless left_type == TypeRef::VOID
      type_desc = @module.get_type_descriptor(left_type)
      class_name = type_desc.try(&.name) || ""
      class_name = normalize_method_owner_name(class_name)
      base_method_name = class_name.empty? ? op : "#{class_name}##{op}"
      primary_mangled_name = mangle_function_name(base_method_name, [right_type])
      method_name = resolve_method_call(ctx, left, op, [right_type])
      remember_callsite_arg_types(primary_mangled_name, [right_type])
      if method_name != primary_mangled_name
        remember_callsite_arg_types(method_name, [right_type])
      end
      lower_function_if_needed(primary_mangled_name)
      if method_name != primary_mangled_name
        lower_function_if_needed(method_name)
      end
      call = Call.new(ctx.next_id, TypeRef::VOID, left, method_name, [right])
      ctx.emit(call)
      call.id
    end

    private def lower_unary(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::UnaryNode) : ValueId
      operand_id = lower_expr(ctx, node.operand)

      op_str = String.new(node.operator)
      op = case op_str
           when "-" then UnaryOp::Neg
           when "!" then UnaryOp::Not
           when "~" then UnaryOp::BitNot
           else
             # Unknown unary op - emit as method call
             # Qualify method name with receiver's class
             operand_type = ctx.type_of(operand_id)
             ensure_monomorphized_type(operand_type) unless operand_type == TypeRef::VOID
             type_desc = @module.get_type_descriptor(operand_type)
             class_name = type_desc.try(&.name) || ""
             class_name = normalize_method_owner_name(class_name)
             base_method_name = class_name.empty? ? op_str : "#{class_name}##{op_str}"
             primary_mangled_name = mangle_function_name(base_method_name, [] of TypeRef)
             method_name = resolve_method_call(ctx, operand_id, op_str, [] of TypeRef)
             remember_callsite_arg_types(primary_mangled_name, [] of TypeRef)
             if method_name != primary_mangled_name
               remember_callsite_arg_types(method_name, [] of TypeRef)
             end
             lower_function_if_needed(primary_mangled_name)
             if method_name != primary_mangled_name
               lower_function_if_needed(method_name)
             end
             call = Call.new(ctx.next_id, TypeRef::VOID, operand_id, method_name, [] of ValueId)
             ctx.emit(call)
             return call.id
           end

      # Determine result type based on operation
      result_type = case op
                    when UnaryOp::Not
                      TypeRef::BOOL
                    when UnaryOp::Neg, UnaryOp::BitNot
                      # Negation and bitwise not preserve operand type
                      ctx.type_of(operand_id)
                    else
                      ctx.type_of(operand_id)
                    end
      unop = UnaryOperation.new(ctx.next_id, result_type, op, operand_id)
      ctx.emit(unop)
      unop.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # CONTROL FLOW
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_if(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::IfNode) : ValueId
      merge_block = ctx.create_block

      # Save locals state before branching
      pre_branch_locals = ctx.save_locals
      truthy_targets = truthy_narrowing_targets(node.condition)
      is_a_targets = is_a_narrowing_targets(node.condition)

      # Collect all branches: (exit_block, value, locals, flows_to_merge)
      branches = [] of {BlockId, ValueId, Hash(String, ValueId), Bool}

      # Build the chain: if -> elsif1 -> elsif2 -> ... -> else
      # Each test that fails jumps to the next test block (or final else block)
      elsifs = node.elsifs
      has_elsifs = elsifs && !elsifs.empty?

      # Create blocks for the chain
      then_block = ctx.create_block
      next_test_block = if has_elsifs
                          ctx.create_block  # First elsif test
                        else
                          ctx.create_block  # Direct else block
                        end

      # Lower main condition and branch
      cond_id = lower_expr(ctx, node.condition)
      ctx.terminate(Branch.new(cond_id, then_block, next_test_block))

      # Process "then" branch
      ctx.current_block = then_block
      ctx.push_scope(ScopeKind::Block)
      apply_truthy_narrowing(ctx, truthy_targets)
      apply_is_a_narrowing(ctx, is_a_targets)
      then_value = lower_body(ctx, node.then_body)
      then_exit_block = ctx.current_block
      then_locals = ctx.save_locals
      ctx.pop_scope

      then_block_data = ctx.get_block(ctx.current_block)
      then_has_noreturn = then_block_data.instructions.any? { |inst| inst.is_a?(Raise) || inst.is_a?(Return) }
      then_flows_to_merge = then_block_data.terminator.is_a?(Unreachable) && !then_has_noreturn
      if then_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end
      branches << {then_exit_block, then_value, then_locals, then_flows_to_merge}

      # Process elsif branches
      if elsifs && !elsifs.empty?
        elsifs.each_with_index do |elsif_branch, idx|
          # Restore locals for this test (each elsif sees pre-branch state)
          ctx.restore_locals(pre_branch_locals)

          # We're now in the test block for this elsif
          ctx.current_block = next_test_block

          # Lower elsif condition
          elsif_truthy_targets = truthy_narrowing_targets(elsif_branch.condition)
          elsif_is_a_targets = is_a_narrowing_targets(elsif_branch.condition)
          elsif_cond_id = lower_expr(ctx, elsif_branch.condition)

          # Create body block and next block
          elsif_body_block = ctx.create_block
          is_last_elsif = (idx == elsifs.size - 1)
          next_test_block = if is_last_elsif
                              ctx.create_block  # Final else block
                            else
                              ctx.create_block  # Next elsif test
                            end

          ctx.terminate(Branch.new(elsif_cond_id, elsif_body_block, next_test_block))

          # Process elsif body
          ctx.current_block = elsif_body_block
          ctx.push_scope(ScopeKind::Block)
          apply_truthy_narrowing(ctx, elsif_truthy_targets)
          apply_is_a_narrowing(ctx, elsif_is_a_targets)
          elsif_value = lower_body(ctx, elsif_branch.body)
          elsif_exit_block = ctx.current_block
          elsif_locals = ctx.save_locals
          ctx.pop_scope

          elsif_block_data = ctx.get_block(ctx.current_block)
          elsif_has_noreturn = elsif_block_data.instructions.any? { |inst| inst.is_a?(Raise) || inst.is_a?(Return) }
          elsif_flows_to_merge = elsif_block_data.terminator.is_a?(Unreachable) && !elsif_has_noreturn
          if elsif_flows_to_merge
            ctx.terminate(Jump.new(merge_block))
          end
          branches << {elsif_exit_block, elsif_value, elsif_locals, elsif_flows_to_merge}
        end
      end

      # Process final else branch
      ctx.restore_locals(pre_branch_locals)
      ctx.current_block = next_test_block
      ctx.push_scope(ScopeKind::Block)
      else_value = if else_body = node.else_body
                     if else_body.empty?
                       nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                       ctx.emit(nil_lit)
                       nil_lit.id
                     else
                       lower_body(ctx, else_body)
                     end
                   else
                     # No else: produce nil
                     nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                     ctx.emit(nil_lit)
                     nil_lit.id
                   end
      else_exit_block = ctx.current_block
      else_locals = ctx.save_locals
      ctx.pop_scope

      else_block_data = ctx.get_block(ctx.current_block)
      else_has_noreturn = else_block_data.instructions.any? { |inst| inst.is_a?(Raise) || inst.is_a?(Return) }
      else_flows_to_merge = else_block_data.terminator.is_a?(Unreachable) && !else_has_noreturn
      if else_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end
      branches << {else_exit_block, else_value, else_locals, else_flows_to_merge}

      # Merge block
      ctx.current_block = merge_block

      # Count flowing branches
      flowing_branches = branches.select { |_, _, _, flows| flows }

      if flowing_branches.empty?
        # All branches return/raise - emit nil placeholder
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      elsif flowing_branches.size == 1
        # Only one branch flows - use its value and locals
        exit_block, value, locals, _ = flowing_branches.first
        locals.each { |name, val| ctx.register_local(name, val) }
        return value
      else
        # Multiple branches flow - create phi
        # Use first flowing branch's type as phi type (simplified)
        first_value = flowing_branches.first[1]
        phi_type = ctx.type_of(first_value)

        # Don't create phi for void/nil types
        if phi_type == TypeRef::VOID || phi_type == TypeRef::NIL
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit(nil_lit)
          return nil_lit.id
        end

        phi = Phi.new(ctx.next_id, phi_type)
        flowing_branches.each do |exit_block, value, _, _|
          phi.add_incoming(exit_block, value)
        end
        ctx.emit(phi)
        return phi.id
      end
    end

    # Merge locals from two branches, creating phi nodes where needed
    private def merge_branch_locals(ctx : LoweringContext,
                                    pre_locals : Hash(String, ValueId),
                                    then_locals : Hash(String, ValueId),
                                    else_locals : Hash(String, ValueId),
                                    then_block : BlockId,
                                    else_block : BlockId)
      # Find all variables that exist in either branch or existed before
      all_vars = (then_locals.keys + else_locals.keys + pre_locals.keys).uniq

      all_vars.each do |var_name|
        then_val = then_locals[var_name]?
        else_val = else_locals[var_name]?
        pre_val = pre_locals[var_name]?

        # Use pre-branch value if branch didn't define the variable
        then_val ||= pre_val
        else_val ||= pre_val

        # If variable is new in only one branch (not in pre_locals), use nil for other
        # Crystal semantics: variables assigned in one branch are nilable outside
        if then_val && !else_val
          # Create nil literal for else branch
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit_to_block(else_block, nil_lit)
          else_val = nil_lit.id
        elsif else_val && !then_val
          # Create nil literal for then branch
          nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
          ctx.emit_to_block(then_block, nil_lit)
          then_val = nil_lit.id
        end

        # Skip if variable doesn't exist in either branch (and didn't exist before)
        next unless then_val && else_val

        # If both branches have the same value, no phi needed
        if then_val == else_val
          ctx.register_local(var_name, then_val)
          next
        end

        # Create phi to merge the values
        var_type = ctx.type_of(then_val)
        merge_phi = Phi.new(ctx.next_id, var_type)
        merge_phi.add_incoming(then_block, then_val)
        merge_phi.add_incoming(else_block, else_val)
        ctx.emit(merge_phi)
        ctx.register_local(var_name, merge_phi.id)
      end
    end

    # Merge locals from N branches (for case expressions), creating phi nodes where needed
    # branch_info: Array of (BlockId, Hash(String, ValueId)) for each branch
    private def merge_case_locals(ctx : LoweringContext,
                                  pre_locals : Hash(String, ValueId),
                                  branch_info : Array(Tuple(BlockId, Hash(String, ValueId))))
      return if branch_info.empty?

      # Collect all variable names across all branches
      all_vars = Set(String).new
      branch_info.each { |(_, locals)| all_vars.concat(locals.keys) }

      all_vars.each do |var_name|
        pre_val = pre_locals[var_name]?

        # Collect values from all branches that have this variable
        branch_values = [] of Tuple(BlockId, ValueId)
        branch_info.each do |(block, locals)|
          if val = locals[var_name]?
            branch_values << {block, val}
          elsif pre_val
            # Branch didn't modify, use pre-case value
            branch_values << {block, pre_val}
          end
        end

        # Skip if variable doesn't exist in all branches and didn't exist before
        next if branch_values.size != branch_info.size

        # If all branches have the same value, no phi needed
        first_val = branch_values.first[1]
        if branch_values.all? { |(_, v)| v == first_val }
          ctx.register_local(var_name, first_val)
          next
        end

        # Create phi to merge values from all branches
        var_type = ctx.type_of(first_val)
        merge_phi = Phi.new(ctx.next_id, var_type)
        branch_values.each { |(blk, val)| merge_phi.add_incoming(blk, val) }
        ctx.emit(merge_phi)
        ctx.register_local(var_name, merge_phi.id)
      end
    end

    private def lower_unless(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::UnlessNode) : ValueId
      # Unless is just if with inverted condition
      cond_id = lower_expr(ctx, node.condition)

      # Save locals state before branching
      pre_branch_locals = ctx.save_locals

      # Negate condition
      neg_cond = UnaryOperation.new(ctx.next_id, TypeRef::BOOL, UnaryOp::Not, cond_id)
      ctx.emit(neg_cond)

      then_block = ctx.create_block
      else_block = ctx.create_block
      merge_block = ctx.create_block

      ctx.terminate(Branch.new(neg_cond.id, then_block, else_block))

      # Then (was unless body)
      ctx.current_block = then_block
      ctx.restore_locals(pre_branch_locals)
      ctx.push_scope(ScopeKind::Block)
      then_value = lower_body(ctx, node.then_branch)
      then_exit = ctx.current_block
      ctx.pop_scope
      then_locals = ctx.save_locals

      # Check if then branch flows to merge (not terminated by return/raise)
      then_block_data = ctx.get_block(ctx.current_block)
      then_has_noreturn = then_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
      then_flows_to_merge = then_block_data.terminator.is_a?(Unreachable) && !then_has_noreturn
      if then_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      # Else branch (if any)
      ctx.current_block = else_block
      ctx.restore_locals(pre_branch_locals)
      else_value = if else_branch = node.else_branch
                     lower_body(ctx, else_branch)
                   else
                     nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                     ctx.emit(nil_lit)
                     nil_lit.id
                   end
      else_exit = ctx.current_block
      else_locals = ctx.save_locals

      # Check if else branch flows to merge
      else_block_data = ctx.get_block(ctx.current_block)
      else_has_noreturn = else_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
      else_flows_to_merge = else_block_data.terminator.is_a?(Unreachable) && !else_has_noreturn
      if else_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      # Merge
      ctx.current_block = merge_block

      # Only create phi if at least one branch flows to merge
      if then_flows_to_merge || else_flows_to_merge
        if then_flows_to_merge && else_flows_to_merge
          # Merge locals from both branches
          merge_branch_locals(ctx, pre_branch_locals, then_locals, else_locals,
                              then_exit, else_exit)

          phi_type = ctx.type_of(then_value)

          # Don't create phi for void types - LLVM doesn't allow phi void
          if phi_type == TypeRef::VOID || phi_type == TypeRef::NIL
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            return nil_lit.id
          end

          phi = Phi.new(ctx.next_id, phi_type)
          phi.add_incoming(then_exit, then_value)
          phi.add_incoming(else_exit, else_value)
          ctx.emit(phi)
          return phi.id
        elsif then_flows_to_merge
          # Only then flows - use then_value, then_locals
          then_locals.each { |name, val| ctx.register_local(name, val) }
          return then_value
        else
          # Only else flows - use else_value, else_locals
          else_locals.each { |name, val| ctx.register_local(name, val) }
          return else_value
        end
      end

      # Neither branch flows to merge - emit nil placeholder
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_while(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::WhileNode) : ValueId
      # Collect variables that might be assigned in the loop body
      # We need phi nodes at the loop header for these
      assigned_vars = collect_assigned_vars(node.body)
      inline_vars = Set(String).new

      # Save the initial values of variables before the loop
      pre_loop_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      cond_block = ctx.create_block
      body_block = ctx.create_block
      exit_block = ctx.create_block

      # Jump to condition check
      ctx.terminate(Jump.new(cond_block))

      # Condition block - create phi nodes for mutable variables
      ctx.current_block = cond_block
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          # Add incoming from pre-loop block
          phi.add_incoming(pre_loop_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          # Update local to point to phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      cond_id = lower_expr(ctx, node.condition)
      ctx.terminate(Branch.new(cond_id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Loop)
      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      begin
        lower_body(ctx, node.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
      end
      body_exit_block = ctx.current_block
      ctx.pop_scope

      # After body execution, get updated values and patch phi nodes
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            # Add incoming from body block (the updated value)
            phi.add_incoming(body_exit_block, updated_val)
            # Reset local to point back to phi for next iteration
            ctx.register_local(var_name, phi.id)
          end
        end
      end

      if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
        ctx.terminate(Jump.new(cond_block))  # Loop back
      end

      # Exit block - locals should still point to phi nodes
      ctx.current_block = exit_block

      # Restore phi values for use after the loop
      phi_nodes.each do |var_name, phi|
        ctx.register_local(var_name, phi.id)
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # LOOP (infinite loop) LOWERING
    # ═══════════════════════════════════════════════════════════════════════
    private def lower_loop(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::LoopNode) : ValueId
      # Collect variables that might be assigned in the loop body
      assigned_vars = collect_assigned_vars(node.body)
      inline_vars = Set(String).new

      # Save the initial values of variables before the loop
      pre_loop_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      # For infinite loop, we just need body and exit blocks
      body_block = ctx.create_block
      exit_block = ctx.create_block

      # Jump directly to body
      ctx.terminate(Jump.new(body_block))

      # Body block - create phi nodes for mutable variables
      ctx.current_block = body_block
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          phi.add_incoming(pre_loop_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      ctx.push_scope(ScopeKind::Loop)
      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      begin
        lower_body(ctx, node.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
      end
      body_exit_block = ctx.current_block
      ctx.pop_scope

      # After body execution, update phi nodes for next iteration
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            phi.add_incoming(body_exit_block, updated_val)
            ctx.register_local(var_name, phi.id)
          end
        end
      end

      # Loop back unconditionally (break will jump to exit_block)
      if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
        ctx.terminate(Jump.new(body_block))
      end

      # Exit block (reached via break)
      ctx.current_block = exit_block

      # Restore phi values for use after the loop
      phi_nodes.each do |var_name, phi|
        ctx.register_local(var_name, phi.id)
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Collect variable names that are assigned in a list of expressions
    private def collect_assigned_vars(body : Array(ExprId), visited_blocks : Set(UInt64)? = nil) : Array(String)
      visited_blocks ||= Set(UInt64).new
      vars = [] of String
      body.each do |expr_id|
        collect_assigned_vars_in_expr(expr_id, vars, visited_blocks)
      end
      vars.uniq
    end

    private def collect_assigned_vars_in_expr(expr_id : ExprId, vars : Array(String), visited_blocks : Set(UInt64))
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::AssignNode
        target = @arena[node.target]
        if target.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          vars << String.new(target.name)
        end
        # Also check the value side for nested assignments
        collect_assigned_vars_in_expr(node.value, vars, visited_blocks)

      when CrystalV2::Compiler::Frontend::MultipleAssignNode
        node.targets.each do |target_id|
          target = @arena[target_id]
          if target.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            vars << String.new(target.name)
          end
        end
        collect_assigned_vars_in_expr(node.value, vars, visited_blocks)

      when CrystalV2::Compiler::Frontend::TypeDeclarationNode
        vars << String.new(node.name)
        if value = node.value
          collect_assigned_vars_in_expr(value, vars, visited_blocks)
        end

      when CrystalV2::Compiler::Frontend::WhileNode
        # Nested while - check its body
        collect_assigned_vars(node.body, visited_blocks).each { |v| vars << v }

      when CrystalV2::Compiler::Frontend::LoopNode
        # Nested loop - check its body
        collect_assigned_vars(node.body, visited_blocks).each { |v| vars << v }

      when CrystalV2::Compiler::Frontend::IfNode
        # Check all branches
        collect_assigned_vars(node.then_body, visited_blocks).each { |v| vars << v }
        if else_body = node.else_body
          collect_assigned_vars(else_body, visited_blocks).each { |v| vars << v }
        end

      when CrystalV2::Compiler::Frontend::UnlessNode
        # Check all branches
        collect_assigned_vars(node.then_branch, visited_blocks).each { |v| vars << v }
        if else_body = node.else_branch
          collect_assigned_vars(else_body, visited_blocks).each { |v| vars << v }
        end

      when CrystalV2::Compiler::Frontend::CaseNode
        # Check all when branches and else
        node.when_branches.each do |when_branch|
          collect_assigned_vars(when_branch.body, visited_blocks).each { |v| vars << v }
        end
        if else_body = node.else_branch
          collect_assigned_vars(else_body, visited_blocks).each { |v| vars << v }
        end

      when CrystalV2::Compiler::Frontend::BinaryNode
        collect_assigned_vars_in_expr(node.left, vars, visited_blocks)
        collect_assigned_vars_in_expr(node.right, vars, visited_blocks)

      when CrystalV2::Compiler::Frontend::CallNode
        node.args.each { |arg| collect_assigned_vars_in_expr(arg, vars, visited_blocks) }

      when CrystalV2::Compiler::Frontend::GroupingNode
        collect_assigned_vars_in_expr(node.expression, vars, visited_blocks)

      when CrystalV2::Compiler::Frontend::YieldNode
        if inline_block = @inline_yield_block_stack.last?
          block_id = inline_block.object_id
          unless visited_blocks.includes?(block_id)
            visited_blocks.add(block_id)
            old_arena = @arena
            if block_arena = @inline_yield_block_arena_stack.last?
              @arena = block_arena
            end
            begin
              block_vars = collect_assigned_vars(inline_block.body, visited_blocks)
            ensure
              @arena = old_arena
            end
            if params = inline_block.params
              param_names = params.compact_map { |param| param.name ? String.new(param.name.not_nil!) : nil }
              block_vars.reject! { |name| param_names.includes?(name) }
            end
            block_vars.each { |v| vars << v }
          end
        end
      end
    end

    private def lookup_local_for_phi(ctx : LoweringContext, name : String, inline_vars : Set(String)) : ValueId?
      if val = ctx.lookup_local(name)
        return val
      end

      if caller_locals = @inline_caller_locals_stack.last?
        if val = caller_locals[name]?
          inline_vars.add(name)
          return val
        end
      end

      nil
    end

    private def inline_loop_vars_union : Set(String)?
      return nil if @inline_loop_vars_stack.empty?
      union = Set(String).new
      @inline_loop_vars_stack.each do |set|
        set.each { |name| union.add(name) }
      end
      union
    end

    private def lower_until(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::UntilNode) : ValueId
      # Until is while with inverted condition
      cond_block = ctx.create_block
      body_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      ctx.current_block = cond_block
      cond_id = lower_expr(ctx, node.condition)
      # Negate condition
      neg_cond = UnaryOperation.new(ctx.next_id, TypeRef::BOOL, UnaryOp::Not, cond_id)
      ctx.emit(neg_cond)
      ctx.terminate(Branch.new(neg_cond.id, body_block, exit_block))

      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Loop)
      lower_body(ctx, node.body)
      ctx.pop_scope

      if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
        ctx.terminate(Jump.new(cond_block))
      end

      ctx.current_block = exit_block
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_ternary(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::TernaryNode) : ValueId
      cond_id = lower_expr(ctx, node.condition)

      # Save locals before branching
      pre_branch_locals = ctx.save_locals

      then_block = ctx.create_block
      else_block = ctx.create_block
      merge_block = ctx.create_block

      ctx.terminate(Branch.new(cond_id, then_block, else_block))

      ctx.current_block = then_block
      ctx.restore_locals(pre_branch_locals)
      then_value = lower_expr(ctx, node.true_branch)
      then_exit = ctx.current_block
      then_locals = ctx.save_locals

      # Check if then branch flows to merge
      then_block_data = ctx.get_block(ctx.current_block)
      then_has_noreturn = then_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
      then_flows_to_merge = then_block_data.terminator.is_a?(Unreachable) && !then_has_noreturn
      if then_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      ctx.current_block = else_block
      ctx.restore_locals(pre_branch_locals)
      else_value = lower_expr(ctx, node.false_branch)
      else_exit = ctx.current_block
      else_locals = ctx.save_locals

      # Check if else branch flows to merge
      else_block_data = ctx.get_block(ctx.current_block)
      else_has_noreturn = else_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
      else_flows_to_merge = else_block_data.terminator.is_a?(Unreachable) && !else_has_noreturn
      if else_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      ctx.current_block = merge_block

      # Only create phi if at least one branch flows to merge
      if then_flows_to_merge || else_flows_to_merge
        if then_flows_to_merge && else_flows_to_merge
          # Merge locals from both branches
          merge_branch_locals(ctx, pre_branch_locals, then_locals, else_locals,
                              then_exit, else_exit)

          phi_type = ctx.type_of(then_value)

          # Don't create phi for void types - LLVM doesn't allow phi void
          if phi_type == TypeRef::VOID || phi_type == TypeRef::NIL
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            return nil_lit.id
          end

          phi = Phi.new(ctx.next_id, phi_type)
          phi.add_incoming(then_exit, then_value)
          phi.add_incoming(else_exit, else_value)
          ctx.emit(phi)
          return phi.id
        elsif then_flows_to_merge
          then_locals.each { |name, val| ctx.register_local(name, val) }
          return then_value
        else
          else_locals.each { |name, val| ctx.register_local(name, val) }
          return else_value
        end
      end

      # Neither branch flows - return nil placeholder
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Emit comparison for case/when using appropriate === semantics
    # Returns ValueId of boolean result
    private def emit_case_comparison(ctx : LoweringContext, subject_id : ValueId, cond_expr : ExprId) : ValueId
      cond_node = @arena[cond_expr]

      case cond_node
      when CrystalV2::Compiler::Frontend::NumberNode,
           CrystalV2::Compiler::Frontend::BoolNode,
           CrystalV2::Compiler::Frontend::NilNode,
           CrystalV2::Compiler::Frontend::CharNode
        # Primitive literals: direct equality comparison (optimized)
        cond_val = lower_expr(ctx, cond_expr)
        eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
        ctx.emit(eq)
        eq.id

      when CrystalV2::Compiler::Frontend::ConstantNode
        # Could be a type name (Int32, String) → is_a? check
        # Or a constant value → equality
        const_name = String.new(cond_node.name)
        if is_type_name?(const_name)
          # Type check: subject.is_a?(ConstName)
          check_type = type_ref_for_name(const_name)
          subject_type = ctx.type_of(subject_id)

          # If subject is union type, use UnionIs
          if is_union_type?(subject_type)
            variant_id = get_union_variant_id(subject_type, check_type)
            if variant_id >= 0
              union_is = UnionIs.new(ctx.next_id, subject_id, variant_id)
              ctx.emit(union_is)
              return union_is.id
            end
          end

          # Regular is_a? check
          is_a = IsA.new(ctx.next_id, subject_id, check_type)
          ctx.emit(is_a)
          is_a.id
        else
          # Constant value - equality
          cond_val = lower_expr(ctx, cond_expr)
          eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
          ctx.emit(eq)
          eq.id
        end

      when CrystalV2::Compiler::Frontend::RangeNode
        # Range: call Range#=== or Range#includes?
        # For now, expand to: subject >= begin && subject <= end (or < for exclusive)
        range_begin = lower_expr(ctx, cond_node.begin_expr)
        range_end = lower_expr(ctx, cond_node.end_expr)

        gte = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Ge, subject_id, range_begin)
        ctx.emit(gte)

        cmp_op = cond_node.exclusive ? BinaryOp::Lt : BinaryOp::Le
        lte = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, cmp_op, subject_id, range_end)
        ctx.emit(lte)

        and_op = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::And, gte.id, lte.id)
        ctx.emit(and_op)
        and_op.id

      when CrystalV2::Compiler::Frontend::IdentifierNode
        # Could be a type name (Int32, String) or variable
        ident_name = String.new(cond_node.name)
        if is_type_name?(ident_name)
          # Type check: subject.is_a?(IdentName)
          check_type = type_ref_for_name(ident_name)
          subject_type = ctx.type_of(subject_id)

          # If subject is union type, use UnionIs
          if is_union_type?(subject_type)
            variant_id = get_union_variant_id(subject_type, check_type)
            if variant_id >= 0
              union_is = UnionIs.new(ctx.next_id, subject_id, variant_id)
              ctx.emit(union_is)
              return union_is.id
            end
          end

          # Regular is_a? check
          is_a = IsA.new(ctx.next_id, subject_id, check_type)
          ctx.emit(is_a)
          is_a.id
        else
          # Variable - equality
          cond_val = lower_expr(ctx, cond_expr)
          eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
          ctx.emit(eq)
          eq.id
        end

      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # Check for implicit receiver pattern: .method? → subject.method?
        obj_node = @arena[cond_node.object]
        member_name = String.new(cond_node.member)

        if obj_node.is_a?(CrystalV2::Compiler::Frontend::ImplicitObjNode)
          # Implicit receiver: .data1?, .block?, etc.
          # This is "subject.method?" - check if it's an enum predicate
          if member_name.ends_with?("?")
            # Try to find enum type from subject
            enum_name = @enum_value_types.try(&.[subject_id]?)

            # If not directly tracked, try to infer from type descriptor
            if enum_name.nil?
              subject_type = ctx.type_of(subject_id)
              if type_desc = @module.get_type_descriptor(subject_type)
                type_name = type_desc.name
                if @enum_info.try(&.has_key?(type_name))
                  enum_name = type_name
                end
              end
              # Also try direct lookup by type_ref id in enum_base_types
              # For primitive types that map to enums (e.g., UInt8 for Color : UInt8)
            if enum_name.nil? && @enum_base_types
              @enum_base_types.not_nil!.each do |name, base_type|
                if base_type == subject_type
                  # Found an enum with matching base type - check if it has the member
                  if members = @enum_info.try(&.[name]?)
                    base_name = member_name[0...-1]
                    if members.keys.any? { |m| underscore_lower(m) == underscore_lower(base_name) }
                      enum_name = name
                      break
                    end
                  end
                end
                end
              end
            end
            # As a fallback, search all enums for a matching member.
            # This mirrors the CallNode path and avoids unqualified predicate calls.
            if enum_name.nil?
              base_name = member_name[0...-1]
              if enum_info = @enum_info
                enum_info.each do |name, members|
                  if members.keys.any? { |m| underscore_lower(m) == underscore_lower(base_name) }
                    enum_name = name
                    break
                  end
                end
              end
            end

            if enum_name && (enum_info = @enum_info)
              if members = enum_info[enum_name]?
                # Try to match the predicate to an enum member
                # e.g., "data1?" -> "Data1", "block?" -> "Block"
                base_name = member_name[0...-1]  # Remove trailing ?
                member_match = members.keys.find { |m| underscore_lower(m) == underscore_lower(base_name) }
                if member_match
                  member_value = members[member_match]
                  # Emit: subject_id == member_value
                  enum_type = enum_base_type(enum_name)
                  lit = Literal.new(ctx.next_id, enum_type, member_value)
                  ctx.emit(lit)
                  ctx.register_type(lit.id, enum_type)
                  cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, lit.id)
                  ctx.emit(cmp)
                  ctx.register_type(cmp.id, TypeRef::BOOL)
                  return cmp.id
                end
              end
            end
          end

          # Fall through: call the method on subject and use boolean result
          call = Call.new(ctx.next_id, TypeRef::BOOL, subject_id, member_name, [] of ValueId)
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::BOOL)
          return call.id
        else
          # Non-implicit receiver: lower normally and compare
          cond_val = lower_expr(ctx, cond_expr)
          eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
          ctx.emit(eq)
          eq.id
        end

      when CrystalV2::Compiler::Frontend::CallNode
        # Check for implicit receiver pattern: .method?() → subject.method?()
        # CallNode.callee is a MemberAccessNode with ImplicitObjNode
        callee_node = @arena[cond_node.callee]
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          obj_node = @arena[callee_node.object]
          member_name = String.new(callee_node.member)

          # Check for implicit receiver OR explicit receiver that's an identifier or member access
          is_implicit = obj_node.is_a?(CrystalV2::Compiler::Frontend::ImplicitObjNode)
          is_identifier = obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          is_member_access = obj_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          if (is_implicit || is_identifier || is_member_access) && member_name.ends_with?("?")
            # Implicit receiver call OR explicit subject call: .data1?(), c.red?(), format.format.data1?()
            # The parser expands "when .data1?" to "subject.data1?()" so the callee's object
            # represents the SAME expression as the case subject. Use subject_id directly.
            #
            # For is_member_access: obj_node is a MemberAccessNode representing subject expression
            # This is the same expression that was already lowered to subject_id, so reuse it.
            actual_object_id = subject_id

            # Find enum type by matching predicate name against known enum members
            enum_name = nil.as(String?)
            base_name = member_name[0...-1]  # Remove trailing ?

            if enum_info = @enum_info
              # Search all enums for one that has this member
              enum_info.each do |name, members|
                if members.keys.any? { |m| underscore_lower(m) == underscore_lower(base_name) }
                  enum_name = name
                  break
                end
              end
            end

            # If no match, try to disambiguate using type info
            if enum_name.nil?
              obj_type = ctx.type_of(actual_object_id)
              if type_desc = @module.get_type_descriptor(obj_type)
                type_name = type_desc.name
                if @enum_info.try(&.has_key?(type_name))
                  enum_name = type_name
                end
              end
            end

            # Fall back to enum_value_types tracking
            if enum_name.nil?
              enum_name = @enum_value_types.try(&.[actual_object_id]?)
            end

            if enum_name && (enum_info = @enum_info)
              if members = enum_info[enum_name]?
                base_name = member_name[0...-1]  # Remove trailing ?
                member_match = members.keys.find { |m| underscore_lower(m) == underscore_lower(base_name) }
                if member_match
                  member_value = members[member_match]
                  enum_type = enum_base_type(enum_name)
                  lit = Literal.new(ctx.next_id, enum_type, member_value)
                  ctx.emit(lit)
                  ctx.register_type(lit.id, enum_type)
                  # Compare against actual_object_id (which may differ from subject_id for member access)
                  cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, actual_object_id, lit.id)
                  ctx.emit(cmp)
                  ctx.register_type(cmp.id, TypeRef::BOOL)
                  return cmp.id
                end
              end
            end

            # Fall through: call the method on actual object
            call = Call.new(ctx.next_id, TypeRef::BOOL, actual_object_id, member_name, [] of ValueId)
            ctx.emit(call)
            ctx.register_type(call.id, TypeRef::BOOL)
            return call.id
          end
        end

        # Default: lower the call expression and compare
        cond_val = lower_expr(ctx, cond_expr)
        eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
        ctx.emit(eq)
        eq.id

      else
        # Default: call === method (when we have method calls working)
        # For now, fall back to equality
        cond_val = lower_expr(ctx, cond_expr)
        eq = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, subject_id, cond_val)
        ctx.emit(eq)
        eq.id
      end
    end

    # Check if a name refers to a type (starts with uppercase)
    private def is_type_name?(name : String) : Bool
      return false if name.empty?
      first_char = name[0]
      first_char.uppercase? && @class_info.has_key?(name) ||
        ["Int32", "Int64", "String", "Bool", "Nil", "Float64"].includes?(name)
    end

    private def lower_case(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::CaseNode) : ValueId
      # Save locals state before case for proper phi merging
      pre_case_locals = ctx.save_locals

      # Lower case subject
      subject_id = if subj = node.value
                     lower_expr(ctx, subj)
                   else
                     nil
                   end

      merge_block = ctx.create_block
      incoming = [] of Tuple(BlockId, ValueId)
      branch_locals = [] of Tuple(BlockId, Hash(String, ValueId))  # Track locals for each branch

      # Process each when branch
      node.when_branches.each_with_index do |when_branch, idx|
        when_block = ctx.create_block
        next_block = ctx.create_block

        # Build condition (any match)
        if subject_id
          # Match subject against when values using appropriate === semantics
          conds = when_branch.conditions.map do |cond_expr|
            emit_case_comparison(ctx, subject_id.not_nil!, cond_expr)
          end

          # Combine with OR
          combined = conds.reduce do |acc, c|
            or_op = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Or, acc, c)
            ctx.emit(or_op)
            or_op.id
          end

          ctx.terminate(Branch.new(combined, when_block, next_block))
        else
          # No subject: conditions are boolean
          cond_val = lower_expr(ctx, when_branch.conditions.first)
          ctx.terminate(Branch.new(cond_val, when_block, next_block))
        end

        # When body - restore locals before each branch
        ctx.current_block = when_block
        ctx.restore_locals(pre_case_locals)
        ctx.push_scope(ScopeKind::Block)
        result = lower_body(ctx, when_branch.body)
        exit_block = ctx.current_block
        ctx.pop_scope

        # Check if branch flows to merge
        when_block_data = ctx.get_block(ctx.current_block)
        when_has_noreturn = when_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
        when_flows_to_merge = when_block_data.terminator.is_a?(Unreachable) && !when_has_noreturn

        if when_flows_to_merge
          # Save branch locals before jumping to merge (only if flowing)
          branch_locals << {exit_block, ctx.save_locals}
          ctx.terminate(Jump.new(merge_block))
          incoming << {exit_block, result}
        end

        ctx.current_block = next_block
      end

      # Else branch - restore locals before else branch
      ctx.restore_locals(pre_case_locals)
      ctx.push_scope(ScopeKind::Block)
      else_result = if else_body = node.else_branch
                      if else_body.empty?
                        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                        ctx.emit(nil_lit)
                        nil_lit.id
                      else
                        lower_body(ctx, else_body)
                      end
                    else
                      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                      ctx.emit(nil_lit)
                      nil_lit.id
                    end
      else_exit = ctx.current_block
      ctx.pop_scope

      # Check if else branch flows to merge
      else_block_data = ctx.get_block(ctx.current_block)
      else_has_noreturn = else_block_data.instructions.any? { |inst| inst.is_a?(Raise) }
      else_flows_to_merge = else_block_data.terminator.is_a?(Unreachable) && !else_has_noreturn

      if else_flows_to_merge
        # Save else branch locals (only if flowing)
        branch_locals << {else_exit, ctx.save_locals}
        ctx.terminate(Jump.new(merge_block))
        incoming << {else_exit, else_result}
      end

      # Merge
      ctx.current_block = merge_block

      # Only merge locals and create phi if at least one branch flows
      if incoming.empty?
        # No branches flow to merge - emit nil placeholder
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      # Merge locals from branches that flow to merge
      merge_case_locals(ctx, pre_case_locals, branch_locals)

      value_types = incoming.map { |(_, val)| ctx.type_of(val) }.reject { |t| t == TypeRef::VOID }.uniq
      phi_type = value_types.first? || TypeRef::VOID

      # If branch value types differ, prefer a union type that covers them.
      # This avoids invalid IR when merging mixed types (e.g., Bool/Float64/Int64),
      # and matches Crystal semantics (case expression returns a union).
      if value_types.size > 1 && !value_types.all? { |t| numeric_primitive?(t) }
        if union_ref = find_covering_union_type(value_types)
          phi_type = union_ref
        else
          union_name = value_types.map { |t| get_type_name_from_ref(t) }.uniq.join(" | ")
          phi_type = create_union_type(union_name)
        end
      end

      # Coerce incoming values to the chosen phi type when needed.
      #
      # NOTE: We must insert conversions into the predecessor blocks (not the merge block),
      # otherwise the SSA value won't dominate the phi edge.
      coerced_incoming = incoming.map do |(blk, val)|
        val_type = ctx.type_of(val)
        if val_type == phi_type
          {blk, val}
        elsif is_union_type?(phi_type)
          variant_id = get_union_variant_id(phi_type, val_type)
          if variant_id >= 0
            wrap = UnionWrap.new(ctx.next_id, phi_type, val, variant_id)
            ctx.emit_to_block(blk, wrap)
            {blk, wrap.id}
          else
            {blk, val}
          end
        elsif numeric_primitive?(val_type) && numeric_primitive?(phi_type)
          cast = Cast.new(ctx.next_id, phi_type, val, phi_type, safe: false)
          ctx.emit_to_block(blk, cast)
          {blk, cast.id}
        else
          {blk, val}
        end
      end

      # Don't create phi for void types - LLVM doesn't allow phi void
      if phi_type == TypeRef::VOID || phi_type == TypeRef::NIL
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        return nil_lit.id
      end

      # If only one branch flows, no phi needed
      if coerced_incoming.size == 1
        return coerced_incoming.first[1]
      end

      phi = Phi.new(ctx.next_id, phi_type)
      coerced_incoming.each { |(blk, val)| phi.add_incoming(blk, val) }
      ctx.emit(phi)
      phi.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # FUNCTION-RELATED
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_return(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::ReturnNode) : ValueId
      value_id = if val = node.value
                   lower_expr(ctx, val)
                 else
                   nil
                 end

      # Returns inside a caller-provided block should return from the caller,
      # not from the inlined callee. When nested yield inlining is active,
      # route block-body returns to the next outer inline-return context.
      inline_return = nil
      if @inline_yield_proc_depth == 0
        if override = @inline_yield_return_override_stack.last?
          if override.active
            inline_return = override.context
          else
            inline_return = @inline_yield_return_stack.last?
          end
        else
          inline_return = @inline_yield_return_stack.last?
        end
      end
      if ENV["DEBUG_INLINE_RETURN"]?
        filter = ENV["DEBUG_INLINE_RETURN_FILTER"]?
        if filter.nil? || ctx.function.name.includes?(filter)
          stack_ids = @inline_yield_return_stack.map { |entry| "#{entry.function_id}:#{entry.exit_block}" }.join(",")
          override_targets = @inline_yield_return_override_stack.map { |entry| entry.active ? (entry.context ? "#{entry.context.not_nil!.function_id}:#{entry.context.not_nil!.exit_block}" : "nil") : "-" }.join(",")
          chosen = inline_return ? "#{inline_return.function_id}:#{inline_return.exit_block}" : "nil"
          STDERR.puts "[INLINE_RETURN] func=#{ctx.function.name} block_depth=#{@inline_yield_block_body_depth} stack=[#{stack_ids}] overrides=[#{override_targets}] chosen=#{chosen}"
        end
      end

      if inline_return
          if inline_return.function_id != ctx.function.id
            debug_hook("inline.return.skip", "func=#{ctx.function.name} inline=#{inline_return.function_id}")
          else
            if ctx.current_block >= ctx.function.blocks.size
              debug_hook("inline.return.block_oob", "func=#{ctx.function.name} block=#{ctx.current_block} size=#{ctx.function.blocks.size}")
            else
              if value_id.nil?
                nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                ctx.emit(nil_lit)
                value_id = nil_lit.id
              end
              exit_block = inline_return.exit_block
              current_block = ctx.current_block
              ctx.terminate(Jump.new(exit_block))
              inline_return.incoming << {current_block, value_id.not_nil!}
              nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
              ctx.emit(nil_lit)
              return nil_lit.id
            end
          end
      end

      ctx.terminate(Return.new(value_id))

      # Return a dummy value (code after return is unreachable)
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_yield(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::YieldNode) : ValueId
      args = if node_args = node.args
               node_args.reject(&.invalid?).map { |arg| lower_expr(ctx, arg) }
             else
               [] of ValueId
             end

      y = Yield.new(ctx.next_id, TypeRef::VOID, args)
      ctx.emit(y)
      y.id
    end

    private def lower_break(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::BreakNode) : ValueId
      # Break needs special handling - for now emit as unreachable
      # TODO: proper break with loop exit block tracking
      ctx.terminate(Unreachable.new)
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_next(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::NextNode) : ValueId
      # Next needs special handling - for now emit as unreachable
      # TODO: proper next with loop continue block tracking
      ctx.terminate(Unreachable.new)
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # EXCEPTION HANDLING
    # ═══════════════════════════════════════════════════════════════════════

    # Lower begin/rescue/ensure block
    # Structure:
    #   begin
    #     body...
    #   rescue ex : ExceptionType
    #     handler...
    #   else
    #     else_body...
    #   ensure
    #     cleanup...
    #   end
    private def lower_begin(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::BeginNode) : ValueId
      # Exception handling using setjmp/longjmp:
      # 1. Call TryBegin (setjmp) - returns 0 for normal, non-zero for exception
      # 2. Branch based on result
      # 3. Body path: execute body, call TryEnd
      # 4. Rescue path: execute rescue handlers, call TryEnd
      # 5. Ensure path: always executed

      has_rescue = !node.rescue_clauses.nil? && !node.rescue_clauses.not_nil!.empty?
      has_else = !node.else_body.nil? && !node.else_body.not_nil!.empty?
      has_ensure = !node.ensure_body.nil? && !node.ensure_body.not_nil!.empty?

      # Create blocks
      body_block = ctx.create_block
      rescue_block = ctx.create_block if has_rescue
      else_block = ctx.create_block if has_else
      ensure_block = ctx.create_block if has_ensure
      exit_block = ctx.create_block

      # If we have rescue clauses, set up exception handling
      if has_rescue
        # Call TryBegin - returns 0 for normal path, non-zero for exception
        try_begin = TryBegin.new(ctx.next_id)
        ctx.emit(try_begin)
        ctx.register_type(try_begin.id, TypeRef::INT32)

        # Compare with 0
        zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
        ctx.emit(zero)
        ctx.register_type(zero.id, TypeRef::INT32)

        cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, try_begin.id, zero.id)
        ctx.emit(cmp)
        ctx.register_type(cmp.id, TypeRef::BOOL)

        # Branch: if result == 0, normal path (body); else exception path (rescue)
        ctx.terminate(Branch.new(cmp.id, body_block, rescue_block.not_nil!))
      else
        # No rescue - just jump to body
        ctx.terminate(Jump.new(body_block))
      end

      ctx.switch_to_block(body_block)

      # Lower body
      result_id : ValueId = ctx.next_id
      node.body.each do |expr_id|
        result_id = lower_expr(ctx, expr_id)
      end

      # After body, call TryEnd if we have rescue handlers
      if has_rescue
        try_end = TryEnd.new(ctx.next_id)
        ctx.emit(try_end)
      end

      # After body, jump to else (if exists) or ensure (if exists) or exit
      after_body_target = else_block || ensure_block || exit_block
      ctx.terminate(Jump.new(after_body_target))

      # Lower rescue clauses if any
      if has_rescue
        rescue_clauses = node.rescue_clauses.not_nil!
        ctx.switch_to_block(rescue_block.not_nil!)

        # For now, just execute the first rescue clause's body
        # TODO: proper exception type matching
        rescue_result : ValueId = ctx.next_id
        rescue_clauses.each_with_index do |clause, idx|
          # If clause has variable name, create local for exception
          if var_name = clause.variable_name
            exc_var = Local.new(ctx.next_id, TypeRef::POINTER, String.new(var_name), ctx.current_scope, true)
            ctx.emit(exc_var)
            ctx.register_local(String.new(var_name), exc_var.id)
            ctx.register_type(exc_var.id, TypeRef::POINTER)

            # Get exception value
            get_exc = GetException.new(ctx.next_id, TypeRef::POINTER)
            ctx.emit(get_exc)
            ctx.register_type(get_exc.id, TypeRef::POINTER)

            # Copy to variable
            copy = Copy.new(ctx.next_id, TypeRef::POINTER, get_exc.id)
            ctx.emit(copy)
            ctx.register_type(copy.id, TypeRef::POINTER)
          end

          # Lower rescue body
          clause.body.each do |expr_id|
            rescue_result = lower_expr(ctx, expr_id)
          end

          # Only handle first clause for now
          break
        end

        # Call TryEnd after rescue
        try_end = TryEnd.new(ctx.next_id)
        ctx.emit(try_end)

        # After rescue, jump to ensure or exit
        after_rescue_target = ensure_block || exit_block
        ctx.terminate(Jump.new(after_rescue_target))
      end

      # Lower else block if any
      if has_else
        else_body = node.else_body.not_nil!
        ctx.switch_to_block(else_block.not_nil!)
        else_body.each do |expr_id|
          result_id = lower_expr(ctx, expr_id)
        end
        after_else_target = ensure_block || exit_block
        ctx.terminate(Jump.new(after_else_target))
      end

      # Lower ensure block if any
      if has_ensure
        ensure_body = node.ensure_body.not_nil!
        ctx.switch_to_block(ensure_block.not_nil!)
        ensure_body.each do |expr_id|
          lower_expr(ctx, expr_id)  # ensure result is discarded
        end
        ctx.terminate(Jump.new(exit_block))
      end

      # Continue from exit block
      ctx.switch_to_block(exit_block)

      result_id
    end

    # Lower raise statement
    private def lower_raise(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::RaiseNode) : ValueId
      exc_value : ValueId? = nil
      exc_message : String? = nil

      if val_id = node.value
        val_node = @arena[val_id]
        # Check if it's a string literal for simple raise "message"
        if val_node.is_a?(CrystalV2::Compiler::Frontend::StringNode)
          exc_message = String.new(val_node.value)
        else
          # Lower the exception value
          exc_value = lower_expr(ctx, val_id)
        end
      end

      # Emit raise instruction
      raise_inst = Raise.new(ctx.next_id, exc_value, exc_message)
      ctx.emit(raise_inst)

      # Raise is a terminator - nothing executes after
      ctx.terminate(Unreachable.new)

      raise_inst.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # CALLS
    # ═══════════════════════════════════════════════════════════════════════

    private def call_signature_for_base(base_name : String, arity : Int32, has_block : Bool) : CallSignature?
      return nil if base_name.empty?
      CallSignature.new(base_name, arity, has_block)
    end

    private def call_signature_for_call(name : String, arg_count : Int32, has_block : Bool) : CallSignature?
      base = base_callsite_key(name)
      call_signature_for_base(base, arg_count, has_block)
    end

    private def call_signature_for_def(
      func_def : CrystalV2::Compiler::Frontend::DefNode,
      name : String,
      target_name : String
    ) : CallSignature?
      base = base_callsite_key(target_name.empty? ? name : target_name)
      return nil if base.empty?
      params = func_def.params
      return nil unless params

      has_block = params.any?(&.is_block)
      param_count = params.count { |p| !p.is_block && !named_only_separator?(p) }
      call_signature_for_base(base, param_count, has_block)
    end

    private def remember_callsite_arg_types(
      name : String,
      arg_types : Array(TypeRef),
      arg_literals : Array(Bool)? = nil,
      has_block : Bool = false
    ) : Nil
      return if name.empty?
      @pending_arg_types[name] = arg_types.dup
      @pending_arg_type_literals[name] = arg_literals.dup if arg_literals
      base_key = base_callsite_key(name)
      return if base_key.empty?
      by_arity = @pending_arg_types_by_arity[base_key]? || begin
        new_map = {} of Int32 => Array(CallsiteArgs)
        @pending_arg_types_by_arity[base_key] = new_map
        new_map
      end
      callsite = CallsiteArgs.new(arg_types.dup, arg_literals ? arg_literals.dup : nil)
      bucket = by_arity[arg_types.size]? || [] of CallsiteArgs
      bucket << callsite
      by_arity[arg_types.size] = bucket
      if DebugHooks::ENABLED && name.includes?("read_bytes")
        literal_payload = arg_literals ? arg_literals.join(",") : "nil"
        debug_hook(
          "callsite.args",
          "name=#{name} types=#{arg_types.map(&.id).join(",")} literals=#{literal_payload}"
        )
      end
      if signature = call_signature_for_call(name, arg_types.size, has_block)
        sig_bucket = @pending_arg_types_by_signature[signature]? || [] of CallsiteArgs
        sig_bucket << callsite
        @pending_arg_types_by_signature[signature] = sig_bucket
      end
    end

    private def base_callsite_key(name : String) : String
      return "" if name.empty?
      base = name.split("$", 2)[0]
      base = base.sub(/_(double_)?splat$/, "")
      base
    end

    private def pop_pending_callsite_args(name : String, target_name : String) : CallsiteArgs?
      candidates = [] of String
      {name, target_name}.each do |key|
        next if key.empty?
        candidates << key

        if key.ends_with?("_splat") || key.ends_with?("_double_splat")
          stripped = key.sub(/_(double_)?splat$/, "")
          candidates << stripped if stripped != key
        end

        base = key.split("$", 2)[0]
        candidates << base if base != key
        if base.ends_with?("_splat") || base.ends_with?("_double_splat")
          stripped_base = base.sub(/_(double_)?splat$/, "")
          candidates << stripped_base if stripped_base != base
        end
      end

      candidates.uniq!
      candidates.each do |key|
        if types = @pending_arg_types[key]?
          literals = @pending_arg_type_literals[key]?
          @pending_arg_types.delete(key)
          @pending_arg_type_literals.delete(key)
          base = base_callsite_key(key)
          remove_callsite_from_pending_maps(base, types, literals)
          return CallsiteArgs.new(types, literals)
        end
      end

      nil
    end

    private def consume_callsite_args(base_key : String, entry : CallsiteArgs) : Nil
      remove_callsite_from_pending_maps(base_key, entry.types, entry.literals)
    end

    private def remove_callsite_from_pending_maps(
      base_key : String,
      types : Array(TypeRef),
      literals : Array(Bool)?
    ) : Nil
      return if base_key.empty?

      if by_arity = @pending_arg_types_by_arity[base_key]?
        if bucket = by_arity[types.size]?
          idx = bucket.index do |candidate|
            candidate.types == types && (literals.nil? || candidate.literals == literals)
          end
          if idx
            bucket.delete_at(idx)
            by_arity.delete(types.size) if bucket.empty?
            @pending_arg_types_by_arity.delete(base_key) if by_arity.empty?
          end
        end
      end

      {true, false}.each do |has_block|
        if signature = call_signature_for_base(base_key, types.size, has_block)
          if sig_bucket = @pending_arg_types_by_signature[signature]?
            idx = sig_bucket.index do |candidate|
              candidate.types == types && (literals.nil? || candidate.literals == literals)
            end
            if idx
              sig_bucket.delete_at(idx)
              @pending_arg_types_by_signature.delete(signature) if sig_bucket.empty?
            end
          end
        end
      end
    end

    private def select_best_callsite_args(
      func_def : CrystalV2::Compiler::Frontend::DefNode,
      candidates : Array(CallsiteArgs),
      context : String?
    ) : CallsiteArgs?
      best : CallsiteArgs? = nil
      best_score = Int32::MIN
      candidates.each do |entry|
        call_types = entry.types
        next if call_types.all? { |t| t == TypeRef::VOID }
        next unless params_compatible_with_args?(func_def, call_types, context)
        score = params_match_score(func_def, call_types, context)
        if score > best_score
          best = entry
          best_score = score
        end
      end
      best
    end

    private def pending_callsite_args_for_def(
      func_def : CrystalV2::Compiler::Frontend::DefNode,
      name : String,
      target_name : String
    ) : CallsiteArgs?
      base_key = base_callsite_key(target_name.empty? ? name : target_name)
      return nil if base_key.empty?
      by_arity = @pending_arg_types_by_arity[base_key]?
      return nil unless by_arity

      params = func_def.params
      return nil unless params
      param_count = 0
      required_count = 0
      has_splat = false
      params.each do |param|
        next if named_only_separator?(param) || param.is_block || param.is_double_splat
        if param.is_splat
          has_splat = true
          param_count += 1
          next
        end
        param_count += 1
        required_count += 1 unless param.default_value
      end

      func_context = function_context_from_name(target_name.empty? ? name : target_name)
      if bucket = by_arity[param_count]?
        if match = select_best_callsite_args(func_def, bucket, func_context) || bucket.first?
          consume_callsite_args(base_key, match)
          return match
        end
      end

      if signature = call_signature_for_def(func_def, name, target_name)
        if sig_bucket = @pending_arg_types_by_signature[signature]?
          if match = select_best_callsite_args(func_def, sig_bucket, func_context) || sig_bucket.first?
            consume_callsite_args(base_key, match)
            return match
          end
        end
      end

      fallback_key = if has_splat
                       by_arity.keys.select { |key| key >= required_count }.max?
                     else
                       by_arity.keys.select { |key| key >= required_count && key <= param_count }.max?
                     end
      return nil unless fallback_key
      bucket = by_arity[fallback_key]
      match = select_best_callsite_args(func_def, bucket, func_context) || bucket.first?
      return nil unless match
      consume_callsite_args(base_key, match)
      match
    end

    # Search a generic template's body for a method definition by name.
    # Returns {DefNode, Arena} if found, nil otherwise.
    private def find_method_in_generic_template(
      template : GenericClassTemplate,
      method_name : String
    ) : Tuple(CrystalV2::Compiler::Frontend::DefNode, CrystalV2::Compiler::Frontend::ArenaLike)?
      body = template.node.body
      return nil unless body

      body.each do |expr_id|
        member = template.arena[expr_id]
        # Unwrap visibility modifier using template's arena, not @arena
        while member.is_a?(CrystalV2::Compiler::Frontend::VisibilityModifierNode)
          member = template.arena[member.expression]
        end

        case member
        when CrystalV2::Compiler::Frontend::DefNode
          def_name = member.name.nil? ? "" : String.new(member.name.not_nil!)
          if def_name == method_name
            return {member, template.arena}
          end
        end
      end

      nil
    end

    private def generic_owner_info(owner : String) : NamedTuple(base: String, owner: String, args: Array(String), map: Hash(String, String))?
      info = split_generic_base_and_args(owner)
      return nil unless info

      base = info[:base]
      template = @generic_templates[base]?
      return nil unless template

      raw_args = split_generic_type_args(info[:args]).map do |arg|
        normalize_tuple_literal_type_name(arg.strip)
      end
      return nil unless raw_args.size == template.type_params.size

      substituted_args = raw_args.map { |arg| @type_param_map[arg]? || arg }
      map = {} of String => String
      template.type_params.each_with_index do |param, idx|
        map[param] = substituted_args[idx]
      end

      resolved_owner = "#{base}(#{substituted_args.join(", ")})"
      {base: base, owner: resolved_owner, args: substituted_args, map: map}
    end

    private def find_module_def_recursive(
      module_name : String,
      method_base : String,
      expected_param_count : Int32,
      visited : Set(String)
    ) : Tuple(CrystalV2::Compiler::Frontend::DefNode, CrystalV2::Compiler::Frontend::ArenaLike)?
      return nil if visited.includes?(module_name)
      visited << module_name

      mod_defs = @module_defs[module_name]?
      if ENV.has_key?("DEBUG_FIND_MODULE") && method_base == "byte_range"
        has_defs = !mod_defs.nil?
        STDERR.puts "[FIND_MODULE] module=#{module_name} method=#{method_base} has_defs=#{has_defs} num_defs=#{mod_defs.try(&.size) || 0}"
      end
      return nil unless mod_defs

      mod_defs.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          body = mod_node.body
          next unless body

          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            case member
            when CrystalV2::Compiler::Frontend::IncludeNode
              include_name = resolve_path_like_name(member.target)
              next unless include_name
              if found = find_module_def_recursive(include_name, method_base, expected_param_count, visited)
                return found
              end
            when CrystalV2::Compiler::Frontend::DefNode
              next if (recv = member.receiver) && String.new(recv) == "self"
              next if member.is_abstract
              member_name = String.new(member.name)
              next unless member_name == method_base

              actual_param_count = 0
              if params = member.params
                params.each do |param|
                  next if param.is_block || param.is_splat || param.is_double_splat || named_only_separator?(param)
                  actual_param_count += 1
                end
              end

              if expected_param_count == 0 || expected_param_count == actual_param_count
                return {member, mod_arena}
              end
            end
          end
        end
      end

      nil
    end

    private def find_module_class_def(
      module_name : String,
      method_base : String,
      expected_param_count : Int32
    ) : Tuple(CrystalV2::Compiler::Frontend::DefNode, CrystalV2::Compiler::Frontend::ArenaLike)?
      entries = @module_defs[module_name]?
      return nil unless entries

      entries.each do |mod_node, mod_arena|
        with_arena(mod_arena) do
          body = mod_node.body
          next unless body

          body.each do |expr_id|
            member = unwrap_visibility_member(@arena[expr_id])
            next unless member.is_a?(CrystalV2::Compiler::Frontend::DefNode)
            next if member.is_abstract
            recv = member.receiver
            next unless recv && String.new(recv) == "self"
            next unless String.new(member.name) == method_base

            actual_param_count = 0
            if params = member.params
              params.each do |param|
                next if param.is_block || param.is_splat || param.is_double_splat || named_only_separator?(param)
                actual_param_count += 1
              end
            end

            if expected_param_count == 0 || expected_param_count == actual_param_count
              return {member, mod_arena}
            end
          end
        end
      end

      nil
    end

    private def lower_function_if_needed(name : String) : Nil
      return if name.empty?
      if ENV["DEBUG_FROM_CHARS"]? && name.includes?("from_chars_advanced")
        STDERR.puts "[DEBUG_FROM_CHARS] lower_function_if_needed name=#{name}"
      end
      is_yield = @yield_functions.includes?(name)
      if ENV.has_key?("DEBUG_YIELD_SKIP") && name.includes?("byte_range")
        STDERR.puts "[YIELD_SKIP] name=#{name} is_yield=#{is_yield}"
      end
      return if is_yield
      if @lowering_functions.includes?(name)
        if ENV["DEBUG_FROM_CHARS"]? && name.includes?("from_chars_advanced")
          STDERR.puts "[DEBUG_FROM_CHARS] skip already lowering name=#{name}"
        end
        return
      end
      return if @module.has_function?(name)

      target_name = name
      primitive_template_map : Hash(String, String)? = nil
      debug_hook("function.lookup.start", name)
      func_def = @function_defs[target_name]?
      arena = @function_def_arenas[target_name]?
      lookup_branch : String? = func_def ? "direct" : nil
      unless func_def
        if maybe_generate_class_accessor_for_name(name)
          debug_hook("function.lookup.generated", "name=#{name} kind=class_accessor")
          return
        end
        if maybe_generate_accessor_for_name(name)
          debug_hook("function.lookup.generated", "name=#{name} kind=ivar_accessor")
          return
        end
        base_name = name.split("$").first
        if base_name != name
          func_def = @function_defs[base_name]?
          arena = @function_def_arenas[base_name]? if func_def
          target_name = base_name if func_def
          lookup_branch = "base_name" if func_def
        end
        # If still not found, try monomorphizing a generic owner and retry.
        unless func_def
          if base_name.includes?("#") || base_name.includes?(".")
            sep = base_name.includes?("#") ? "#" : "."
            owner, method_part = base_name.split(sep, 2)
            if info = generic_owner_info(owner)
              if !@monomorphized.includes?(info[:owner]) &&
                 concrete_type_args?(info[:args]) &&
                 !@suppress_monomorphization
                monomorphize_generic_class(info[:base], info[:args], info[:owner])
              end
              resolved_base = "#{info[:owner]}#{sep}#{method_part}"
              resolved_candidate = resolved_base
              if name.includes?("$")
                suffix = name.split("$", 2)[1]
                resolved_candidate = "#{resolved_base}$#{suffix}"
              end
              if resolved_def = @function_defs[resolved_candidate]?
                func_def = resolved_def
                arena = @function_def_arenas[resolved_candidate]
                target_name = resolved_candidate
                lookup_branch = "generic_owner"
              elsif resolved_def = @function_defs[resolved_base]?
                func_def = resolved_def
                arena = @function_def_arenas[resolved_base]
                target_name = resolved_base
                lookup_branch = "generic_owner_base"
              else
                template_base = "#{info[:base]}#{sep}#{method_part}"
                if candidate = @function_defs[template_base]?
                  func_def = candidate
                  arena = @function_def_arenas[template_base]
                  target_name = name
                  lookup_branch = "generic_owner_template"
                elsif name.includes?("$")
                  suffix = name.split("$", 2)[1]
                  template_mangled = "#{template_base}$#{suffix}"
                  if candidate = @function_defs[template_mangled]?
                    func_def = candidate
                    arena = @function_def_arenas[template_mangled]
                    target_name = name
                    lookup_branch = "generic_owner_template_mangled"
                  else
                    mangled_prefix = "#{template_base}$"
                    @function_defs.each_key do |key|
                      if key.starts_with?(mangled_prefix)
                        func_def = @function_defs[key]
                        arena = @function_def_arenas[key]
                        target_name = name
                        lookup_branch = "generic_owner_template_prefix"
                        break
                      end
                    end
                  end
                end
                # Fallback: search the generic template's body for the method
                unless func_def
                  if template = @generic_templates[info[:base]]?
                    method_name_part = method_part.split("$").first
                    found_in_template = find_method_in_generic_template(template, method_name_part)
                    if found_in_template
                      func_def = found_in_template[0]
                      arena = found_in_template[1]
                      target_name = name
                      lookup_branch = "generic_template_body"
                    end
                    # Also search reopenings
                    unless func_def
                      if reopenings = @generic_reopenings[info[:base]]?
                        reopenings.each do |reopen_template|
                          found_in_reopen = find_method_in_generic_template(reopen_template, method_name_part)
                          if found_in_reopen
                            func_def = found_in_reopen[0]
                            arena = found_in_reopen[1]
                            target_name = name
                            lookup_branch = "generic_reopen_body"
                            break
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        # If still not found, search for any mangled variant of the base name
        # This handles methods with default parameters where call-site arg count < defined param count
        unless func_def
          mangled_prefix = "#{base_name}$"
          if ENV.has_key?("DEBUG_LOOKUP")
            STDERR.puts "[DEBUG_LOOKUP] Searching for prefix '#{mangled_prefix}' for name '#{name}'"
          end
          if ENV["DEBUG_FROM_CHARS"]? && name.includes?("from_chars_advanced")
            STDERR.puts "[DEBUG_FROM_CHARS] scan_prefix start prefix=#{mangled_prefix} defs=#{@function_defs.size}"
          end
          callsite_by_arity = @pending_arg_types_by_arity[base_callsite_key(name)]?
          best_def : CrystalV2::Compiler::Frontend::DefNode? = nil
          best_name : String? = nil
          best_param_count = Int32::MAX
          best_score = Int32::MIN
          if callsite_by_arity && !callsite_by_arity.empty?
            @function_defs.each do |key, def_node|
              next unless key.starts_with?(mangled_prefix)
              params = def_node.params
              next unless params

              param_count = params.count { |p| !p.is_block && !named_only_separator?(p) }
              has_splat = params.any? { |p| p.is_splat && !named_only_separator?(p) }
              has_double_splat = params.any? { |p| p.is_double_splat }
              required = params.count do |p|
                !p.is_block && !named_only_separator?(p) && p.default_value.nil? && !p.is_splat && !p.is_double_splat
              end
              block_penalty = params.any?(&.is_block) ? 1 : 0

              callsite_by_arity.each do |arity, call_entries|
                next if arity < required
                next if arity > param_count && !has_splat && !has_double_splat
                call_entries.each do |entry|
                  call_arg_types = entry.types
                  next if call_arg_types.all? { |t| t == TypeRef::VOID }

                  func_context = function_context_from_name(key)
                  next unless params_compatible_with_args?(def_node, call_arg_types, func_context)
                  score = params_match_score(def_node, call_arg_types, func_context)
                  score -= 1 if has_splat || has_double_splat
                  score -= block_penalty

                  if param_count < best_param_count || (param_count == best_param_count && score > best_score)
                    best_def = def_node
                    best_name = key
                    best_param_count = param_count
                    best_score = score
                  end
                end
              end
            end
          end

          if best_def && best_name
            if ENV.has_key?("DEBUG_LOOKUP")
              STDERR.puts "[DEBUG_LOOKUP]   Found match: '#{best_name}' (typed)"
            end
            func_def = best_def
            arena = @function_def_arenas[best_name]
            target_name = best_name
            lookup_branch = "mangled_prefix_typed"
          else
            @function_defs.each_key do |key|
              if key.starts_with?(mangled_prefix)
                if ENV.has_key?("DEBUG_LOOKUP")
                  STDERR.puts "[DEBUG_LOOKUP]   Found match: '#{key}'"
                end
                func_def = @function_defs[key]
                arena = @function_def_arenas[key]
                target_name = key
                lookup_branch = "mangled_prefix"
                break
              end
            end
          end
          if ENV.has_key?("DEBUG_LOOKUP") && !func_def
            STDERR.puts "[DEBUG_LOOKUP]   No match found for '#{mangled_prefix}'"
          end
        end

        # If still not found, try looking in included modules
        # e.g., IO::FileDescriptor#sync= -> IO::Buffered#sync=
        unless func_def
          if base_name.includes?("#")
            owner, method = base_name.split("#", 2)
            if included = @class_included_modules[owner]?
              included.each do |module_name|
                # Strip generic params: IO::Buffered(T) -> IO::Buffered
                base_module = module_name.split('(').first
                module_method = "#{base_module}##{method}"
                if mod_func_def = @function_defs[module_method]?
                  func_def = mod_func_def
                  arena = @function_def_arenas[module_method]
                  # Keep target_name as class method name - will generate with class prefix
                  target_name = base_name
                  lookup_branch = "included_module"
                  break
                end
                # Also try mangled versions
                @function_defs.each_key do |key|
                  if key.starts_with?("#{module_method}$")
                    func_def = @function_defs[key]
                    arena = @function_def_arenas[key]
                    target_name = base_name
                    lookup_branch = "included_module_mangled"
                    break
                  end
                end
                break if func_def
              end
            end
          end
        end

        # DEFERRED MODULE LOOKUP: If still not found, look directly in @module_defs
        # This handles cases where module inclusion was processed before all module
        # reopenings were registered (e.g., BinaryFormat reopened across multiple files)
        deferred_lookup_used = false
        unless func_def
          if base_name.includes?("#")
            owner, method_part = base_name.split("#", 2)
            # Extract param signature from original name (includes $params)
            original_method_part = name.includes?("#") ? name.split("#", 2).last : method_part
            if included = @class_included_modules[owner]?
              method_base = method_part.split("$").first
              expected_param_count = if original_method_part.includes?("$")
                                       original_method_part.split("$", 2).last.split("_").size
                                     else
                                       0
                                     end
              included.each do |module_name|
                base_module = module_name.split('(').first
                visited = Set(String).new
                if found = find_module_def_recursive(base_module, method_base, expected_param_count, visited)
                  func_def = found[0]
                  arena = found[1]
                  # DON'T override target_name - let lower_method compute correct mangled name
                  target_name = base_name
                  deferred_lookup_used = true
                  lookup_branch = "deferred_module"
                  if ENV.has_key?("DEBUG_DEFERRED") && method_base == "byte_range"
                    STDERR.puts "[DEFERRED_LOOKUP] Found #{method_base} in module #{base_module} for #{base_name} target=#{target_name} func_def=#{func_def.class} arena=#{arena.class}:#{arena.size}"
                  end
                  if method_part.includes?("from_chars")
                    STDERR.puts "[DEFERRED_LOOKUP] Found #{method_base} in module #{base_module} for #{base_name}"
                  end
                  break
                elsif method_part.includes?("from_chars")
                  STDERR.puts "[DEFERRED_LOOKUP] Skipping #{method_base} in module #{base_module} (no match)"
                end
                break if func_def
              end
            end
          end
        end

        # PARENT CLASS FALLBACK: use parent method bodies for subclasses.
        # This keeps method resolution working when a subclass doesn't redefine a method.
        unless func_def
          if base_name.includes?("#")
            owner, method_part = base_name.split("#", 2)
            if info = @class_info[owner]?
              parent = info.parent_name
              matched_parent : String? = nil
              while parent
                parent_base = "#{parent}##{method_part}"
                if candidate = @function_defs[parent_base]?
                  func_def = candidate
                  arena = @function_def_arenas[parent_base]
                  target_name = base_name
                  lookup_branch = "parent_fallback"
                  matched_parent = parent
                elsif name.includes?("$")
                  suffix = name.split("$", 2)[1]
                  parent_mangled = "#{parent_base}$#{suffix}"
                  if candidate = @function_defs[parent_mangled]?
                    func_def = candidate
                    arena = @function_def_arenas[parent_mangled]
                    target_name = base_name
                    lookup_branch = "parent_fallback_mangled"
                    matched_parent = parent
                  end
                end
                unless func_def
                  mangled_prefix = "#{parent_base}$"
                  @function_defs.each_key do |key|
                    if key.starts_with?(mangled_prefix)
                      func_def = @function_defs[key]
                      arena = @function_def_arenas[key]
                      target_name = base_name
                      lookup_branch = "parent_fallback_prefix"
                      matched_parent = parent
                      break
                    end
                  end
                end
                break if func_def
                parent = @class_info[parent]?.try(&.parent_name)
              end
              if func_def
                debug_hook("function.lookup.parent_fallback", "name=#{name} parent=#{matched_parent || "Object"}")
              end
            end
          end
        end

        # DEFERRED MODULE LOOKUP (class methods): direct module/class method call (Module.method)
        unless func_def
          if base_name.includes?(".")
            owner, method_part = base_name.split(".", 2)
            original_method_part = name.includes?(".") ? name.split(".", 2).last : method_part
            method_base = method_part.split("$").first
            expected_param_count = if original_method_part.includes?("$")
                                     original_method_part.split("$", 2).last.split("_").size
                                   else
                                     0
                                   end
            if found = find_module_class_def(owner, method_base, expected_param_count)
              func_def = found[0]
              arena = found[1]
              target_name = base_name
              deferred_lookup_used = true
              lookup_branch = "deferred_module_class"
            end
          end
        end

        # PRIMITIVE TEMPLATE FALLBACK: use Int/Float method bodies for primitive receivers.
        unless func_def
          if base_name.includes?("#")
            owner, method_part = base_name.split("#", 2)
            if template_owner = primitive_template_owner(owner)
              template_base = "#{template_owner}##{method_part}"
              if candidate = @function_defs[template_base]?
                func_def = candidate
                arena = @function_def_arenas[template_base]
                target_name = base_name
                primitive_template_map = primitive_template_type_map(template_owner, owner)
                lookup_branch = "primitive_template"
              elsif name.includes?("$")
                suffix = name.split("$", 2)[1]
                template_mangled = "#{template_base}$#{suffix}"
                if candidate = @function_defs[template_mangled]?
                  func_def = candidate
                  arena = @function_def_arenas[template_mangled]
                  target_name = base_name
                  primitive_template_map = primitive_template_type_map(template_owner, owner)
                  lookup_branch = "primitive_template_mangled"
                end
              end
              unless func_def
                mangled_prefix = "#{template_base}$"
                @function_defs.each_key do |key|
                  if key.starts_with?(mangled_prefix)
                    func_def = @function_defs[key]
                    arena = @function_def_arenas[key]
                    target_name = base_name
                    primitive_template_map = primitive_template_type_map(template_owner, owner)
                    lookup_branch = "primitive_template_prefix"
                    break
                  end
                end
              end
            end
          end
        end

        # OBJECT FALLBACK: use Object method bodies when classes omit explicit parents.
        unless func_def
          if base_name.includes?("#")
            owner, method_part = base_name.split("#", 2)
            if owner != "Object"
              object_base = "Object##{method_part}"
              if candidate = @function_defs[object_base]?
                func_def = candidate
                arena = @function_def_arenas[object_base]
                target_name = base_name
                lookup_branch = "object_fallback"
              elsif name.includes?("$")
                suffix = name.split("$", 2)[1]
                object_mangled = "#{object_base}$#{suffix}"
                if candidate = @function_defs[object_mangled]?
                  func_def = candidate
                  arena = @function_def_arenas[object_mangled]
                  target_name = base_name
                  lookup_branch = "object_fallback_mangled"
                end
              end
              unless func_def
                mangled_prefix = "#{object_base}$"
                @function_defs.each_key do |key|
                  if key.starts_with?(mangled_prefix)
                    func_def = @function_defs[key]
                    arena = @function_def_arenas[key]
                    target_name = base_name
                    lookup_branch = "object_fallback_prefix"
                    break
                  end
                end
              end
            end
        end
      end

      # PARENT FALLBACK (class methods): reuse parent class method defs for subclasses.
      unless func_def
        if base_name.includes?(".")
          owner, method_part = base_name.split(".", 2)
          visited_parents = Set(String).new
          parent = @class_info[owner]?.try(&.parent_name)
          while parent
            break if visited_parents.includes?(parent)
            visited_parents << parent
            parent_base = "#{parent}.#{method_part}"
            if candidate = @function_defs[parent_base]?
              func_def = candidate
              arena = @function_def_arenas[parent_base]
              target_name = name
              lookup_branch = "parent_class_fallback"
              break
            elsif name.includes?("$")
              suffix = name.split("$", 2)[1]
              parent_mangled = "#{parent_base}$#{suffix}"
              if candidate = @function_defs[parent_mangled]?
                func_def = candidate
                arena = @function_def_arenas[parent_mangled]
                target_name = name
                lookup_branch = "parent_class_fallback_mangled"
                break
              end
            end
            unless func_def
              mangled_prefix = "#{parent_base}$"
              @function_defs.each_key do |key|
                if key.starts_with?(mangled_prefix)
                  func_def = @function_defs[key]
                  arena = @function_def_arenas[key]
                  target_name = name
                  lookup_branch = "parent_class_fallback_prefix"
                  break
                end
              end
            end
            break if func_def
            parent = @class_info[parent]?.try(&.parent_name)
          end
        end
      end

      # PRIMITIVE TEMPLATE FALLBACK (class methods): reuse Int/Float class methods for numeric primitives.
      unless func_def
        if base_name.includes?(".")
          owner, method_part = base_name.split(".", 2)
          if template_owner = primitive_template_owner(owner)
            template_base = "#{template_owner}.#{method_part}"
            if candidate = @function_defs[template_base]?
              func_def = candidate
              arena = @function_def_arenas[template_base]
              target_name = name
              lookup_branch = "primitive_class_fallback"
            elsif name.includes?("$")
              suffix = name.split("$", 2)[1]
              template_mangled = "#{template_base}$#{suffix}"
              if candidate = @function_defs[template_mangled]?
                func_def = candidate
                arena = @function_def_arenas[template_mangled]
                target_name = name
                lookup_branch = "primitive_class_fallback_mangled"
              end
            end
            unless func_def
              mangled_prefix = "#{template_base}$"
              @function_defs.each_key do |key|
                if key.starts_with?(mangled_prefix)
                  func_def = @function_defs[key]
                  arena = @function_def_arenas[key]
                  target_name = name
                  lookup_branch = "primitive_class_fallback_prefix"
                  break
                end
              end
            end
          end
        end
      end

      # OBJECT FALLBACK (class methods): reuse Object's class methods for subclasses.
      # This ensures inherited class methods are lowered with the subclass context.
      unless func_def
        if base_name.includes?(".")
            owner, method_part = base_name.split(".", 2)
            if owner != "Object" && @class_info.has_key?(owner)
              object_base = "Object.#{method_part}"
              if candidate = @function_defs[object_base]?
                func_def = candidate
                arena = @function_def_arenas[object_base]
                target_name = name
                lookup_branch = "object_class_fallback"
              elsif name.includes?("$")
                suffix = name.split("$", 2)[1]
                object_mangled = "#{object_base}$#{suffix}"
                if candidate = @function_defs[object_mangled]?
                  func_def = candidate
                  arena = @function_def_arenas[object_mangled]
                  target_name = name
                  lookup_branch = "object_class_fallback_mangled"
                end
              end
              unless func_def
                mangled_prefix = "#{object_base}$"
                @function_defs.each_key do |key|
                  if key.starts_with?(mangled_prefix)
                    func_def = @function_defs[key]
                    arena = @function_def_arenas[key]
                    target_name = name
                    lookup_branch = "object_class_fallback_prefix"
                    break
                  end
                end
              end
            end
          end
        end
      end

      if !func_def && !name.includes?("#") && !name.includes?(".")
        if current = @current_class
          base = name.split("$", 2)[0]
          qualified_base = "#{current}##{base}"
          if candidate = @function_defs[qualified_base]?
            func_def = candidate
            arena = @function_def_arenas[qualified_base]?
            if name.includes?("$")
              suffix = name.split("$", 2)[1]
              target_name = "#{qualified_base}$#{suffix}"
            else
              target_name = qualified_base
            end
            name = target_name
            lookup_branch = "qualified_current"
          end
        end
      end

      if func_def
        data = "name=#{name} target=#{target_name} branch=#{lookup_branch || "unknown"}"
        if callsite = @debug_callsite
          data += " callsite=#{callsite}"
        end
        debug_hook("function.lookup.hit", data)
      else
        data = "name=#{name}"
        if callsite = @debug_callsite
          data += " callsite=#{callsite}"
        end
        debug_hook("function.lookup.miss", data)
      end
      if ENV["DEBUG_FROM_CHARS"]? && name.includes?("from_chars_advanced")
        STDERR.puts "[DEBUG_FROM_CHARS] lookup_result branch=#{lookup_branch || "none"} target=#{target_name} func_def=#{!func_def.nil?}"
      end

      if ENV.has_key?("DEBUG_DEFERRED") && name.includes?("byte_range")
        STDERR.puts "[DEFERRED_FUNC] func_def=#{!func_def.nil?} name=#{name} target=#{target_name} lookup=#{lookup_branch || "none"}"
      end
      return unless func_def
      is_yield_target = @yield_functions.includes?(target_name)
      is_lowering_target = @lowering_functions.includes?(target_name)
      if ENV.has_key?("DEBUG_DEFERRED") && name.includes?("byte_range")
        STDERR.puts "[DEFERRED_CHECK] is_yield=#{is_yield_target} is_lowering=#{is_lowering_target}"
      end
      return if is_yield_target
      return if is_lowering_target

      if arena.nil?
        arena = resolve_arena_for_def(func_def, @arena)
        if ENV["DEBUG_CALL_TRACE"]? && name.includes?("copy_to")
          STDERR.puts "[LOWER_TRACE] arena_fallback name=#{name} arena=#{arena.class}:#{arena.size}"
        end
      elsif body = func_def.body
        unless body.empty?
          max_index = body.max_of(&.index)
          if max_index >= arena.size
            arena = resolve_arena_for_def(func_def, arena)
            if ENV["DEBUG_CALL_TRACE"]? && name.includes?("copy_to")
              STDERR.puts "[LOWER_TRACE] arena_repair name=#{name} max=#{max_index} arena=#{arena.class}:#{arena.size}"
            end
          end
        end
      end

      callsite_args = pop_pending_callsite_args(name, target_name)
      if callsite_args.nil? && func_def
        callsite_args = pending_callsite_args_for_def(func_def, name, target_name)
      end
      call_arg_types = callsite_args ? callsite_args.types : nil
      call_arg_literals = callsite_args ? callsite_args.literals : nil

      extra_type_params : Hash(String, String)? = nil
      resolved_owner : String? = nil
      resolved_target_name = target_name
      base_target_name = target_name.split("$", 2)[0]
      force_class_method = base_target_name.includes?(".")
      if base_target_name.includes?("#") || base_target_name.includes?(".")
        sep = base_target_name.includes?("#") ? "#" : "."
        owner, method = base_target_name.split(sep, 2)
        if info = generic_owner_info(owner)
          resolved_owner = info[:owner]
          extra_type_params = info[:map]
          if resolved_owner != owner
            resolved_base = "#{resolved_owner}#{sep}#{method}"
            if target_name.includes?("$")
              suffix = target_name.split("$", 2)[1]
              resolved_target_name = "#{resolved_base}$#{suffix}"
            else
              resolved_target_name = resolved_base
            end
          end
          if !@class_info.has_key?(info[:owner]) && !@monomorphized.includes?(info[:owner]) && concrete_type_args?(info[:args])
            monomorphize_generic_class(info[:base], info[:args], info[:owner])
          end
        end
      end

      if registered_params = function_type_param_map_for(target_name, base_target_name, name)
        if DebugHooks::ENABLED && base_target_name.includes?("map")
          params_str = registered_params.map { |k, v| "#{k}=#{v}" }.join(",")
          debug_hook("function.lower.type_params", "target=#{target_name} base=#{base_target_name} params=#{params_str}")
        end
        extra_type_params = extra_type_params ? extra_type_params.merge(registered_params) : registered_params.dup
      elsif DebugHooks::ENABLED && base_target_name.includes?("map")
        debug_hook("function.lower.type_params", "target=#{target_name} base=#{base_target_name} params=")
      end

      if pending_params = consume_pending_type_param_map(name)
        if DebugHooks::ENABLED && base_target_name.includes?("map")
          params_str = pending_params.map { |k, v| "#{k}=#{v}" }.join(",")
          debug_hook("function.lower.pending_params", "target=#{target_name} name=#{name} params=#{params_str}")
        end
        extra_type_params = extra_type_params ? extra_type_params.merge(pending_params) : pending_params.dup
      elsif pending_params = consume_pending_type_param_map(target_name)
        if DebugHooks::ENABLED && base_target_name.includes?("map")
          params_str = pending_params.map { |k, v| "#{k}=#{v}" }.join(",")
          debug_hook("function.lower.pending_params", "target=#{target_name} name=#{target_name} params=#{params_str}")
        end
        extra_type_params = extra_type_params ? extra_type_params.merge(pending_params) : pending_params.dup
      elsif pending_params = consume_pending_type_param_map(base_target_name)
        if DebugHooks::ENABLED && base_target_name.includes?("map")
          params_str = pending_params.map { |k, v| "#{k}=#{v}" }.join(",")
          debug_hook("function.lower.pending_params", "target=#{target_name} name=#{base_target_name} params=#{params_str}")
        end
        extra_type_params = extra_type_params ? extra_type_params.merge(pending_params) : pending_params.dup
      end

      has_in_module = @module.has_function?(resolved_target_name)
      is_lowering_resolved = @lowering_functions.includes?(resolved_target_name)
      if ENV.has_key?("DEBUG_DEFERRED") && name.includes?("byte_range")
        STDERR.puts "[DEFERRED_FINAL] resolved=#{resolved_target_name} has_in_module=#{has_in_module} is_lowering=#{is_lowering_resolved}"
      end
      return if has_in_module
      return if is_lowering_resolved

      target_name = resolved_target_name
      @lowering_functions.add(target_name)
      debug_hook("function.lower.start", "name=#{target_name} requested=#{name}")
      if ENV.has_key?("DEBUG_CLASS_MODULES") && (target_name.includes?("byte_begin") || target_name.includes?("MatchData"))
        owner = target_name.split("#", 2)[0]
        modules = @class_included_modules[owner]?
        STDERR.puts "[CLASS_MODULES] target=#{target_name} owner=#{owner} modules=#{modules ? modules.to_a.join(",") : "nil"}"
      end
      if target_name.includes?("from_chars")
        STDERR.puts "[LOWERING] Starting lower for #{target_name}, arena=#{arena.class}"
      end
      begin
        with_arena(arena || @arena) do
          if target_name.includes?("#")
            owner = resolved_owner || target_name.split("#", 2)[0]
            if class_info = @class_info[owner]?
              if DebugHooks::ENABLED && unresolved_generic_receiver?(owner)
                debug_hook(
                  "lower.class_receiver.unresolved",
                  "owner=#{owner} target=#{target_name} requested=#{name} map=#{type_param_map_debug_string}"
                )
              end
              old_class = @current_class
              @current_class = owner
              if target_name.includes?("from_chars")
                STDERR.puts "[LOWERING] Calling lower_method for #{target_name}, deferred=#{deferred_lookup_used}"
              end
              # For deferred lookup, pass the caller's expected name (with mangled types) so the
              # generated function matches what the call site is looking for. This handles cases where
              # the def signature uses unresolved generic types (like ParseOptionsT(UC)) but the call
              # site uses concrete types (like Pointer).
              # The `name` variable contains the full mangled name from the call site.
              override = name
              namespace_override = function_namespace_override_for(target_name, base_target_name, name)
              # Add forall type param bindings for primitive templates and FastFloat methods.
              extra_params = primitive_template_map || {} of String => String
              if target_name.includes?("FastFloat")
                extra_params = extra_params.merge({"UC" => "UInt8", "T" => "Float64"})
              end
              merged_params = extra_type_params ? extra_params.merge(extra_type_params) : extra_params
              with_type_param_map(merged_params) do
                if namespace_override
                  with_namespace_override(namespace_override) do
                    lower_method(owner, class_info, func_def, call_arg_types, call_arg_literals, override, force_class_method: force_class_method)
                  end
                else
                  lower_method(owner, class_info, func_def, call_arg_types, call_arg_literals, override, force_class_method: force_class_method)
                end
              end
              @current_class = old_class
            elsif enum_info = @enum_info
              if enum_info.has_key?(owner)
                old_class = @current_class
                @current_class = owner
                dummy_info = ClassInfo.new(owner, TypeRef::INT32, [] of IVarInfo, [] of ClassVarInfo, 0, false, nil)
                lower_method(owner, dummy_info, func_def, call_arg_types, call_arg_literals, name, force_class_method: force_class_method)
                @current_class = old_class
              elsif target_name.includes?("from_chars")
                STDERR.puts "[LOWERING] No class_info for #{owner}"
              end
            elsif target_name.includes?("from_chars")
              STDERR.puts "[LOWERING] No class_info for #{owner}"
            end
          elsif target_name.includes?(".")
            parts = target_name.split(".", 2)
            owner = resolved_owner || parts[0]
            method = parts[1]?
            namespace_override = function_namespace_override_for(target_name, base_target_name, name)
            full_override = name != target_name ? name : nil
            target_for_lower = full_override || target_name
            # For .new on classes/structs, use generate_allocator (not lower_method)
            # This ensures correct init_params from the initialize method are used
            if method && method.split("$", 2)[0] == "new"
              if class_info = @class_info[owner]?
                base_new = "#{owner}.new"
                explicit_new = @function_defs.has_key?(base_new)
                unless explicit_new
                  prefix = "#{base_new}$"
                  @function_defs.each_key do |key|
                    if key.starts_with?(prefix)
                      explicit_new = true
                      break
                    end
                  end
                end
                if allocator_supported?(owner) && !explicit_new
                  generate_allocator(owner, class_info)
                  # The function was just generated (or already existed), return
                  return
                end
              end
            end
            if class_info = @class_info[owner]?
              old_class = @current_class
              @current_class = owner
              if extra_type_params
                with_type_param_map(extra_type_params) do
                  if namespace_override
                    with_namespace_override(namespace_override) do
                      lower_method(owner, class_info, func_def, call_arg_types, call_arg_literals, target_for_lower, force_class_method: force_class_method)
                    end
                  else
                    lower_method(owner, class_info, func_def, call_arg_types, call_arg_literals, target_for_lower, force_class_method: force_class_method)
                  end
                end
              else
                if namespace_override
                  with_namespace_override(namespace_override) do
                    lower_method(owner, class_info, func_def, call_arg_types, call_arg_literals, target_for_lower, force_class_method: force_class_method)
                  end
                else
                  lower_method(owner, class_info, func_def, call_arg_types, call_arg_literals, target_for_lower, force_class_method: force_class_method)
                end
              end
              @current_class = old_class
            elsif enum_info = @enum_info
              if enum_info.has_key?(owner)
                old_class = @current_class
                @current_class = owner
                dummy_info = ClassInfo.new(owner, TypeRef::INT32, [] of IVarInfo, [] of ClassVarInfo, 0, false, nil)
                lower_method(owner, dummy_info, func_def, call_arg_types, call_arg_literals, target_for_lower)
                @current_class = old_class
              else
                lower_module_method(owner, func_def, call_arg_types, call_arg_literals, target_for_lower)
              end
            else
              lower_module_method(owner, func_def, call_arg_types, call_arg_literals, target_for_lower)
            end
          else
            # Use the call-site mangled name so top-level defs match call signatures.
            lower_def(func_def, call_arg_types, call_arg_literals, name)
          end
        end
      ensure
        @lowering_functions.delete(target_name)
        @lowered_functions.add(target_name)
        debug_hook("function.lower.done", "name=#{target_name}")
      end
    end

    private def maybe_generate_accessor_for_name(name : String) : Bool
      base_name = name.split("$", 2)[0]
      return false unless base_name.includes?("#")

      owner, method_name = base_name.split("#", 2)
      return false if owner.empty? || method_name.empty?

      class_info = @class_info[owner]?
      return false unless class_info

      if method_name.ends_with?("=")
        accessor = method_name[0, method_name.size - 1]
        ivar_name = "@#{accessor}"
        if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
          expected_name = mangle_function_name(base_name, [ivar_info.type])
          return false if name.includes?("$") && expected_name != name
          generate_setter_method_for_ivar(owner, class_info, ivar_info)
          return true
        end
      else
        accessor = method_name.ends_with?("?") ? method_name[0, method_name.size - 1] : method_name
        ivar_name = "@#{accessor}"
        if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
          expected_name = mangle_function_name(base_name, [] of TypeRef)
          return false if name.includes?("$") && expected_name != name
          generate_getter_method_for_ivar(owner, class_info, ivar_info, method_name)
          return true
        end
      end

      false
    end

    private def register_class_accessor_entry(
      owner_name : String,
      spec : CrystalV2::Compiler::Frontend::AccessorSpec,
      kind : Symbol
    ) : Nil
      storage_name = accessor_storage_name(spec)
      method_name = accessor_method_name(spec)

      case kind
      when :getter
        return_type = if ta = spec.type_annotation
                        type_ref_for_name(String.new(ta))
                      elsif spec.predicate
                        TypeRef::BOOL
                      elsif default_value = spec.default_value
                        infer_type_from_expr(default_value, owner_name) || TypeRef::VOID
                      else
                        TypeRef::VOID
                      end
        base_name = "#{owner_name}.#{method_name}"
        full_name = mangle_function_name(base_name, [] of TypeRef)
        register_function_type(full_name, return_type)
        entry = ClassAccessorEntry.new(owner_name, spec, @arena, :getter)
        @class_accessor_entries[full_name] = entry
        @class_accessor_entries[base_name] = entry
      when :setter
        param_type = if ta = spec.type_annotation
                       type_ref_for_name(String.new(ta))
                     else
                       TypeRef::VOID
                     end
        base_name = "#{owner_name}.#{storage_name}="
        full_name = mangle_function_name(base_name, [param_type])
        register_function_type(full_name, param_type)
        entry = ClassAccessorEntry.new(owner_name, spec, @arena, :setter)
        @class_accessor_entries[full_name] = entry
        @class_accessor_entries[base_name] = entry
      end
    end

    private def maybe_generate_class_accessor_for_name(name : String) : Bool
      entry = @class_accessor_entries[name]?
      unless entry
        base_name = name.split("$", 2)[0]
        entry = @class_accessor_entries[base_name]?
      end
      return false unless entry

      with_arena(entry.arena) do
        case entry.kind
        when :getter
          generate_class_getter_method(entry.owner, entry.spec, entry.arena)
        when :setter
          generate_class_setter_method(entry.owner, entry.spec)
        end
      end
      true
    end

    private def ensure_accessor_method(
      ctx : LoweringContext,
      receiver_id : ValueId,
      method_name : String
    ) : Tuple(TypeRef, String)?
      receiver_type = ctx.type_of(receiver_id)
      class_name = get_type_name_from_ref(receiver_type)
      class_info = @class_info[class_name]?
      return nil unless class_info

      if method_name.ends_with?("=")
        accessor_name = method_name[0, method_name.size - 1]
        ivar_name = "@#{accessor_name}"
        if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
          func_name = mangle_function_name("#{class_name}##{accessor_name}=", [ivar_info.type])
          generate_setter_method_for_ivar(class_name, class_info, ivar_info) unless @module.has_function?(func_name)
          return {ivar_info.type, func_name}
        end
      else
        ivar_name = "@#{method_name}"
        if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
          func_name = mangle_function_name("#{class_name}##{method_name}", [] of TypeRef)
          generate_getter_method_for_ivar(class_name, class_info, ivar_info) unless @module.has_function?(func_name)
          return {ivar_info.type, func_name}
        end
      end

      nil
    end

    private def ivar_type_for_setter(
      ctx : LoweringContext,
      receiver_id : ValueId,
      method_name : String
    ) : TypeRef?
      return nil unless method_name.ends_with?("=")
      receiver_type = ctx.type_of(receiver_id)
      class_name = get_type_name_from_ref(receiver_type)
      return nil if class_name.empty?

      if class_info = @class_info[class_name]?
        accessor_name = method_name[0, method_name.size - 1]
        ivar_name = "@#{accessor_name}"
        if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
          return ivar_info.type
        end
      end

      nil
    end

    private def lower_spawn(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::SpawnNode) : ValueId
      body_exprs = if body = node.body
                     body
                   elsif expr = node.expression
                     [expr] of CrystalV2::Compiler::Frontend::ExprId
                   else
                     [] of CrystalV2::Compiler::Frontend::ExprId
                   end

      block_node = CrystalV2::Compiler::Frontend::BlockNode.new(node.span, nil, body_exprs)
      block_id = @arena.add_typed(block_node)

      callee_id = @arena.add_typed(
        CrystalV2::Compiler::Frontend::IdentifierNode.new(node.span, "spawn".to_slice)
      )
      call_node = CrystalV2::Compiler::Frontend::CallNode.new(node.span, callee_id, [] of CrystalV2::Compiler::Frontend::ExprId, block_id)
      lower_call(ctx, call_node)
    end

    private def lower_call(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::CallNode) : ValueId
      if ENV["DEBUG_ALL_CALLS"]? || ENV["DEBUG_LOWER_CALL"]?
        callee_node = @arena[node.callee]
        callee_name = case callee_node
                      when CrystalV2::Compiler::Frontend::IdentifierNode
                        String.new(callee_node.name)
                      when CrystalV2::Compiler::Frontend::MemberAccessNode
                        String.new(callee_node.member)
                      else
                        "(other)"
                      end
        if ENV["DEBUG_ALL_CALLS"]? || callee_name == "byte_range"
          STDERR.puts "[LOWER_CALL] method=#{callee_name} callee_type=#{callee_node.class.name.split("::").last} current_class=#{@current_class || "nil"} block=#{node.block.nil? ? "no" : "yes"} func=#{ctx.function.name}"
        end
      end
      if ENV["DEBUG_INLINE_CRASH"]?
        if @inline_yield_name_stack.any? { |name| name.includes?("Char::Reader#decode_char_at") }
          stack = @inline_yield_name_stack.join(" -> ")
          if ctx.current_block >= ctx.function.blocks.size
            STDERR.puts "[INLINE_CRASH] block_oob call block=#{ctx.current_block} size=#{ctx.function.blocks.size} stack=#{stack}"
          end
          if source = @sources_by_arena[@arena]?
            span = node.span
            start = span.start_offset
            length = span.end_offset - span.start_offset
            if length > 0 && start >= 0 && start < source.bytesize
              slice_len = length > 80 ? 80 : length
              snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
              STDERR.puts "[INLINE_CRASH] lower_call span=#{start}..#{span.end_offset} stack=#{stack} \"#{snippet}\""
            else
              STDERR.puts "[INLINE_CRASH] lower_call span=#{start}..#{span.end_offset} stack=#{stack}"
            end
          else
            STDERR.puts "[INLINE_CRASH] lower_call span=#{node.span.start_offset}..#{node.span.end_offset} stack=#{stack}"
          end
        end
      end
      call_arena = @arena
      if type_like_call_expr?(node)
        base = resolve_path_like_name(node.callee) || stringify_type_expr(node.callee)
        if base
          args = node.args.map { |arg| stringify_type_expr(arg) }
          if args.all?(&.itself)
            type_name = "#{base}(#{args.join(", ")})"
            return lower_type_literal_from_name(ctx, type_name)
          end
        end
      end
      # CallNode has callee (ExprId) which can be:
      # - IdentifierNode: simple function call like foo() or ClassName.new()
      # - MemberAccessNode: method call like obj.method()
      # - Other: chained/complex calls

      callee_node = @arena[node.callee]

      # Intrinsic: obj.is_a?(Type) should lower to IsA/UnionIs without a runtime method call.
      if node.named_args.nil?
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode) &&
           String.new(callee_node.member) == "is_a?"
          if node.args.empty?
            debug_hook("is_a.missing_type", "receiver=#{stringify_type_expr(callee_node.object) || "unknown"}")
            lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
            ctx.emit(lit)
            return lit.id
          elsif type_str = stringify_type_expr(node.args.first)
            is_a_receiver_id = lower_expr(ctx, callee_node.object)
            return emit_is_a_check(ctx, is_a_receiver_id, type_str)
          end
        elsif callee_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode) &&
              String.new(callee_node.name) == "is_a?"
          if node.args.empty?
            debug_hook("is_a.missing_type", "receiver=self")
            lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
            ctx.emit(lit)
            return lit.id
          elsif type_str = stringify_type_expr(node.args.first)
            is_a_receiver_id = emit_self(ctx)
            return emit_is_a_check(ctx, is_a_receiver_id, type_str)
          end
        end
      end

      call_args = node.args
      block_expr = node.block
      block_pass_expr : ExprId? = nil

      if block_expr.nil? && !call_args.empty?
        last_id = call_args.last
        last_node = @arena[last_id]
        case last_node
        when CrystalV2::Compiler::Frontend::BlockNode
          block_expr = last_id
          call_args = call_args[0...-1]
        when CrystalV2::Compiler::Frontend::UnaryNode
          if String.new(last_node.operator) == "&"
            operand = last_node.operand
            operand_node = @arena[operand]
            if operand_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              block_expr = operand
            else
              block_pass_expr = operand
            end
            call_args = call_args[0...-1]
          end
        end
      end

      receiver_id : ValueId? = nil
      receiver_type : TypeRef = TypeRef::VOID
      method_name : String
      full_method_name : String? = nil
      static_class_name : String? = nil
      proc_return_type_name : String? = nil

      case callee_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        # Simple function call: foo()
        method_name = String.new(callee_node.name)

        # Check if this is a macro call - expand inline instead of generating Call.
        # Skip spawn macro when lowering SpawnNode-generated calls (block + no args).
        unless method_name == "spawn" && block_expr && call_args.empty? && node.named_args.nil?
          if macro_lookup = lookup_macro_entry(method_name, @current_class)
            macro_entry, macro_key = macro_lookup
            macro_def, macro_arena = macro_entry
            return expand_macro(ctx, macro_def, macro_arena, call_args, node.named_args, block_expr, macro_key)
          end
        end

        # If inside a class/module, check if this is a method call on self or module
        if ENV.has_key?("DEBUG_CALL_PATH") && method_name == "byte_range"
          STDERR.puts "[CALL_PATH] IdentifierNode method=#{method_name} @current_class=#{@current_class || "nil"}"
        end
        if current = @current_class
          # Debug: track when @current_class is a short name
          if ENV.has_key?("DEBUG_SHORT_NAMES") && !current.includes?("::") &&
             (current == "Seek" || current == "Section" || current == "LoadCommand" || current == "Sequence")
            STDERR.puts "[SHORT_CLASS] @current_class=#{current}, method=#{method_name}"
          end
          # Check if method exists in current class (instance method: Class#method)
          class_method_name = "#{current}##{method_name}"
          # O(1) lookup: check exact match or mangled version exists
          has_class_method = @function_types.has_key?(class_method_name) || has_function_base?(class_method_name)
          if has_class_method
            # This is a method call on self - set receiver to self
            receiver_id = emit_self(ctx)
            full_method_name = class_method_name
          else
            # Check if method exists in included modules
            included_method_found = false
            if modules = @class_included_modules[current]?
              if ENV.has_key?("DEBUG_INCLUDED") && method_name == "byte_range"
                STDERR.puts "[INCLUDED] class=#{current} method=#{method_name} modules=#{modules.to_a.join(",")}"
              end
              modules.each do |mod_name|
                mod_method_name = "#{mod_name}##{method_name}"
                has_in_types = @function_types.has_key?(mod_method_name)
                has_in_base = has_function_base?(mod_method_name)
                if ENV.has_key?("DEBUG_INCLUDED") && method_name == "byte_range"
                  STDERR.puts "[INCLUDED_LOOKUP] mod_method=#{mod_method_name} has_in_types=#{has_in_types} has_in_base=#{has_in_base}"
                end
                if has_in_types || has_in_base
                  receiver_id = emit_self(ctx)
                  full_method_name = mod_method_name
                  included_method_found = true
                  break
                end
                # If not found in function_types, try to find in module def AST
                # This handles instance methods (def foo) that aren't pre-registered
                unless included_method_found
                  base_module = mod_name.split('(').first
                  visited = Set(String).new
                  if found = find_module_def_recursive(base_module, method_name, 0, visited)
                    if ENV.has_key?("DEBUG_INCLUDED") && method_name == "byte_range"
                      STDERR.puts "[INCLUDED_FOUND_IN_AST] mod=#{base_module} method=#{method_name}"
                    end
                    receiver_id = emit_self(ctx)
                    # Use class#method name for lowering (will use deferred lookup)
                    full_method_name = "#{current}##{method_name}"
                    included_method_found = true
                    break
                  end
                end
              end
            elsif ENV.has_key?("DEBUG_INCLUDED") && method_name == "byte_range"
              STDERR.puts "[INCLUDED] class=#{current} method=#{method_name} no_modules"
            end
            unless included_method_found
              # Also check for module-style method (Module.method)
              module_method_name = "#{current}.#{method_name}"
              # O(1) lookup: check exact match or mangled version exists
              has_module_method = @function_types.has_key?(module_method_name) || has_function_base?(module_method_name)
              if has_module_method
                # This is a module method call (no receiver)
                receiver_id = nil
                full_method_name = module_method_name
              else
                receiver_id = nil
              end
            end
          end
        else
          receiver_id = nil
        end

      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # Could be method call: obj.method() or class method: ClassName.new()
        obj_expr = callee_node.object
        obj_node = @arena[obj_expr]
        while obj_node.is_a?(CrystalV2::Compiler::Frontend::GroupingNode) ||
              obj_node.is_a?(CrystalV2::Compiler::Frontend::MacroExpressionNode)
          obj_expr = obj_node.is_a?(CrystalV2::Compiler::Frontend::GroupingNode) ? obj_node.expression : obj_node.expression
          obj_node = @arena[obj_expr]
        end
        method_name = String.new(callee_node.member)
        if ENV["DEBUG_ENUM_PREDICATE"]? && method_name == "character_device?"
          STDERR.puts "[DEBUG_ENUM_CALL_PATH] lower_call method=#{method_name} callee=#{callee_node.class.name}"
        end
        if ENV["DEBUG_POINTER_LIST"]? && method_name == "new"
          if obj_name = stringify_type_expr(obj_expr)
            if obj_name.includes?("PointerLinkedList")
              STDERR.puts "[POINTER_LIST_AST] obj=#{obj_name} method=#{method_name}"
            end
          end
        end

        # Intrinsic: unsafe_as(Type) should lower to a raw cast without a method call.
        if method_name == "unsafe_as" && node.named_args.nil? && block_expr.nil? && block_pass_expr.nil?
          if arg = call_args.first?
            if type_str = stringify_type_expr(arg)
              receiver_id = lower_expr(ctx, obj_expr)
              target_type = type_ref_for_name(type_str)
              if target_type != TypeRef::VOID
                cast = Cast.new(ctx.next_id, target_type, receiver_id, target_type, safe: false)
                ctx.emit(cast)
                ctx.register_type(cast.id, target_type)
                return cast.id
              end
            end
          end
        end

        # Direct ivar access on another object: obj.@ivar
        # Lower as field get when no args/block are present.
        if method_name.starts_with?("@") && call_args.empty? && block_expr.nil? && block_pass_expr.nil?
          return lower_member_access(ctx, callee_node)
        end

        # Intrinsic: `x.upto(y).each { ... }` / `x.downto(y).each { ... }`
        # Prefer lowering directly via the yield-based overload to avoid iterator types like
        # `UptoIterator(typeof(self), typeof(to))` which are not yet fully monomorphized in codegen.
        if method_name == "each"
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode) && obj_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
              inner_call = obj_node
              if inner_call.block.nil?
                inner_callee = @arena[inner_call.callee]
                if inner_callee.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
                  inner_method = String.new(inner_callee.member)
                  if inner_method == "upto" || inner_method == "downto"
                    inner_receiver_id = lower_expr(ctx, inner_callee.object)
                    inner_args = if inner_call.named_args
                                   # Named args for upto/downto are not expected; fall back to positional.
                                   expand_splat_args(ctx, inner_call.args, call_arena)
                                 else
                                   expand_splat_args(ctx, inner_call.args, call_arena)
                                 end
                    if yield_key = find_yield_method_fallback(inner_method, inner_args.size)
                      if func_def = @function_defs[yield_key]?
                        callee_arena = @function_def_arenas[yield_key]? || @arena
                        return inline_yield_function(ctx, func_def, yield_key, inner_receiver_id, inner_args, blk_node, callee_arena)
                      end
                    end
                  end
                end
              end
            end
          end
        end

        # Check if it's a class/module method call (ClassName.new() or Module.method())
        # Can be ConstantNode, IdentifierNode starting with uppercase, or GenericNode
        class_name_str : String? = nil
        constant_receiver = false
        if obj_node.is_a?(CrystalV2::Compiler::Frontend::SelfNode) && @current_method_is_class
          class_name_str = @current_class
        elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
          name = String.new(obj_node.name)
          if resolve_constant_name_in_context(name)
            if @module.is_lib?(name)
              class_name_str = name
            else
              constant_receiver = true
            end
          else
            resolved = resolve_class_name_in_context(name)
            resolved = resolve_type_alias_chain(resolved)
            # Only treat constants as type/module names when they resolve to known types.
            if type_name_exists?(resolved) || primitive_self_type(resolved)
              class_name_str = resolved
            elsif is_module_method?(resolved, method_name)
              class_name_str = resolved
            end
          end
        elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
          name = String.new(obj_node.name)
          if resolve_constant_name_in_context(name)
            if @module.is_lib?(name)
              class_name_str = name
            else
              constant_receiver = true
            end
          else
            if type_name = lookup_typeof_local_name(name)
              if ENV["DEBUG_TYPE_CLASS"]? && type_name.ends_with?(".class")
                STDERR.puts "[DEBUG_TYPE_CLASS] method=#{method_name} name=#{name} type_name=#{type_name}"
              end
              if class_literal = resolve_type_literal_class_name(type_name)
                class_name_str = class_literal
              end
            end
            resolved_name = resolve_class_name_in_context(name)
            resolved_name = resolve_type_alias_chain(resolved_name)
            # Check if it's a class name (starts with uppercase and is known class)
            # OR a module name (check if Module.method exists in function_types)
            if class_name_str.nil? && resolved_name[0].uppercase?
              # Prefer nested types in the current namespace over top-level types.
              resolved_name = resolve_class_name_in_context(resolved_name) unless resolved_name.includes?("::")
              if @class_info.has_key?(resolved_name) ||
                 @enum_info.try(&.has_key?(resolved_name))
                class_name_str = resolved_name
              elsif is_module_method?(resolved_name, method_name)
                # It's a module method call
                class_name_str = resolved_name
              elsif @generic_templates.has_key?(resolved_name) && method_name == "new"
                # Calling .new on a generic template (e.g., Array.new, Hash.new)
                # Try to infer type argument from constructor arguments or block
                inferred_type = infer_generic_type_arg(resolved_name, call_args, block_expr, ctx)
                if inferred_type
                  specialized_name = "#{resolved_name}(#{inferred_type})"
                  # Monomorphize if not already done
                  if !@monomorphized.includes?(specialized_name)
                    monomorphize_generic_class(resolved_name, [inferred_type], specialized_name)
                  end
                  class_name_str = specialized_name
                else
                  # Can't infer type - use fallback or report error
                  # For now, use String as default for Array (common case)
                  if resolved_name == "Array"
                    specialized_name = "Array(String)"
                    if !@monomorphized.includes?(specialized_name)
                      monomorphize_generic_class(resolved_name, ["String"], specialized_name)
                    end
                    class_name_str = specialized_name
                  end
                end
              else
                # For primitive types and aliases not in class_info, use the resolved name directly.
                # Avoid treating value constants (like STDERR) as type names.
                if primitive_self_type(resolved_name)
                  class_name_str = resolved_name
                elsif @type_aliases.has_key?(resolved_name) || LIBC_TYPE_ALIASES.has_key?(resolved_name)
                  class_name_str = resolved_name
                end
              end
            end
          end
        elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::GenericNode)
          # Generic type like Box(Int32).new()
          base_name = resolve_path_like_name(obj_node.base_type)
          if base_name
            base_name = resolve_type_name_in_context(base_name)
            base_name = resolve_type_alias_chain(base_name)
            normalize_typeof_name = ->(type_name : String) : String {
              if type_name == "Void" || type_name == "Unknown" || type_name.includes?("|")
                "Pointer(Void)"
              else
                type_name
              end
            }

            type_args = obj_node.type_args.map do |arg_id|
              arg_node = @arena[arg_id]
              arg_name = case arg_node
                         when CrystalV2::Compiler::Frontend::TypeofNode
                           inner = arg_node.args.first?
                           inner ? resolve_typeof_expr(inner) : "Pointer(Void)"
                         else
                           stringify_type_expr(arg_id) || "Unknown"
                         end
              arg_name = resolve_typeof_in_type_string(arg_name)
              arg_name = normalize_typeof_name.call(arg_name)
              arg_name = resolve_type_name_in_context(arg_name)
              arg_name = substitute_type_params_in_type_name(arg_name)
              normalize_tuple_literal_type_name(arg_name)
            end

            # Create specialized class name like Box(Int32)
            class_name_str = "#{base_name}(#{type_args.join(", ")})"
            class_name_str = substitute_type_params_in_type_name(class_name_str)

            if base_name == "Proc"
              proc_return_type_name = class_name_str
              class_name_str = "Proc"
            else
              # Monomorphize generic class if not already done
              if !@monomorphized.includes?(class_name_str)
                monomorphize_generic_class(base_name, type_args, class_name_str)
              end
            end
          end
        elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::CallNode)
          if type_name = stringify_type_expr(obj_expr)
            type_name = substitute_type_params_in_type_name(type_name)
            if type_name[0]?.try(&.uppercase?) || type_name.includes?("::")
              if info = split_generic_base_and_args(type_name)
                base_name = resolve_type_alias_chain(info[:base])
                type_args = split_generic_type_args(info[:args]).map do |arg|
                  arg = substitute_type_params_in_type_name(arg)
                  normalize_tuple_literal_type_name(arg)
                end
                class_name_str = "#{base_name}(#{type_args.join(", ")})"
                if base_name == "Proc"
                  proc_return_type_name = class_name_str
                  class_name_str = "Proc"
                else
                  if !@monomorphized.includes?(class_name_str)
                    monomorphize_generic_class(base_name, type_args, class_name_str)
                  end
                end
              else
                class_name_str = resolve_type_alias_chain(type_name)
              end
            end
          end
        elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::PathNode)
          # Path like Foo::Bar for nested classes/modules
          raw_path = collect_path_string(obj_node)
          absolute_path = path_is_absolute?(obj_node)
          full_path = if absolute_path
                        raw_path.starts_with?("::") ? raw_path[2..] : raw_path
                      else
                        resolve_path_string_in_context(raw_path)
                      end
          if constant_name_exists?(full_path)
            if @module.is_lib?(full_path)
              class_name_str = full_path
            else
              constant_receiver = true
            end
          else
            # Check if this path is a known class
            if @class_info.has_key?(full_path)
              class_name_str = full_path
            elsif @type_aliases.has_key?(full_path) || LIBC_TYPE_ALIASES.has_key?(full_path)
              # Resolve type alias with chain resolution
              resolved = @type_aliases[full_path]? || LIBC_TYPE_ALIASES[full_path]? || full_path
              # Chain resolve if needed (e.g., LibCrypto::ULong -> LibC::ULong -> UInt64) - max 10 iterations
              depth = 0
              while (next_resolved = @type_aliases[resolved]? || LIBC_TYPE_ALIASES[resolved]?) && next_resolved != resolved && depth < 10
                resolved = next_resolved
                depth += 1
              end
              class_name_str = resolved
            else
              # Even if not in class_info, treat path as class name for class method calls
              # This handles nested classes/modules that may not be fully registered
              class_name_str = full_path
            end
          end
        end

        if class_name_str.nil? && !constant_receiver
          if type_name = stringify_type_expr(obj_expr)
            type_name = substitute_type_params_in_type_name(type_name)
            if type_name[0]?.try(&.uppercase?) || type_name.includes?("::")
              if info = split_generic_base_and_args(type_name)
                base_name = resolve_type_alias_chain(info[:base])
                type_args = split_generic_type_args(info[:args]).map do |arg|
                  arg = substitute_type_params_in_type_name(arg)
                  normalize_tuple_literal_type_name(arg)
                end
                class_name_str = "#{base_name}(#{type_args.join(", ")})"
                if base_name == "Proc"
                  proc_return_type_name = class_name_str
                  class_name_str = "Proc"
                else
                  if !@monomorphized.includes?(class_name_str)
                    monomorphize_generic_class(base_name, type_args, class_name_str)
                  end
                end
              else
                class_name_str = resolve_type_alias_chain(type_name)
              end
            end
          end
        end

        if class_name_str.nil?
          receiver_id = lower_expr(ctx, callee_node.object)
          receiver_type = ctx.type_of(receiver_id)
          if receiver_type.id >= TypeRef::FIRST_USER_TYPE
            if value = ctx.value_for(receiver_id)
              if value.is_a?(Literal) && value.value.is_a?(Nil)
                type_name = get_type_name_from_ref(receiver_type)
                class_name_str = resolve_type_alias_chain(type_name) unless type_name.empty?
              end
            end
          end
        end

        if class_name_str
          if DebugHooks::ENABLED && unresolved_generic_receiver?(class_name_str)
            debug_hook(
              "call.class_receiver.unresolved",
              "owner=#{class_name_str} method=#{method_name} current=#{@current_class || ""} current_method=#{@current_method || ""} class_method=#{@current_method_is_class} map=#{type_param_map_debug_string}"
            )
          end
          # Intrinsics.* macros lower to LibIntrinsics.* extern calls. In codegen
          # we bypass macro expansion and rewrite the target here to avoid missing symbols.
          if class_name_str == "Intrinsics"
            if method_name == "memcpy" || method_name == "memmove" || method_name == "memset"
              class_name_str = "LibIntrinsics"
            end
          end
          if macro_lookup = lookup_macro_entry(method_name, class_name_str)
            macro_entry, macro_key = macro_lookup
            macro_def, macro_arena = macro_entry
            return expand_macro(ctx, macro_def, macro_arena, call_args, node.named_args, block_expr, macro_key)
          end
          # Check if this is a lib function call (e.g., LibC.puts)
          extern_func = @module.get_extern_function(class_name_str, method_name)
          if ENV["DEBUG_EXTERN_CALL"]? && class_name_str == "LibUnwind"
            STDERR.puts "[EXTERN_CALL] lib=#{class_name_str} method=#{method_name} hit=#{!!extern_func}"
          end
          if extern_func
            # This is a call to an extern C function
            # Lower args and emit extern call with real C name
            has_splat = call_args.any? do |arg_expr|
              call_arena[arg_expr].is_a?(CrystalV2::Compiler::Frontend::SplatNode)
            end
            arg_ids = if has_splat
                        expand_splat_args(ctx, call_args, call_arena)
                      else
                        expand_extern_args(ctx, call_args, call_arena, extern_func)
                      end
            if ENV["DEBUG_MEM_INTRINSIC"]? && class_name_str == "LibIntrinsics"
              STDERR.puts "[MEM_INTRINSIC] extern method=#{method_name} call_args=#{call_args.size} lowered=#{arg_ids.size}"
            end
            return emit_extern_call(ctx, extern_func, arg_ids)
          end
          # Fallback for LibIntrinsics mem* when lib macro branches aren't expanded.
          if class_name_str == "LibIntrinsics"
            if method_name == "memcpy" || method_name == "memmove" || method_name == "memset"
              if ENV["DEBUG_MEM_INTRINSIC"]?
                STDERR.puts "[MEM_INTRINSIC] call method=#{method_name} args=#{call_args.size} named=#{node.named_args.try(&.size) || 0} arena=#{call_arena.class}:#{call_arena.size}"
              end
              arg_ids = expand_splat_args(ctx, call_args, call_arena)
              return emit_mem_intrinsic(ctx, method_name, arg_ids)
            end
          end
          # Class method call like Counter.new()
          if method_name == "new"
            full_method_name = "#{class_name_str}.#{method_name}"
            static_class_name = class_name_str
          else
            full_method_name = resolve_class_method_with_inheritance(class_name_str, method_name) || "#{class_name_str}.#{method_name}"
            static_class_name = full_method_name.split(".", 2)[0]? || class_name_str
          end
          receiver_id = nil  # Static call, no receiver
          if method_name == "new"
            if class_info = @class_info[class_name_str]?
              generate_allocator(class_name_str, class_info)
            end
          end
        else
          # Instance method call like c.increment()
          receiver_id ||= lower_expr(ctx, callee_node.object)
          receiver_type = ctx.type_of(receiver_id)
          if call_args.empty? && block_expr.nil? && block_pass_expr.nil?
            if predicate_id = lower_enum_predicate(ctx, receiver_id, method_name)
              return predicate_id
            end
          end
          receiver_is_module = module_type_ref?(receiver_type)
          if receiver_is_module && (obj_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode) ||
             obj_node.is_a?(CrystalV2::Compiler::Frontend::PathNode))
            ctx.mark_type_literal(receiver_id)
          end
          receiver_is_type_literal = receiver_type.id >= TypeRef::FIRST_USER_TYPE &&
                                     ctx.type_literal?(receiver_id)
          ensure_monomorphized_type(receiver_type) unless receiver_type == TypeRef::VOID
          if receiver_type.id > 0
            # Look up class name from type, then resolve method with inheritance
            @class_info.each do |name, info|
              if info.type_ref.id == receiver_type.id
                # Debug: track when short names are matched
                if ENV.has_key?("DEBUG_CLASS_MATCH") && !name.includes?("::")
                  STDERR.puts "[CLASS_MATCH] method=#{method_name}, receiver_id=#{receiver_type.id}, name=#{name}"
                end
                if receiver_is_type_literal
                  if method_name == "new"
                    full_method_name = "#{name}.#{method_name}"
                    static_class_name = name
                  else
                    full_method_name = resolve_class_method_with_inheritance(name, method_name) || "#{name}.#{method_name}"
                    static_class_name = full_method_name.split(".", 2)[0]? || name
                  end
                  receiver_id = nil
                  if method_name == "new"
                    generate_allocator(name, info)
                  end
                else
                  # Use inheritance-aware method resolution
                  full_method_name = resolve_method_with_inheritance(name, method_name)
                  full_method_name ||= "#{name}##{method_name}"
                  generate_allocator(name, info) if method_name == "new"
                end
                break
              end
            end

            # Fallback: if not found in class_info, try type descriptor name
            # This handles records, generic structs, and module types
            unless full_method_name
              if type_desc = @module.get_type_descriptor(receiver_type)
                type_name = type_desc.name
                # DEBUG: Detect type name mismatches for any type that doesn't include ::
                if ENV.has_key?("DEBUG_TYPE_RESOLVE") && !type_name.includes?("::")
                  STDERR.puts "[DEBUG_TYPE] method=#{method_name}, receiver_type_id=#{receiver_type.id}, type_name=#{type_name}"
                end
                # DEBUG: Catch specifically problematic short names
                if ENV.has_key?("DEBUG_SHORT_NAMES") &&
                   (type_name == "Seek" || type_name == "Section" || type_name == "LoadCommand" || type_name == "Sequence")
                  STDERR.puts "[SHORT_NAME_FALLBACK] type=#{type_name}, method=#{method_name}, receiver_id=#{receiver_type.id}"
                end
                unless type_name.empty?
                  if receiver_is_type_literal
                    full_method_name = "#{type_name}.#{method_name}"
                    receiver_id = nil
                    static_class_name = type_name
                    if method_name == "new"
                      if class_info = @class_info[type_name]?
                        generate_allocator(type_name, class_info)
                      end
                    end
                  elsif type_desc.kind != TypeKind::Module
                    # Try to find method with this type name
                    test_method = "#{type_name}##{method_name}"
                    if @function_types.has_key?(test_method) || has_function_base?(test_method)
                      full_method_name = test_method
                    else
                      # Even if method not registered, use type name as prefix
                      # This ensures proper symbol naming
                      full_method_name = test_method
                    end
                    if method_name == "new"
                      if class_info = @class_info[type_name]?
                        generate_allocator(type_name, class_info)
                      end
                    end
                  end
                end
              end
            end

            if receiver_is_type_literal && full_method_name && full_method_name.includes?("#")
              class_name = full_method_name.split("#", 2).first
              full_method_name = "#{class_name}.#{method_name}"
              receiver_id = nil
              static_class_name = class_name
              if method_name == "new"
                if class_info = @class_info[class_name]?
                  generate_allocator(class_name, class_info)
                end
              end
            end

            # NOTE: Avoid call-site monomorphization here: it can explode compilation time by creating many
            # specialized types reachable only through transient receiver types. Prefer monomorphization from
            # explicit annotations (see `ensure_monomorphized_type`) and constructor calls.
          end
        end

      else
        # Complex callee (e.g., another call result being called)
        # Lower callee as receiver and use "call" as synthetic method name
        receiver_id = lower_node(ctx, callee_node)
        method_name = "call"
      end

      # Handle named arguments by reordering them to match parameter positions
      # Also expand splat arguments (*array -> individual elements)
      has_block_call = !!block_expr || !!block_pass_expr
      if ENV["DEBUG_SPLAT_TRACE"]?
        source = @sources_by_arena[call_arena]?
        span = node.span
        snippet = nil
        if source
          start = span.start_offset
          length = span.end_offset - span.start_offset
          if length > 0 && start >= 0 && start < source.bytesize
            max_len = 120
            slice_len = length > max_len ? max_len : length
            snippet = source.byte_slice(start, slice_len).gsub(/\s+/, " ").strip
          end
        end
        inline_stack = @inline_yield_name_stack.join(" -> ")
        @last_splat_context = "func=#{ctx.function.name} method=#{method_name} class=#{@current_class || ""} inline=#{inline_stack} arena=#{call_arena.class}:#{call_arena.size} span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column} snippet=\"#{snippet || ""}\""
      end
      args = with_arena(call_arena) do
        if DebugHooks::ENABLED && block_pass_expr
          kind = CrystalV2::Compiler::Frontend.node_kind(@arena[block_pass_expr])
          debug_hook("call.block_pass", "method=#{method_name} kind=#{kind}")
        end
        has_splat = call_args.any? { |arg_id| @arena[arg_id].is_a?(CrystalV2::Compiler::Frontend::SplatNode) }
        if ENV["DEBUG_SPLAT_TRACE"]?
          kinds = call_args.map do |arg_id|
            CrystalV2::Compiler::Frontend.node_kind(@arena[arg_id]).to_s
          end
          STDERR.puts "[SPLAT_TRACE_ARGS] #{@last_splat_context || "func=#{ctx.function.name}"} args=#{kinds.join(",")}"
        end
        args_result = if named_args = node.named_args
                        reorder_named_args(ctx, call_args, named_args, method_name, full_method_name, has_block_call, call_arena)
                      elsif has_splat
                        expand_splat_args(ctx, call_args, call_arena)
                      else
                        lower_args_with_expected_types(ctx, call_args, method_name, full_method_name, has_block_call, call_arena)
                      end
        if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
          STDERR.puts "[CALL_TRACE] stage=with_arena_done method=#{method_name} args=#{args_result.size} receiver=#{!!receiver_id} full=#{full_method_name || ""}"
        end
        args_result
      end
      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=after_args method=#{method_name} args=#{args.size} receiver=#{!!receiver_id} full=#{full_method_name || ""}"
      end
      args = apply_default_args(ctx, args, method_name, full_method_name, has_block_call)
      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=after_defaults method=#{method_name} args=#{args.size} receiver=#{!!receiver_id} full=#{full_method_name || ""}"
      end
      args = pack_splat_args_for_call(ctx, args, method_name, full_method_name, has_block_call, receiver_id)
      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=after_pack method=#{method_name} args=#{args.size} receiver=#{!!receiver_id} full=#{full_method_name || ""}"
      end
      args = ensure_double_splat_arg(ctx, args, method_name, full_method_name, has_block_call, receiver_id)
      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=after_double_splat method=#{method_name} args=#{args.size} receiver=#{!!receiver_id} full=#{full_method_name || ""}"
      end

      if static_class_name && method_name == "new"
        if enum_name = resolve_enum_name(static_class_name)
          enum_type = enum_base_type(enum_name)
          if args.size == 1
            value_id = args.first
            value_type = ctx.type_of(value_id)
            if value_type != enum_type
              cast = Cast.new(ctx.next_id, enum_type, value_id, enum_type, safe: false)
              ctx.emit(cast)
              ctx.register_type(cast.id, enum_type)
              (@enum_value_types ||= {} of ValueId => String)[cast.id] = enum_name
              return cast.id
            end
            (@enum_value_types ||= {} of ValueId => String)[value_id] = enum_name
            return value_id
          end
        end
      end

      # Special handling for Tuple#size - return compile-time constant based on type parameters
      if method_name == "size" && receiver_id && args.empty?
        if type_desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
          tuple_size = tuple_size_from_type_name(type_desc.name)
          if tuple_size.nil?
            base_name = type_desc.name.split("(").first
            tuple_size = type_desc.type_params.size if base_name == "Tuple" && !type_desc.type_params.empty?
          end
          if tuple_size
            lit = Literal.new(ctx.next_id, TypeRef::INT32, tuple_size.to_i64)
            ctx.emit(lit)
            ctx.register_type(lit.id, TypeRef::INT32)
            return lit.id
          end
        end
      end

      # Handle .times { |i| body } intrinsic BEFORE lowering block
      if method_name == "times" && receiver_id
        if blk_expr = block_expr
          blk_node = @arena[blk_expr]
          if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
            return lower_times_intrinsic(ctx, receiver_id, blk_node)
          end
        end
      end

      # Handle nil? intrinsic for union types (T | Nil)
      if method_name == "nil?" && receiver_id
        receiver_type = ctx.type_of(receiver_id)
        # Try to get declared type from local variable if receiver is a Load
        declared_type = receiver_type
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          obj = @arena[callee_node.object]
          if obj.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            var_name = String.new(obj.name)
            if local_id = ctx.lookup_local(var_name)
              local_type = ctx.type_of(local_id)
              if @module.get_type_descriptor(local_type)
                declared_type = local_type
              end
            end
          end
        end
        # Check if receiver is a union type (has variants) or nilable
        if is_union_or_nilable_type?(declared_type)
          return lower_nil_check_intrinsic(ctx, receiver_id, declared_type)
        end
        # Non-union nil? is a constant for primitives and Nil, and a pointer check for pointers.
        if declared_type == TypeRef::NIL
          lit = Literal.new(ctx.next_id, TypeRef::BOOL, true)
          ctx.emit(lit)
          return lit.id
        elsif declared_type == TypeRef::POINTER
          nil_val = Literal.new(ctx.next_id, TypeRef::POINTER, 0_i64)
          ctx.emit(nil_val)
          eq_check = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, receiver_id, nil_val.id)
          ctx.emit(eq_check)
          ctx.register_type(eq_check.id, TypeRef::BOOL)
          return eq_check.id
        else
          lit = Literal.new(ctx.next_id, TypeRef::BOOL, false)
          ctx.emit(lit)
          return lit.id
        end
      end

      # Handle not_nil! intrinsic for union types - extracts non-nil value
      if method_name == "not_nil!" && receiver_id
        receiver_type = ctx.type_of(receiver_id)
        # Try to get declared type from local variable if receiver is a Load
        declared_type = receiver_type
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          obj = @arena[callee_node.object]
          if obj.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
            var_name = String.new(obj.name)
            if local_id = ctx.lookup_local(var_name)
              local_type = ctx.type_of(local_id)
              if type_desc = @module.get_type_descriptor(local_type)
                declared_type = local_type
              end
            end
          end
        end
        if is_union_or_nilable_type?(declared_type)
          return lower_not_nil_intrinsic(ctx, receiver_id, declared_type)
        end
        if declared_type == TypeRef::VOID
          ctx.register_type(receiver_id, TypeRef::POINTER)
          return receiver_id
        end
      end

      if ENV["DEBUG_TRY_CALL"]? && method_name == "try"
        recv_type = receiver_id ? ctx.type_of(receiver_id) : TypeRef::VOID
        recv_name = receiver_id ? get_type_name_from_ref(recv_type) : "nil"
        STDERR.puts "[TRY_CALL] receiver=#{recv_name} block=#{!block_expr.nil?} block_pass=#{!block_pass_expr.nil?}"
      end

      # Handle Range#each { |i| body } and Array#each { |x| body } intrinsics
      if method_name == "each"
        # Check if callee is (range).each - MemberAccessNode on RangeNode
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          inner_obj = @arena[callee_node.object]
          # Unwrap GroupingNode: (1..3) creates GroupingNode around RangeNode
          if inner_obj.is_a?(CrystalV2::Compiler::Frontend::GroupingNode)
            inner_obj = @arena[inner_obj.expression]
          end
          if inner_obj.is_a?(CrystalV2::Compiler::Frontend::RangeNode)
            if blk_expr = block_expr
              blk_node = @arena[blk_expr]
              if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                return lower_range_each_intrinsic(ctx, inner_obj, blk_node)
              end
            end
          end
          # Array#each intrinsic - check if inner_obj is ArrayLiteralNode or identifier
          if inner_obj.is_a?(CrystalV2::Compiler::Frontend::ArrayLiteralNode)
            if blk_expr = block_expr
              blk_node = @arena[blk_expr]
              if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                # Lower array first, then call array_each
                array_id = lower_array_literal(ctx, inner_obj)
                return lower_array_each_intrinsic(ctx, array_id, inner_obj.elements.size, blk_node)
              end
            end
          end
        end
        # arr.each where arr is a variable (receiver_id set)
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                # For arrays, use dynamic size via ArraySize.
                return lower_array_each_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Handle Array#each_with_index { |elem, idx| ... } intrinsic
      if method_name == "each_with_index"
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                return lower_array_each_with_index_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Handle Array#map { |x| expr } intrinsic
      if method_name == "map"
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          inner_obj = @arena[callee_node.object]
          # Array literal: [1, 2, 3].map { |x| x * 2 }
          if inner_obj.is_a?(CrystalV2::Compiler::Frontend::ArrayLiteralNode)
            if blk_expr = block_expr
              blk_node = @arena[blk_expr]
              if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                array_id = lower_array_literal(ctx, inner_obj)
                return lower_array_map_intrinsic(ctx, array_id, inner_obj.elements.size, blk_node)
              end
            end
          end
        end
        # arr.map where arr is a variable (receiver_id set)
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                return lower_array_map_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Handle Array#select { |x| condition } intrinsic
      if method_name == "select"
        if callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
          inner_obj = @arena[callee_node.object]
          # Array literal: [1, 2, 3].select { |x| x > 1 }
          if inner_obj.is_a?(CrystalV2::Compiler::Frontend::ArrayLiteralNode)
            if blk_expr = block_expr
              blk_node = @arena[blk_expr]
              if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                # Pass element expressions for compile-time predicate evaluation
                return lower_array_select_intrinsic_with_ast(ctx, inner_obj, blk_node)
              end
            end
          end
        end
        # arr.select where arr is a variable (receiver_id set)
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                return lower_array_select_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Fallback: treat bare unsafe_* calls inside numeric primitives as self-calls.
      if receiver_id.nil? && (current_class = @current_class) && numeric_primitive_class_name?(current_class)
        if method_name == "unsafe_div" || method_name == "unsafe_mod" ||
           method_name == "unsafe_shl" || method_name == "unsafe_shr"
          receiver_id = emit_self(ctx)
          full_method_name = "#{current_class}##{method_name}"
        end
      end

      # Handle Array#reduce { |acc, elem| ... } intrinsic
      if method_name == "reduce"
        if receiver_id
          if blk_expr = block_expr
            blk_node = @arena[blk_expr]
            if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
              if array_intrinsic_receiver?(ctx, receiver_id)
                return lower_array_reduce_dynamic(ctx, receiver_id, blk_node)
              end
            end
          end
        end
      end

      # Collect argument types for name mangling (overloading support)
      arg_types = args.map { |arg_id| ctx.type_of(arg_id) }
      arg_literals = args.map { |arg_id| ctx.type_literal?(arg_id) }
      if receiver_id && method_name.ends_with?("=") && args.size == 1 &&
         arg_types.all? { |t| t == TypeRef::VOID }
        if inferred = ivar_type_for_setter(ctx, receiver_id, method_name)
          arg_types = [inferred]
        end
      end
      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        type_ids = arg_types.map(&.id)
        STDERR.puts "[CALL_TRACE] stage=after_arg_types method=#{method_name} arg_types=#{type_ids.join(",")}"
      end

      # Compute mangled name based on base name + argument types
      # If no explicit receiver and we're inside a class, try class#method first
      if ENV.has_key?("DEBUG_BASE_METHOD") && method_name == "byte_range"
        STDERR.puts "[BASE_METHOD] method=#{method_name} full_method_name=#{full_method_name || "nil"} receiver_id=#{receiver_id.nil? ? "nil" : receiver_id.to_s} @current_class=#{@current_class || "nil"}"
      end
      base_method_name = if full_method_name
                           full_method_name
                         elsif receiver_id.nil? && (current = @current_class)
                           # Bare calls inside a class/module resolve to self.<method> only
                           # when that method exists; otherwise fall back to top-level.
                           sep = @current_method_is_class ? "." : "#"
                           candidate = "#{current}#{sep}#{method_name}"
                           if @function_types.has_key?(candidate) || has_function_base?(candidate)
                             candidate
                           else
                             # Check if method exists in included modules
                             included_candidate : String? = nil
                             if modules = @class_included_modules[current]?
                               if ENV.has_key?("DEBUG_INCLUDED_BASE") && method_name == "byte_range"
                                 STDERR.puts "[INCLUDED_BASE] class=#{current} modules=#{modules.to_a.join(",")}"
                               end
                               modules.each do |mod_name|
                                 mod_candidate = "#{mod_name}##{method_name}"
                                 if @function_types.has_key?(mod_candidate) || has_function_base?(mod_candidate)
                                   included_candidate = mod_candidate
                                   break
                                 end
                               end
                             elsif ENV.has_key?("DEBUG_INCLUDED_BASE") && method_name == "byte_range"
                               STDERR.puts "[INCLUDED_BASE] class=#{current} NO_MODULES"
                             end
                             included_candidate || method_name
                           end
                         else
                           method_name
                         end
      base_method_name = rewrite_event_loop_method_name(base_method_name)
      if receiver_id.nil? && full_method_name.nil? && method_name == "main" && @top_level_main_defined
        base_method_name = TOP_LEVEL_MAIN_BASE
      end

      # Refine VOID arg types by looking at overload parameter annotations
      arg_types = refine_void_args_from_overloads(base_method_name, arg_types)

      if receiver_id.nil? && method_name == "new"
        target_name = full_method_name || base_method_name
        if target_name == "Pointer.new" || target_name.starts_with?("Pointer(")
          if lowered = lower_pointer_new_intrinsic(ctx, args)
            return lowered
          end
        end
      end
      mangled_method_name = mangle_function_name(base_method_name, arg_types)
      if has_block_call
        mangled_with_block = mangle_function_name(base_method_name, arg_types, true)
        if @function_types.has_key?(mangled_with_block) || @yield_functions.includes?(mangled_with_block) || @module.has_function?(mangled_with_block)
          mangled_method_name = mangled_with_block
        end
      end

      if receiver_id && base_method_name.includes?("|") && base_method_name.includes?("#")
        union_name = base_method_name.split("#", 2)[0]
        if resolved = resolve_union_method_call(union_name, method_name, arg_types)
          if resolved.includes?("$")
            mangled_method_name = resolved
            base_method_name = resolved.split("$", 2)[0]
          else
            base_method_name = resolved
            mangled_method_name = mangle_function_name(base_method_name, arg_types, has_block_call)
          end
        end
      end

      lookup_name = full_method_name || base_method_name
      if entry = lookup_function_def_for_call(lookup_name, args.size, has_block_call, arg_types)
        entry_name = entry[0]
        entry_def = entry[1]
        base_method_name = entry_name.split("$").first
        if entry_name.includes?("$")
          mangled_method_name = entry_name
        elsif !arg_types.empty?
          untyped_params = true
          if params = entry_def.params
            params.each do |param|
              next if param.is_block || named_only_separator?(param)
              if param.is_double_splat
                untyped_params = false
                break
              end
              if ta = param.type_annotation
                type_name = String.new(ta)
                if !type_param_like?(type_name) || @type_param_map.has_key?(type_name)
                  untyped_params = false
                  break
                end
              end
            end
          end
          mangled_method_name = untyped_params ? entry_name : mangle_function_name(entry_name, arg_types, has_block_call)
        else
          mangled_method_name = entry_name
        end
      end
      if receiver_id
        # Preserve a callsite-mangled overload (typed args) to avoid collapsing
        # into base names like `IO#puts` that hide typed overloads.
        unless mangled_method_name.includes?("$")
          resolved_name = resolve_method_call(ctx, receiver_id, method_name, arg_types)
          if resolved_name != mangled_method_name &&
             (resolved_name.includes?("$") || @function_types.has_key?(resolved_name) || @module.has_function?(resolved_name))
            mangled_method_name = resolved_name
            base_method_name = resolved_name.split("$").first
          end
        end

        # When argument types are unknown (all VOID), try to select a single
        # overload by arity to avoid falling back to an unmangled base name.
        if !mangled_method_name.includes?("$") &&
           arg_types.all? { |t| t == TypeRef::VOID } &&
           node.named_args.nil? &&
           !node.args.any? { |arg_id| @arena[arg_id].is_a?(CrystalV2::Compiler::Frontend::SplatNode) }
          if resolved_untyped = resolve_untyped_overload(base_method_name, args.size, has_block_call)
            mangled_method_name = resolved_untyped
            base_method_name = resolved_untyped.split("$").first
          end
        end
      end
      if method_name == "new" && full_method_name
        if class_name = full_method_name.split(".", 2).first?
          if class_info = @class_info[class_name]?
            generate_allocator(class_name, class_info)
          end
        end
        explicit_new = !!lookup_function_def_for_call(full_method_name, args.size, has_block_call, arg_types)
        if !explicit_new && @module.has_function?(full_method_name) && !@module.has_function?(mangled_method_name)
          mangled_method_name = full_method_name
          base_method_name = full_method_name
        end
      end

      if receiver_id && full_method_name.nil? && callee_node.is_a?(CrystalV2::Compiler::Frontend::MemberAccessNode)
        receiver_type = ctx.type_of(receiver_id)
          if type_desc = @module.get_type_descriptor(receiver_type)
            # LOWER_CALL_DEBUG disabled
            if type_desc.kind == TypeKind::Module || module_like_type_name?(type_desc.name)
              # Try to get module type name from AST, fall back to type_desc.name
              # This handles cases where the receiver is a call result (e.g., event_loop().write())
              module_type_name = module_receiver_type_name(callee_node) || type_desc.name
            if resolved = resolve_module_typed_method(method_name, arg_types, module_type_name, has_block_call, @current_class)
              mangled_method_name = resolved
              base_method_name = resolved.split("$").first
            end
          end
        end
      end
      if arg_types.any? { |t| t != TypeRef::VOID }
        desired_mangled = mangle_function_name(base_method_name, arg_types, has_block_call)
        if desired_mangled != mangled_method_name &&
           (@function_types.has_key?(desired_mangled) || @function_defs.has_key?(desired_mangled) || @module.has_function?(desired_mangled))
          mangled_method_name = desired_mangled
        end
      end
      primary_mangled_name = mangled_method_name
      receiver_name = ""
      if receiver_id
        if desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
          receiver_name = desc.name
        end
      end
      arg_names = arg_types.map { |t| type_name_for_mangling(t) }
      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=after_resolve method=#{method_name} base=#{base_method_name} mangled=#{mangled_method_name}"
      end
      debug_hook("call.resolve", "method=#{method_name} base=#{base_method_name} mangled=#{mangled_method_name} receiver=#{receiver_name} args=#{arg_names} current=#{@current_class || ""}")
      if ENV["DEBUG_PUTS_CALLS"]? && method_name == "puts"
        STDERR.puts "[DEBUG_PUTS_CALL] base=#{base_method_name} mangled=#{mangled_method_name} args=#{arg_names.join(",")}"
      end

      if receiver_id.nil? && method_name == "new" && args.size == 1
        if mangled_method_name.starts_with?("Pointer_") && mangled_method_name.ends_with?("__new")
          if lowered = lower_pointer_new_intrinsic(ctx, args)
            return lowered
          end
        end
      end

      # Handle yield-functions with inline expansion FIRST (before lowering block)
      # Must check with mangled name since that's how yield functions are registered.
      block_for_inline : CrystalV2::Compiler::Frontend::BlockNode? = nil
      proc_for_inline : CrystalV2::Compiler::Frontend::ProcLiteralNode? = nil
      if block_expr
        blk_node = @arena[block_expr]
        if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
          block_for_inline = blk_node
        elsif blk_node.is_a?(CrystalV2::Compiler::Frontend::ProcLiteralNode)
          proc_for_inline = blk_node
        end
      elsif block_pass_expr
        block_param_types = block_param_types_for_call(mangled_method_name, base_method_name, receiver_id ? ctx.type_of(receiver_id) : nil)
        if method_name == "try" && receiver_id
          if non_nil = non_nil_type_for_union(ctx.type_of(receiver_id))
            block_param_types = [non_nil]
          elsif block_param_types.nil?
            block_param_types = [ctx.type_of(receiver_id)]
          end
        end
        block_for_inline = build_block_from_block_pass(block_pass_expr, block_param_types, node.span)
      end

      if block_for_inline || proc_for_inline
        if block_for_inline
          @block_node_arenas[block_for_inline.object_id] = @arena
        end
          if ENV["DEBUG_YIELD_TRACE"]? && (method_name == "char_at" || method_name == "fetch" || method_name == "upto" ||
              method_name == "byte_range" ||
              base_method_name.includes?("char_at") || base_method_name.includes?("fetch") || base_method_name.includes?("upto") ||
              mangled_method_name.includes?("char_at") || mangled_method_name.includes?("fetch") || mangled_method_name.includes?("upto"))
            STDERR.puts "[YIELD_TRACE] method=#{method_name} base=#{base_method_name} mangled=#{mangled_method_name} in_set=#{@yield_functions.includes?(mangled_method_name)} block=#{!!block_for_inline} current=#{@current_class || ""}"
          end
          # For Object#tap, inline directly when we have a receiver
          # tap yields self to the block then returns self
          if receiver_id && method_name == "tap"
            if block_for_inline
              return inline_tap_with_block(ctx, receiver_id, block_for_inline)
            elsif proc_for_inline
              return inline_tap_with_proc(ctx, receiver_id, proc_for_inline)
            end
          end
          if receiver_id && method_name == "try"
            recv_type = ctx.type_of(receiver_id)
            if is_union_or_nilable_type?(recv_type)
              if block_for_inline
                return inline_try_with_block(ctx, receiver_id, recv_type, block_for_inline)
              elsif proc_for_inline
                return inline_try_with_proc(ctx, receiver_id, recv_type, proc_for_inline)
              end
            end
          end

          if block_for_inline
            block_cast = block_for_inline
            call_args = args

            skip_inline = false
            if type_param_name = block_return_type_param_name(mangled_method_name, base_method_name)
              receiver_map = type_param_map_for_receiver_name(base_method_name)
              unless @type_param_map.has_key?(type_param_name) || receiver_map.has_key?(type_param_name)
                debug_hook("call.inline.skip", "callee=#{mangled_method_name} missing=#{type_param_name}")
                skip_inline = true
              end
            end
            if !skip_inline && method_name == "try" && receiver_id
              recv_type = ctx.type_of(receiver_id)
              if ENV["DEBUG_TRY_INLINE"]?
                STDERR.puts "[TRY_INLINE] recv_type=#{get_type_name_from_ref(recv_type)} union=#{is_union_or_nilable_type?(recv_type)}"
              end
              # Avoid inlining try on unions so nil variants can short-circuit in dispatch.
              if is_union_or_nilable_type?(recv_type)
                skip_inline = true
              end
            end

            # Check if this is a call to a yield-function using mangled name
            if !skip_inline && @yield_functions.includes?(mangled_method_name)
              if func_def = @function_defs[mangled_method_name]?
                debug_hook("call.inline.yield", "callee=#{mangled_method_name} current=#{@current_class || ""}")
                callee_arena = @function_def_arenas[mangled_method_name]? || @arena
                return inline_yield_function(ctx, func_def, mangled_method_name, receiver_id, call_args, block_cast, callee_arena)
              end
            end
            # Also try base method name (for functions without overloading)
            if !skip_inline && @yield_functions.includes?(base_method_name)
              if func_def = @function_defs[base_method_name]?
                debug_hook("call.inline.yield", "callee=#{base_method_name} current=#{@current_class || ""}")
                callee_arena = @function_def_arenas[base_method_name]? || @arena
                return inline_yield_function(ctx, func_def, base_method_name, receiver_id, call_args, block_cast, callee_arena)
              end
            end

            # Fallback: resolve the def node by arity/signature and inline if it yields,
            # even if @yield_functions didn't capture the mangled name.
            if !skip_inline && (entry = lookup_block_function_def_for_call(base_method_name, call_args.size, arg_types))
              yield_name, yield_def = entry
              callee_arena = @function_def_arenas[yield_name]? || @arena
              if def_contains_yield?(yield_def, callee_arena)
                @yield_functions.add(yield_name)
                debug_hook("call.inline.yield", "callee=#{yield_name} current=#{@current_class || ""}")
                return inline_yield_function(ctx, yield_def, yield_name, receiver_id, call_args, block_cast, callee_arena)
              end
            end

            # Fallback: try to find yield method by name + arity.
            # This handles inherited methods like Object#tap called on any class.
            # Example: `fd.tap { |x| x.something }` where tap is defined in Object.
            if !skip_inline && receiver_id
              if yield_key = find_yield_method_fallback(method_name, call_args.size)
                if func_def = @function_defs[yield_key]?
                  debug_hook("call.inline.yield", "callee=#{yield_key} current=#{@current_class || ""}")
                  callee_arena = @function_def_arenas[yield_key]? || @arena
                  return inline_yield_function(ctx, func_def, yield_key, receiver_id, call_args, block_cast, callee_arena)
                end
              end
            end
        end
      end

      # Handle String.build { |io| ... } intrinsic
      # This is a common pattern that builds a string using an IO-like builder
      if full_method_name == "String.build"
        if blk_expr = block_expr
          blk_node = @arena[blk_expr]
          if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
            return lower_string_build_intrinsic(ctx, blk_node, args.first?)
          end
        end
      end

      # Check for block (ExprId -> must lower to BlockNode) - for non-inline calls only
      # This is after yield function check so we don't emit dead block code
      block_id = if block_expr
                   blk_node = @arena[block_expr]
                   if blk_node.is_a?(CrystalV2::Compiler::Frontend::BlockNode)
                     block_param_types = block_param_types_for_call(mangled_method_name, base_method_name, receiver_id ? ctx.type_of(receiver_id) : nil)
                     if method_name == "try" && receiver_id
                       if non_nil = non_nil_type_for_union(ctx.type_of(receiver_id))
                         block_param_types = [non_nil]
                       elsif block_param_types.nil?
                         block_param_types = [ctx.type_of(receiver_id)]
                       end
                     end
                     if DebugHooks::ENABLED && method_name == "map"
                       types_str = block_param_types ? block_param_types.map { |t| get_type_name_from_ref(t) }.join(",") : ""
                       debug_hook("block.param.result", "method=#{base_method_name} mangled=#{mangled_method_name} types=#{types_str}")
                     end
                     lower_block_to_block_id(ctx, blk_node, block_param_types)
                   else
                     # Block is some other expression - should not happen in well-formed AST
                     nil
                   end
                 elsif block_pass_expr
                   block_param_types = block_param_types_for_call(mangled_method_name, base_method_name, receiver_id ? ctx.type_of(receiver_id) : nil)
                   if method_name == "try" && receiver_id
                     if non_nil = non_nil_type_for_union(ctx.type_of(receiver_id))
                       block_param_types = [non_nil]
                     elsif block_param_types.nil?
                       block_param_types = [ctx.type_of(receiver_id)]
                     end
                   end
                   lower_block_pass_proc(ctx, block_pass_expr, block_param_types)
                 else
                   nil
                 end

      # Try to infer return type using mangled name first, fallback to base name
      # For non-overloaded functions, prefer base name since that's how they're registered in HIR module
      return_type = get_function_return_type(mangled_method_name)

      has_typed_args = arg_types.any? { |t| t != TypeRef::VOID }
      base_signature_exists = @function_types.has_key?(base_method_name)
      if base_signature_exists && !@function_types.has_key?(mangled_method_name) && mangled_method_name != base_method_name
        return_type = get_function_return_type(base_method_name)
        mangled_method_name = base_method_name unless has_typed_args
      end

      # Check if function exists in module by base name (for unqualified functions).
      base_func_exists = @module.functions.any? { |f| f.name == base_method_name }

      if base_func_exists && !base_method_name.includes?("#") && !base_method_name.includes?(".") && !has_typed_args
        # Function exists with base name - use that (no mangling needed for simple functions)
        return_type = get_function_return_type(base_method_name) if return_type == TypeRef::VOID
        mangled_method_name = base_method_name
      elsif return_type == TypeRef::VOID && mangled_method_name != base_method_name &&
            !base_method_name.includes?("#") && !base_method_name.includes?(".") && !has_typed_args
        # Try unmangled name as fallback for unqualified functions.
        return_type = get_function_return_type(base_method_name)
        if return_type != TypeRef::VOID
          mangled_method_name = base_method_name
        end
      end

      block_return_name = nil
      if block_id
        block_return_name = block_return_type_name(ctx, block_id)
        if block_return_name
          if type_param_name = block_return_type_param_name(mangled_method_name, base_method_name)
            record_pending_type_param_map(mangled_method_name, {type_param_name => block_return_name})
          end
          if inferred = resolve_block_dependent_return_type(mangled_method_name, base_method_name, block_return_name)
            return_type = inferred
          end
        end
      end

      if block_id && method_name == "try" && block_return_name
        inferred = type_ref_for_name(block_return_name)
        if receiver_id && is_union_or_nilable_type?(ctx.type_of(receiver_id))
          inferred = create_union_type_for_nullable(inferred)
        end
        return_type = inferred if inferred != TypeRef::VOID
      end

      if block_id && block_return_name
        if yield_return_function_for_call(mangled_method_name, base_method_name)
          inferred = type_ref_for_name(block_return_name)
          return_type = inferred if inferred != TypeRef::VOID
        end
      end

      if proc_return_type_name && method_name == "new"
        if proc_ref = proc_type_ref_for_name(proc_return_type_name.not_nil!)
          return_type = proc_ref
        end
      end

      if receiver_id
        if tuple_return = tuple_return_type_for_method(ctx.type_of(receiver_id), method_name)
          return_type = tuple_return
        end
      end

      # If still not found and receiver_id is set, try to find method in any class.
      # NOTE: Only do this when we couldn't resolve the receiver class; otherwise it can
      # incorrectly bind to a different specialization (e.g., Hash(Int32, Bool)#[]?).
      if return_type == TypeRef::VOID && receiver_id && full_method_name.nil?
        receiver_type = ctx.type_of(receiver_id)
        type_desc = @module.get_type_descriptor(receiver_type)
        if receiver_type == TypeRef::VOID || type_desc.nil?
          @class_info.each do |class_name, info|
            test_base = "#{class_name}##{method_name}"
            test_mangled = mangle_function_name(test_base, arg_types)
            if type = @function_types[test_mangled]?
              return_type = type
              mangled_method_name = test_mangled
              break
            elsif type = @function_types[test_base]?
              return_type = type
              mangled_method_name = test_base
              break
            end
          end
        end
      end

      # Ensure synthetic accessors exist for direct ivar access.
      if return_type == TypeRef::VOID && receiver_id
        if accessor = ensure_accessor_method(ctx, receiver_id, method_name)
          return_type = accessor[0]
          mangled_method_name = accessor[1]
        end
      end

      # Check for primitive binary operator inlining
      # When calling methods like Int32#+ on primitive types, emit BinaryOperation instead of Call
      if receiver_id && args.size == 1
        receiver_type = ctx.type_of(receiver_id)
        if numeric_primitive?(receiver_type)
          if bin_op = binary_op_for_method(method_name)
            # Emit native binary operation instead of method call
            # Return type is same as receiver type for arithmetic, bool for comparisons
            result_type = case bin_op
                          when BinaryOp::Eq, BinaryOp::Ne, BinaryOp::Lt, BinaryOp::Le,
                               BinaryOp::Gt, BinaryOp::Ge, BinaryOp::And, BinaryOp::Or
                            TypeRef::BOOL
                          else
                            receiver_type
                          end
            bin_node = BinaryOperation.new(ctx.next_id, result_type, bin_op, receiver_id, args[0])
            ctx.emit(bin_node)
            return bin_node.id
          end
        end
      end

      if receiver_id && method_name == "ord" && args.empty?
        receiver_type = ctx.type_of(receiver_id)
        if receiver_type == TypeRef::CHAR
          cast = Cast.new(ctx.next_id, TypeRef::INT32, receiver_id, TypeRef::INT32)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT32)
          return cast.id
        end
      end

      if receiver_id && method_name == "unsafe_chr" && args.empty?
        receiver_type = ctx.type_of(receiver_id)
        if is_union_or_nilable_type?(receiver_type)
          nil_variant_id = get_union_variant_id(receiver_type, TypeRef::NIL)
          if nil_variant_id >= 0
            unwrapped = lower_not_nil_intrinsic(ctx, receiver_id, receiver_type)
            unwrapped_type = ctx.type_of(unwrapped)
            if numeric_primitive?(unwrapped_type)
              cast = Cast.new(ctx.next_id, TypeRef::CHAR, unwrapped, TypeRef::CHAR)
              ctx.emit(cast)
              ctx.register_type(cast.id, TypeRef::CHAR)
              return cast.id
            end
          elsif type_desc = @module.get_type_descriptor(receiver_type)
            variants = split_union_type_name(type_desc.name)
            idx = variants.index do |variant|
              next false if variant == "Nil"
              numeric_primitive?(type_ref_for_name(variant))
            end
            if idx
              unwrap_type = type_ref_for_name(variants[idx])
              unwrapped = UnionUnwrap.new(ctx.next_id, unwrap_type, receiver_id, idx, false)
              ctx.emit(unwrapped)
              ctx.register_type(unwrapped.id, unwrap_type)
              if numeric_primitive?(unwrap_type)
                cast = Cast.new(ctx.next_id, TypeRef::CHAR, unwrapped.id, TypeRef::CHAR)
                ctx.emit(cast)
                ctx.register_type(cast.id, TypeRef::CHAR)
                return cast.id
              end
            end
          end
        end
        case receiver_type
        when TypeRef::INT8, TypeRef::INT16, TypeRef::INT32, TypeRef::INT64, TypeRef::INT128,
             TypeRef::UINT8, TypeRef::UINT16, TypeRef::UINT32, TypeRef::UINT64, TypeRef::UINT128
          cast = Cast.new(ctx.next_id, TypeRef::CHAR, receiver_id, TypeRef::CHAR)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::CHAR)
          return cast.id
        end
      end

      # Primitive numeric conversions (to_i*, to_u*, to_f*).
      if receiver_id && args.empty?
        receiver_type = ctx.type_of(receiver_id)
        target_type = case method_name
                      when "to_i", "to_i32", "to_i32!"
                        TypeRef::INT32
                      when "to_i8", "to_i8!"
                        TypeRef::INT8
                      when "to_i16", "to_i16!"
                        TypeRef::INT16
                      when "to_i64", "to_i64!"
                        TypeRef::INT64
                      when "to_i128", "to_i128!"
                        TypeRef::INT128
                      when "to_u", "to_u32", "to_u32!"
                        TypeRef::UINT32
                      when "to_u8", "to_u8!"
                        TypeRef::UINT8
                      when "to_u16", "to_u16!"
                        TypeRef::UINT16
                      when "to_u64", "to_u64!"
                        TypeRef::UINT64
                      when "to_u128", "to_u128!"
                        TypeRef::UINT128
                      when "to_f", "to_f64", "to_f64!"
                        TypeRef::FLOAT64
                      when "to_f32", "to_f32!"
                        TypeRef::FLOAT32
                      else
                        nil
                      end
        if target_type
          if receiver_type == TypeRef::VOID
            # Treat unknown receivers as target type to avoid invalid pointer casts.
            # Call-site coercion will handle the actual conversion when needed.
            ctx.register_type(receiver_id, target_type)
            return receiver_id
          end
          if numeric_primitive?(receiver_type)
            return receiver_id if receiver_type == target_type
            cast = Cast.new(ctx.next_id, target_type, receiver_id, target_type)
            ctx.emit(cast)
            ctx.register_type(cast.id, target_type)
            return cast.id
          end
        end
      end

      # Primitive numeric predicates and shifts.
      if receiver_id && numeric_primitive?(ctx.type_of(receiver_id))
        receiver_type = ctx.type_of(receiver_id)
        if method_name == "zero?" && args.empty?
          zero = Literal.new(ctx.next_id, receiver_type, 0_i64)
          ctx.emit(zero)
          ctx.register_type(zero.id, receiver_type)
          cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, receiver_id, zero.id)
          ctx.emit(cmp)
          ctx.register_type(cmp.id, TypeRef::BOOL)
          return cmp.id
        end
        if receiver_type == TypeRef::UINT8 && method_name == "ascii?" && args.empty?
          limit = Literal.new(ctx.next_id, TypeRef::UINT8, 128_i64)
          ctx.emit(limit)
          ctx.register_type(limit.id, TypeRef::UINT8)
          cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, receiver_id, limit.id)
          ctx.emit(cmp)
          ctx.register_type(cmp.id, TypeRef::BOOL)
          return cmp.id
        end
        if receiver_type == TypeRef::UINT8 && method_name == "ord" && args.empty?
          cast = Cast.new(ctx.next_id, TypeRef::INT32, receiver_id, TypeRef::INT32)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT32)
          return cast.id
        end
        if (method_name == "unsafe_shl" || method_name == "unsafe_shr") && args.size == 1
          op = method_name == "unsafe_shl" ? BinaryOp::Shl : BinaryOp::Shr
          shift = BinaryOperation.new(ctx.next_id, receiver_type, op, receiver_id, args[0])
          ctx.emit(shift)
          ctx.register_type(shift.id, receiver_type)
          return shift.id
        end
        if method_name == "unsafe_div" && args.size == 1
          div = BinaryOperation.new(ctx.next_id, receiver_type, BinaryOp::Div, receiver_id, args[0])
          ctx.emit(div)
          ctx.register_type(div.id, receiver_type)
          return div.id
        end
        if method_name == "unsafe_mod" && args.size == 1
          rem = BinaryOperation.new(ctx.next_id, receiver_type, BinaryOp::Mod, receiver_id, args[0])
          ctx.emit(rem)
          ctx.register_type(rem.id, receiver_type)
          return rem.id
        end
      end

      # Pointer address conversions.
      if receiver_id && args.empty?
        receiver_type = ctx.type_of(receiver_id)
        recv_type_desc = @module.get_type_descriptor(receiver_type)
        is_pointer_type = receiver_type == TypeRef::POINTER ||
                          (recv_type_desc && recv_type_desc.name.starts_with?("Pointer"))
        if is_pointer_type
          case method_name
          when "address", "to_u64"
            cast = Cast.new(ctx.next_id, TypeRef::UINT64, receiver_id, TypeRef::UINT64)
            ctx.emit(cast)
            ctx.register_type(cast.id, TypeRef::UINT64)
            return cast.id
          when "to_i", "to_i64"
            cast = Cast.new(ctx.next_id, TypeRef::INT64, receiver_id, TypeRef::INT64)
            ctx.emit(cast)
            ctx.register_type(cast.id, TypeRef::INT64)
            return cast.id
          when "to_f64"
            int_cast = Cast.new(ctx.next_id, TypeRef::UINT64, receiver_id, TypeRef::UINT64)
            ctx.emit(int_cast)
            ctx.register_type(int_cast.id, TypeRef::UINT64)
            float_cast = Cast.new(ctx.next_id, TypeRef::FLOAT64, int_cast.id, TypeRef::FLOAT64)
            ctx.emit(float_cast)
            ctx.register_type(float_cast.id, TypeRef::FLOAT64)
            return float_cast.id
          end
        end
      end

      # Check for pointer primitive operations
      # Pointer(T).malloc(count) -> PointerMalloc
      if full_method_name && full_method_name.starts_with?("Pointer(") && method_name == "malloc" && args.size == 1
        pointer_type_name = full_method_name.split(".", 2).first
        pointer_type_ref = type_ref_for_name(pointer_type_name)
        element_type = pointer_element_type(full_method_name)
        result_type = pointer_type_ref == TypeRef::VOID ? TypeRef::POINTER : pointer_type_ref
        malloc_node = PointerMalloc.new(ctx.next_id, result_type, element_type, args[0])
        ctx.emit(malloc_node)
        ctx.register_type(malloc_node.id, result_type)
        return malloc_node.id
      end

      if full_method_name && (full_method_name == "Pointer.new" || full_method_name.starts_with?("Pointer(")) && method_name == "new" && args.size == 1
        if lowered = lower_pointer_new_intrinsic(ctx, args)
          if full_method_name.starts_with?("Pointer(")
            pointer_type_name = full_method_name.rchop(".new")
            pointer_type_ref = type_ref_for_name(pointer_type_name)
            ctx.register_type(lowered, pointer_type_ref) unless pointer_type_ref == TypeRef::VOID
          end
          return lowered
        end
      end

      if full_method_name && full_method_name.starts_with?("Pointer(") && method_name == "null" && args.empty?
        zero = Literal.new(ctx.next_id, TypeRef::INT64, 0_i64)
        ctx.emit(zero)
        ctx.register_type(zero.id, TypeRef::INT64)
        pointer_type_name = full_method_name.rchop(".null")
        pointer_type_ref = type_ref_for_name(pointer_type_name)
        result_type = pointer_type_ref == TypeRef::VOID ? TypeRef::POINTER : pointer_type_ref
        cast = Cast.new(ctx.next_id, result_type, zero.id, result_type)
        ctx.emit(cast)
        ctx.register_type(cast.id, result_type)
        return cast.id
      end

      # ptr.value or ptr[index] -> PointerLoad
      if receiver_id && (method_name == "value" || method_name == "[]")
        receiver_type = ctx.type_of(receiver_id)
        recv_type_desc = @module.get_type_descriptor(receiver_type)
        if recv_type_desc && recv_type_desc.kind == TypeKind::Union
          if unwrapped = unwrap_pointer_union(ctx, receiver_id, receiver_type)
            receiver_id, receiver_type = unwrapped
            recv_type_desc = @module.get_type_descriptor(receiver_type)
          end
        end
        is_pointer_type = receiver_type == TypeRef::POINTER ||
                          (recv_type_desc && recv_type_desc.kind == TypeKind::Pointer)
        if ENV.has_key?("DEBUG_PTR_VALUE")
          STDERR.puts "[DEBUG_PTR_VALUE] method=#{method_name} receiver_type.id=#{receiver_type.id} desc=#{recv_type_desc.try(&.name)} is_pointer=#{is_pointer_type}"
        end
        if is_pointer_type
          index_id = if method_name == "[]" && args.size == 1
                       args[0]
                     else
                       nil
                     end
          # Return the dereferenced type from Pointer(T) -> T
          deref_type = if recv_type_desc && recv_type_desc.name.starts_with?("Pointer(") && recv_type_desc.name.ends_with?(")")
                         element_type_name = recv_type_desc.name[8...-1]
                         type_ref_for_name(element_type_name)
                       else
                         TypeRef::UINT8  # Fallback for untyped pointers
                       end
          load_node = PointerLoad.new(ctx.next_id, deref_type, receiver_id, index_id)
          ctx.emit(load_node)
          ctx.register_type(load_node.id, deref_type)
          return load_node.id
        end
      end

      # ptr.value= or ptr[index]= -> PointerStore
      if receiver_id && (method_name == "value=" || method_name == "[]=")
        receiver_type = ctx.type_of(receiver_id)
        recv_type_desc = @module.get_type_descriptor(receiver_type)
        if recv_type_desc && recv_type_desc.kind == TypeKind::Union
          if value_type = args.first?
            if unwrapped = unwrap_pointer_union(ctx, receiver_id, receiver_type, ctx.type_of(value_type))
              receiver_id, receiver_type = unwrapped
              recv_type_desc = @module.get_type_descriptor(receiver_type)
            end
          end
        end
        is_pointer_type = receiver_type == TypeRef::POINTER ||
                          (recv_type_desc && recv_type_desc.kind == TypeKind::Pointer)
        if is_pointer_type
          if method_name == "value=" && args.size == 1
            store_node = PointerStore.new(ctx.next_id, TypeRef::VOID, receiver_id, args[0], nil)
            ctx.emit(store_node)
            return store_node.id
          elsif method_name == "[]=" && args.size == 2
            store_node = PointerStore.new(ctx.next_id, TypeRef::VOID, receiver_id, args[1], args[0])
            ctx.emit(store_node)
            return store_node.id
          end
        end
      end

      # ptr + offset or ptr - offset -> PointerAdd
      if receiver_id && (method_name == "+" || method_name == "-") && args.size == 1
        receiver_type = ctx.type_of(receiver_id)
        recv_type_desc = @module.get_type_descriptor(receiver_type)
        if recv_type_desc && recv_type_desc.kind == TypeKind::Union
          if unwrapped = unwrap_pointer_union(ctx, receiver_id, receiver_type)
            receiver_id, receiver_type = unwrapped
            recv_type_desc = @module.get_type_descriptor(receiver_type)
          end
        end
        is_pointer_type = receiver_type == TypeRef::POINTER ||
                          (recv_type_desc && recv_type_desc.kind == TypeKind::Pointer)
        if is_pointer_type
          offset_id = args[0]
          # For subtraction, negate the offset
          if method_name == "-"
            neg_one = Literal.new(ctx.next_id, TypeRef::INT32, -1_i64)
            ctx.emit(neg_one)
            ctx.register_type(neg_one.id, TypeRef::INT32)
            neg_offset = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Mul, offset_id, neg_one.id)
            ctx.emit(neg_offset)
            ctx.register_type(neg_offset.id, TypeRef::INT32)
            offset_id = neg_offset.id
          end
          element_type = if recv_type_desc && recv_type_desc.name.starts_with?("Pointer(")
                           pointer_element_type(recv_type_desc.name)
                         else
                           TypeRef::INT32
                         end
          result_type = receiver_type == TypeRef::VOID ? TypeRef::POINTER : receiver_type
          add_node = PointerAdd.new(ctx.next_id, result_type, receiver_id, offset_id, element_type)
          ctx.emit(add_node)
          ctx.register_type(add_node.id, result_type)
          return add_node.id
        end
      end

      # ptr.realloc(new_count) -> PointerRealloc
      if receiver_id && method_name == "realloc" && args.size == 1
        receiver_type = ctx.type_of(receiver_id)
        recv_type_desc = @module.get_type_descriptor(receiver_type)
        is_pointer_type = receiver_type == TypeRef::POINTER ||
                          (recv_type_desc && recv_type_desc.name.starts_with?("Pointer"))
        if is_pointer_type
          result_type = receiver_type == TypeRef::VOID ? TypeRef::POINTER : receiver_type
          realloc_node = PointerRealloc.new(ctx.next_id, result_type, receiver_id, args[0])
          ctx.emit(realloc_node)
          ctx.register_type(realloc_node.id, result_type)
          return realloc_node.id
        end
      end

      # For allocator calls (ClassName.new), ensure return type is the class type
      # This handles cases where the mangled name wasn't found in @function_types
      if method_name == "new" && full_method_name && return_type == TypeRef::VOID
        # Extract class name from "ClassName.new"
        class_name = full_method_name.rchop(".new")
        if class_info = @class_info[class_name]?
          return_type = class_info.type_ref
        else
          # Unknown class (probably from stdlib) - use pointer type as fallback
          # This ensures exception types like ArgumentError work correctly
          return_type = TypeRef::POINTER
        end
      end

      # For method calls that return void but are likely returning the receiver or a value,
      # use pointer type as fallback to avoid void type errors in LLVM
      if return_type == TypeRef::VOID && receiver_id
        # Methods that typically return self or a collection (stdlib methods)
        methods_returning_self_or_value = ["to_a", "to_s", "map", "select", "reduce", "each",
                                           "first", "last", "dup", "clone", "cover",
                                           "compact", "flatten", "sort", "reverse", "uniq",
                                           "join", "split", "strip", "chomp", "chars",
                                           "keys", "values", "value",  # 'value' is common getter
                                           "lines", "bytes", "codepoints", "graphemes",
                                           "rstrip", "lstrip", "downcase", "upcase", "capitalize",
                                           "gsub", "sub", "tr", "delete", "squeeze",
                                           "rjust", "ljust", "center", "each_line",
                                           "each_with_index", "map_with_index", "select_with_index",
                                           "index", "rindex", "find", "find_index", "count",
                                           "sum", "product", "min", "max", "minmax", "sample",
                                           "take", "drop", "take_while", "drop_while",
                                           "group_by", "partition", "zip", "transpose",
                                           "shuffle", "rotate", "pop", "shift", "slice",
                                           "to_slice", "to_unsafe", "to_h", "to_set", "copy_from"]
        if methods_returning_self_or_value.includes?(method_name)
          return_type = TypeRef::POINTER
        end
      end

      # Methods that return the same type as the receiver.
      # Handle this even if return_type is NIL (often incorrectly registered for abstract modules).
      methods_returning_receiver_type = ["tap", "clamp", "abs", "ceil", "floor", "round", "truncate",
                                         "remainder", "tdiv", "unsafe_mod", "unsafe_div", "gcd", "lcm"]
      if receiver_id && methods_returning_receiver_type.includes?(method_name)
        recv_type = ctx.type_of(receiver_id)
        # Only override if receiver is not Nil (these methods don't make sense on Nil)
        if recv_type != TypeRef::NIL && recv_type != TypeRef::VOID
          if ENV.has_key?("DEBUG_RECV_TYPE") && (method_name == "abs" || method_name == "remainder")
            STDERR.puts "[RECV_TYPE_CALL] method=#{method_name} recv_type=#{recv_type.id} old_return=#{return_type.id} current_class=#{@current_class || ""} current_method=#{@current_method || ""}"
          end
          return_type = recv_type
        elsif ENV.has_key?("DEBUG_RECV_TYPE") && (method_name == "abs" || method_name == "remainder")
          STDERR.puts "[RECV_TYPE_CALL_SKIP] method=#{method_name} recv_type=#{recv_type.id} return=#{return_type.id} current_class=#{@current_class || ""} current_method=#{@current_method || ""}"
        end
      end

      # For unqualified method calls (no class prefix in the call name),
      # if return type is still void, use pointer as fallback
      # This handles stdlib methods that aren't defined in the bootstrap sources
      if return_type == TypeRef::VOID && receiver_id && !mangled_method_name.includes?("#") && !mangled_method_name.includes?(".")
        return_type = TypeRef::POINTER
      end

      # For class method calls (no receiver), handle common builder patterns
      # These methods return a new object (typically the class's instance type)
      if return_type == TypeRef::VOID && receiver_id.nil?
        class_methods_returning_value = ["build", "new", "create", "from", "parse", "load", "open"]
        if class_methods_returning_value.includes?(method_name)
          return_type = TypeRef::POINTER
        end
      end

      # For module method calls (within the same module), if return type is still void,
      # try to find the method's declared return type or use POINTER fallback
      # Module methods returning String/Array/etc. should not be void
      if return_type == TypeRef::VOID && receiver_id.nil? && @current_class
        # Check if it's a method that typically returns a value (not a side-effect only method)
        # Methods with "build_", "get_", "create_", "make_", "extract_", "format_" prefixes
        # typically return values
        if method_name.starts_with?("build_") || method_name.starts_with?("get_") ||
           method_name.starts_with?("create_") || method_name.starts_with?("make_") ||
           method_name.starts_with?("extract_") || method_name.starts_with?("format_") ||
           method_name.starts_with?("parse_") || method_name.starts_with?("to_") ||
           method_name.ends_with?("_lines") || method_name.ends_with?("_string") ||
           method_name.ends_with?("_snippet") || method_name.ends_with?("_range") ||
           method_name.ends_with?("_gutter") || method_name.ends_with?("_segment")
          return_type = TypeRef::POINTER
        end
      end

      if receiver_id && ctx.type_literal?(receiver_id) && mangled_method_name.includes?("#")
        mangled_method_name = mangled_method_name.sub("#", ".")
        primary_mangled_name = primary_mangled_name.sub("#", ".")
        base_method_name = base_method_name.sub("#", ".") if base_method_name.includes?("#")
        receiver_id = nil
      elsif receiver_id && mangled_method_name.includes?("#") && ENV["DEBUG_TYPE_LITERAL_CALL"]?
        STDERR.puts "[TYPE_LITERAL_CALL] recv=#{receiver_id} type_literal=#{ctx.type_literal?(receiver_id)} name=#{mangled_method_name}"
      end
      if ENV["DEBUG_POINTER_LIST"]? &&
         (mangled_method_name.includes?("PointerLinkedList") ||
          base_method_name.includes?("PointerLinkedList") ||
          full_method_name.try(&.includes?("PointerLinkedList")))
        STDERR.puts "[POINTER_LIST_CALL] recv=#{receiver_id || "nil"} type_literal=#{receiver_id && ctx.type_literal?(receiver_id)} name=#{mangled_method_name} base=#{base_method_name} full=#{full_method_name || "nil"} method=#{method_name}"
      end
      if ENV["DEBUG_NEW_CALLS"]? && method_name == "new"
        STDERR.puts "[NEW_CALL] recv=#{receiver_id || "nil"} name=#{mangled_method_name}"
      end

      call_virtual = false
      if receiver_id
        if type_desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
          call_virtual = type_desc.kind.in?(TypeKind::Union, TypeKind::Module)
          if !call_virtual && type_desc.kind == TypeKind::Class
            call_virtual = class_has_subclasses?(type_desc.name) ||
              abstract_def?(mangled_method_name) ||
              (mangled_method_name != primary_mangled_name && abstract_def?(primary_mangled_name))
          end
        end
      end
      if ENV.has_key?("DEBUG_VIRTUAL_CALLS") && receiver_id
        recv_type = ctx.type_of(receiver_id)
        recv_desc = @module.get_type_descriptor(recv_type)
        recv_name = recv_desc ? "#{recv_desc.name}(#{recv_desc.kind})" : recv_type.id.to_s
        STDERR.puts "[HIR_VIRTUAL_CALL] method=#{method_name} recv=#{recv_name} virtual=#{call_virtual}"
      end

      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=before_lower_function method=#{method_name} mangled=#{mangled_method_name} primary=#{primary_mangled_name} return=#{return_type.id}"
      end
      # Lazily lower target function bodies (avoid full stdlib lowering).
      remember_callsite_arg_types(primary_mangled_name, arg_types, arg_literals, has_block_call)
      if mangled_method_name != primary_mangled_name
        remember_callsite_arg_types(mangled_method_name, arg_types, arg_literals, has_block_call)
      end
      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=after_remember method=#{method_name} mangled=#{mangled_method_name} primary=#{primary_mangled_name}"
      end
      callsite_label = nil
      if DebugHooks::ENABLED
        span = node.span
        receiver_type_name = receiver_id ? type_name_for_mangling(ctx.type_of(receiver_id)) : "nil"
        callsite_label = "func=#{ctx.function.name} method=#{method_name} full=#{full_method_name || ""} class=#{@current_class || ""} recv=#{receiver_type_name} span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column}"
      end
      # Debug disabled for performance
      # if mangled_method_name.includes?("from_chars") || mangled_method_name == "ec" || mangled_method_name == "ptr" || mangled_method_name == "current" || (method_name == "write" && base_method_name.includes?("FileDescriptor")) || mangled_method_name.includes?("Slice") && method_name == "new"
      #   arg_type_names = arg_types.map { |t| type_name_for_mangling(t) }
      #   STDERR.puts "[CALL_DEBUG] method=#{method_name}, base=#{base_method_name}, mangled=#{mangled_method_name}, primary=#{primary_mangled_name}, return_type=#{return_type}, arg_types=#{arg_type_names}, full=#{full_method_name}"
      # end
      with_debug_callsite(callsite_label) do
        lower_function_if_needed(primary_mangled_name)
        if mangled_method_name != primary_mangled_name
          lower_function_if_needed(mangled_method_name)
        end
      end
      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=after_lower_function method=#{method_name} mangled=#{mangled_method_name} primary=#{primary_mangled_name}"
      end

      # After lowering, re-check return type if it was VOID
      # The lowered function may have registered its return type
      if return_type == TypeRef::VOID
        return_type = get_function_return_type(mangled_method_name)
        if return_type == TypeRef::VOID && mangled_method_name != base_method_name
          return_type = get_function_return_type(base_method_name)
        end
      end
      # If we still have a fallback type, prefer a registered function type when available.
      # But don't override a concrete receiver-derived type with NIL.
      resolved_return_type = get_function_return_type(mangled_method_name)
      if resolved_return_type == TypeRef::VOID && mangled_method_name != base_method_name
        resolved_return_type = get_function_return_type(base_method_name)
      end
      if resolved_return_type != TypeRef::VOID && resolved_return_type != TypeRef::NIL && resolved_return_type != return_type
        return_type = resolved_return_type
      end

      # Coerce arguments to union types if needed
      # This handles cases like passing Int32 to a parameter of type Int32 | Nil
      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=before_coerce method=#{method_name} mangled=#{mangled_method_name} args=#{args.size}"
      end
      args = coerce_args_to_param_types(ctx, args, mangled_method_name)
      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=after_coerce method=#{method_name} mangled=#{mangled_method_name} args=#{args.size}"
      end

      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=before_emit method=#{method_name} mangled=#{mangled_method_name} return=#{return_type.id}"
      end
      if ENV["DEBUG_FROM_CHARS"]? && method_name == "from_chars_advanced"
        arg_names = args.map { |arg_id| get_type_name_from_ref(ctx.type_of(arg_id)) }
        STDERR.puts "[DEBUG_FROM_CHARS] base=#{base_method_name} mangled=#{mangled_method_name} args=#{arg_names.join(",")}"
      end
      call = Call.new(ctx.next_id, return_type, receiver_id, mangled_method_name, args, block_id, call_virtual)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      if function_returns_type_literal?(mangled_method_name, base_method_name)
        ctx.mark_type_literal(call.id)
      end
      if enum_name = enum_return_name_for(mangled_method_name)
        (@enum_value_types ||= {} of ValueId => String)[call.id] = enum_name
        if ENV["DEBUG_ENUM_CALL"]? && mangled_method_name == "File::Info#type"
          STDERR.puts "[DEBUG_ENUM_CALL] name=#{mangled_method_name} enum=#{enum_name}"
        end
      elsif ENV["DEBUG_ENUM_CALL"]? && mangled_method_name == "File::Info#type"
        STDERR.puts "[DEBUG_ENUM_CALL] name=#{mangled_method_name} enum=(nil)"
      end
      if ENV["DEBUG_CALL_TRACE"]? && method_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=after_emit method=#{method_name} mangled=#{mangled_method_name}"
      end
      call.id
    end

    # Expand splat arguments in a call
    # *array becomes individual elements at compile time (if array is literal)
    private def out_alloc_type_for_param(param_type : TypeRef) : TypeRef
      if desc = @module.get_type_descriptor(param_type)
        if desc.kind == TypeKind::Pointer
          elem_type = pointer_element_type(desc.name)
          return elem_type unless elem_type == TypeRef::VOID
        end
      end
      param_type == TypeRef::POINTER ? TypeRef::POINTER : param_type
    end

    private def lower_out_arg(
      ctx : LoweringContext,
      node : CrystalV2::Compiler::Frontend::OutNode,
      param_type : TypeRef
    ) : ValueId
      var_name = String.new(node.identifier)
      var_id = ctx.lookup_local(var_name)
      if var_id.nil?
        alloc_type = out_alloc_type_for_param(param_type)
        alloc = Allocate.new(ctx.next_id, alloc_type, [] of ValueId, true)
        ctx.emit(alloc)
        record_allocation_location(ctx, alloc.id, @arena, node)
        ctx.register_local(var_name, alloc.id)
        var_id = alloc.id
      end
      ptr = AddressOf.new(ctx.next_id, TypeRef::POINTER, var_id)
      ctx.emit(ptr)
      ptr.id
    end

    private def expand_extern_args(
      ctx : LoweringContext,
      arg_exprs : Array(ExprId),
      call_arena : CrystalV2::Compiler::Frontend::ArenaLike,
      extern_func : ExternFunction
    ) : Array(ValueId)
      result = [] of ValueId
      param_types = extern_func.param_types
      old_arena = @arena
      begin
        arg_exprs.each_with_index do |arg_expr, idx|
          @arena = call_arena
          arg_node = @arena[arg_expr]
          if arg_node.is_a?(CrystalV2::Compiler::Frontend::OutNode)
            expected_type = param_types[idx]? || TypeRef::POINTER
            result << lower_out_arg(ctx, arg_node, expected_type)
          else
            result << lower_expr(ctx, arg_expr)
          end
        end
      ensure
        @arena = old_arena
      end

      result
    end

    private def expand_splat_args(
      ctx : LoweringContext,
      arg_exprs : Array(ExprId),
      call_arena : CrystalV2::Compiler::Frontend::ArenaLike
    ) : Array(ValueId)
      result = [] of ValueId

      old_arena = @arena
      begin
        arg_exprs.each do |arg_expr|
          @arena = call_arena
          if ENV["DEBUG_SPLAT_ARENA"]?
            inline_desc = if arenas = @inline_arenas
                            arenas.map { |candidate| "#{candidate.class}:#{candidate.size}" }.join(",")
                          else
                            "none"
                          end
            STDERR.puts "[SPLAT_ARENA] expr=#{arg_expr.index} arena=#{@arena.class}:#{@arena.size} inline=#{inline_desc}"
          end
          if ENV["DEBUG_SPLAT_TRACE"]?
            ctx_info = @last_splat_context || "func=#{ctx.function.name}"
            STDERR.puts "[SPLAT_TRACE] #{ctx_info} expr=#{arg_expr.index}"
          end
          if arg_expr.invalid?
            debug_hook("splat.arg.invalid", "expr=#{arg_expr.index} arena=#{@arena.class} size=#{@arena.size}")
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            result << nil_lit.id
            next
          end
          arg_node = @arena[arg_expr]

          if arg_node.is_a?(CrystalV2::Compiler::Frontend::SplatNode)
            # Splat - try to expand if inner is array literal
            if arg_node.expr.invalid?
              debug_hook("splat.inner.invalid", "expr=#{arg_node.expr.index} arena=#{@arena.class} size=#{@arena.size}")
              nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
              ctx.emit(nil_lit)
              result << nil_lit.id
              next
            end
            @arena = call_arena
            inner_node = @arena[arg_node.expr]
            if inner_node.is_a?(CrystalV2::Compiler::Frontend::ArrayLiteralNode)
              # Expand array elements as individual arguments
              inner_node.elements.each do |elem_id|
                @arena = call_arena
                result << lower_expr(ctx, elem_id)
                @arena = call_arena
                if ENV["DEBUG_SPLAT_TRACE"]?
                  STDERR.puts "[SPLAT_TRACE_DONE] elem=#{elem_id.index}"
                end
              end
            else
              # Non-literal splat - just pass through (runtime behavior not fully supported)
              @arena = call_arena
              result << lower_expr(ctx, arg_node.expr)
              @arena = call_arena
              if ENV["DEBUG_SPLAT_TRACE"]?
                STDERR.puts "[SPLAT_TRACE_DONE] inner=#{arg_node.expr.index}"
              end
            end
          else
            @arena = call_arena
            result << lower_expr(ctx, arg_expr)
            @arena = call_arena
            if ENV["DEBUG_SPLAT_TRACE"]?
              STDERR.puts "[SPLAT_TRACE_DONE] expr=#{arg_expr.index}"
            end
          end
          @arena = call_arena
        end
      ensure
        @arena = old_arena
      end

      result
    end

    private def pack_splat_args_for_call(
      ctx : LoweringContext,
      args : Array(ValueId),
      method_name : String,
      full_method_name : String?,
      has_block_call : Bool,
      receiver_id : ValueId?
    ) : Array(ValueId)
      func_name = if full_method_name
                    full_method_name
                  elsif receiver_id
                    if desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
                      resolve_method_with_inheritance(desc.name, method_name) || "#{desc.name}##{method_name}"
                    else
                      method_name
                    end
                  elsif current = @current_class
                    sep = @current_method_is_class ? "." : "#"
                    candidate = "#{current}#{sep}#{method_name}"
                    if @function_types.has_key?(candidate) || has_function_base?(candidate)
                      candidate
                    else
                      method_name
                    end
                  else
                    method_name
                  end
      arg_types = args.map { |arg_id| ctx.type_of(arg_id) }
      entry = lookup_function_def_for_call(func_name, args.size, has_block_call, arg_types)
      return args unless entry

      func_def = entry[1]
      return args unless params = func_def.params
      if ENV["DEBUG_PUTS_PACK"]? && method_name == "puts"
        param_debug = params.map do |param|
          name = param.name ? String.new(param.name.not_nil!) : "(anon)"
          type_name = param.type_annotation ? String.new(param.type_annotation.not_nil!) : ""
          flags = [] of String
          flags << "splat" if param.is_splat
          flags << "double_splat" if param.is_double_splat
          "#{name}:#{type_name}#{flags.empty? ? "" : "[#{flags.join(",")}]" }"
        end
        STDERR.puts "[DEBUG_PUTS_PACK] func=#{func_name} entry=#{entry[0]} params=#{param_debug.join("|")}"
      end

      splat_index : Int32? = nil
      splat_is_last = true
      param_index = 0
      saw_splat = false
      params.each do |param|
        next if param.is_block || named_only_separator?(param)
        if param.is_splat && !param.is_double_splat
          splat_index = param_index
          saw_splat = true
        elsif saw_splat
          splat_is_last = false
          break
        end
        param_index += 1
      end

      return args unless splat_index && splat_is_last
      return args if args.size <= splat_index

      fixed = args[0, splat_index]
      splat_args = args[splat_index..-1] || [] of ValueId
      return args if splat_args.empty?

      splat_types = splat_args.map { |arg_id| ctx.type_of(arg_id) }
      tuple_type = tuple_type_from_arg_types(splat_types)
      return args if tuple_type == TypeRef::VOID

      tuple_alloc = Allocate.new(ctx.next_id, tuple_type, splat_args)
      ctx.emit(tuple_alloc)

      fixed + [tuple_alloc.id]
    end

    private def ensure_double_splat_arg(
      ctx : LoweringContext,
      args : Array(ValueId),
      method_name : String,
      full_method_name : String?,
      has_block_call : Bool,
      receiver_id : ValueId?
    ) : Array(ValueId)
      func_name = if full_method_name
                    full_method_name
                  elsif receiver_id
                    if desc = @module.get_type_descriptor(ctx.type_of(receiver_id))
                      resolve_method_with_inheritance(desc.name, method_name) || "#{desc.name}##{method_name}"
                    else
                      method_name
                    end
                  elsif current = @current_class
                    sep = @current_method_is_class ? "." : "#"
                    candidate = "#{current}#{sep}#{method_name}"
                    if @function_types.has_key?(candidate) || has_function_base?(candidate)
                      candidate
                    else
                      method_name
                    end
                  else
                    method_name
                  end
      arg_types = args.map { |arg_id| ctx.type_of(arg_id) }
      entry = lookup_function_def_for_call(func_name, args.size, has_block_call, arg_types)
      return args unless entry

      func_def = entry[1]
      return args unless params = func_def.params

      double_splat_index : Int32? = nil
      param_index = 0
      params.each do |param|
        next if param.is_block || named_only_separator?(param)
        if param.is_double_splat
          double_splat_index = param_index
          break
        end
        param_index += 1
      end

      return args unless double_splat_index
      return args if args.size > double_splat_index

      result = args.dup
      while result.size < double_splat_index
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        result << nil_lit.id
      end
      result << allocate_named_tuple(ctx, [] of ValueId)
      result
    end

    # Coerce arguments to match parameter types (e.g., wrap concrete types in unions)
    # This is needed when passing Int32 to a parameter of type Int32 | Nil
    private def coerce_args_to_param_types(
      ctx : LoweringContext,
      args : Array(ValueId),
      method_name : String
    ) : Array(ValueId)
      # Find the target function to get parameter types
      target_func = @module.functions.find { |f| f.name == method_name }

      # If not found, try fuzzy match (for mangled names)
      unless target_func
        base_name = method_name.split("$").first
        target_func = @module.functions.find { |f| f.name.split("$").first == base_name }
      end

      # Try another fuzzy match: method name may have different type suffix but same base
      unless target_func
        # Look for functions that match the method base (class#method or Module.method)
        if method_name.includes?("#") || method_name.includes?(".")
          # Extract class and method parts: "Class.method$Types" -> "Class", "method"
          separator = method_name.includes?("#") ? "#" : "."
          parts = method_name.split(separator, 2)
          if parts.size == 2
            class_part = parts[0]
            method_with_types = parts[1]
            # Extract just the method name (before $type suffix)
            method_part = method_with_types.split("$").first
            # Match: same class, same method name, possibly different type suffixes
            target_func = @module.functions.find do |f|
              if f.name.includes?(separator)
                f_parts = f.name.split(separator, 2)
                f_parts.size == 2 &&
                  f_parts[0] == class_part &&
                  f_parts[1].split("$").first == method_part
              else
                false
              end
            end
          end
        end
      end

      return args unless target_func

      # Receiver counts as first implicit parameter for instance methods
      # The function params include self for instance methods
      params = target_func.params
      param_offset = params.first?.try(&.name) == "self" ? 1 : 0

      # Coerce each argument
      result = [] of ValueId
      args.each_with_index do |arg_id, idx|
        param = params[idx + param_offset]?
        if param.nil?
          # No more params - just pass through
          result << arg_id
          next
        end

        arg_type = ctx.type_of(arg_id)
        param_type = param.type
        param_type_name = @module.get_type_descriptor(param_type).try(&.name) || ""

        # Check if we need to coerce: arg is concrete type, param is union containing that type
        if needs_union_coercion?(arg_type, param_type)
          # Determine variant id: 0 for the concrete type, 1 for Nil typically
          variant_id = get_union_variant_id(param_type, arg_type)
          wrap = UnionWrap.new(ctx.next_id, param_type, arg_id, variant_id)
          ctx.emit(wrap)
          ctx.register_type(wrap.id, param_type)
          result << wrap.id
        elsif arg_type != TypeRef::VOID && param_type != TypeRef::VOID && arg_type != param_type
          target_type = nil
          if numeric_primitive?(param_type) && numeric_primitive?(arg_type)
            target_type = param_type
          elsif !param_type_name.empty?
            target_type = numeric_param_target_type(param_type_name, arg_type)
          end

          if target_type && target_type != TypeRef::VOID && target_type != arg_type
            cast = Cast.new(ctx.next_id, target_type, arg_id, target_type)
            ctx.emit(cast)
            ctx.register_type(cast.id, target_type)
            result << cast.id
          else
            result << arg_id
          end
        else
          result << arg_id
        end
      end

      result
    end

    # Check if arg_type needs to be wrapped into param_type union
    private def needs_union_coercion?(arg_type : TypeRef, param_type : TypeRef) : Bool
      # Quick check: same type, no coercion needed
      return false if arg_type == param_type

      # Check if param_type is a union type (has type descriptor with union marker)
      if type_desc = @module.get_type_descriptor(param_type)
        if type_desc.kind == TypeKind::Union
          # Check if arg_type is one of the union variants
          # For now, assume simple unions like Int32 | Nil
          # The arg_type should be a non-union type that's part of the union
          return true if arg_type != param_type && !is_union_type?(arg_type)
        end
      end

      # Also check by type naming convention: types with "___" are usually unions
      # e.g., Int32___Nil is Int32 | Nil
      if param_type.id > 0
        @module.types.each_with_index do |desc, idx|
          if TypeRef.new(TypeRef::FIRST_USER_TYPE + idx.to_u32) == param_type
            if desc.name.includes?("___") || desc.kind == TypeKind::Union
              # Param is union type - check if arg is a concrete type
              return !is_union_type?(arg_type)
            end
          end
        end
      end

      false
    end

    # Check if a type is a union type
    private def is_union_type?(type : TypeRef) : Bool
      if type_desc = @module.get_type_descriptor(type)
        return type_desc.kind == TypeKind::Union || type_desc.name.includes?("___")
      end
      false
    end

    # Check if a type is a nilable Int32 union (Int32 | Nil)
    private def is_nilable_int32_union?(type : TypeRef) : Bool
      if type_desc = @module.get_type_descriptor(type)
        # Check if it's a union with Int32 in the name (Int32___Nil or Int32 | Nil)
        if type_desc.kind == TypeKind::Union || type_desc.name.includes?("___")
          name = type_desc.name
          return name.includes?("Int32") && (name.includes?("Nil") || name.includes?("nil"))
        end
      end
      false
    end

    private def lookup_function_def_for_call(
      func_name : String,
      arg_count : Int32,
      has_block : Bool,
      arg_types : Array(TypeRef)? = nil
    ) : Tuple(String, CrystalV2::Compiler::Frontend::DefNode)?
      if func_name.includes?("$")
        if func_def = @function_defs[func_name]?
          return {func_name, func_def}
        end
      end

      best : CrystalV2::Compiler::Frontend::DefNode? = nil
      best_name : String? = nil
      best_param_count = Int32::MAX
      best_score = Int32::MIN
      prefer_untyped = false
      if arg_types && arg_types.any? { |t| t == TypeRef::VOID }
        @function_defs.each do |name, def_node|
          next unless name == func_name || name.starts_with?("#{func_name}$")
          params = def_node.params
          next unless params

          if has_block
            next unless params.any?(&.is_block)
          else
            next if params.any?(&.is_block)
          end

          param_count = params.count { |p| !p.is_block && !named_only_separator?(p) }
          has_splat = params.any? { |p| p.is_splat && !named_only_separator?(p) }
          has_double_splat = params.any? { |p| p.is_double_splat }
          required = params.count do |p|
            !p.is_block && !named_only_separator?(p) && p.default_value.nil? && !p.is_splat && !p.is_double_splat
          end

          next if arg_count < required
          next if arg_count > param_count && !has_splat && !has_double_splat

          untyped_candidate = true
          params.each do |param|
            next if param.is_block || named_only_separator?(param)
            next if param.is_splat || param.is_double_splat
            if ta = param.type_annotation
              type_name = String.new(ta)
              if !type_param_like?(type_name) || @type_param_map.has_key?(type_name)
                untyped_candidate = false
                break
              end
            end
          end
          if untyped_candidate
            prefer_untyped = true
            break
          end
        end
      end

      @function_defs.each do |name, def_node|
        next unless name == func_name || name.starts_with?("#{func_name}$")
        params = def_node.params
        next unless params

        if has_block
          next unless params.any?(&.is_block)
        else
          next if params.any?(&.is_block)
        end

        param_count = params.count { |p| !p.is_block && !named_only_separator?(p) }
        has_splat = params.any? { |p| p.is_splat && !named_only_separator?(p) }
        has_double_splat = params.any? { |p| p.is_double_splat }
        required = params.count do |p|
          !p.is_block && !named_only_separator?(p) && p.default_value.nil? && !p.is_splat && !p.is_double_splat
        end

        next if arg_count < required
        next if arg_count > param_count && !has_splat && !has_double_splat

        untyped_candidate = true
        params.each do |param|
          next if param.is_block || named_only_separator?(param)
          next if param.is_splat || param.is_double_splat
          if ta = param.type_annotation
            type_name = String.new(ta)
            if !type_param_like?(type_name) || @type_param_map.has_key?(type_name)
              untyped_candidate = false
              break
            end
          end
        end
        next if prefer_untyped && !untyped_candidate

        score = 0
        if arg_types
          func_context = function_context_from_name(name)
          next unless params_compatible_with_args?(def_node, arg_types, func_context)
          score = params_match_score(def_node, arg_types, func_context)
        end
        if arg_types && arg_types.any? { |t| t == TypeRef::VOID }
          typed_param_count = params.count do |p|
            !p.is_block && !named_only_separator?(p) && !p.type_annotation.nil?
          end
          score -= typed_param_count
        end
        if has_splat
          score -= 1
        elsif has_double_splat
          score -= 1
        end

        if param_count < best_param_count || (param_count == best_param_count && score > best_score)
          best = def_node
          best_name = name
          best_param_count = param_count
          best_score = score
        end
      end

      return nil unless best && best_name
      if ENV["DEBUG_PUTS_LOOKUP"]? && func_name.includes?("IO#puts")
        type_names = if arg_types
                       arg_types.map { |t| type_name_for_mangling(t) }.join(",")
                     else
                       ""
                     end
        STDERR.puts "[DEBUG_PUTS_LOOKUP] func=#{func_name} count=#{arg_count} args=#{type_names} best=#{best_name}"
      end
      {best_name, best}
    end


    private def lookup_block_function_def_for_call(
      func_name : String,
      arg_count : Int32,
      arg_types : Array(TypeRef)? = nil
    ) : Tuple(String, CrystalV2::Compiler::Frontend::DefNode)?
      best : CrystalV2::Compiler::Frontend::DefNode? = nil
      best_name : String? = nil
      best_param_count = Int32::MAX
      best_score = Int32::MIN

      @function_defs.each do |name, def_node|
        next unless name == func_name || name.starts_with?("#{func_name}$")
        params = def_node.params
        next unless params && params.any?(&.is_block)

        param_count = params.count { |p| !p.is_block && !named_only_separator?(p) }
        has_splat = params.any? { |p| p.is_splat && !named_only_separator?(p) }
        has_double_splat = params.any? { |p| p.is_double_splat }
        required = params.count do |p|
          !p.is_block && !named_only_separator?(p) && p.default_value.nil? && !p.is_splat && !p.is_double_splat
        end

        next if arg_count < required
        next if arg_count > param_count && !has_splat && !has_double_splat

        score = 0
        if arg_types
          func_context = function_context_from_name(name)
          next unless params_compatible_with_args?(def_node, arg_types, func_context)
          score = params_match_score(def_node, arg_types, func_context)
        end
        if has_splat
          score -= 1
        elsif has_double_splat
          score -= 1
        end

        if param_count < best_param_count || (param_count == best_param_count && score > best_score)
          best = def_node
          best_name = name
          best_param_count = param_count
          best_score = score
        end
      end

      return nil unless best && best_name
      {best_name, best}
    end

    private def underscore_lower(name : String) : String
      name.downcase.gsub("_", "")
    end

    private def enum_members_for_type_name(type_name : String, context : String? = nil) : Hash(String, Int64)?
      return nil unless enum_info = @enum_info
      normalized = normalize_declared_type_name(type_name, context)
      candidates = [] of String
      candidates << normalized
      if normalized.ends_with?("?")
        candidates << normalized[0...-1]
      end
      if normalized.includes?("|")
        normalized.split("|").each do |part|
          candidates << part.strip
        end
      end

      candidates.uniq.each do |candidate|
        lookup = resolve_type_alias_chain(candidate)
        return enum_info[lookup]? if enum_info.has_key?(lookup)
        short_name = lookup.split("::").last?
        return enum_info[short_name]? if short_name && enum_info.has_key?(short_name)
      end
      nil
    end

    private def enum_member_value(type_name : String, symbol_name : String, context : String? = nil) : Int64?
      members = enum_members_for_type_name(type_name, context)
      return nil unless members
      clean_symbol = symbol_name.starts_with?(":") ? symbol_name[1..] : symbol_name
      target = underscore_lower(clean_symbol)
      members.each do |member_name, value|
        return value if underscore_lower(member_name) == target
      end
      nil
    end

    private def lower_arg_with_expected_type(
      ctx : LoweringContext,
      arg_expr : ExprId,
      expected_type : TypeRef,
      expected_type_name : String?,
      context : String? = nil
    ) : ValueId
      arg_node = @arena[arg_expr]
      if expected_type_name && arg_node.is_a?(CrystalV2::Compiler::Frontend::SymbolNode)
        if value = enum_member_value(expected_type_name, String.new(arg_node.name), context)
          lit = Literal.new(ctx.next_id, TypeRef::INT32, value)
          ctx.emit(lit)
          ctx.register_type(lit.id, TypeRef::INT32)
          return lit.id
        end
      end

      lower_expr(ctx, arg_expr)
    end

    private def allocate_named_tuple(ctx : LoweringContext, values : Array(ValueId)) : ValueId
      named_tuple_type = ctx.get_type("NamedTuple")
      alloc = Allocate.new(ctx.next_id, named_tuple_type, values)
      ctx.emit(alloc)
      alloc.id
    end

    private def lower_args_with_expected_types(
      ctx : LoweringContext,
      positional_args : Array(ExprId),
      method_name : String,
      full_method_name : String?,
      has_block_call : Bool,
      call_arena : CrystalV2::Compiler::Frontend::ArenaLike
    ) : Array(ValueId)
      func_name = full_method_name || method_name
      arg_types = infer_arg_types_for_call(positional_args, @current_class)
      func_entry = lookup_function_def_for_call(func_name, positional_args.size, has_block_call, arg_types)
      func_def = func_entry ? func_entry[1] : nil
      func_context = func_entry ? function_context_from_name(func_entry[0]) : nil
      return positional_args.map { |arg| lower_expr(ctx, arg) } unless func_def

      param_types = [] of TypeRef
      param_type_names = [] of String?

      if params = func_def.params
        params.each do |param|
          next if param.is_block
          next if named_only_separator?(param)

          param_type_name = if ta = param.type_annotation
                              normalize_declared_type_name(String.new(ta), func_context)
                            else
                              nil
                            end

          param_type = if param.is_double_splat
                         param_type_name ? type_ref_for_name(param_type_name) : type_ref_for_name("NamedTuple")
                       else
                         if param_type_name
                           type_ref_for_name(param_type_name)
                         else
                           TypeRef::VOID
                         end
                       end

          param_types << param_type
          param_type_names << param_type_name
        end
      end

      result = [] of ValueId
      old_arena = @arena
      begin
        positional_args.each_with_index do |arg_expr, idx|
          @arena = call_arena
          if ENV["DEBUG_CALL_ARGS"]?
            kind = if arg_expr.index >= 0 && arg_expr.index < call_arena.size
                     CrystalV2::Compiler::Frontend.node_kind(call_arena[arg_expr]).to_s
                   else
                     "oob"
                   end
            STDERR.puts "[CALL_ARGS] func=#{func_name} idx=#{idx} expr=#{arg_expr.index} kind=#{kind} arena=#{call_arena.class}:#{call_arena.size}"
          end
          if idx < param_types.size
            value_id = lower_arg_with_expected_type(ctx, arg_expr, param_types[idx], param_type_names[idx], func_context)
            result << value_id
            if ENV["DEBUG_CALL_ARGS"]?
              STDERR.puts "[CALL_ARGS_DONE] func=#{func_name} idx=#{idx} expr=#{arg_expr.index} value=#{value_id} type=#{ctx.type_of(value_id)}"
            end
          else
            value_id = lower_expr(ctx, arg_expr)
            result << value_id
            if ENV["DEBUG_CALL_ARGS"]?
              STDERR.puts "[CALL_ARGS_DONE] func=#{func_name} idx=#{idx} expr=#{arg_expr.index} value=#{value_id} type=#{ctx.type_of(value_id)}"
            end
          end
          @arena = call_arena
        end
      ensure
        @arena = old_arena
      end

      if ENV["DEBUG_CALL_ARGS"]?
        STDERR.puts "[CALL_ARGS_END] func=#{func_name} args=#{result.size}"
      end

      result
    end

    # Reorder named arguments to match parameter positions
    private def reorder_named_args(
      ctx : LoweringContext,
      positional_args : Array(ExprId),
      named_args : Array(CrystalV2::Compiler::Frontend::NamedArgument),
      method_name : String,
      full_method_name : String?,
      has_block_call : Bool,
      call_arena : CrystalV2::Compiler::Frontend::ArenaLike
    ) : Array(ValueId)
      # Get parameter names from function definition
      func_name = full_method_name || method_name
      func_entry = lookup_function_def_for_call(func_name, positional_args.size + named_args.size, has_block_call)
      func_def = func_entry ? func_entry[1] : nil
      func_context = func_entry ? function_context_from_name(func_entry[0]) : nil
      def_arena = func_entry ? (@function_def_arenas[func_entry[0]]? || @arena) : @arena

      if func_def && (params = func_def.params)
        param_call_names = [] of String
        param_local_names = [] of String
        param_defaults = [] of ExprId?
        param_types = [] of TypeRef
        param_type_names = [] of String?
        double_splat_index : Int32? = nil

        params.each do |p|
          next if p.is_block
          next if named_only_separator?(p)
          call_name = if ext = p.external_name
                        String.new(ext)
                      elsif name = p.name
                        String.new(name)
                      else
                        ""
                      end
          local_name = p.name ? String.new(p.name.not_nil!) : ""
          param_type_name = if ta = p.type_annotation
                              normalize_declared_type_name(String.new(ta), func_context)
                            else
                              nil
                            end
          param_type = if p.is_double_splat
                         param_type_name ? type_ref_for_name(param_type_name) : type_ref_for_name("NamedTuple")
                       elsif param_type_name
                         type_ref_for_name(param_type_name)
                       else
                         TypeRef::VOID
                       end
          param_call_names << call_name
          param_local_names << local_name
          param_defaults << p.default_value
          param_types << param_type
          param_type_names << param_type_name
          if p.is_double_splat
            double_splat_index = param_types.size - 1
          end
        end

        result = [] of ValueId
        provided = [] of Bool
        old_arena = @arena
        begin

        positional_args.each_with_index do |arg_expr, idx|
          @arena = call_arena
          if idx < param_types.size
            result << lower_arg_with_expected_type(ctx, arg_expr, param_types[idx], param_type_names[idx], func_context)
          else
            result << lower_expr(ctx, arg_expr)
          end
          provided << true
          @arena = call_arena
        end

        extra_named = [] of CrystalV2::Compiler::Frontend::NamedArgument

        # Process named args
        named_args.each do |named_arg|
          arg_name = String.new(named_arg.name)

          # Find position of this parameter
          idx = param_call_names.index(arg_name)
          if idx
            # Extend result array if needed
            while result.size <= idx
              # Fill with nil placeholder (will be replaced)
              nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
              ctx.emit(nil_lit)
              result << nil_lit.id
              provided << false
            end
            @arena = call_arena
            result[idx] = lower_arg_with_expected_type(ctx, named_arg.value, param_types[idx], param_type_names[idx], func_context)
            provided[idx] = true
          else
            extra_named << named_arg
          end
        end

        if double_splat_index
          while result.size <= double_splat_index
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            result << nil_lit.id
            provided << false
          end

          unless provided[double_splat_index]
            tuple_values = extra_named.map do |arg|
              @arena = call_arena
              lower_expr(ctx, arg.value)
            end
            result[double_splat_index] = allocate_named_tuple(ctx, tuple_values)
            provided[double_splat_index] = true
            extra_named.clear
          end
        end

        extra_named.each do |named_arg|
          @arena = call_arena
          result << lower_expr(ctx, named_arg.value)
          provided << true
        end

        # Fill missing args with defaults (evaluate in a param-local context)
        if param_defaults.any?
          while result.size < param_call_names.size
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            result << nil_lit.id
            provided << false
          end

          saved_locals = ctx.save_locals
          begin
            locals = ctx.all_locals
            param_local_names.each_with_index do |name, idx|
              next if name.empty?
              if idx < result.size && provided[idx]
                locals[name] = result[idx]
              end
            end

            param_defaults.each_with_index do |default_expr, idx|
              next if provided[idx]
              next unless default_expr
              @arena = call_arena
              default_id = with_arena(def_arena) { lower_expr(ctx, default_expr) }
              if param_types[idx] != TypeRef::VOID
                ctx.register_type(default_id, param_types[idx])
              end
              result[idx] = default_id
              provided[idx] = true
              name = param_local_names[idx]
              locals[name] = default_id unless name.empty?
            end
          ensure
            ctx.restore_locals(saved_locals)
          end
        end
        ensure
          @arena = old_arena
        end
      else
        # No function definition found - just append named args in order
        result = positional_args.map do |arg|
          @arena = call_arena
          lower_expr(ctx, arg)
        end
        named_args.each do |named_arg|
          @arena = call_arena
          result << lower_expr(ctx, named_arg.value)
        end
      end

      result
    end

    private def apply_default_args(
      ctx : LoweringContext,
      args : Array(ValueId),
      method_name : String,
      full_method_name : String?,
      has_block_call : Bool
    ) : Array(ValueId)
      func_name = full_method_name || method_name
      arg_types = args.map { |arg_id| ctx.type_of(arg_id) }
      func_entry = lookup_function_def_for_call(func_name, args.size, has_block_call, arg_types)
      return args unless func_entry
      func_def = func_entry[1]
      func_context = function_context_from_name(func_entry[0])
      def_arena = @function_def_arenas[func_entry[0]]? || @arena
      params = func_def.params
      return args unless params

      param_local_names = [] of String
      param_defaults = [] of ExprId?
      param_types = [] of TypeRef

      params.each do |p|
        next if p.is_block
        next if named_only_separator?(p)
        local_name = p.name ? String.new(p.name.not_nil!) : ""
        param_local_names << local_name
        param_defaults << p.default_value
        if ta = p.type_annotation
          param_type_name = normalize_declared_type_name(String.new(ta), func_context)
          param_types << type_ref_for_name(param_type_name)
        else
          param_types << TypeRef::VOID
        end
      end

      return args if args.size >= param_defaults.size

      saved_locals = ctx.save_locals
      begin
        locals = ctx.all_locals
        param_local_names.each_with_index do |name, idx|
          break if idx >= args.size
          locals[name] = args[idx] unless name.empty?
        end

        idx = args.size
        while idx < param_defaults.size
          default_expr = param_defaults[idx]
          break unless default_expr
          default_id = with_arena(def_arena) { lower_expr(ctx, default_expr) }
          if param_types[idx] != TypeRef::VOID
            ctx.register_type(default_id, param_types[idx])
          end
          args << default_id
          local_name = param_local_names[idx]
          locals[local_name] = default_id unless local_name.empty?
          idx += 1
        end
      ensure
        ctx.restore_locals(saved_locals)
      end

      args
    end

    # Intrinsic: n.times { |i| body }
    # Expands to: i = 0; while i < n { body; i += 1 }
    # Uses phi nodes for loop variable AND mutable external variables
    private def lower_times_intrinsic(ctx : LoweringContext, count_id : ValueId, block : CrystalV2::Compiler::Frontend::BlockNode) : ValueId
      # Get block param name (default to "i" if not specified)
      param_name = if params = block.params
                     if first_param = params.first?
                       if pname = first_param.name
                         String.new(pname)
                       else
                         "__times_i"
                       end
                     else
                       "__times_i"
                     end
                   else
                     "__times_i"
                   end

      # Collect variables that might be assigned in the block body (same as while loop)
      assigned_vars = collect_assigned_vars(block.body)
      # Remove the block parameter from assigned vars - it's handled separately
      assigned_vars = assigned_vars.reject { |v| v == param_name }
      inline_vars = Set(String).new

      # Save initial values of mutable variables before the loop
      entry_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      # Initial counter value
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      # Create blocks
      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      # Jump to condition
      ctx.terminate(Jump.new(cond_block))

      # Condition block with phi for counter
      ctx.current_block = cond_block
      counter_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      counter_phi.add_incoming(entry_block, zero.id)
      ctx.emit(counter_phi)

      # Create phi nodes for mutable external variables (same pattern as lower_while)
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          phi.add_incoming(entry_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      # Register counter for use in body
      ctx.register_local(param_name, counter_phi.id)
      ctx.register_type(counter_phi.id, TypeRef::INT32)

      # Compare: i < n
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, counter_phi.id, count_id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      # Lower block body
      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      begin
        lower_body(ctx, block.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
      end
      body_exit_block = ctx.current_block
      ctx.pop_scope

      # Jump to increment block
      ctx.terminate(Jump.new(incr_block))

      # Increment block: i + 1
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, counter_phi.id, one.id)
      ctx.emit(new_i)

      # Add incoming to counter phi from increment block
      counter_phi.add_incoming(incr_block, new_i.id)

      # Patch mutable variable phi nodes - incoming from incr_block (the actual predecessor of cond_block)
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            # Add incoming from incr_block (not body_block!)
            phi.add_incoming(incr_block, updated_val)
          end
        end
      end

      # Jump back to condition
      ctx.terminate(Jump.new(cond_block))

      # Exit block - restore phi values for use after the loop
      ctx.current_block = exit_block
      phi_nodes.each do |var_name, phi|
        ctx.register_local(var_name, phi.id)
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Intrinsic: (begin..end).each { |i| body } or (begin...end).each { |i| body }
    # Expands to: i = begin; while i <= end (or < for exclusive) { body; i += 1 }
    private def lower_range_each_intrinsic(
      ctx : LoweringContext,
      range : CrystalV2::Compiler::Frontend::RangeNode,
      block : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      # Get block param name
      param_name = if params = block.params
                     if first_param = params.first?
                       if pname = first_param.name
                         String.new(pname)
                       else
                         "__range_i"
                       end
                     else
                       "__range_i"
                     end
                   else
                     "__range_i"
                   end

      # Lower range bounds
      begin_id = lower_expr(ctx, range.begin_expr)
      end_id = lower_expr(ctx, range.end_expr)

      # Collect mutable vars (same as times)
      assigned_vars = collect_assigned_vars(block.body)
      assigned_vars = assigned_vars.reject { |v| v == param_name }
      inline_vars = Set(String).new

      entry_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      # Create blocks
      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block with phi
      ctx.current_block = cond_block
      counter_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      counter_phi.add_incoming(entry_block, begin_id)
      ctx.emit(counter_phi)

      # Phi for mutable vars
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          phi.add_incoming(entry_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      ctx.register_local(param_name, counter_phi.id)
      ctx.register_type(counter_phi.id, TypeRef::INT32)

      # Compare: i <= end (inclusive) or i < end (exclusive)
      cmp_op = range.exclusive ? BinaryOp::Lt : BinaryOp::Le
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, cmp_op, counter_phi.id, end_id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)
      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      begin
        lower_body(ctx, block.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
      end
      ctx.pop_scope
      ctx.terminate(Jump.new(incr_block))

      # Increment block
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, counter_phi.id, one.id)
      ctx.emit(new_i)

      counter_phi.add_incoming(incr_block, new_i.id)

      # Patch mutable var phis
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            phi.add_incoming(incr_block, updated_val)
          end
        end
      end

      ctx.terminate(Jump.new(cond_block))

      # Exit block
      ctx.current_block = exit_block
      phi_nodes.each do |var_name, phi|
        ctx.register_local(var_name, phi.id)
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Intrinsic: arr.each { |x| body } for static array with known size
    private def lower_array_each_intrinsic(
      ctx : LoweringContext,
      array_id : ValueId,
      array_size : Int32,
      block : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      # Get block param name
      param_name = if params = block.params
                     if first_param = params.first?
                       if pname = first_param.name
                         String.new(pname)
                       else
                         "__arr_elem"
                       end
                     else
                       "__arr_elem"
                     end
                   else
                     "__arr_elem"
                   end

      # Collect mutable vars
      assigned_vars = collect_assigned_vars(block.body)
      assigned_vars = assigned_vars.reject { |v| v == param_name }
      inline_vars = Set(String).new

      entry_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      # Emit zero in entry block BEFORE jump (required for phi SSA)
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      # Create blocks
      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block with index phi
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      # Phi for mutable vars
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          phi.add_incoming(entry_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      # Compare: i < size
      size_lit = Literal.new(ctx.next_id, TypeRef::INT32, array_size.to_i64)
      ctx.emit(size_lit)
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_lit.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      # Get element: arr[i]
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)

      # Handle tuple destructuring: |(a, b, ...)| vs single param |x|
      if params = block.params
        if params.size > 1
          # Tuple destructuring - extract each element
          params.each_with_index do |param, idx|
            if pname = param.name
              name = String.new(pname)
              idx_lit = Literal.new(ctx.next_id, TypeRef::INT32, idx.to_i64)
              ctx.emit(idx_lit)
              elem_extract = IndexGet.new(ctx.next_id, TypeRef::POINTER, index_get.id, idx_lit.id)
              ctx.emit(elem_extract)
              ctx.register_type(elem_extract.id, TypeRef::POINTER)
              ctx.register_local(name, elem_extract.id)
            end
          end
        else
          # Single parameter - bind whole element
          ctx.register_local(param_name, index_get.id)
        end
      else
        ctx.register_local(param_name, index_get.id)
      end

      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      begin
        lower_body(ctx, block.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
      end
      ctx.pop_scope
      ctx.terminate(Jump.new(incr_block))

      # Increment block
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)

      index_phi.add_incoming(incr_block, new_i.id)

      # Patch mutable var phis
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            phi.add_incoming(incr_block, updated_val)
          end
        end
      end

      ctx.terminate(Jump.new(cond_block))

      # Exit block
      ctx.current_block = exit_block
      phi_nodes.each do |var_name, phi|
        ctx.register_local(var_name, phi.id)
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Dynamic array each - gets size at runtime via ArraySize
    private def lower_array_each_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      # Get block param name
      param_name = if params = block.params
                     if first_param = params.first?
                       if pname = first_param.name
                         String.new(pname)
                       else
                         "__arr_elem"
                       end
                     else
                       "__arr_elem"
                     end
                   else
                     "__arr_elem"
                   end

      # Collect mutable vars
      assigned_vars = collect_assigned_vars(block.body)
      assigned_vars = assigned_vars.reject { |v| v == param_name }
      inline_vars = Set(String).new

      entry_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      # Emit zero in entry block BEFORE jump (required for phi SSA)
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      # Create blocks
      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block with index phi
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      # Phi for mutable vars
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          phi.add_incoming(entry_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      # Get array size dynamically
      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      # Compare: i < size
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      # Get element: arr[i]
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::INT32)
      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)

      # Handle tuple destructuring: |(a, b, ...)| vs single param |x|
      if params = block.params
        if params.size > 1
          # Tuple destructuring - extract each element
          params.each_with_index do |param, idx|
            if pname = param.name
              name = String.new(pname)
              idx_lit = Literal.new(ctx.next_id, TypeRef::INT32, idx.to_i64)
              ctx.emit(idx_lit)
              elem_extract = IndexGet.new(ctx.next_id, TypeRef::POINTER, index_get.id, idx_lit.id)
              ctx.emit(elem_extract)
              ctx.register_type(elem_extract.id, TypeRef::POINTER)
              ctx.register_local(name, elem_extract.id)
            end
          end
        else
          # Single parameter - bind whole element
          ctx.register_local(param_name, index_get.id)
        end
      else
        ctx.register_local(param_name, index_get.id)
      end

      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      begin
        lower_body(ctx, block.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
      end
      ctx.pop_scope
      ctx.terminate(Jump.new(incr_block))

      # Increment block
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)

      index_phi.add_incoming(incr_block, new_i.id)

      # Patch mutable var phis
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            phi.add_incoming(incr_block, updated_val)
          end
        end
      end

      ctx.terminate(Jump.new(cond_block))

      # Exit block
      ctx.current_block = exit_block
      phi_nodes.each do |var_name, phi|
        ctx.register_local(var_name, phi.id)
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def array_intrinsic_receiver?(ctx : LoweringContext, receiver_id : ValueId) : Bool
      receiver_type = ctx.type_of(receiver_id)
      return false if receiver_type == TypeRef::VOID

      if desc = @module.get_type_descriptor(receiver_type)
        return desc.kind == TypeKind::Array &&
               (desc.name.starts_with?("Array(") || desc.name.starts_with?("StaticArray("))
      end

      false
    end

    # Array each_with_index intrinsic - iterates with element and index
    private def lower_array_each_with_index_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      # Get block param names (element, index)
      elem_param_name = "__arr_elem"
      index_param_name = "__arr_idx"
      if params = block.params
        if first_param = params[0]?
          if pname = first_param.name
            elem_param_name = String.new(pname)
          end
        end
        if second_param = params[1]?
          if pname = second_param.name
            index_param_name = String.new(pname)
          end
        end
      end

      # Collect mutable vars
      assigned_vars = collect_assigned_vars(block.body)
      assigned_vars = assigned_vars.reject { |v| v == elem_param_name || v == index_param_name }
      inline_vars = Set(String).new

      entry_block = ctx.current_block
      initial_values = {} of String => ValueId
      assigned_vars.each do |var_name|
        if val = lookup_local_for_phi(ctx, var_name, inline_vars)
          initial_values[var_name] = val
        end
      end

      # Emit zero in entry block BEFORE jump (required for phi SSA)
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      # Create blocks
      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block with index phi
      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      # Phi for mutable vars
      phi_nodes = {} of String => Phi
      assigned_vars.each do |var_name|
        if initial_val = initial_values[var_name]?
          var_type = ctx.type_of(initial_val)
          phi = Phi.new(ctx.next_id, var_type)
          phi.add_incoming(entry_block, initial_val)
          ctx.emit(phi)
          phi_nodes[var_name] = phi
          ctx.register_local(var_name, phi.id)
          if inline_vars.includes?(var_name)
            @inline_caller_locals_stack[-1][var_name] = phi.id
          end
        end
      end

      # Get array size dynamically
      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      # Compare: i < size
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      # Get element: arr[i] - element type should be POINTER for array of strings/objects
      element_type = array_element_type_for_value(ctx, array_id, TypeRef::POINTER)
      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)
      ctx.register_local(elem_param_name, index_get.id)

      # Register index parameter with INT32 type
      ctx.register_local(index_param_name, index_phi.id)
      ctx.register_type(index_phi.id, TypeRef::INT32)

      pushed_inline = false
      if !inline_vars.empty?
        @inline_loop_vars_stack << inline_vars
        pushed_inline = true
      end
      begin
        lower_body(ctx, block.body)
      ensure
        @inline_loop_vars_stack.pop? if pushed_inline
      end
      ctx.pop_scope
      ctx.terminate(Jump.new(incr_block))

      # Increment block
      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)

      index_phi.add_incoming(incr_block, new_i.id)

      # Patch mutable var phis
      assigned_vars.each do |var_name|
        if phi = phi_nodes[var_name]?
          if updated_val = ctx.lookup_local(var_name)
            phi.add_incoming(incr_block, updated_val)
          end
        end
      end

      ctx.terminate(Jump.new(cond_block))

      # Exit block
      ctx.current_block = exit_block
      phi_nodes.each do |var_name, phi|
        ctx.register_local(var_name, phi.id)
      end

      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    # Array map intrinsic - creates new array with transformed elements (compile-time size)
    # Uses inline expansion for small arrays, creating ArrayLiteral with transformed values
    private def lower_array_map_intrinsic(
      ctx : LoweringContext,
      array_id : ValueId,
      array_size : Int32,
      block : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      # Get block param name
      param_name = if params = block.params
                     if first_param = params.first?
                       if pname = first_param.name
                         String.new(pname)
                       else
                         "__map_elem"
                       end
                     else
                       "__map_elem"
                     end
                   else
                     "__map_elem"
                   end

      # Get element type from source array
      source_element_type = TypeRef::INT32  # Default to Int32

      # Collect transformed values
      transformed_values = [] of ValueId
      result_element_type = TypeRef::INT32  # Will be updated based on first result

      (0...array_size).each do |i|
        # Get element: arr[i]
        index_lit = Literal.new(ctx.next_id, TypeRef::INT32, i.to_i64)
        ctx.emit(index_lit)
        ctx.register_type(index_lit.id, TypeRef::INT32)

        index_get = IndexGet.new(ctx.next_id, source_element_type, array_id, index_lit.id)
        ctx.emit(index_get)
        ctx.register_type(index_get.id, source_element_type)

        # Bind block parameter
        ctx.push_scope(ScopeKind::Block)
        ctx.register_local(param_name, index_get.id)
        ctx.register_type(index_get.id, source_element_type)

        # Lower block body to get transformed value
        result_value = lower_body(ctx, block.body)
        ctx.pop_scope

        if result_value
          transformed_values << result_value
          # Track element type from first result
          if i == 0
            result_element_type = ctx.type_of(result_value)
          end
        end
      end

      # Create new ArrayLiteral with transformed values
      arr_lit = ArrayLiteral.new(ctx.next_id, result_element_type, transformed_values)
      ctx.emit(arr_lit)
      ctx.register_type(arr_lit.id, TypeRef::POINTER)  # Arrays are pointers
      arr_lit.id
    end

    # Dynamic array map - for arrays with runtime-determined size
    # Currently falls back to returning the source array (not fully implemented)
    private def lower_array_map_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      # TODO: Implement dynamic map with runtime allocation
      # For now, just process inline similar to static case but use ArraySize
      param_name = if params = block.params
                     if first_param = params.first?
                       if pname = first_param.name
                         String.new(pname)
                       else
                         "__map_elem"
                       end
                     else
                       "__map_elem"
                     end
                   else
                     "__map_elem"
                   end

      element_type = TypeRef::INT32

      # Get size dynamically
      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      entry_block = ctx.current_block
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)

      cond_block = ctx.create_block
      body_block = ctx.create_block
      incr_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      ctx.current_block = cond_block
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, zero.id)
      ctx.emit(index_phi)

      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      index_get = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(index_get)
      ctx.register_type(index_get.id, element_type)
      ctx.register_local(param_name, index_get.id)

      # Lower block body (transformed value stored in-place for now)
      result_value = lower_body(ctx, block.body)
      ctx.pop_scope

      # Store transformed value back to source array (in-place map)
      if result_value
        index_set = IndexSet.new(ctx.next_id, element_type, array_id, index_phi.id, result_value)
        ctx.emit(index_set)
      end

      ctx.terminate(Jump.new(incr_block))

      ctx.current_block = incr_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)
      new_i = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(new_i)
      index_phi.add_incoming(incr_block, new_i.id)
      ctx.terminate(Jump.new(cond_block))

      ctx.current_block = exit_block
      # Return the modified source array
      array_id
    end

    # Select intrinsic for compile-time sized arrays with AST access
    # For [1, 2, 3].select { |x| x > 1 }, evaluates predicate at compile-time
    private def lower_array_select_intrinsic_with_ast(
      ctx : LoweringContext,
      array_literal : CrystalV2::Compiler::Frontend::ArrayLiteralNode,
      block : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      # Get block param name
      param_name = if params = block.params
                     if first_param = params.first?
                       if pname = first_param.name
                         String.new(pname)
                       else
                         "__select_elem"
                       end
                     else
                       "__select_elem"
                     end
                   else
                     "__select_elem"
                   end

      source_element_type = TypeRef::INT32  # Default to Int32

      # Try to evaluate predicate at compile-time for each element
      # Collect indices of elements that pass the predicate
      selected_indices = [] of Int32

      array_literal.elements.each_with_index do |elem_expr_id, i|
        elem_node = @arena[elem_expr_id]

        # Try to get compile-time value of element
        elem_value = extract_compile_time_int(elem_node)
        if elem_value
          # Try to evaluate predicate at compile time
          if evaluate_predicate_at_compile_time(param_name, elem_value, block)
            selected_indices << i
          end
        else
          # Can't evaluate at compile time - include element (conservative)
          selected_indices << i
        end
      end

      # Now lower only the selected elements into a new array
      selected_values = [] of ValueId
      selected_indices.each do |i|
        elem_expr_id = array_literal.elements[i]
        elem_val = lower_expr(ctx, elem_expr_id)
        selected_values << elem_val
      end

      # Create result array with only selected elements
      arr_lit = ArrayLiteral.new(ctx.next_id, source_element_type, selected_values)
      ctx.emit(arr_lit)
      ctx.register_type(arr_lit.id, TypeRef::POINTER)
      arr_lit.id
    end

    # Try to extract compile-time integer value from AST node
    private def extract_compile_time_int(node : CrystalV2::Compiler::Frontend::Node) : Int64?
      case node
      when CrystalV2::Compiler::Frontend::NumberNode
        # NumberNode stores value as Slice(UInt8)
        str_val = String.new(node.value)
        str_val.to_i64?
      else
        nil
      end
    end

    # Try to evaluate a simple predicate at compile time
    # Supports: x > n, x < n, x >= n, x <= n, x == n, x != n
    private def evaluate_predicate_at_compile_time(param_name : String, param_value : Int64, block : CrystalV2::Compiler::Frontend::BlockNode) : Bool
      # Get block body - should be a single expression
      return true if block.body.empty?

      body_expr_id = block.body.last
      body_node = @arena[body_expr_id]

      case body_node
      when CrystalV2::Compiler::Frontend::BinaryNode
        # For x > 2, structure is:
        # BinaryNode { operator: ">", left: x, right: 2 }
        op_name = String.new(body_node.operator)

        # Get left operand (should be our parameter)
        left_node = @arena[body_node.left]
        return true unless left_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)

        # Check if left is our parameter
        left_name = String.new(left_node.name)
        return true unless left_name == param_name

        # Get right operand (should be a number)
        right_node = @arena[body_node.right]
        compare_value = extract_compile_time_int(right_node)
        return true unless compare_value

        # Evaluate comparison
        case op_name
        when ">"  then param_value > compare_value
        when "<"  then param_value < compare_value
        when ">=" then param_value >= compare_value
        when "<=" then param_value <= compare_value
        when "==" then param_value == compare_value
        when "!=" then param_value != compare_value
        else
          true  # Unknown op - include element
        end
      when CrystalV2::Compiler::Frontend::CallNode
        # For method-style comparisons: x.>(2)
        callee_node = @arena[body_node.callee]

        case callee_node
        when CrystalV2::Compiler::Frontend::MemberAccessNode
          # Get operator name from member
          op_name = String.new(callee_node.member)

          # Get receiver (object of member access)
          receiver_node = @arena[callee_node.object]
          return true unless receiver_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)

          # Check if receiver is our parameter
          recv_name = String.new(receiver_node.name)
          return true unless recv_name == param_name

          # Get comparison value from args
          args = body_node.args
          return true if args.empty?

          arg_node = @arena[args.first]
          compare_value = extract_compile_time_int(arg_node)
          return true unless compare_value

          # Evaluate comparison
          case op_name
          when ">"  then param_value > compare_value
          when "<"  then param_value < compare_value
          when ">=" then param_value >= compare_value
          when "<=" then param_value <= compare_value
          when "==" then param_value == compare_value
          when "!=" then param_value != compare_value
          else
            true  # Unknown op - include element
          end
        else
          true  # Unknown callee structure
        end
      else
        true  # Can't evaluate - include element conservatively
      end
    end

    # Dynamic array select - for arrays with runtime-determined size
    # TODO: Implement full dynamic select with proper allocation
    # For now, falls back to map-style in-place filtering
    private def lower_array_select_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      # For dynamic select, we need runtime allocation which is not yet supported
      # Fall back to returning original array (partial implementation)
      # This works for cases where the array is only read, not modified
      array_id
    end

    # Lower Array#reduce { |acc, elem| ... } intrinsic
    # Reduces array to single value by iterating with accumulator
    private def lower_array_reduce_dynamic(
      ctx : LoweringContext,
      array_id : ValueId,
      block : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      # Extract block parameter names (acc, elem)
      acc_name = "__reduce_acc"
      elem_name = "__reduce_elem"
      if params = block.params
        if params.size >= 1 && (pname = params[0].name)
          acc_name = String.new(pname)
        end
        if params.size >= 2 && (pname = params[1].name)
          elem_name = String.new(pname)
        end
      end

      # Element type - use POINTER since we're typically working with objects
      element_type = TypeRef::POINTER

      # Get array size
      size_val = ArraySize.new(ctx.next_id, TypeRef::INT32, array_id)
      ctx.emit(size_val)

      # Entry block - initialize accumulator with first element
      entry_block = ctx.current_block
      one = Literal.new(ctx.next_id, TypeRef::INT32, 1_i64)
      ctx.emit(one)

      # Get first element as initial accumulator
      zero = Literal.new(ctx.next_id, TypeRef::INT32, 0_i64)
      ctx.emit(zero)
      first_elem = IndexGet.new(ctx.next_id, element_type, array_id, zero.id)
      ctx.emit(first_elem)
      ctx.register_type(first_elem.id, element_type)

      # Create blocks: cond, body, exit
      cond_block = ctx.create_block
      body_block = ctx.create_block
      exit_block = ctx.create_block

      ctx.terminate(Jump.new(cond_block))

      # Condition block - check if index < size
      ctx.current_block = cond_block

      # PHI for index (starts at 1, since we already used element 0)
      index_phi = Phi.new(ctx.next_id, TypeRef::INT32)
      index_phi.add_incoming(entry_block, one.id)
      ctx.emit(index_phi)

      # PHI for accumulator
      acc_phi = Phi.new(ctx.next_id, element_type)
      acc_phi.add_incoming(entry_block, first_elem.id)
      ctx.emit(acc_phi)
      ctx.register_type(acc_phi.id, element_type)

      # Compare index < size
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, index_phi.id, size_val.id)
      ctx.emit(cmp)
      ctx.terminate(Branch.new(cmp.id, body_block, exit_block))

      # Body block - execute reduce operation
      ctx.current_block = body_block
      ctx.push_scope(ScopeKind::Block)

      # Get current element
      curr_elem = IndexGet.new(ctx.next_id, element_type, array_id, index_phi.id)
      ctx.emit(curr_elem)
      ctx.register_type(curr_elem.id, element_type)

      # Register block parameters
      ctx.register_local(acc_name, acc_phi.id)
      ctx.register_local(elem_name, curr_elem.id)

      # Lower block body - result becomes new accumulator
      new_acc = lower_body(ctx, block.body)
      ctx.pop_scope

      # Increment index
      incr = BinaryOperation.new(ctx.next_id, TypeRef::INT32, BinaryOp::Add, index_phi.id, one.id)
      ctx.emit(incr)
      index_phi.add_incoming(body_block, incr.id)

      # Update accumulator PHI
      if new_acc
        acc_phi.add_incoming(body_block, new_acc)
      else
        acc_phi.add_incoming(body_block, acc_phi.id)
      end

      ctx.terminate(Jump.new(cond_block))

      # Exit block - return final accumulator
      ctx.current_block = exit_block
      ctx.register_type(acc_phi.id, element_type)
      acc_phi.id
    end

    # Handle String.build { |io| ... } intrinsic
    # This creates a StringBuilder, passes it to the block, and returns the final string
    private def lower_string_build_intrinsic(
      ctx : LoweringContext,
      block : CrystalV2::Compiler::Frontend::BlockNode,
      capacity_id : ValueId?
    ) : ValueId
      # Extract block parameter name (typically "io")
      io_name = "io"
      if params = block.params
        if first_param = params.first?
          if pname = first_param.name
            io_name = String.new(pname)
          end
        end
      end

      builder_type = type_ref_for_name("String::Builder")
      capacity_value = capacity_id
      unless capacity_value
        default_capacity = Literal.new(ctx.next_id, TypeRef::INT32, 64_i64)
        ctx.emit(default_capacity)
        ctx.register_type(default_capacity.id, TypeRef::INT32)
        capacity_value = default_capacity.id
      end

      builder_ctor = mangle_function_name("String::Builder.new", [ctx.type_of(capacity_value)])
      remember_callsite_arg_types(builder_ctor, [ctx.type_of(capacity_value)])
      lower_function_if_needed(builder_ctor)

      builder_call = Call.new(ctx.next_id, builder_type, nil, builder_ctor, [capacity_value])
      ctx.emit(builder_call)
      ctx.register_type(builder_call.id, builder_type)

      # Create a scope for the block
      ctx.push_scope(ScopeKind::Block)

      # Register the block parameter "io" as the builder instance
      ctx.register_local(io_name, builder_call.id)
      ctx.register_type(builder_call.id, builder_type)
      update_typeof_local(io_name, builder_type)
      update_typeof_local_name(io_name, "String::Builder")

      # Lower the block body
      # The block will contain operations like io << "text"
      last_value = lower_body(ctx, block.body)

      ctx.pop_scope

      to_s_name = resolve_method_call(ctx, builder_call.id, "to_s", [] of TypeRef)
      remember_callsite_arg_types(to_s_name, [] of TypeRef)
      lower_function_if_needed(to_s_name)
      to_s_call = Call.new(ctx.next_id, TypeRef::STRING, builder_call.id, to_s_name, [] of ValueId)
      ctx.emit(to_s_call)
      ctx.register_type(to_s_call.id, TypeRef::STRING)
      to_s_call.id
    end

    # Inline Object#tap with a BlockNode
    # tap yields self to the block then returns self
    # Example: fd.tap { |x| x.flush_on_newline=(true) }
    #   => fd.flush_on_newline=(true); fd
    private def inline_tap_with_block(
      ctx : LoweringContext,
      receiver_id : ValueId,
      block_node : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      ctx.push_scope(ScopeKind::Block)

      # Bind block params to receiver_id
      if params = block_node.params
        params.each_with_index do |param, i|
          param_name = if param.name
                         String.new(param.name.not_nil!)
                       else
                         "_block_param_#{i}"
                       end
          ctx.register_local(param_name, receiver_id)
          ctx.register_type(receiver_id, ctx.type_of(receiver_id))
        end
      end

      # Execute block body
      if body = block_node.body
        body.each do |expr_id|
          lower_expr(ctx, expr_id)
        end
      end

      ctx.pop_scope
      # tap returns self
      receiver_id
    end

    # Inline Object#tap with a ProcLiteralNode (&.something syntax)
    # tap yields self to the block then returns self
    # Example: fd.tap(&.flush_on_newline=(true))
    #   => fd.flush_on_newline=(true); fd
    private def inline_tap_with_proc(
      ctx : LoweringContext,
      receiver_id : ValueId,
      proc_node : CrystalV2::Compiler::Frontend::ProcLiteralNode
    ) : ValueId
      ctx.push_scope(ScopeKind::Block)

      # The proc body is like: x.flush_on_newline=(true)
      # where x is the implicit block param that should be bound to receiver_id
      if body = proc_node.body
        # For short block syntax &.method, the body is a single call where
        # the first param becomes the receiver. We need to evaluate it with
        # the receiver bound as the implicit block param.
        if params = proc_node.params
          # Bind each block param - for &.method, there's typically one implicit param
          params.each_with_index do |param, i|
            param_name = if param.name
                           String.new(param.name.not_nil!)
                         else
                           "_block_param_#{i}"
                         end
            ctx.register_local(param_name, receiver_id)
            ctx.register_type(receiver_id, ctx.type_of(receiver_id))
          end
        end

        # If no explicit params, the &.method syntax uses the receiver directly
        # The body should be evaluated in current context
        body.each do |expr_id|
          lower_expr(ctx, expr_id)
        end
      end

      ctx.pop_scope
      # tap returns self
      receiver_id
    end

    private def inline_try_with_block(
      ctx : LoweringContext,
      receiver_id : ValueId,
      receiver_type : TypeRef,
      block_node : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      inline_try_core(ctx, receiver_id, receiver_type) do |non_nil_id|
        ctx.push_scope(ScopeKind::Block)

        if params = block_node.params
          params.each_with_index do |param, i|
            param_name = if param.name
                           String.new(param.name.not_nil!)
                         else
                           "_block_param_#{i}"
                         end
            ctx.register_local(param_name, non_nil_id)
            ctx.register_type(non_nil_id, ctx.type_of(non_nil_id))
          end
        end

        value_id = if body = block_node.body
                     lower_body(ctx, body)
                   else
                     nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                     ctx.emit(nil_lit)
                     nil_lit.id
                   end

        ctx.pop_scope
        value_id
      end
    end

    private def inline_try_with_proc(
      ctx : LoweringContext,
      receiver_id : ValueId,
      receiver_type : TypeRef,
      proc_node : CrystalV2::Compiler::Frontend::ProcLiteralNode
    ) : ValueId
      inline_try_core(ctx, receiver_id, receiver_type) do |non_nil_id|
        ctx.push_scope(ScopeKind::Block)

        if params = proc_node.params
          params.each_with_index do |param, i|
            param_name = if param.name
                           String.new(param.name.not_nil!)
                         else
                           "_block_param_#{i}"
                         end
            ctx.register_local(param_name, non_nil_id)
            ctx.register_type(non_nil_id, ctx.type_of(non_nil_id))
          end
        end

        value_id = if body = proc_node.body
                     lower_body(ctx, body)
                   else
                     nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
                     ctx.emit(nil_lit)
                     nil_lit.id
                   end

        ctx.pop_scope
        value_id
      end
    end

    private def inline_try_core(
      ctx : LoweringContext,
      receiver_id : ValueId,
      receiver_type : TypeRef
    ) : ValueId
      nil_check = lower_nil_check_intrinsic(ctx, receiver_id, receiver_type)
      nil_block = ctx.create_block
      value_block = ctx.create_block
      merge_block = ctx.create_block

      ctx.terminate(Branch.new(nil_check, nil_block, value_block))

      # Nil branch
      ctx.current_block = nil_block
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_exit_block = ctx.current_block
      ctx.terminate(Jump.new(merge_block))

      # Non-nil branch
      ctx.current_block = value_block
      non_nil_id = lower_not_nil_intrinsic(ctx, receiver_id, receiver_type)
      non_nil_type = non_nil_type_for_union(receiver_type)
      original_type : TypeRef? = nil
      if non_nil_type && non_nil_type != receiver_type
        original_type = ctx.type_of(receiver_id)
        ctx.register_type(receiver_id, non_nil_type)
      end

      value_id = yield non_nil_id

      if original_type
        ctx.register_type(receiver_id, original_type.not_nil!)
      end

      value_exit_block = ctx.current_block
      block_data = ctx.get_block(value_exit_block)
      value_has_noreturn = block_data.instructions.any? { |inst| inst.is_a?(Raise) || inst.is_a?(Return) }
      value_flows_to_merge = block_data.terminator.is_a?(Unreachable) && !value_has_noreturn
      if value_flows_to_merge
        ctx.terminate(Jump.new(merge_block))
      end

      # Merge
      ctx.current_block = merge_block

      unless value_flows_to_merge
        return nil_lit.id
      end

      value_type = ctx.type_of(value_id)
      if value_type == TypeRef::VOID || value_type == TypeRef::NIL
        return nil_lit.id
      end

      phi_type = is_union_or_nilable_type?(value_type) ? value_type : create_union_type_for_nullable(value_type)
      phi = Phi.new(ctx.next_id, phi_type)
      phi.add_incoming(nil_exit_block, nil_lit.id)
      phi.add_incoming(value_exit_block, value_id)
      ctx.emit(phi)
      ctx.register_type(phi.id, phi_type)
      phi.id
    end

    # Emit a normal call for yield functions when inlining is unsafe.
    private def inline_yield_fallback_call(
      ctx : LoweringContext,
      inline_key : String,
      receiver_id : ValueId?,
      call_args : Array(ValueId),
      block : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      return_type = get_function_return_type(inline_key)
      block_id = lower_block_to_block_id(ctx, block)
      call = Call.new(ctx.next_id, return_type, receiver_id, inline_key, call_args, block_id)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      ctx.pop_scope
      call.id
    end

    # Inline a yield-function call with block
    # Transforms: func(args) { |params| block_body }
    # Into: inline func body, replacing yield with block_body
    private def inline_yield_function(
      ctx : LoweringContext,
      func_def : CrystalV2::Compiler::Frontend::DefNode,
      inline_key : String,
      receiver_id : ValueId?,
      call_args : Array(ValueId),
      block : CrystalV2::Compiler::Frontend::BlockNode,
      callee_arena : CrystalV2::Compiler::Frontend::ArenaLike
    ) : ValueId
      ctx.push_scope(ScopeKind::Block)

      # Prevent infinite recursion / runaway stack usage in aggressive yield inlining.
      # This can happen in stdlib where yield is used deeply (or recursively).
      # Keep inline expansion bounded to avoid runaway lowering on deep stdlib chains.
      max_depth = (ENV["INLINE_YIELD_MAX_DEPTH"]? || "16").to_i
      max_repeat = (ENV["INLINE_YIELD_MAX_REPEAT"]? || "2").to_i
      caller_arena = @arena
      repeat_count = @inline_yield_name_stack.count(inline_key)
      if @inline_yield_name_stack.size >= max_depth || repeat_count >= max_repeat
        if ENV.has_key?("DEBUG_YIELD_INLINE")
          STDERR.puts "[INLINE_YIELD] skipping inline: #{inline_key} (depth=#{@inline_yield_name_stack.size}, max=#{max_depth}, repeat=#{repeat_count}, max_repeat=#{max_repeat})"
        end
        return inline_yield_fallback_call(ctx, inline_key, receiver_id, call_args, block)
      end
      base_inline_name = inline_key.split("$", 2)[0]
      if receiver = receiver_name_from_method_name(base_inline_name)
        if unresolved_generic_receiver?(receiver)
          debug_hook("inline.yield.skip", "callee=#{inline_key} receiver=#{receiver} reason=unresolved_generic")
          return inline_yield_fallback_call(ctx, inline_key, receiver_id, call_args, block)
        end
      end
      if ENV["DEBUG_YIELD_INLINE_ALL"]?
        STDERR.puts "[INLINE_YIELD] inline #{inline_key} in #{ctx.function.name}"
      end
      if ENV["DEBUG_YIELD_TRACE"]? && (inline_key.includes?("char_at") || inline_key.includes?("fetch") || inline_key.includes?("upto"))
        STDERR.puts "[INLINE_YIELD] inline #{inline_key} in #{ctx.function.name}"
      end

      if ENV["DEBUG_INLINE_CRASH"]? && base_inline_name == "Char::Reader#decode_char_at"
        STDERR.puts "[INLINE_CRASH] callee=#{inline_key} caller=#{ctx.function.name} arena=#{callee_arena.size}"
      end

      block_arena = resolve_arena_for_block(block, caller_arena)
      unless block_arena
        debug_hook("inline.yield.block_arena_missing", "callee=#{inline_key} caller=#{ctx.function.name}")
        return inline_yield_fallback_call(ctx, inline_key, receiver_id, call_args, block)
      end
      unless block.body.empty?
        max_index = block.body.max_of(&.index)
        if max_index < 0 || max_index >= block_arena.size
          debug_hook(
            "inline.yield.block_arena_mismatch",
            "callee=#{inline_key} max=#{max_index} arena=#{block_arena.size}"
          )
          return inline_yield_fallback_call(ctx, inline_key, receiver_id, call_args, block)
        end
      end

      if func_body = func_def.body
        unless func_body.empty?
          max_index = func_body.max_of(&.index)
          if ENV["DEBUG_INLINE_CRASH"]? && base_inline_name == "Char::Reader#decode_char_at"
            STDERR.puts "[INLINE_CRASH] callee=#{inline_key} body_size=#{func_body.size} max_index=#{max_index}"
          end
          if max_index < 0 || max_index >= callee_arena.size
            debug_hook("inline.yield.arena_mismatch", "callee=#{inline_key} max=#{max_index} arena=#{callee_arena.size}")
            return inline_yield_fallback_call(ctx, inline_key, receiver_id, call_args, block)
          end
        end
      end

      old_inline_arenas = @inline_arenas
      if old_inline_arenas
        combined = old_inline_arenas.dup
        combined << caller_arena unless combined.includes?(caller_arena)
        combined << callee_arena unless combined.includes?(callee_arena)
        combined << block_arena unless combined.includes?(block_arena)
        @inline_arenas = combined
      else
        @inline_arenas = [caller_arena, callee_arena, block_arena]
      end
      @arena = callee_arena

      # Isolate callee locals from caller locals, but keep caller locals available for block bodies.
      caller_locals = ctx.save_locals
      @inline_caller_locals_stack << caller_locals
      ctx.restore_locals({} of String => ValueId)

      begin
        pushed_name = false
        pushed_block = false
        pushed_override = false

        @inline_yield_name_stack << inline_key
        pushed_name = true
        if @inline_yield_block_body_depth > 0
          @inline_yield_return_override_stack << InlineReturnOverride.new(false, nil)
          pushed_override = true
        end
        @inline_yield_block_stack << block
        @inline_yield_block_arena_stack << block_arena
        pushed_block = true
        inline_return = InlineReturnContext.new(ctx.create_block, [] of {BlockId, ValueId}, ctx.function.id)
        @inline_yield_return_stack << inline_return

        old_current_class = @current_class
        old_current_method = @current_method
        old_current_method_is_class = @current_method_is_class
        @inline_caller_class_stack << old_current_class
        @inline_caller_method_stack << old_current_method
        @inline_caller_method_is_class_stack << old_current_method_is_class
        @inline_caller_type_param_map_stack << @type_param_map.dup
        if base_inline_name.includes?("#")
          owner, method = base_inline_name.split("#", 2)
          unless owner.empty?
            @current_class = owner
            @current_method = method unless method.empty?
            @current_method_is_class = false
          end
        elsif base_inline_name.includes?(".")
          owner, method = base_inline_name.split(".", 2)
          unless owner.empty?
            @current_class = owner
            @current_method = method unless method.empty?
            @current_method_is_class = true
          end
        end
        inline_param_map = type_param_map_for_receiver_name(base_inline_name)
        result_value = nil_value(ctx)
        apply_inline = -> do
          # If inlining an instance method, bind the receiver as `self`.
          if receiver_id
            ctx.register_local("self", receiver_id)
            ctx.register_type(receiver_id, ctx.type_of(receiver_id))
          end

          # Bind function parameters to call arguments
          if params = func_def.params
            params.each_with_index do |param, idx|
              if pname = param.name
                param_name = String.new(pname)
                if idx < call_args.size
                  ctx.register_local(param_name, call_args[idx])
                end
              end
            end
          end

          # Lower function body with yield substitution
          if inline_body = func_def.body
            result_value = lower_body(ctx, inline_body)
          end
        end
        if inline_param_map.empty?
          apply_inline.call
        else
          with_type_param_map(inline_param_map) do
            apply_inline.call
          end
        end

        if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
          ctx.terminate(Jump.new(inline_return.exit_block))
          inline_return.incoming << {ctx.current_block, result_value}
        end

        ctx.switch_to_block(inline_return.exit_block)

        begin
          if inline_return.incoming.empty?
            nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
            ctx.emit(nil_lit)
            nil_lit.id
          elsif inline_return.incoming.size == 1
            inline_return.incoming.first[1]
          else
            value_types = inline_return.incoming.map { |(_, val)| ctx.type_of(val) }.reject { |t| t == TypeRef::VOID }.uniq
            phi_type = value_types.first? || TypeRef::VOID

            if value_types.size > 1 && !value_types.all? { |t| numeric_primitive?(t) }
              if union_ref = find_covering_union_type(value_types)
                phi_type = union_ref
              else
                value_names = value_types.map { |t| get_type_name_from_ref(t) }.uniq
                if ENV.has_key?("DEBUG_INLINE_RETURN")
                  STDERR.puts "[INLINE_RETURN] callee=#{inline_key} types=#{value_names.join(",")}"
                end
                union_name = value_names.join(" | ")
                phi_type = create_union_type(union_name)
              end
            end

            coerced_incoming = inline_return.incoming.map do |(blk, val)|
              val_type = ctx.type_of(val)
              if val_type == phi_type
                {blk, val}
              elsif is_union_type?(phi_type)
                variant_id = get_union_variant_id(phi_type, val_type)
                if variant_id >= 0
                  wrap = UnionWrap.new(ctx.next_id, phi_type, val, variant_id)
                  ctx.emit_to_block(blk, wrap)
                  {blk, wrap.id}
                else
                  {blk, val}
                end
              elsif numeric_primitive?(val_type) && numeric_primitive?(phi_type)
                cast = Cast.new(ctx.next_id, phi_type, val, phi_type, safe: false)
                ctx.emit_to_block(blk, cast)
                {blk, cast.id}
              else
                {blk, val}
              end
            end

            if phi_type == TypeRef::VOID || phi_type == TypeRef::NIL
              nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
              ctx.emit(nil_lit)
              nil_lit.id
            else
              phi = Phi.new(ctx.next_id, phi_type)
              coerced_incoming.each { |(blk, val)| phi.add_incoming(blk, val) }
              ctx.emit(phi)
              phi.id
            end
          end
        rescue ex
          if ENV.has_key?("DEBUG_INLINE_RETURN")
            STDERR.puts "[INLINE_RETURN] error=#{ex.message} callee=#{inline_key} func=#{ctx.function.name} incoming=#{inline_return.incoming.size} blocks=#{ctx.function.blocks.size}"
            inline_return.incoming.each do |(blk, val)|
              STDERR.puts "[INLINE_RETURN]   blk=#{blk} val=%#{val} type=#{get_type_name_from_ref(ctx.type_of(val))}"
            end
          end
          raise ex
        end
      ensure
        @current_class = old_current_class
        @current_method = old_current_method
        @current_method_is_class = old_current_method_is_class || false
        @inline_caller_class_stack.pop?
        @inline_caller_method_stack.pop?
        @inline_caller_method_is_class_stack.pop?
        @inline_caller_type_param_map_stack.pop?
        @inline_yield_block_stack.pop? if pushed_block
        @inline_yield_block_arena_stack.pop? if pushed_block
        @inline_yield_name_stack.pop? if pushed_name
        @inline_yield_return_stack.pop?
        @inline_yield_return_override_stack.pop? if pushed_override
        # Restore caller locals (including any mutations made inside the inlined block body).
        if restored = @inline_caller_locals_stack.pop?
          ctx.restore_locals(restored)
        end
        @arena = caller_arena
        @inline_arenas = old_inline_arenas
        ctx.pop_scope
      end
    end

    # Inline block body in place of yield
    private def inline_block_body(
      ctx : LoweringContext,
      yield_node : CrystalV2::Compiler::Frontend::YieldNode,
      block : CrystalV2::Compiler::Frontend::BlockNode
    ) : ValueId
      @inline_yield_block_body_depth += 1
      pushed_override = false
      begin
        base_override = nil
        if active_entry = @inline_yield_return_override_stack.reverse.find(&.active)
          base_override = active_entry.context
        elsif @inline_yield_return_stack.size > 1
          base_override = @inline_yield_return_stack[-2]
        end
        @inline_yield_return_override_stack << InlineReturnOverride.new(true, base_override)
        pushed_override = true

        # Lower yield arguments
        yield_args = if args = yield_node.args
                       args.reject(&.invalid?).map { |arg| lower_expr(ctx, arg) }
                     else
                       [] of ValueId
                     end

      # Lower block body
      # For inlined yield-functions, the block body must run in the *caller* lexical scope
      # (caller locals, caller `self`). Otherwise ivar access inside the block can target
      # the callee receiver (e.g. `tap` receiver) and generate invalid IR.
      result = if caller_locals = @inline_caller_locals_stack.last?
        old_inline_class = @current_class
        old_inline_method = @current_method
        old_inline_method_is_class = @current_method_is_class
        old_type_param_map = @type_param_map
        @current_class = @inline_caller_class_stack.last?
        @current_method = @inline_caller_method_stack.last?
        @current_method_is_class = @inline_caller_method_is_class_stack.last? || false
        if caller_type_map = @inline_caller_type_param_map_stack.last?
          @type_param_map = caller_type_map
        end
        begin
          saved_callee_locals = ctx.save_locals
          ctx.restore_locals(caller_locals)

          caller_locals_before_params = ctx.save_locals
          param_names = [] of String
          if params = block.params
            params.each do |param|
              if pname = param.name
                param_names << String.new(pname)
              end
            end
          end

          # Bind block parameters to yield arguments (in caller scope).
          param_names.each_with_index do |param_name, idx|
            next unless idx < yield_args.size
            ctx.register_local(param_name, yield_args[idx])
            arg_id = yield_args[idx]
            ctx.register_type(arg_id, ctx.type_of(arg_id))
          end

          # Ensure block body is lowered in the caller arena, even when the callee comes from another file.
          body_result = begin
            # The block body belongs to the *caller* and may itself contain `yield`.
            # Temporarily disable the current inlined-yield substitution so nested `yield`
            # in the block body can bind to an outer inlining context (if any).
            popped_block = @inline_yield_block_stack.pop?
            popped_arena = @inline_yield_block_arena_stack.pop?
            if popped_block && popped_block.object_id != block.object_id
              # Unexpected mismatch; restore stacks and continue without popping.
              @inline_yield_block_stack << popped_block
              @inline_yield_block_arena_stack << popped_arena if popped_arena
              popped_block = nil
              popped_arena = nil
            end

            old_arena = @arena
            begin
              block_arena = resolve_arena_for_block(block, old_arena)
              chosen_arena = block_arena || popped_arena || @inline_yield_block_arena_stack.last? || old_arena
              @arena = chosen_arena
              begin
                lower_body(ctx, block.body)
              ensure
                @arena = old_arena
              end
            ensure
              if popped_block
                @inline_yield_block_stack << popped_block
                if restored_arena = popped_arena
                  @inline_yield_block_arena_stack << restored_arena
                else
                  @inline_yield_block_arena_stack << old_arena
                end
              end
            end
          end

          caller_locals_after = ctx.save_locals
          # Block parameters must not leak outside the block.
          param_names.each do |name|
            if prev = caller_locals_before_params[name]?
              caller_locals_after[name] = prev
            else
              caller_locals_after.delete(name)
            end
          end

          # If we're in an inline loop context, keep phi-bound locals stable across iterations.
          if loop_vars = inline_loop_vars_union
            loop_vars.each do |name|
              if prev = caller_locals[name]?
                caller_locals_after[name] = prev
              else
                caller_locals_after.delete(name)
              end
            end
          end
          @inline_caller_locals_stack[-1] = caller_locals_after

          ctx.restore_locals(saved_callee_locals)
          body_result
        ensure
          @current_class = old_inline_class
          @current_method = old_inline_method
          @current_method_is_class = old_inline_method_is_class || false
          @type_param_map = old_type_param_map
        end
      else
        # No yield inlining context; just lower block normally.
        if arenas = @inline_arenas
          candidate = arenas[0]
          chosen = candidate
          unless block.body.empty?
            max_index = block.body.max_of(&.index)
            if max_index < 0 || max_index >= candidate.size
              chosen = @arena
            end
          end

          old_arena = @arena
          @arena = chosen
          begin
            lower_body(ctx, block.body)
          ensure
            @arena = old_arena
          end
        else
          lower_body(ctx, block.body)
        end
      end

      if ENV["DEBUG_INLINE_BLOCK_RESULT"]?
        inline_name = @inline_yield_name_stack.last? || ""
        if inline_name.includes?("decode_char_before")
          result_type = result ? ctx.type_of(result) : TypeRef::VOID
          yield_types = yield_args.map { |arg_id| get_type_name_from_ref(ctx.type_of(arg_id)) }
          STDERR.puts "[INLINE_BLOCK_RESULT] callee=#{inline_name} result=#{get_type_name_from_ref(result_type)} yield=#{yield_types.join(",")}"
        end
      end

      # If the block body didn't infer a result type, fall back to a non-void arg type.
      if result && ctx.type_of(result) == TypeRef::VOID
        yield_args.each do |arg_id|
          arg_type = ctx.type_of(arg_id)
          next if arg_type == TypeRef::VOID
          ctx.register_type(result, arg_type)
          break
        end
      end

        result
      ensure
        @inline_yield_return_override_stack.pop? if pushed_override
        @inline_yield_block_body_depth -= 1
      end
    end

    # Helper to create nil value
    private def nil_value(ctx : LoweringContext) : ValueId
      nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
      ctx.emit(nil_lit)
      nil_lit.id
    end

    private def lower_index(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::IndexNode) : ValueId
      object_id = lower_expr(ctx, node.object)

      # Check if any index is a Range - if so, this is a slice operation
      # Need to check BEFORE lowering the indices so we can handle Range specially
      if node.indexes.size == 1
        idx_node = @arena[node.indexes.first]
        if idx_node.is_a?(CrystalV2::Compiler::Frontend::RangeNode)
          # Array slice: arr[start..end] -> call Array#[] with range, returns Array
          # For bootstrap, emit as a method call to the slice variant
          start_id = lower_expr(ctx, idx_node.begin_expr)
          end_id = lower_expr(ctx, idx_node.end_expr)

          # Emit a call to an intrinsic that creates a slice
          # For now, create a new array and copy elements
          # Qualify method name with receiver's class
          start_type = ctx.type_of(start_id)
          end_type = ctx.type_of(end_id)
          method_name = resolve_method_call(ctx, object_id, "[]", [start_type, end_type])
          call = Call.new(ctx.next_id, TypeRef::POINTER, object_id, method_name, [start_id, end_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::POINTER)
          return call.id
        end
      end

      # IndexNode has indexes (Array) - can be multi-dimensional like arr[1, 2]
      index_ids = node.indexes.map { |idx| lower_expr(ctx, idx) }

      # Check if this is an array by looking at the object node (ArrayLiteral check)
      # This is necessary because arrays are typed as POINTER but should use IndexGet
      obj_node = @arena[node.object]
      is_array_literal = obj_node.is_a?(CrystalV2::Compiler::Frontend::ArrayLiteralNode)
      # Also check if object is an identifier that was assigned an array
      if !is_array_literal && obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
        # Check if the emitted HIR instruction is an ArrayLiteral
        # (This is a simple check - for now just assume POINTER type without explicit Pointer(T) is an array)
        object_type = ctx.type_of(object_id)
        type_desc = @module.get_type_descriptor(object_type)
        # If it's POINTER but NOT Pointer(T), treat as array
        if object_type == TypeRef::POINTER && !(type_desc && type_desc.name.starts_with?("Pointer"))
          is_array_literal = true
        end
      end

      # Array indexing: use IndexGet for element access
      if is_array_literal && index_ids.size == 1
        element_type = TypeRef::INT32  # Default element type
        index_get = IndexGet.new(ctx.next_id, element_type, object_id, index_ids.first)
        ctx.emit(index_get)
        ctx.register_type(index_get.id, element_type)
        return index_get.id
      end

      # Check if this is pointer indexing (ptr[i])
      object_type = ctx.type_of(object_id)
      type_desc = @module.get_type_descriptor(object_type)
      is_pointer_type = object_type == TypeRef::POINTER ||
                        (type_desc && type_desc.kind == TypeKind::Pointer) ||
                        (type_desc && type_desc.name.starts_with?("Pointer"))
      if is_pointer_type && index_ids.size == 1
        # Pointer indexing: ptr[i] -> PointerLoad with index
        # Extract element type from Pointer(T) if available
        deref_type = if type_desc && type_desc.name.starts_with?("Pointer(")
                       elem_name = type_desc.name[8, type_desc.name.size - 9]
                       type_ref_for_name(elem_name)
                     else
                       TypeRef::INT32
                     end
        load_node = PointerLoad.new(ctx.next_id, deref_type, object_id, index_ids.first)
        ctx.emit(load_node)
        ctx.register_type(load_node.id, deref_type)
        return load_node.id
      end

      # Check if this is an array-like type (which uses IndexGet for element access)
      is_array_type = type_desc && (type_desc.kind == TypeKind::Array ||
                                     type_desc.name.starts_with?("Array") ||
                                     type_desc.name.starts_with?("StaticArray"))

      if is_array_type && index_ids.size == 1
        # Array element access: arr[i] -> IndexGet
        # Prefer the array's element type from the interned TypeDescriptor params.
        # Arrays are represented as POINTER at runtime, so we must carry element type explicitly.
        element_type = type_desc.not_nil!.type_params.first? || TypeRef::INT32
        element_type = TypeRef::INT32 if element_type == TypeRef::VOID

        index_get = IndexGet.new(ctx.next_id, element_type, object_id, index_ids.first)
        ctx.emit(index_get)
        ctx.register_type(index_get.id, element_type)
        index_get.id
      else
        # Everything else (classes like Hash, custom types): call [] method
        # Resolve the method name properly (with class name and mangling)
        arg_types = index_ids.map { |idx| ctx.type_of(idx) }
        method_name = resolve_method_call(ctx, object_id, "[]", arg_types)
        # Ensure the target function is lowered (IndexNode bypasses lower_call).
        object_type = ctx.type_of(object_id)
        type_desc = @module.get_type_descriptor(object_type)
        class_name = type_desc.try(&.name) || primitive_class_name(object_type) || ""
        class_name = normalize_method_owner_name(class_name)
        base_method_name = class_name.empty? ? "[]" : "#{class_name}#[]"
        primary_mangled_name = mangle_function_name(base_method_name, arg_types)
        remember_callsite_arg_types(primary_mangled_name, arg_types)
        if method_name != primary_mangled_name
          remember_callsite_arg_types(method_name, arg_types)
        end
        callsite_label = nil
        if DebugHooks::ENABLED
          span = node.span
          receiver_name = type_name_for_mangling(ctx.type_of(object_id))
          callsite_label = "func=#{ctx.function.name} method=[] full=#{method_name} class=#{@current_class || ""} recv=#{receiver_name} span=#{span.start_line}:#{span.start_column}-#{span.end_line}:#{span.end_column}"
        end
        with_debug_callsite(callsite_label) do
          lower_function_if_needed(primary_mangled_name)
          if method_name != primary_mangled_name
            lower_function_if_needed(method_name)
          end
        end
        return_type = get_function_return_type(method_name)
        # Fallback: [] typically returns a value (element or subslice)
        if return_type == TypeRef::VOID
          return_type = TypeRef::POINTER
        end
        call = Call.new(ctx.next_id, return_type, object_id, method_name, index_ids)
        ctx.emit(call)
        ctx.register_type(call.id, return_type)
        call.id
      end
    end

    private def lower_enum_predicate(ctx : LoweringContext, object_id : ValueId, member_name : String) : ValueId?
      return nil unless member_name.ends_with?("?")
      if ENV["DEBUG_ENUM_PREDICATE"]? && member_name == "character_device?"
        enum_hit = @enum_value_types.try(&.[object_id]?)
        STDERR.puts "[DEBUG_ENUM_PREDICATE] member=#{member_name} object_id=#{object_id} enum=#{enum_hit || "(nil)"}"
      end
      enum_name = @enum_value_types.try(&.[object_id]?)
      return nil unless enum_name
      members = enum_members_for_type_name(enum_name)
      return nil unless members

      # Try to match the predicate to an enum member (e.g., "data1?" -> "Data1").
      base_name = member_name[0...-1]
      target = underscore_lower(base_name)
      member_match = members.keys.find { |m| underscore_lower(m) == target }
      return nil unless member_match

      member_value = members[member_match]
      enum_type = enum_base_type(enum_name)
      lit = Literal.new(ctx.next_id, enum_type, member_value)
      ctx.emit(lit)
      ctx.register_type(lit.id, enum_type)
      cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, object_id, lit.id)
      ctx.emit(cmp)
      ctx.register_type(cmp.id, TypeRef::BOOL)
      cmp.id
    end

    private def lower_member_access(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::MemberAccessNode) : ValueId
      obj_node = @arena[node.object]
      member_name = String.new(node.member)
      if ENV["DEBUG_ENUM_PREDICATE"]? && member_name == "character_device?"
        STDERR.puts "[DEBUG_ENUM_CALL_PATH] lower_member_access method=#{member_name} object=#{obj_node.class.name}"
      end

      # Check if this is a class/module static call like Counter.new (without parens)
      # Similar logic to lower_call for MemberAccessNode
      class_name_str : String? = nil

      if obj_node.is_a?(CrystalV2::Compiler::Frontend::ConstantNode)
        name = String.new(obj_node.name)
        resolved_name = resolve_class_name_in_context(name)
        resolved_name = resolve_type_alias_chain(resolved_name)
        if type_name_exists?(resolved_name) || primitive_self_type(resolved_name)
          class_name_str = resolved_name
        elsif is_module_method?(resolved_name, member_name)
          class_name_str = resolved_name
        end
      elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::IdentifierNode)
        name = String.new(obj_node.name)
        # Resolve type alias if exists (check both @type_aliases and LIBC_TYPE_ALIASES)
        resolved_name = @type_aliases[name]? || LIBC_TYPE_ALIASES[name]? || name
        # Chain resolve if needed - max 10 iterations
        depth = 0
        while (next_resolved = @type_aliases[resolved_name]? || LIBC_TYPE_ALIASES[resolved_name]?) && next_resolved != resolved_name && depth < 10
          resolved_name = next_resolved
          depth += 1
        end
        if resolved_name[0].uppercase?
          resolved_name = resolve_class_name_in_context(resolved_name)
          if @class_info.has_key?(resolved_name) ||
             @enum_info.try(&.has_key?(resolved_name)) ||
             is_module_method?(resolved_name, member_name)
            class_name_str = resolved_name
          end
        end
      elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::GenericNode)
        # Generic type like Hash(Int32, Int32).new
        base_name = resolve_path_like_name(obj_node.base_type)
        if base_name
          base_name = resolve_type_name_in_context(base_name)
          base_name = resolve_type_alias_chain(base_name)
          normalize_typeof_name = ->(type_name : String) : String {
            if type_name == "Void" || type_name == "Unknown" || type_name.includes?("|")
              "Pointer(Void)"
            else
              type_name
            end
          }

          type_args = obj_node.type_args.map do |arg_id|
            arg_name = stringify_type_expr(arg_id) || "Unknown"
            arg_name = resolve_typeof_in_type_string(arg_name)
            arg_name = normalize_typeof_name.call(arg_name)
            arg_name = resolve_type_name_in_context(arg_name)
            substitute_type_params_in_type_name(arg_name)
          end
          # Create specialized class name like Hash(Int32, Int32)
          class_name_str = "#{base_name}(#{type_args.join(", ")})"
          class_name_str = substitute_type_params_in_type_name(class_name_str)
          # Monomorphize generic class if not already done
          if !@monomorphized.includes?(class_name_str)
            monomorphize_generic_class(base_name, type_args, class_name_str)
          end
        end
      elsif obj_node.is_a?(CrystalV2::Compiler::Frontend::PathNode)
        # Path like Crystal::EventLoop for nested module/class method calls
        raw_path = collect_path_string(obj_node)
        absolute_path = path_is_absolute?(obj_node)
        full_path = if absolute_path
                      raw_path.starts_with?("::") ? raw_path[2..] : raw_path
                    else
                      resolve_path_string_in_context(raw_path)
                    end
        is_constant_path = resolve_constant_name_in_context(full_path) != nil
        left_name = nil
        if left_id = obj_node.left
          left_node = @arena[left_id]
          left_name = case left_node
                      when CrystalV2::Compiler::Frontend::IdentifierNode
                        String.new(left_node.name)
                      when CrystalV2::Compiler::Frontend::ConstantNode
                        String.new(left_node.name)
                      when CrystalV2::Compiler::Frontend::PathNode
                        left_path = collect_path_string(left_node)
                        left_absolute = path_is_absolute?(left_node)
                        if left_absolute
                          left_path.starts_with?("::") ? left_path[2..] : left_path
                        else
                          resolve_path_string_in_context(left_path)
                        end
                      else
                        nil
                      end
        end
        right_node = @arena[obj_node.right]
        right_name = case right_node
                     when CrystalV2::Compiler::Frontend::IdentifierNode
                       String.new(right_node.name)
                     when CrystalV2::Compiler::Frontend::ConstantNode
                       String.new(right_node.name)
                     else
                       nil
                     end

        if !is_constant_path && left_name && right_name
          if enum_info = @enum_info
            if enum_info.has_key?(left_name) && right_name[0]?.try(&.uppercase?)
              class_name_str = nil
            else
              class_name_str = full_path
            end
          else
            class_name_str = full_path
          end
        elsif !is_constant_path
          class_name_str = full_path
        end
      end

      # If it's a static class call (like Counter.new), emit as static call
      if class_name_str
        return lower_static_member_access_call(ctx, class_name_str, member_name)
      end

      # Otherwise it's an instance method call - evaluate object first
      object_id = lower_expr(ctx, node.object)

      # Check for pointer.value -> PointerLoad
      receiver_type = ctx.type_of(object_id)
      ensure_monomorphized_type(receiver_type) unless receiver_type == TypeRef::VOID
      receiver_is_type_literal = receiver_type.id >= TypeRef::FIRST_USER_TYPE &&
                                 ctx.type_literal?(object_id)
      if member_name == "unsafe_chr" && ENV["DEBUG_UNSAFE_CHR"]?
        STDERR.puts "[UNSAFE_CHR] receiver=#{get_type_name_from_ref(receiver_type)}"
      end
      if receiver_is_type_literal
        class_name = nil
        if info = class_info_for_type(receiver_type)
          class_name = info.name
        elsif desc = @module.get_type_descriptor(receiver_type)
          class_name = desc.name unless desc.name.empty?
        end
        if class_name
          return lower_static_member_access_call(ctx, class_name, member_name)
        end
      end

      if member_name == "value"
        if @enum_value_types.try(&.[object_id]?)
          return object_id
        end
      end

      # Handle enum predicate methods (.data1?, .block?, etc.)
      # These should compile to `value == Enum::Member` comparisons, not function calls
      if member_name.ends_with?("?")
        if predicate_id = lower_enum_predicate(ctx, object_id, member_name)
          return predicate_id
        end
      end

      # Direct ivar access on another object (obj.@ivar) - use field get.
      if member_name.starts_with?("@")
        if info = class_info_for_type(receiver_type)
          if ivar_info = info.ivars.find { |iv| iv.name == member_name }
            field_get = FieldGet.new(ctx.next_id, ivar_info.type, object_id, member_name, ivar_info.offset)
            ctx.emit(field_get)
            ctx.register_type(field_get.id, ivar_info.type)
            return field_get.id
          end
        end
        module_type_name = get_type_name_from_ref(receiver_type)
        if resolved = resolve_module_typed_ivar(module_type_name, member_name)
          _info, ivar_info = resolved
          field_get = FieldGet.new(ctx.next_id, ivar_info.type, object_id, member_name, ivar_info.offset)
          ctx.emit(field_get)
          ctx.register_type(field_get.id, ivar_info.type)
          return field_get.id
        end
      end

      # Lib struct field access (action.sa_mask) should lower to a direct field get.
      if info = class_info_for_type(receiver_type)
        if info.is_struct && @lib_structs.includes?(info.name)
          if ivar_info = info.ivars.find { |iv| iv.name == member_name || iv.name == "@#{member_name}" }
            field_get = FieldGet.new(ctx.next_id, ivar_info.type, object_id, member_name, ivar_info.offset)
            ctx.emit(field_get)
            ctx.register_type(field_get.id, ivar_info.type)
            return field_get.id
          end
        end
      end

      # Handle nil? intrinsic for union types (T | Nil)
      if member_name == "nil?" && is_union_or_nilable_type?(receiver_type)
        return lower_nil_check_intrinsic(ctx, object_id, receiver_type)
      end

      # Handle not_nil! intrinsic for union types
      if member_name == "not_nil!" && is_union_or_nilable_type?(receiver_type)
        return lower_not_nil_intrinsic(ctx, object_id, receiver_type)
      end
      if member_name == "not_nil!" && receiver_type == TypeRef::VOID
        ctx.register_type(object_id, TypeRef::POINTER)
        return object_id
      end

      if receiver_type == TypeRef::CHAR && member_name == "ord"
        cast = Cast.new(ctx.next_id, TypeRef::INT32, object_id, TypeRef::INT32)
        ctx.emit(cast)
        ctx.register_type(cast.id, TypeRef::INT32)
        return cast.id
      end

      if member_name == "unsafe_chr"
        if is_union_or_nilable_type?(receiver_type)
          nil_variant_id = get_union_variant_id(receiver_type, TypeRef::NIL)
          if nil_variant_id >= 0
            unwrapped = lower_not_nil_intrinsic(ctx, object_id, receiver_type)
            unwrapped_type = ctx.type_of(unwrapped)
            if numeric_primitive?(unwrapped_type)
              cast = Cast.new(ctx.next_id, TypeRef::CHAR, unwrapped, TypeRef::CHAR)
              ctx.emit(cast)
              ctx.register_type(cast.id, TypeRef::CHAR)
              STDERR.puts "[UNSAFE_CHR] cast union->Char" if ENV["DEBUG_UNSAFE_CHR"]?
              return cast.id
            end
          elsif type_desc = @module.get_type_descriptor(receiver_type)
            variants = split_union_type_name(type_desc.name)
            idx = variants.index do |variant|
              next false if variant == "Nil"
              numeric_primitive?(type_ref_for_name(variant))
            end
            if idx
              unwrap_type = type_ref_for_name(variants[idx])
              unwrapped = UnionUnwrap.new(ctx.next_id, unwrap_type, object_id, idx, false)
              ctx.emit(unwrapped)
              ctx.register_type(unwrapped.id, unwrap_type)
              if numeric_primitive?(unwrap_type)
                cast = Cast.new(ctx.next_id, TypeRef::CHAR, unwrapped.id, TypeRef::CHAR)
                ctx.emit(cast)
                ctx.register_type(cast.id, TypeRef::CHAR)
                STDERR.puts "[UNSAFE_CHR] cast unwrap->Char" if ENV["DEBUG_UNSAFE_CHR"]?
                return cast.id
              end
            end
          end
        end
        case receiver_type
        when TypeRef::INT8, TypeRef::INT16, TypeRef::INT32, TypeRef::INT64, TypeRef::INT128,
             TypeRef::UINT8, TypeRef::UINT16, TypeRef::UINT32, TypeRef::UINT64, TypeRef::UINT128
          cast = Cast.new(ctx.next_id, TypeRef::CHAR, object_id, TypeRef::CHAR)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::CHAR)
          STDERR.puts "[UNSAFE_CHR] cast primitive->Char" if ENV["DEBUG_UNSAFE_CHR"]?
          return cast.id
        end
      end

      # Primitive numeric conversions and predicates for member access (no-arg calls).
      target_type = case member_name
                    when "to_i", "to_i32", "to_i32!"
                      TypeRef::INT32
                    when "to_i8", "to_i8!"
                      TypeRef::INT8
                    when "to_i16", "to_i16!"
                      TypeRef::INT16
                    when "to_i64", "to_i64!"
                      TypeRef::INT64
                    when "to_i128", "to_i128!"
                      TypeRef::INT128
                    when "to_u", "to_u32", "to_u32!"
                      TypeRef::UINT32
                    when "to_u8", "to_u8!"
                      TypeRef::UINT8
                    when "to_u16", "to_u16!"
                      TypeRef::UINT16
                    when "to_u64", "to_u64!"
                      TypeRef::UINT64
                    when "to_u128", "to_u128!"
                      TypeRef::UINT128
                    when "to_f", "to_f64", "to_f64!"
                      TypeRef::FLOAT64
                    when "to_f32", "to_f32!"
                      TypeRef::FLOAT32
                    else
                      nil
                    end
      if target_type
        if receiver_type == TypeRef::VOID
          receiver_type = TypeRef::INT32
          ctx.register_type(object_id, receiver_type)
        end
        if numeric_primitive?(receiver_type)
          return object_id if receiver_type == target_type
          cast = Cast.new(ctx.next_id, target_type, object_id, target_type)
          ctx.emit(cast)
          ctx.register_type(cast.id, target_type)
          return cast.id
        end
      end
      if numeric_primitive?(receiver_type)
        if member_name == "zero?"
          zero = Literal.new(ctx.next_id, receiver_type, 0_i64)
          ctx.emit(zero)
          ctx.register_type(zero.id, receiver_type)
          cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Eq, object_id, zero.id)
          ctx.emit(cmp)
          ctx.register_type(cmp.id, TypeRef::BOOL)
          return cmp.id
        end
        if receiver_type == TypeRef::UINT8 && member_name == "ascii?"
          limit = Literal.new(ctx.next_id, TypeRef::UINT8, 128_i64)
          ctx.emit(limit)
          ctx.register_type(limit.id, TypeRef::UINT8)
          cmp = BinaryOperation.new(ctx.next_id, TypeRef::BOOL, BinaryOp::Lt, object_id, limit.id)
          ctx.emit(cmp)
          ctx.register_type(cmp.id, TypeRef::BOOL)
          return cmp.id
        end
        if receiver_type == TypeRef::UINT8 && member_name == "ord"
          cast = Cast.new(ctx.next_id, TypeRef::INT32, object_id, TypeRef::INT32)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT32)
          return cast.id
        end
      end

      # Pointer address conversions for member access (no-arg calls).
      recv_type_desc = @module.get_type_descriptor(receiver_type)
      is_pointer_type = receiver_type == TypeRef::POINTER ||
                        (recv_type_desc && recv_type_desc.name.starts_with?("Pointer"))
      if is_pointer_type
        case member_name
        when "address", "to_u64"
          cast = Cast.new(ctx.next_id, TypeRef::UINT64, object_id, TypeRef::UINT64)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::UINT64)
          return cast.id
        when "to_i", "to_i64"
          cast = Cast.new(ctx.next_id, TypeRef::INT64, object_id, TypeRef::INT64)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT64)
          return cast.id
        when "to_i32"
          cast = Cast.new(ctx.next_id, TypeRef::INT32, object_id, TypeRef::INT32)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::INT32)
          return cast.id
        when "to_u32"
          cast = Cast.new(ctx.next_id, TypeRef::UINT32, object_id, TypeRef::UINT32)
          ctx.emit(cast)
          ctx.register_type(cast.id, TypeRef::UINT32)
          return cast.id
        when "to_f64"
          int_cast = Cast.new(ctx.next_id, TypeRef::UINT64, object_id, TypeRef::UINT64)
          ctx.emit(int_cast)
          ctx.register_type(int_cast.id, TypeRef::UINT64)
          float_cast = Cast.new(ctx.next_id, TypeRef::FLOAT64, int_cast.id, TypeRef::FLOAT64)
          ctx.emit(float_cast)
          ctx.register_type(float_cast.id, TypeRef::FLOAT64)
          return float_cast.id
        end
      end

      # Handle pointer.value -> PointerLoad for typed pointers (Pointer(T))
      type_desc = @module.get_type_descriptor(receiver_type)
      is_pointer_type = receiver_type == TypeRef::POINTER ||
                        (type_desc && type_desc.name.starts_with?("Pointer"))
      if is_pointer_type && member_name == "value"
        # Return the dereferenced type from Pointer(T) -> T
        deref_type = if type_desc && type_desc.name.starts_with?("Pointer(") && type_desc.name.ends_with?(")")
                       element_type_name = type_desc.name[8...-1]
                       type_ref_for_name(element_type_name)
                     else
                       TypeRef::UINT8  # Fallback for untyped pointers
                     end
        load_node = PointerLoad.new(ctx.next_id, deref_type, object_id, nil)
        ctx.emit(load_node)
        ctx.register_type(load_node.id, deref_type)
        return load_node.id
      end

      # Check for enum.value -> return the enum value as-is (enums are stored as Int32)
      if receiver_type == TypeRef::INT32 && member_name == "value"
        return object_id
      end

      # Special handling for union types containing primitives (like Int32 | Nil)
      # When calling primitive methods on a union, we need to unwrap the value first
      if is_nilable_int32_union?(receiver_type)
        case member_name
        when "to_s"
          # Unwrap Int32 from the union (assuming it's not nil - caller should have checked)
          unwrap = UnionUnwrap.new(ctx.next_id, TypeRef::INT32, object_id, 0, false)  # variant 0 = Int32
          ctx.emit(unwrap)
          ctx.register_type(unwrap.id, TypeRef::INT32)
          # Call __crystal_v2_int_to_string on the unwrapped value
          call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_int_to_string", [unwrap.id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::POINTER)
          return call.id
        when "abs"
          # Unwrap Int32 and call abs intrinsic
          unwrap = UnionUnwrap.new(ctx.next_id, TypeRef::INT32, object_id, 0, false)
          ctx.emit(unwrap)
          ctx.register_type(unwrap.id, TypeRef::INT32)
          call = Call.new(ctx.next_id, TypeRef::INT32, nil, "__crystal_v2_int_abs", [unwrap.id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::INT32)
          return call.id
        end
      end

      # Special handling for primitive type methods (Int32, Bool, etc.)
      # These are NOT classes so class_info lookup will fail
      # We use Call with nil receiver and __crystal_v2_* method name, which hir_to_mir
      # automatically converts to ExternCall
      if receiver_type == TypeRef::INT32
        case member_name
        when "to_s"
          # Call __crystal_v2_int_to_string intrinsic
          call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_int_to_string", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::POINTER)
          return call.id
        when "abs"
          # For abs, we could emit inline: (x < 0) ? -x : x, or extern call
          # For now, emit as extern
          call = Call.new(ctx.next_id, TypeRef::INT32, nil, "__crystal_v2_int_abs", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::INT32)
          return call.id
        when "to_i", "to_i32"
          # Int32.to_i is identity
          return object_id
        when "to_i64"
          # Sign-extend to i64
          call = Call.new(ctx.next_id, TypeRef::INT64, nil, "__crystal_v2_int_to_i64", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::INT64)
          return call.id
        when "to_f", "to_f64"
          call = Call.new(ctx.next_id, TypeRef::FLOAT64, nil, "__crystal_v2_int_to_f64", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::FLOAT64)
          return call.id
        when "times"
          # Int32#times with block - handle as intrinsic loop
          # Will be handled in lower_call for blocks, skip here
        end
      elsif receiver_type == TypeRef::INT64
        case member_name
        when "to_s"
          call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_int64_to_string", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::POINTER)
          return call.id
        when "to_i", "to_i32"
          # Truncate to i32
          call = Call.new(ctx.next_id, TypeRef::INT32, nil, "__crystal_v2_int64_to_i32", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::INT32)
          return call.id
        when "to_i64"
          return object_id
        end
      elsif receiver_type == TypeRef::FLOAT64
        case member_name
        when "to_s"
          call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_f64_to_string", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::POINTER)
          return call.id
        when "to_i", "to_i32"
          call = Call.new(ctx.next_id, TypeRef::INT32, nil, "__crystal_v2_f64_to_i32", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::INT32)
          return call.id
        when "to_i64"
          call = Call.new(ctx.next_id, TypeRef::INT64, nil, "__crystal_v2_f64_to_i64", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::INT64)
          return call.id
        end
      elsif receiver_type == TypeRef::BOOL
        case member_name
        when "to_s"
          call = Call.new(ctx.next_id, TypeRef::POINTER, nil, "__crystal_v2_bool_to_string", [object_id])
          ctx.emit(call)
          ctx.register_type(call.id, TypeRef::POINTER)
          return call.id
        end
      end

      # Determine receiver type to find the correct method
      resolved_method_name : String? = nil
      return_type = TypeRef::VOID

      # Try to find method by receiver type with inheritance support
      if receiver_type.id > 0
        @class_info.each do |class_name, info|
          if info.type_ref.id == receiver_type.id
            # Use inheritance-aware method resolution
            if base_method = resolve_method_with_inheritance(class_name, member_name)
              resolved_method_name = base_method
              return_type = get_function_return_type(base_method)
            end
            break
          end
        end
      end

      # Fallback 1: Try to match by type descriptor name (when type_ref IDs don't match)
      if resolved_method_name.nil? && receiver_type.id > 0
        if type_desc = @module.get_type_descriptor(receiver_type)
          type_name = type_desc.name
          # Try full name first
          if @class_info.has_key?(type_name)
            if base_method = resolve_method_with_inheritance(type_name, member_name)
              resolved_method_name = base_method
              return_type = get_function_return_type(base_method)
            end
          else
            # Try to find a class that ends with the type name (handle namespacing)
            # e.g., type_name="Span" matches "CrystalV2::Compiler::Frontend::Span"
            @class_info.each do |class_name, info|
              if class_name.ends_with?("::#{type_name}") || class_name == type_name
                if base_method = resolve_method_with_inheritance(class_name, member_name)
                  resolved_method_name = base_method
                  return_type = get_function_return_type(base_method)
                  break
                end
              end
            end
          end
        end
      end

      # Fallback 2: search all classes for this method (only when receiver type is unknown)
      if resolved_method_name.nil? && receiver_type.id == 0
        @class_info.each do |class_name, info|
          test_name = "#{class_name}##{member_name}"
          if has_function_base?(test_name)
            resolved_method_name = test_name
            return_type = get_function_return_type(test_name)
            break
          end
        end
      end

      base_method_name = resolved_method_name
      if base_method_name.nil?
        base_method_name = resolve_method_call(ctx, object_id, member_name, [] of TypeRef)
        if dollar = base_method_name.index('$')
          base_method_name = base_method_name[0, dollar]
        end
      end

      args = apply_default_args(ctx, [] of ValueId, member_name, base_method_name, false)
      arg_types = args.map { |arg_id| ctx.type_of(arg_id) }

      actual_name = if resolved_method_name
                      mangled_name = mangle_function_name(resolved_method_name, arg_types)
                      if @function_types.has_key?(mangled_name) || @module.has_function?(mangled_name)
                        mangled_name
                      elsif has_function_base?(resolved_method_name)
                        resolved_method_name
                      else
                        mangled_name
                      end
                    else
                      resolve_method_call(ctx, object_id, member_name, arg_types)
                    end
      if entry = lookup_function_def_for_call(base_method_name, args.size, false, arg_types)
        actual_name = entry[0]
      end

      # Special handling for Tuple#size - return compile-time constant based on type parameters
      if member_name == "size"
        if type_desc = @module.get_type_descriptor(receiver_type)
          tuple_size = tuple_size_from_type_name(type_desc.name)
          if tuple_size.nil?
            base_name = type_desc.name.split("(").first
            tuple_size = type_desc.type_params.size if base_name == "Tuple" && !type_desc.type_params.empty?
          end
          if tuple_size
            lit = Literal.new(ctx.next_id, TypeRef::INT32, tuple_size.to_i64)
            ctx.emit(lit)
            ctx.register_type(lit.id, TypeRef::INT32)
            return lit.id
          end
        end
      end

      return_type = get_function_return_type(actual_name)
      if return_type == TypeRef::VOID && actual_name != base_method_name
        base_return = get_function_return_type(base_method_name)
        if base_return != TypeRef::VOID
          return_type = base_return
          actual_name = base_method_name
        end
      end
      if DebugHooks::ENABLED && (member_name == "first" || member_name == "last" || member_name == "address")
        recv_name = receiver_type == TypeRef::VOID ? "Void" : get_type_name_from_ref(receiver_type)
        ret_name = return_type == TypeRef::VOID ? "Void" : get_type_name_from_ref(return_type)
        debug_hook("member.access", "member=#{member_name} recv=#{recv_name} actual=#{actual_name} return=#{ret_name}")
      end
      if tuple_return = tuple_return_type_for_method(receiver_type, member_name)
        return_type = tuple_return
      end
      if return_type == TypeRef::BOOL && member_name.ends_with?("?")
        if inferred = infer_unannotated_query_return_type(member_name, ctx.type_of(object_id))
          return_type = inferred
        end
      end

      # Fallback for stdlib methods that should return a value (like to_a, map, etc.)
      # Same logic as in lower_call for consistency
      if return_type == TypeRef::VOID
        if member_name == "find" || member_name == "find!"
          if type_desc = @module.get_type_descriptor(ctx.type_of(object_id))
            if elem_name = element_type_for_type_name(type_desc.name)
              elem_type = type_ref_for_name(elem_name)
              return_type = member_name == "find!" ? elem_type : create_union_type_for_nullable(elem_type)
            end
          end
        elsif member_name == "find_index"
          return_type = create_union_type_for_nullable(TypeRef::INT32)
        end
        if return_type == TypeRef::VOID
          if inferred = infer_unannotated_search_return_type(member_name, ctx.type_of(object_id))
            return_type = inferred
          end
        end

        # Methods returning Bool (predicate methods)
        methods_returning_bool = ["empty?", "any?", "all?", "none?", "includes?",
                                  "starts_with?", "ends_with?", "blank?", "present?",
                                  "valid?", "nil?", "is_a?", "responds_to?"]
        # Methods returning Int32
        methods_returning_int32 = ["size", "length", "count", "bytesize", "hash",
                                   "index", "rindex", "ord"]
        if methods_returning_bool.includes?(member_name)
          return_type = TypeRef::BOOL
        elsif methods_returning_int32.includes?(member_name)
          return_type = TypeRef::INT32
        else
          methods_returning_self_or_value = ["to_a", "to_s", "map", "select", "reduce", "each",
                                             "first", "last", "dup", "clone", "cover",
                                             "compact", "flatten", "sort", "reverse", "uniq",
                                             "join", "split", "strip", "chomp", "chars",
                                             "keys", "values", "value",  # 'value' is common getter
                                             "lines", "bytes", "codepoints", "graphemes",
                                             "rstrip", "lstrip", "downcase", "upcase", "capitalize",
                                             "gsub", "sub", "tr", "delete", "squeeze",
                                             "rjust", "ljust", "center", "each_line",
                                             "each_with_index", "map_with_index", "select_with_index",
                                             "find", "find_index",
                                             "sum", "product", "min", "max", "minmax", "sample",
                                             "take", "drop", "take_while", "drop_while",
                                             "group_by", "partition", "zip", "transpose",
                                             "shuffle", "rotate", "pop", "shift", "slice",
                                             "to_slice", "to_unsafe", "to_h", "to_set", "copy_from"]
          if methods_returning_self_or_value.includes?(member_name)
            return_type = TypeRef::POINTER
          end
        end
      end

      # Methods that return the same type as the receiver.
      # Handle this even if return_type is NIL (often incorrectly registered for abstract modules).
      methods_returning_receiver_type = ["tap", "clamp", "abs", "ceil", "floor", "round", "truncate",
                                         "remainder", "tdiv", "unsafe_mod", "unsafe_div", "gcd", "lcm"]
      if methods_returning_receiver_type.includes?(member_name)
        recv_type = ctx.type_of(object_id)
        # Only override if receiver is not Nil (these methods don't make sense on Nil)
        if recv_type != TypeRef::NIL && recv_type != TypeRef::VOID
          if ENV.has_key?("DEBUG_RECV_TYPE") && (member_name == "abs" || member_name == "remainder")
            STDERR.puts "[RECV_TYPE] member=#{member_name} recv_type=#{recv_type.id} old_return=#{return_type.id} current_class=#{@current_class || ""} current_method=#{@current_method || ""}"
          end
          return_type = recv_type
        elsif ENV.has_key?("DEBUG_RECV_TYPE") && (member_name == "abs" || member_name == "remainder")
          STDERR.puts "[RECV_TYPE_SKIP] member=#{member_name} recv_type=#{recv_type.id} return=#{return_type.id} current_class=#{@current_class || ""} current_method=#{@current_method || ""}"
        end
      end

      call_virtual = false
      if type_desc = @module.get_type_descriptor(ctx.type_of(object_id))
        call_virtual = type_desc.kind.in?(TypeKind::Union, TypeKind::Module)
        if !call_virtual && type_desc.kind == TypeKind::Class
          abstract_base = base_method_name ? abstract_def?(base_method_name) : false
          call_virtual = class_has_subclasses?(type_desc.name) || abstract_base
        end
      end
      if ENV.has_key?("DEBUG_VIRTUAL_CALLS") && object_id
        recv_type = ctx.type_of(object_id)
        recv_desc = @module.get_type_descriptor(recv_type)
        recv_name = recv_desc ? "#{recv_desc.name}(#{recv_desc.kind})" : recv_type.id.to_s
        STDERR.puts "[HIR_VIRTUAL_CALL] method=#{member_name} recv=#{recv_name} virtual=#{call_virtual}"
      end

      primary_name = if resolved_method_name
                       mangle_function_name(resolved_method_name, arg_types)
                     else
                       actual_name
                     end

      if ENV["DEBUG_CALL_TRACE"]? && member_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=before_lower_function method=#{member_name} actual=#{actual_name} primary=#{primary_name} return=#{return_type.id}"
      end
      lower_function_if_needed(primary_name)
      if actual_name != primary_name
        lower_function_if_needed(actual_name)
      end

      if ENV["DEBUG_CALL_TRACE"]? && member_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=before_coerce method=#{member_name} actual=#{actual_name} args=#{args.size}"
      end
      args = coerce_args_to_param_types(ctx, args, actual_name)
      if ENV["DEBUG_CALL_TRACE"]? && member_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=before_emit method=#{member_name} actual=#{actual_name} args=#{args.size}"
      end
      call = Call.new(ctx.next_id, return_type, object_id, actual_name, args, nil, call_virtual)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      if enum_name = enum_return_name_for(actual_name)
        (@enum_value_types ||= {} of ValueId => String)[call.id] = enum_name
        if ENV["DEBUG_ENUM_CALL"]? && actual_name == "File::Info#type"
          STDERR.puts "[DEBUG_ENUM_CALL] member_access name=#{actual_name} enum=#{enum_name}"
        end
      elsif ENV["DEBUG_ENUM_CALL"]? && actual_name == "File::Info#type"
        STDERR.puts "[DEBUG_ENUM_CALL] member_access name=#{actual_name} enum=(nil)"
      end
      if ENV["DEBUG_CALL_TRACE"]? && member_name == "copy_to"
        STDERR.puts "[CALL_TRACE] stage=after_emit method=#{member_name} actual=#{actual_name}"
      end
      call.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # ASSIGNMENT
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_assign(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::AssignNode) : ValueId
      value_id = lower_expr(ctx, node.value)
      target_node = @arena[node.target]

      case target_node
      when CrystalV2::Compiler::Frontend::IdentifierNode
        name = String.new(target_node.name)
        value_type = ctx.type_of(value_id)
        if existing = ctx.lookup_local(name)
          # Reassignment
          copy = Copy.new(ctx.next_id, value_type, value_id)
          ctx.emit(copy)
          ctx.register_local(name, copy.id)
          if enum_name = @enum_value_types.try(&.[value_id]?)
            enum_map = @enum_value_types ||= {} of ValueId => String
            enum_map[copy.id] = enum_name
          end
          update_typeof_local(name, value_type)
          if concrete_name = concrete_type_name_for(value_type)
            existing_name = lookup_typeof_local_name(name)
            if existing_name.nil? || module_like_type_name?(existing_name)
              update_typeof_local_name(name, concrete_name)
            end
          end
          copy.id
        else
          # New variable
          local = Local.new(ctx.next_id, value_type, name, ctx.current_scope)
          ctx.emit(local)
          ctx.register_local(name, value_id)
          # Also emit copy
          copy = Copy.new(ctx.next_id, value_type, value_id)
          ctx.emit(copy)
          ctx.register_local(name, copy.id)
          if enum_name = @enum_value_types.try(&.[value_id]?)
            enum_map = @enum_value_types ||= {} of ValueId => String
            enum_map[local.id] = enum_name
            enum_map[copy.id] = enum_name
          end
          update_typeof_local(name, value_type)
          if concrete_name = concrete_type_name_for(value_type)
            update_typeof_local_name(name, concrete_name)
          end
          copy.id
        end

      when CrystalV2::Compiler::Frontend::InstanceVarNode
        name = String.new(target_node.name)
        value_type = ctx.type_of(value_id)
        ivar_offset = get_ivar_offset(name)
        ivar_type = get_ivar_type(name)
        if class_name = @current_class
          if class_info = @class_info[class_name]?
            ivars = class_info.ivars
            if idx = ivars.index { |iv| iv.name == name }
              existing = ivars[idx]
              merged_type = existing.type
              if existing.type == TypeRef::VOID && value_type != TypeRef::VOID
                merged_type = value_type
              elsif value_type != TypeRef::VOID && existing.type != value_type
                merged_type = union_type_for_values(existing.type, value_type)
              end
              if merged_type != existing.type
                # Avoid widening ivar layouts after offsets are fixed (union may increase size).
                if existing.type == TypeRef::VOID || type_size(merged_type) == type_size(existing.type)
                  ivars[idx] = IVarInfo.new(name, merged_type, existing.offset)
                  ivar_type = merged_type
                else
                  ivar_type = existing.type
                  debug_hook("ivar.union.skip", "class=#{class_name} ivar=#{name} from=#{get_type_name_from_ref(existing.type)} to=#{get_type_name_from_ref(merged_type)}")
                end
              else
                ivar_type = existing.type
              end
              ivar_offset = existing.offset
            elsif value_type != TypeRef::VOID
              new_offset = class_info.size
              ivars << IVarInfo.new(name, value_type, new_offset)
              new_size = new_offset + type_size(value_type)
              @class_info[class_name] = ClassInfo.new(
                class_info.name,
                class_info.type_ref,
                ivars,
                class_info.class_vars,
                new_size,
                class_info.is_struct,
                class_info.parent_name
              )
              ivar_type = value_type
              ivar_offset = new_offset
            end
          end
        end
        self_id = emit_self(ctx)

        # Check if ivar is a union type - need to wrap the value
        if ivar_type && is_union_type?(ivar_type)
          # Get the type of the value being assigned
          value_type = ctx.type_of(value_id)
          variant_id = get_union_variant_id(ivar_type, value_type)

          if variant_id >= 0
            # Wrap value into union with type_id
            union_wrap = UnionWrap.new(ctx.next_id, ivar_type, value_id, variant_id)
            ctx.emit(union_wrap)
            ctx.register_type(union_wrap.id, ivar_type)

            # Store the wrapped union value
            field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, self_id, name, union_wrap.id, ivar_offset)
            ctx.emit(field_set)
            return value_id
          end
        end

        # Regular (non-union) field assignment
        field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, self_id, name, value_id, ivar_offset)
        ctx.emit(field_set)
        value_id

      when CrystalV2::Compiler::Frontend::ClassVarNode
        # Name includes @@ prefix, strip it
        raw_name = String.new(target_node.name)
        name = raw_name.lstrip('@')
        cvar_type = get_class_var_type(name)
        class_name = @current_class || ""
        if cvar_type == TypeRef::VOID
          value_type = ctx.type_of(value_id)
          record_class_var_type(class_name, name, value_type)
          cvar_type = value_type unless value_type == TypeRef::VOID
        end
        class_var_set = ClassVarSet.new(ctx.next_id, cvar_type, class_name, name, value_id)
        ctx.emit(class_var_set)
        class_var_set.id

      when CrystalV2::Compiler::Frontend::IndexNode
        object_id = lower_expr(ctx, target_node.object)
        index_ids = target_node.indexes.map { |idx| lower_expr(ctx, idx) }

        # Check if this is pointer indexing (ptr[i] = val)
        object_type = ctx.type_of(object_id)
        type_desc = @module.get_type_descriptor(object_type)
        if type_desc && type_desc.kind == TypeKind::Union
          if unwrapped = unwrap_pointer_union(ctx, object_id, object_type, ctx.type_of(value_id))
            object_id, object_type = unwrapped
            type_desc = @module.get_type_descriptor(object_type)
          end
        end
        is_pointer_type = object_type == TypeRef::POINTER ||
                          (type_desc && type_desc.kind == TypeKind::Pointer)

        if is_pointer_type && index_ids.size == 1
          # Pointer store: ptr[i] = val -> PointerStore with index
          store_type = ctx.type_of(value_id)
          store_node = PointerStore.new(ctx.next_id, store_type, object_id, value_id, index_ids.first)
          ctx.emit(store_node)
          return value_id
        end

        # Check if this is an array-like type (which uses IndexSet for element assignment)
        is_array_type = type_desc && (type_desc.kind == TypeKind::Array ||
                                       type_desc.name.starts_with?("Array") ||
                                       type_desc.name.starts_with?("StaticArray") ||
                                       type_desc.name.starts_with?("Slice"))

        if is_array_type && index_ids.size == 1
          # Array element assignment: arr[i] = val -> IndexSet
          element_type = type_desc.not_nil!.type_params.first? || ctx.type_of(value_id)
          element_type = TypeRef::INT32 if element_type == TypeRef::VOID
          index_set = IndexSet.new(ctx.next_id, element_type, object_id, index_ids.first, value_id)
          ctx.emit(index_set)
          value_id
        else
          # Everything else (classes like Hash, custom types): call []= method
          # Resolve the method name properly (with class name and mangling)
          all_args = index_ids + [value_id]
          arg_types = all_args.map { |arg| ctx.type_of(arg) }
          method_name = resolve_method_call(ctx, object_id, "[]=", arg_types)
          return_type = get_function_return_type(method_name)
          # Ensure the []= method is lowered
          remember_callsite_arg_types(method_name, arg_types)
          lower_function_if_needed(method_name)
          call = Call.new(ctx.next_id, return_type, object_id, method_name, all_args)
          ctx.emit(call)
          ctx.register_type(call.id, return_type)
          call.id
        end

      when CrystalV2::Compiler::Frontend::MemberAccessNode
        # obj.field = value -> call setter method or direct field set
        object_id = lower_expr(ctx, target_node.object)
        field_name = String.new(target_node.member)

        # Get the object's type to resolve the setter method
        object_type = ctx.type_of(object_id)
        type_desc = @module.get_type_descriptor(object_type)

        if field_name == "value"
          if type_desc && type_desc.kind == TypeKind::Union
            if unwrapped = unwrap_pointer_union(ctx, object_id, object_type, ctx.type_of(value_id))
              object_id, object_type = unwrapped
              type_desc = @module.get_type_descriptor(object_type)
            end
          end
          is_pointer_type = object_type == TypeRef::POINTER ||
                            (type_desc && type_desc.kind == TypeKind::Pointer)
          if is_pointer_type
            store_node = PointerStore.new(ctx.next_id, TypeRef::VOID, object_id, value_id, nil)
            ctx.emit(store_node)
            return store_node.id
          end
        end

        # Try direct field access if we know the class layout
        class_name = type_desc ? type_desc.name : nil
        if class_name && @class_info.has_key?(class_name)
          class_info = @class_info[class_name]

          # Check if this is a known field (ivar)
          ivar_name = "@#{field_name}"
          if ivar_info = class_info.ivars.find { |iv| iv.name == ivar_name }
            # Direct field set
            field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, object_id, ivar_name, value_id, ivar_info.offset)
            ctx.emit(field_set)
            return field_set.id
          elsif class_info.is_struct && @lib_structs.includes?(class_name)
            if ivar_info = class_info.ivars.find { |iv| iv.name == field_name }
              field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, object_id, field_name, value_id, ivar_info.offset)
              ctx.emit(field_set)
              return field_set.id
            end
          end
        end

        # Fallback to setter method call: obj.field=(value)
        setter_name = "#{field_name}="
        arg_types = [ctx.type_of(value_id)]
        method_name = resolve_method_call(ctx, object_id, setter_name, arg_types)
        return_type = get_function_return_type(method_name)
        # Ensure the setter method is lowered
        remember_callsite_arg_types(method_name, arg_types)
        lower_function_if_needed(method_name)
        call = Call.new(ctx.next_id, return_type, object_id, method_name, [value_id])
        ctx.emit(call)
        ctx.register_type(call.id, return_type)
        call.id

      when CrystalV2::Compiler::Frontend::GlobalNode
        # Global variable assignment: $name = value
        name = String.new(target_node.name)
        value_type = ctx.type_of(value_id)
        class_var_set = ClassVarSet.new(ctx.next_id, value_type, "$", name, value_id)
        ctx.emit(class_var_set)
        class_var_set.id

      else
        raise LoweringError.new("Unsupported assignment target: #{target_node.class}", target_node)
      end
    end

    private def lower_static_member_access_call(
      ctx : LoweringContext,
      class_name_str : String,
      member_name : String
    ) : ValueId
      full_method_name = if member_name == "new"
                           "#{class_name_str}.#{member_name}"
                         else
                           resolve_class_method_with_inheritance(class_name_str, member_name) || "#{class_name_str}.#{member_name}"
                         end
      if member_name == "new"
        if class_info = @class_info[class_name_str]?
          generate_allocator(class_name_str, class_info)
        end
      end

      if member_name == "null" && full_method_name.starts_with?("Pointer(")
        zero = Literal.new(ctx.next_id, TypeRef::INT64, 0_i64)
        ctx.emit(zero)
        ctx.register_type(zero.id, TypeRef::INT64)
        cast = Cast.new(ctx.next_id, TypeRef::POINTER, zero.id, TypeRef::POINTER)
        ctx.emit(cast)
        ctx.register_type(cast.id, TypeRef::POINTER)
        return cast.id
      end

      enum_name = resolve_enum_name(class_name_str)

      args = apply_default_args(ctx, [] of ValueId, member_name, full_method_name, false)
      if enum_name && member_name == "new"
        enum_type = enum_base_type(enum_name)
        if args.size == 1
          value_id = args.first
          value_type = ctx.type_of(value_id)
          if value_type != enum_type
            cast = Cast.new(ctx.next_id, enum_type, value_id, enum_type, safe: false)
            ctx.emit(cast)
            ctx.register_type(cast.id, enum_type)
            (@enum_value_types ||= {} of ValueId => String)[cast.id] = enum_name
            return cast.id
          end
          (@enum_value_types ||= {} of ValueId => String)[value_id] = enum_name
          return value_id
        end
      end

      arg_types = args.map { |arg_id| ctx.type_of(arg_id) }
      mangled_name = mangle_function_name(full_method_name, arg_types)
      # DEBUG: Catch short names being used for method calls
      if ENV.has_key?("DEBUG_SHORT_NAMES") && full_method_name &&
         (full_method_name.starts_with?("Seek#") || full_method_name.starts_with?("Seek.") ||
          full_method_name.starts_with?("Section#") || full_method_name.starts_with?("Section.") ||
          full_method_name.starts_with?("LoadCommand#") || full_method_name.starts_with?("LoadCommand."))
        STDERR.puts "[SHORT_NAME_CALL] full_method_name=#{full_method_name}, mangled=#{mangled_name}"
      end
      actual_name = if @function_types.has_key?(mangled_name) || @module.has_function?(mangled_name)
                      mangled_name
                    elsif has_function_base?(full_method_name)
                      full_method_name
                    else
                      mangled_name
                    end

      return_type = get_function_return_type(actual_name)
      if member_name == "new" && class_name_str == "Range" && arg_types.size >= 2
        begin_name = get_type_name_from_ref(arg_types[0])
        end_name = get_type_name_from_ref(arg_types[1])
        if begin_name != "Void" && end_name != "Void"
          range_name = "Range(#{begin_name}, #{end_name})"
          monomorphize_generic_class("Range", [begin_name, end_name], range_name)
          return_type = type_ref_for_name(range_name)
        end
      end
      # For .new, use class type_ref as return type
      if member_name == "new" && return_type == TypeRef::VOID
        if enum_name
          return_type = enum_base_type(enum_name)
        elsif class_info = @class_info[class_name_str]?
          return_type = class_info.type_ref
        else
          return_type = TypeRef::POINTER
        end
      end

      lower_function_if_needed(mangled_name)
      if actual_name != mangled_name
        lower_function_if_needed(actual_name)
      end

      args = coerce_args_to_param_types(ctx, args, actual_name)
      call = Call.new(ctx.next_id, return_type, nil, actual_name, args)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)
      if enum_name = enum_return_name_for(actual_name)
        (@enum_value_types ||= {} of ValueId => String)[call.id] = enum_name
      end
      if enum_name && return_type == enum_base_type(enum_name)
        (@enum_value_types ||= {} of ValueId => String)[call.id] = enum_name
      end
      call.id
    end

    private def lower_multiple_assign(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::MultipleAssignNode) : ValueId
      # MultipleAssignNode has a single value (destructured)
      # e.g., a, b, c = expr  where expr is a tuple/array
      rhs_id = lower_expr(ctx, node.value)

      # For each target, emit index operation to destructure
      node.targets.each_with_index do |target_expr, idx|
        target_node = @arena[target_expr]

        # Index into the RHS to get this element
        index_lit = Literal.new(ctx.next_id, TypeRef::INT32, idx.to_i64)
        ctx.emit(index_lit)
        element_id = IndexGet.new(ctx.next_id, TypeRef::VOID, rhs_id, index_lit.id)
        ctx.emit(element_id)

        case target_node
        when CrystalV2::Compiler::Frontend::IdentifierNode
          name = String.new(target_node.name)
          local = Local.new(ctx.next_id, TypeRef::VOID, name, ctx.current_scope)
          ctx.emit(local)
          ctx.register_local(name, element_id.id)

        when CrystalV2::Compiler::Frontend::InstanceVarNode
          name = String.new(target_node.name)
          ivar_offset = get_ivar_offset(name)
          self_id = emit_self(ctx)
          field_set = FieldSet.new(ctx.next_id, TypeRef::VOID, self_id, name, element_id.id, ivar_offset)
          ctx.emit(field_set)

        else
          # Other target types can be added as needed
        end
      end

      rhs_id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # CLOSURES
    # ═══════════════════════════════════════════════════════════════════════

    private def compute_block_captures(
      ctx : LoweringContext,
      closure_scope : ScopeId,
      saved_locals : Hash(String, ValueId),
      assigned_vars : Set(String)
    ) : Array(CapturedVar)
      return [] of CapturedVar if saved_locals.empty?

      value_to_name = {} of ValueId => String
      saved_locals.each { |name, id| value_to_name[id] = name }

      captured_names = Set(String).new
      ctx.function.blocks.each do |block|
        next unless scope_within?(ctx.function, block.scope, closure_scope)
        block.instructions.each do |inst|
          each_operand_for_capture(inst) do |operand|
            if name = value_to_name[operand]?
              captured_names << name
            end
          end
        end
      end

      captures = [] of CapturedVar
      captured_names.each do |name|
        value_id = saved_locals[name]
        by_ref = assigned_vars.includes?(name)
        captures << CapturedVar.new(value_id, name, by_ref)
      end
      captures
    end

    private def scope_within?(function : Function, scope_id : ScopeId, root_scope : ScopeId) : Bool
      current = scope_id
      loop do
        return true if current == root_scope
        scope = function.get_scope(current)
        parent = scope.parent
        return false unless parent
        current = parent
      end
    end

    private def each_operand_for_capture(value : Value, &block : ValueId ->)
      case value
      when Copy
        yield value.source
      when BinaryOperation
        yield value.left
        yield value.right
      when UnaryOperation
        yield value.operand
      when Call
        if recv = value.receiver
          yield recv
        end
        value.args.each { |arg| yield arg }
      when FieldGet
        yield value.object
      when FieldSet
        yield value.object
        yield value.value
      when IndexGet
        yield value.object
        yield value.index
      when IndexSet
        yield value.object
        yield value.index
        yield value.value
      when MakeClosure
        value.captures.each { |cap| yield cap.value_id }
      when Yield
        value.args.each { |arg| yield arg }
      when Phi
        value.incoming.each { |(_, val)| yield val }
      when Cast
        yield value.value
      when IsA
        yield value.value
      when Allocate
        value.constructor_args.each { |arg| yield arg }
      end
    end

    private def lower_block(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::BlockNode) : ValueId
      block_id = lower_block_to_block_id(ctx, node)

      # Create MakeClosure
      captures = @block_captures.delete(block_id) || [] of CapturedVar

      closure = MakeClosure.new(ctx.next_id, TypeRef::VOID, block_id, captures)
      ctx.emit(closure)
      closure.id
    end

    private def lower_block_to_block_id(
      ctx : LoweringContext,
      node : CrystalV2::Compiler::Frontend::BlockNode,
      param_types : Array(TypeRef)? = nil
    ) : BlockId
      saved_block = ctx.current_block
      @block_node_arenas[node.object_id] = @arena
      # Save locals before lowering block body - block-local vars shouldn't leak
      saved_locals = ctx.save_locals
      assigned_vars = collect_assigned_vars(node.body).to_set
      if params = node.params
        params.each do |param|
          next unless param_name = param.name
          assigned_vars.delete(String.new(param_name))
        end
      end
      old_typeof_locals = @current_typeof_locals
      old_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = old_typeof_locals ? old_typeof_locals.dup : old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names ? old_typeof_local_names.dup : old_typeof_local_names

      ctx.push_scope(ScopeKind::Closure)
      closure_scope = ctx.current_scope
      body_block = ctx.create_block
      ctx.current_block = body_block

      # Add block parameters (params can be nil)
      # Default to POINTER type since block parameters are typically objects (IO, etc.)
      if params = node.params
        params.each_with_index do |param, idx|
          if param_name = param.name
            name = String.new(param_name)
            param_type = if ta = param.type_annotation
                           type_ref_for_name(String.new(ta))
                         elsif param_types && (resolved = param_types[idx]?)
                           resolved
                         else
                           TypeRef::POINTER  # Default to pointer for block params
                         end
            param_val = Parameter.new(ctx.next_id, param_type, idx, name)
            ctx.emit(param_val)
            ctx.register_local(name, param_val.id)
            ctx.register_type(param_val.id, param_type)
            update_typeof_local(name, param_type)
            if ta = param.type_annotation
              update_typeof_local_name(name, String.new(ta))
            elsif param_type != TypeRef::VOID
              update_typeof_local_name(name, get_type_name_from_ref(param_type))
            end
          end
        end
      end

      # Lower body
      last_value = lower_body(ctx, node.body)
      ctx.pop_scope

      @block_captures[body_block] = compute_block_captures(ctx, closure_scope, saved_locals, assigned_vars)

      # Implicit return from block
      if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
        ctx.terminate(Return.new(last_value))
      end

      ctx.current_block = saved_block
      # Restore locals - block-local vars shouldn't pollute outer scope
      ctx.restore_locals(saved_locals)
      @current_typeof_locals = old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names
      body_block
    end

    private def lower_block_pass_proc(
      ctx : LoweringContext,
      proc_expr : ExprId,
      param_types : Array(TypeRef)? = nil
    ) : BlockId
      @inline_yield_proc_depth += 1
      proc_id = lower_expr(ctx, proc_expr)

      saved_block = ctx.current_block
      saved_locals = ctx.save_locals
      assigned_vars = Set(String).new
      old_typeof_locals = @current_typeof_locals
      old_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = old_typeof_locals ? old_typeof_locals.dup : old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names ? old_typeof_local_names.dup : old_typeof_local_names

      ctx.push_scope(ScopeKind::Closure)
      closure_scope = ctx.current_scope
      body_block = ctx.create_block
      ctx.current_block = body_block

      if param_types.nil?
        if type_desc = @module.get_type_descriptor(ctx.type_of(proc_id))
          if type_desc.kind == TypeKind::Proc && type_desc.type_params.size > 1
            param_types = type_desc.type_params[0...-1]
          end
        end
      end

      param_ids = [] of ValueId
      if param_types
        param_types.each_with_index do |param_type, idx|
          name = "__arg#{idx}"
          param_val = Parameter.new(ctx.next_id, param_type, idx, name)
          ctx.emit(param_val)
          ctx.register_local(name, param_val.id)
          ctx.register_type(param_val.id, param_type)
          update_typeof_local(name, param_type)
          if param_type != TypeRef::VOID
            update_typeof_local_name(name, get_type_name_from_ref(param_type))
          end
          param_ids << param_val.id
        end
      end

      arg_types = param_ids.map { |param_id| ctx.type_of(param_id) }
      actual_name = resolve_method_call(ctx, proc_id, "call", arg_types)
      return_type = get_function_return_type(actual_name)
      if return_type == TypeRef::VOID
        if type_desc = @module.get_type_descriptor(ctx.type_of(proc_id))
          if type_desc.kind == TypeKind::Proc && type_desc.type_params.size > 1
            return_type = type_desc.type_params.last
          end
        end
      end

      call = Call.new(ctx.next_id, return_type, proc_id, actual_name, param_ids)
      ctx.emit(call)
      ctx.register_type(call.id, return_type)

      if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
        ctx.terminate(Return.new(call.id))
      end

      @block_captures[body_block] = compute_block_captures(ctx, closure_scope, saved_locals, assigned_vars)

      ctx.current_block = saved_block
      ctx.restore_locals(saved_locals)
      @current_typeof_locals = old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names
      body_block
    ensure
      @inline_yield_proc_depth -= 1
    end

    # Build a synthetic BlockNode for block pass (&block) so yield inlining can substitute it.
    # The block body calls proc.call(__arg0, __arg1, ...)
    private def build_block_from_block_pass(
      proc_expr : ExprId,
      param_types : Array(TypeRef)?,
      span : CrystalV2::Compiler::Frontend::Span
    ) : CrystalV2::Compiler::Frontend::BlockNode
      proc_node = @arena[proc_expr]
      param_count = if param_types
                      param_types.size
                    elsif proc_node.is_a?(CrystalV2::Compiler::Frontend::ProcLiteralNode) && (params = proc_node.params)
                      params.size
                    else
                      1
                    end

      params = [] of CrystalV2::Compiler::Frontend::Parameter
      arg_ids = [] of CrystalV2::Compiler::Frontend::ExprId
      if param_count > 0
        param_count.times do |idx|
          name = "__arg#{idx}"
          name_slice = name.to_slice
          params << CrystalV2::Compiler::Frontend::Parameter.new(name_slice, span: span, name_span: span)
          arg_ids << @arena.add_typed(CrystalV2::Compiler::Frontend::IdentifierNode.new(span, name_slice))
        end
      end

      call_member = @arena.add_typed(
        CrystalV2::Compiler::Frontend::MemberAccessNode.new(span, proc_expr, "call".to_slice)
      )
      call_expr = @arena.add_typed(
        CrystalV2::Compiler::Frontend::CallNode.new(span, call_member, arg_ids, nil)
      )

      block_node = CrystalV2::Compiler::Frontend::BlockNode.new(span, params.empty? ? nil : params, [call_expr])
      @block_node_arenas[block_node.object_id] = @arena
      block_node
    end

    private def lower_proc_literal(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::ProcLiteralNode) : ValueId
      saved_block = ctx.current_block
      saved_locals = ctx.save_locals
      assigned_vars = collect_assigned_vars(node.body).to_set
      old_typeof_locals = @current_typeof_locals
      old_typeof_local_names = @current_typeof_local_names
      @current_typeof_locals = old_typeof_locals ? old_typeof_locals.dup : old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names ? old_typeof_local_names.dup : old_typeof_local_names

      ctx.push_scope(ScopeKind::Closure)
      closure_scope = ctx.current_scope
      body_block = ctx.create_block
      ctx.current_block = body_block

      proc_param_types = [] of TypeRef
      # Add proc parameters (params can be nil)
      if params = node.params
        params.each_with_index do |param, idx|
          if param_name = param.name
            name = String.new(param_name)
            param_type = if ta = param.type_annotation
                           type_ref_for_name(String.new(ta))
                         else
                           TypeRef::VOID
                         end
            proc_param_types << param_type
            param_val = Parameter.new(ctx.next_id, param_type, idx, name)
            ctx.emit(param_val)
            ctx.register_local(name, param_val.id)
            ctx.register_type(param_val.id, param_type)
            update_typeof_local(name, param_type)
            if ta = param.type_annotation
              update_typeof_local_name(name, String.new(ta))
            end
            assigned_vars.delete(name)
          end
        end
      end

      @inline_yield_proc_depth += 1
      # Lower body
      last_value = begin
        lower_body(ctx, node.body)
      ensure
        @inline_yield_proc_depth -= 1
      end
      ctx.pop_scope

      if ctx.get_block(ctx.current_block).terminator.is_a?(Unreachable)
        ctx.terminate(Return.new(last_value))
      end

      ctx.current_block = saved_block
      @current_typeof_locals = old_typeof_locals
      @current_typeof_local_names = old_typeof_local_names

      proc_return_type = if rt = node.return_type
                           type_ref_for_name(String.new(rt))
                         elsif last_expr = node.body.last?
                           infer_type_from_expr(last_expr, @current_class) || TypeRef::NIL
                         else
                           TypeRef::NIL
                         end
      proc_type = @module.intern_type(TypeDescriptor.new(TypeKind::Proc, "Proc", proc_param_types + [proc_return_type]))

      # Create MakeClosure
      captures = compute_block_captures(ctx, closure_scope, saved_locals, assigned_vars)
      closure = MakeClosure.new(ctx.next_id, proc_type, body_block, captures)
      closure.lifetime = LifetimeTag::HeapEscape  # Procs typically escape
      ctx.emit(closure)
      ctx.register_type(closure.id, proc_type)
      closure.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # COLLECTIONS
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_array_literal(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::ArrayLiteralNode) : ValueId
      element_ids = node.elements.map { |e| lower_expr(ctx, e) }

      # Determine element type from explicit `of` type, or from first element (or Int32 default)
      element_type_name = nil
      element_type = if of_type = node.of_type
                       if type_str = stringify_type_expr(of_type)
                         element_type_name = normalize_declared_type_name(type_str)
                         type_ref_for_name(element_type_name)
                       else
                         element_ids.size > 0 ? ctx.type_of(element_ids.first) : TypeRef::INT32
                       end
                     elsif element_ids.size > 0
                       ctx.type_of(element_ids.first)
                     else
                       TypeRef::INT32
                     end

      # Create ArrayLiteral instruction (not generic Allocate)
      arr = ArrayLiteral.new(ctx.next_id, element_type, element_ids)
      arr.lifetime = LifetimeTag::StackLocal  # Default to stack until escape analysis
      ctx.emit(arr)
      element_type_name ||= get_type_name_from_ref(element_type)
      if element_type_name != "Unknown" && element_type_name != "Void"
        array_type = type_ref_for_name("Array(#{element_type_name})")
        ctx.register_type(arr.id, array_type)
      else
        # Fallback when element type is unresolved.
        ctx.register_type(arr.id, TypeRef::POINTER)
      end
      arr.id
    end

    private def lower_hash_literal(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::HashLiteralNode) : ValueId
      # Lower key-value pairs
      args = [] of ValueId
      node.entries.each do |entry|
        key_id = lower_expr(ctx, entry.key)
        value_id = lower_expr(ctx, entry.value)
        args << key_id
        args << value_id
      end

      key_type = if key_type_expr = node.of_key_type
                   type_ref_for_name(normalize_declared_type_name(String.new(key_type_expr)))
                 elsif args.size >= 2
                   ctx.type_of(args[0])
                 else
                   TypeRef::VOID
                 end
      value_type = if value_type_expr = node.of_value_type
                     type_ref_for_name(normalize_declared_type_name(String.new(value_type_expr)))
                   elsif args.size >= 2
                     ctx.type_of(args[1])
                   else
                     TypeRef::VOID
                   end
      hash_type = if key_type != TypeRef::VOID && value_type != TypeRef::VOID
                    key_name = get_type_name_from_ref(key_type)
                    value_name = get_type_name_from_ref(value_type)
                    if key_name != "Unknown" && value_name != "Unknown"
                      type_ref_for_name("Hash(#{key_name}, #{value_name})")
                    else
                      ctx.get_type("Hash")
                    end
                  else
                    ctx.get_type("Hash")
                  end
      alloc = Allocate.new(ctx.next_id, hash_type, args)
      ctx.emit(alloc)
      record_allocation_location(ctx, alloc.id, @arena, node)
      alloc.id
    end

    private def lower_tuple_literal(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::TupleLiteralNode) : ValueId
      element_ids = node.elements.map { |e| lower_expr(ctx, e) }

      element_names = element_ids.map { |id| get_type_name_from_ref(ctx.type_of(id)) }
      tuple_type = if element_names.any? { |name| name == "Unknown" || name == "Void" }
                     ctx.get_type("Tuple")
                   else
                     type_ref_for_name("Tuple(#{element_names.join(", ")})")
                   end
      alloc = Allocate.new(ctx.next_id, tuple_type, element_ids)
      ctx.emit(alloc)
      record_allocation_location(ctx, alloc.id, @arena, node)
      alloc.id
    end

    private def lower_named_tuple_literal(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::NamedTupleLiteralNode) : ValueId
      # NamedTuple is like a Tuple but with named fields
      # For now, we treat it similarly to a Tuple - lowering values in order
      # The key names are available for type-level operations
      element_ids = node.entries.map { |entry| lower_expr(ctx, entry.value) }

      # Create a NamedTuple type based on keys
      # For simplicity, use NamedTuple as the type (real Crystal has specialized types)
      named_tuple_type = ctx.get_type("NamedTuple")
      alloc = Allocate.new(ctx.next_id, named_tuple_type, element_ids)
      ctx.emit(alloc)
      record_allocation_location(ctx, alloc.id, @arena, node)
      alloc.id
    end

    private def lower_range(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::RangeNode) : ValueId
      begin_id = lower_expr(ctx, node.begin_expr)
      end_id = lower_expr(ctx, node.end_expr)

      # Include exclusive flag as third argument
      excl_lit = Literal.new(ctx.next_id, TypeRef::BOOL, node.exclusive)
      ctx.emit(excl_lit)

      begin_name = get_type_name_from_ref(ctx.type_of(begin_id))
      end_name = get_type_name_from_ref(ctx.type_of(end_id))
      range_type_name = if begin_name == "Unknown" || end_name == "Unknown" ||
                           begin_name.includes?("|") || end_name.includes?("|")
                          "Range"
                        else
                          "Range(#{begin_name}, #{end_name})"
                        end
      range_type = type_ref_for_name(range_type_name)
      alloc = Allocate.new(ctx.next_id, range_type, [begin_id, end_id, excl_lit.id])
      ctx.emit(alloc)
      record_allocation_location(ctx, alloc.id, @arena, node)
      alloc.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # TYPE OPERATIONS
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_as(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::AsNode) : ValueId
      value_id = lower_expr(ctx, node.expression)
      # target_type is Slice(UInt8) - type name as bytes
      target_type = type_ref_for_name(String.new(node.target_type))

      # Check if value is union type - use UnionUnwrap instead of Cast
      value_type = ctx.type_of(value_id)
      if is_union_type?(value_type)
        variant_id = get_union_variant_id(value_type, target_type)
        if variant_id >= 0
          # Unsafe unwrap - assumes type_id matches (caller should have checked with is_a?)
          unwrap = UnionUnwrap.new(ctx.next_id, target_type, value_id, variant_id, safe: false)
          ctx.emit(unwrap)
          return unwrap.id
        end
      end

      # Regular cast for non-union types
      cast = Cast.new(ctx.next_id, target_type, value_id, target_type, safe: false)
      ctx.emit(cast)
      cast.id
    end

    private def lower_as_question(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::AsQuestionNode) : ValueId
      value_id = lower_expr(ctx, node.expression)
      # target_type is Slice(UInt8) - type name as bytes
      target_type = type_ref_for_name(String.new(node.target_type))

      cast = Cast.new(ctx.next_id, target_type, value_id, target_type, safe: true)
      ctx.emit(cast)
      cast.id
    end

    private def lower_is_a(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::IsANode) : ValueId
      value_id = lower_expr(ctx, node.expression)
      # target_type is Slice(UInt8) - type name as bytes
      check_type = type_ref_for_name(String.new(node.target_type))

      # Check if value is a union type - use UnionIs for runtime type check
      value_type = ctx.type_of(value_id)
      if is_union_type?(value_type)
        # Get the variant_type_id for the check_type within this union
        variant_id = get_union_variant_id(value_type, check_type)
        if variant_id >= 0
          union_is = UnionIs.new(ctx.next_id, value_id, variant_id)
          ctx.emit(union_is)
          return union_is.id
        end
      end

      # Regular is_a check for non-union types
      is_a = IsA.new(ctx.next_id, value_id, check_type)
      ctx.emit(is_a)
      is_a.id
    end

    private def lower_responds_to(ctx : LoweringContext, node : CrystalV2::Compiler::Frontend::RespondsToNode) : ValueId
      value_id = lower_expr(ctx, node.expression)
      value_type = ctx.type_of(value_id)

      # Get method name from the symbol literal
      method_name_node = @arena[node.method_name]
      method_name = case method_name_node
                    when CrystalV2::Compiler::Frontend::SymbolNode
                      String.new(method_name_node.name)
                    else
                      ""
                    end

      # Try to determine at compile time if the type responds to this method
      type_desc = @module.get_type_descriptor(value_type)
      class_name = type_desc ? type_desc.name : nil

      result = false
      if class_name && !method_name.empty?
        # Check if the class has this method
        # O(1) lookup: check exact match or mangled version exists
        full_method = "#{class_name}.#{method_name}"
        result = @function_types.has_key?(full_method) || has_function_base?(full_method)
      end

      # Return compile-time constant boolean
      bool_lit = Literal.new(ctx.next_id, TypeRef::BOOL, result)
      ctx.emit(bool_lit)
      bool_lit.id
    end

    # ═══════════════════════════════════════════════════════════════════════
    # HELPERS
    # ═══════════════════════════════════════════════════════════════════════

    private def lower_body(ctx : LoweringContext, body : Array(ExprId)) : ValueId
      last_value : ValueId? = nil
      progress_filter = ENV["DEBUG_LOWER_PROGRESS"]?
      progress_match = nil
      if progress_filter && @current_class && @current_method
        method_name = "#{@current_class}##{@current_method}"
        progress_match = progress_filter == "1" || method_name.includes?(progress_filter)
      end
      body.each_with_index do |expr_id, idx|
        next if expr_id.invalid?
        if progress_match
          node = @arena[expr_id]
          STDERR.puts "[LOWER_PROGRESS] method=#{@current_class}##{@current_method} idx=#{idx} node=#{node.class.name}"
        end
        last_value = lower_expr(ctx, expr_id)
      end

      last_value || begin
        nil_lit = Literal.new(ctx.next_id, TypeRef::NIL, nil)
        ctx.emit(nil_lit)
        nil_lit.id
      end
    end

    private def get_type_name(expr_id : ExprId) : String
      node = @arena[expr_id]
      case node
      when CrystalV2::Compiler::Frontend::PathNode
        String.new(node.names.first)
      when CrystalV2::Compiler::Frontend::GenericNode
        String.new(node.name)
      when CrystalV2::Compiler::Frontend::IdentifierNode
        String.new(node.name)
      else
        "Unknown"
      end
    end

    # Sanitize malformed type names with unbalanced parentheses
    private def sanitize_type_name(name : String) : String
      # Handle union types by sanitizing each part separately
      if name.includes?(" | ")
        parts = name.split(" | ").map { |part| sanitize_type_name_part(part.strip) }
        return parts.join(" | ")
      end

      sanitize_type_name_part(name)
    end

    private def sanitize_type_name_part(name : String) : String
      # Count parens to check balance
      open_count = name.count('(')
      close_count = name.count(')')

      return name if open_count == close_count

      # Remove extra closing parens - find and remove unbalanced ones
      if close_count > open_count
        result = String::Builder.new
        depth = 0
        extra_close = close_count - open_count

        name.each_char do |c|
          case c
          when '('
            depth += 1
            result << c
          when ')'
            if depth > 0
              depth -= 1
              result << c
            else
              # This is an unbalanced close paren
              if extra_close > 0
                extra_close -= 1
                # Skip this paren
              else
                result << c
              end
            end
          else
            result << c
          end
        end

        return result.to_s
      end

      # Remove extra opening parens from the end (less common)
      if open_count > close_count
        result = String::Builder.new
        depth = 0
        extra_open = open_count - close_count

        # Reverse scan to find unbalanced opens at end
        chars = name.chars.reverse
        kept_chars = [] of Char

        chars.each do |c|
          case c
          when ')'
            depth += 1
            kept_chars << c
          when '('
            if depth > 0
              depth -= 1
              kept_chars << c
            else
              if extra_open > 0
                extra_open -= 1
              else
                kept_chars << c
              end
            end
          else
            kept_chars << c
          end
        end

        return kept_chars.reverse.join
      end

      name
    end

    private def normalize_tuple_literal_type_name(name : String) : String
      trimmed = name.strip
      return trimmed unless trimmed.starts_with?("{") && trimmed.ends_with?("}")

      inner = trimmed[1, trimmed.size - 2]
      tuple_args = split_generic_type_args(inner)
      "Tuple(#{tuple_args.join(", ")})"
    end

    private def type_cache_context : String?
      @current_namespace_override || @current_class
    end

    private def type_cache_key(name : String) : String
      return name if name.empty?
      return name if name.starts_with?("::")
      return name if name.includes?("::")
      context = type_cache_context
      return name if context.nil? || context.empty?
      "#{context}::#{name}"
    end

    private def invalidate_type_cache_for_namespace(name : String) : Nil
      return if name.empty?
      short = name.split("::").last?
      keys = [] of String
      @type_cache.each_key do |key|
        next if key.empty?
        if key == name || key.includes?("::#{name}") || key.starts_with?("#{name}(")
          keys << key
          next
        end
        if short && (key == short || key.includes?("::#{short}") || key.starts_with?("#{short}("))
          keys << key
        end
      end
      keys.each { |key| @type_cache.delete(key) }
    end

    private def invalidate_type_cache_for_macro_output(output : String) : Nil
      return if output.empty?
      return unless output.matches?(/\b(class|module|struct|enum|lib|alias)\b/)

      if context = type_cache_context
        invalidate_type_cache_for_namespace(context)
      else
        @type_cache.clear
      end
    end

    private def type_ref_for_name(name : String) : TypeRef
      # Sanitize malformed type names (extra parens etc)
      name = sanitize_type_name(name)

      # Normalize union type names: "Int32|Nil" -> "Int32 | Nil"
      # This ensures consistent caching regardless of spacing
      normalized_name = if name.includes?("|")
        name.split("|").map(&.strip).join(" | ")
      else
        name
      end

      lookup_name = normalized_name
      if lookup_name.includes?("typeof(")
        lookup_name = resolve_typeof_in_type_string(lookup_name)
      end
      # Resolve type parameters (including nested generics) before cache and namespace resolution.
      if !@type_param_map.empty?
        substituted_name = substitute_type_params_in_type_name(lookup_name)
        lookup_name = substituted_name if substituted_name != lookup_name
      end
      if type_param_like?(lookup_name) && !@type_param_map.has_key?(lookup_name)
        return TypeRef::VOID
      end
      # Resolve type names in the current namespace before cache lookup.
      # This avoids poisoning the cache with names that resolve differently per scope.
      if !lookup_name.includes?("|")
        lookup_name = resolve_type_name_in_context(lookup_name)
      end
      cache_key = type_cache_key(lookup_name)
      if lookup_name.ends_with?(".class") || lookup_name.ends_with?(".metaclass")
        if base_name = resolve_type_literal_class_name(lookup_name)
          result = type_ref_for_name(base_name)
          @type_cache[cache_key] = result
          return result
        end
      end

      if cached = @type_cache[cache_key]?
        if info = split_generic_base_and_args(lookup_name)
          if template = @generic_templates[info[:base]]?
            if desc = @module.get_type_descriptor(cached)
              expected_kind = template.is_struct ? TypeKind::Struct : TypeKind::Class
              return cached if desc.kind == expected_kind
            else
              return cached
            end
          else
            return cached
          end
        else
          return cached
        end
      end

      if proc_ref = proc_type_ref_for_name(lookup_name)
        @type_cache[cache_key] = proc_ref
        return proc_ref
      end

      # Normalize tuple literal types: "{A, B}" -> "Tuple(A, B)"
      # Do this before union handling so inner unions are preserved.
      if lookup_name.starts_with?("{") && lookup_name.ends_with?("}")
        inner = lookup_name[1, lookup_name.size - 2]
        tuple_args = split_generic_type_args(inner)
        tuple_name = "Tuple(#{tuple_args.join(", ")})"
        result = type_ref_for_name(tuple_name)
        @type_cache[cache_key] = result
        return result
      end

      # Check for union type syntax: "Type1 | Type2" or "Type1|Type2" (parser may not add spaces)
      # NOTE: Don't set placeholder here - create_union_type handles its own caching
      if lookup_name.includes?("|")
        result = create_union_type(lookup_name)
        return result
      end

      # Mark as being processed with placeholder to break cycles (BEFORE any recursion)
      # Only for non-union types - union types are handled by create_union_type
      @type_cache[cache_key] = TypeRef::VOID

      # Handle nullable type suffix: "T?" means "T | Nil"
      if lookup_name.ends_with?("?")
        base_name = lookup_name[0, lookup_name.size - 1]
        # Substitute type parameter if present
        base_name = @type_param_map[base_name]? || base_name
        union_name = "#{base_name} | Nil"
        result = create_union_type(union_name)
        @type_cache[cache_key] = result
        return result
      end

      # Check if this is a type alias (but not self-referencing)
      if alias_target = @type_aliases[lookup_name]?
        if alias_target != lookup_name
          result = type_ref_for_name(alias_target)
          @type_cache[cache_key] = result
          return result
        end
      end

      # Check LibC type aliases (platform-specific fallback)
      if libc_target = LIBC_TYPE_ALIASES[lookup_name]?
        result = type_ref_for_name(libc_target)
        @type_cache[cache_key] = result
        return result
      end

      # Handle generic types like Pointer(K), Array(T) - substitute type parameters
      if info = split_generic_base_and_args(lookup_name)
        # Parse generic: "Pointer(K)" -> base="Pointer", params=["K"]
        base_name = info[:base]
        params_str = info[:args]

        # Substitute each type parameter
        substituted_params = split_generic_type_args(params_str).map do |param|
          param = param.strip
          param = @type_param_map[param]? || param
          normalize_tuple_literal_type_name(param)
        end

        # Reconstruct with substituted params
        substituted_name = "#{base_name}(#{substituted_params.join(", ")})"
        if substituted_name != lookup_name
          # Types changed - recurse with new name
          return type_ref_for_name(substituted_name)
        end

        # Avoid materializing generics with unresolved type parameters.
        # This preserves prior behavior for `Array(T)`/`Pointer(T)` while
        # still allowing concrete generics like `Slice(UInt8)`.
        unresolved_param = substituted_params.any? do |param|
          param_name = param.strip
          next false if param_name.empty?
          next false if @type_param_map.has_key?(param_name)
          if template = @generic_templates[base_name]?
            template.type_params.includes?(param_name)
          else
            param_name.matches?(/\A[A-Z]\z/)
          end
        end
        if unresolved_param
          @type_cache.delete(cache_key)
          return TypeRef::VOID
        end

        # Intern a parameterized type descriptor so downstream passes can recover element/key/value types.
        # This is critical for arrays/hashes/pointers where runtime representation is "ptr", but codegen
        # still needs the generic parameters for correct loads/stores.
        type_params = substituted_params.map { |p| type_ref_for_name(p) }
        type_kind = case base_name
                    when "Array", "StaticArray" then TypeKind::Array
                    when "Hash"                then TypeKind::Hash
                    when "Pointer"             then TypeKind::Pointer
                    when "Tuple"               then TypeKind::Tuple
                    when "NamedTuple"          then TypeKind::NamedTuple
                    else
                      if template = @generic_templates[base_name]?
                        template.is_struct ? TypeKind::Struct : TypeKind::Class
                      else
                        TypeKind::Generic
                      end
                    end
        result = @module.intern_type(TypeDescriptor.new(type_kind, substituted_name, type_params))
        @type_cache[cache_key] = result

        # Trigger monomorphization if this is a generic class/struct template
        # This ensures included module methods get registered for the specialized type
        if template = @generic_templates[base_name]?
          unless @monomorphized.includes?(substituted_name)
            if !concrete_type_args?(substituted_params)
              STDERR.puts "[MONO] Skipping unresolved: #{substituted_name}" if ENV.has_key?("DEBUG_MONO")
            elsif @suppress_monomorphization
              # Skip eager monomorphization while scanning specialized bodies.
            elsif @defer_monomorphization
              # Queue for later - templates may not be fully registered yet
              @pending_monomorphizations << {base_name, substituted_params, substituted_name}
            else
              monomorphize_generic_class(base_name, substituted_params, substituted_name)
            end
          end
        end

        return result
      end

      # Handle pointer types (Void*, Pointer(T), T*)
      # IMPORTANT: This must be checked BEFORE the case statement for "Void"
      if lookup_name.ends_with?("*")
        base_name = lookup_name
        star_count = 0
        while base_name.ends_with?("*")
          base_name = base_name[0...-1]
          star_count += 1
        end
        base_name = base_name.strip
        if base_name.empty?
          @type_cache[cache_key] = TypeRef::POINTER
          return TypeRef::POINTER
        end

        pointer_name = base_name
        star_count.times { pointer_name = "Pointer(#{pointer_name})" }
        result = type_ref_for_name(pointer_name)
        @type_cache[cache_key] = result
        return result
      end

      if lookup_name == "Pointer"
        # Pointer(T) or just Pointer -> pointer type
        @type_cache[cache_key] = TypeRef::POINTER
        return TypeRef::POINTER
      end

      if event_loop_interface_module_name?(lookup_name)
        result = @module.intern_type(TypeDescriptor.new(TypeKind::Module, lookup_name))
        @type_cache[cache_key] = result
        return result
      end

      result = case lookup_name
               when "Void"    then TypeRef::VOID
               when "Nil"     then TypeRef::NIL
               when "Bool"    then TypeRef::BOOL
               when "Int8"    then TypeRef::INT8
               when "Int16"   then TypeRef::INT16
               when "Int32"   then TypeRef::INT32
               when "Int64"   then TypeRef::INT64
               when "Int128"  then TypeRef::INT128
               when "UInt8"   then TypeRef::UINT8
               when "UInt16"  then TypeRef::UINT16
               when "UInt32"  then TypeRef::UINT32
               when "UInt64"  then TypeRef::UINT64
               when "UInt128" then TypeRef::UINT128
               when "Float32" then TypeRef::FLOAT32
               when "Float64" then TypeRef::FLOAT64
               when "Char"    then TypeRef::CHAR
               when "String"  then TypeRef::STRING
               when "Symbol"  then TypeRef::SYMBOL
               else
                 # Check if this is an enum type - enums are stored as Int32
                 if enum_info = @enum_info
                   if enum_info.has_key?(lookup_name)
                     @type_cache[cache_key] = TypeRef::INT32
                     return TypeRef::INT32
                   end
                 end

                 # Prefer already-registered concrete types to preserve kind (struct vs class).
                 if info = @class_info[lookup_name]?
                   @type_cache[cache_key] = info.type_ref
                   return info.type_ref
                 end
                 if @module_defs.has_key?(lookup_name)
                   result = @module.intern_type(TypeDescriptor.new(TypeKind::Module, lookup_name))
                   @type_cache[cache_key] = result
                   return result
                 end

                 # For unknown types, keep the unqualified name to avoid poisoning
                 # the cache with a context-specific namespace.
                 @module.intern_type(TypeDescriptor.new(TypeKind::Class, lookup_name))
               end
      # Cache the result to avoid VOID placeholder being returned on subsequent calls
      @type_cache[cache_key] = result
      result
    end

    # Create a union type from "Type1 | Type2 | Type3" syntax
    private def create_union_type(name : String) : TypeRef
      # Parse variant type names (handle both "Type1 | Type2" and "Type1|Type2")
      variant_names = name.split("|").map(&.strip).reject(&.empty?)
      if variant_names.empty?
        return TypeRef::VOID
      end

      resolved_variant_names = variant_names.map do |variant|
        resolved = variant
        if !@type_param_map.empty?
          resolved = substitute_type_params_in_type_name(resolved)
        end
        resolved = resolve_type_name_in_context(resolved)
        resolved
      end
      normalized_name = resolved_variant_names.join(" | ")
      cache_key = type_cache_key(normalized_name)

      # Check cache first to prevent infinite recursion
      if cached = @type_cache[cache_key]?
        return cached
      end
      # Mark as being processed with placeholder to break cycles
      @type_cache[cache_key] = TypeRef::VOID

      # Get TypeRefs for each variant (recursive to handle nested unions)
      variant_refs = resolved_variant_names.map { |vn| type_ref_for_name(vn) }

      # Calculate union layout
      variants = [] of MIR::UnionVariantDescriptor
      max_size = 0
      max_align = 4  # Minimum alignment for type_id

      variant_refs.each_with_index do |vref, idx|
        vsize = type_size(vref)
        valign = type_alignment(vref)
        max_size = {max_size, vsize}.max
        max_align = {max_align, valign}.max

        # Convert HIR::TypeRef to MIR::TypeRef using proper ID mapping
        mir_type_ref = hir_to_mir_type_ref(vref)

        variants << MIR::UnionVariantDescriptor.new(
          type_id: idx,
          type_ref: mir_type_ref,
          full_name: resolved_variant_names[idx],
          size: vsize,
          alignment: valign,
          field_offsets: nil
        )
      end

      # Total size: header (4 bytes for type_id) + padding + max payload
      payload_offset = ((4 + max_align - 1) // max_align) * max_align
      total_size = payload_offset + max_size

      # Create union type and register descriptor
      type_ref = @module.intern_type(TypeDescriptor.new(TypeKind::Union, normalized_name))

      # Convert to MIR::TypeRef for the descriptor key
      mir_union_type_ref = hir_to_mir_type_ref(type_ref)

      # Create union descriptor
      descriptor = MIR::UnionDescriptor.new(
        name: normalized_name,
        variants: variants,
        total_size: total_size,
        alignment: max_align
      )

      # Store descriptor for LLVM backend
      @union_descriptors[mir_union_type_ref] = descriptor

      # Update cache with real value (replacing placeholder)
      @type_cache[cache_key] = type_ref

      type_ref
    end

    # Create a nullable union type (T | Nil) from a concrete type
    private def create_union_type_for_nullable(concrete_type : TypeRef) : TypeRef
      # Get the name of the concrete type
      type_name = get_type_name_from_ref(concrete_type)
      union_name = "#{type_name} | Nil"

      # Create the union type via the string-based method
      create_union_type(union_name)
    end

    # Get the type name from a TypeRef
    private def get_type_name_from_ref(type_ref : TypeRef) : String
      case type_ref
      when TypeRef::VOID    then "Void"
      when TypeRef::BOOL    then "Bool"
      when TypeRef::INT8    then "Int8"
      when TypeRef::INT16   then "Int16"
      when TypeRef::INT32   then "Int32"
      when TypeRef::INT64   then "Int64"
      when TypeRef::INT128  then "Int128"
      when TypeRef::UINT8   then "UInt8"
      when TypeRef::UINT16  then "UInt16"
      when TypeRef::UINT32  then "UInt32"
      when TypeRef::UINT64  then "UInt64"
      when TypeRef::UINT128 then "UInt128"
      when TypeRef::FLOAT32 then "Float32"
      when TypeRef::FLOAT64 then "Float64"
      when TypeRef::CHAR    then "Char"
      when TypeRef::STRING  then "String"
      when TypeRef::NIL     then "Nil"
      when TypeRef::SYMBOL  then "Symbol"
      when TypeRef::POINTER then "Pointer"
      else
        # Look up in type registry
        if desc = @module.get_type_descriptor(type_ref)
          desc.name
        else
          "Unknown"
        end
      end
    end

    # Convert HIR::TypeRef to MIR::TypeRef with proper ID mapping
    # HIR and MIR have different primitive type IDs
    private def hir_to_mir_type_ref(hir_type : TypeRef) : MIR::TypeRef
      case hir_type
      when TypeRef::VOID    then MIR::TypeRef::VOID
      when TypeRef::BOOL    then MIR::TypeRef::BOOL
      when TypeRef::INT8    then MIR::TypeRef::INT8
      when TypeRef::INT16   then MIR::TypeRef::INT16
      when TypeRef::INT32   then MIR::TypeRef::INT32
      when TypeRef::INT64   then MIR::TypeRef::INT64
      when TypeRef::INT128  then MIR::TypeRef::INT128
      when TypeRef::UINT8   then MIR::TypeRef::UINT8
      when TypeRef::UINT16  then MIR::TypeRef::UINT16
      when TypeRef::UINT32  then MIR::TypeRef::UINT32
      when TypeRef::UINT64  then MIR::TypeRef::UINT64
      when TypeRef::UINT128 then MIR::TypeRef::UINT128
      when TypeRef::FLOAT32 then MIR::TypeRef::FLOAT32
      when TypeRef::FLOAT64 then MIR::TypeRef::FLOAT64
      when TypeRef::CHAR    then MIR::TypeRef::CHAR
      when TypeRef::STRING  then MIR::TypeRef::STRING
      when TypeRef::NIL     then MIR::TypeRef::NIL
      when TypeRef::SYMBOL  then MIR::TypeRef::SYMBOL
      when TypeRef::POINTER then MIR::TypeRef::POINTER
      else
        # User-defined types: offset by 20 (matching hir_to_mir.cr convert_type)
        MIR::TypeRef.new(hir_type.id + 20_u32)
      end
    end

    # Convert MIR::TypeRef back to HIR::TypeRef (inverse of hir_to_mir_type_ref).
    private def mir_to_hir_type_ref(mir_type : MIR::TypeRef) : TypeRef
      case mir_type
      when MIR::TypeRef::VOID    then TypeRef::VOID
      when MIR::TypeRef::BOOL    then TypeRef::BOOL
      when MIR::TypeRef::INT8    then TypeRef::INT8
      when MIR::TypeRef::INT16   then TypeRef::INT16
      when MIR::TypeRef::INT32   then TypeRef::INT32
      when MIR::TypeRef::INT64   then TypeRef::INT64
      when MIR::TypeRef::INT128  then TypeRef::INT128
      when MIR::TypeRef::UINT8   then TypeRef::UINT8
      when MIR::TypeRef::UINT16  then TypeRef::UINT16
      when MIR::TypeRef::UINT32  then TypeRef::UINT32
      when MIR::TypeRef::UINT64  then TypeRef::UINT64
      when MIR::TypeRef::UINT128 then TypeRef::UINT128
      when MIR::TypeRef::FLOAT32 then TypeRef::FLOAT32
      when MIR::TypeRef::FLOAT64 then TypeRef::FLOAT64
      when MIR::TypeRef::CHAR    then TypeRef::CHAR
      when MIR::TypeRef::STRING  then TypeRef::STRING
      when MIR::TypeRef::NIL     then TypeRef::NIL
      when MIR::TypeRef::SYMBOL  then TypeRef::SYMBOL
      when MIR::TypeRef::POINTER then TypeRef::POINTER
      else
        first_user_mir = TypeRef::FIRST_USER_TYPE + 20_u32
        if mir_type.id >= first_user_mir
          TypeRef.new(mir_type.id - 20_u32)
        else
          TypeRef::POINTER
        end
      end
    end

    # Get type alignment in bytes
    private def type_alignment(type : TypeRef) : Int32
      case type
      when TypeRef::BOOL, TypeRef::INT8, TypeRef::UINT8
        1
      when TypeRef::INT16, TypeRef::UINT16
        2
      when TypeRef::INT32, TypeRef::UINT32, TypeRef::FLOAT32, TypeRef::CHAR
        4
      when TypeRef::INT64, TypeRef::UINT64, TypeRef::FLOAT64
        8
      when TypeRef::INT128, TypeRef::UINT128
        16
      else
        8  # Pointer alignment for reference types
      end
    end

    private def type_ref_for_expr(ctx : LoweringContext, expr_id : ExprId) : TypeRef
      name = get_type_name(expr_id)
      type_ref_for_name(name)
    end

    # Check if a type is a union type or nilable (T | Nil)
    private def is_union_or_nilable_type?(type : TypeRef) : Bool
      is_union_type?(type)
    end

    # Intrinsic: value.nil? for union types
    # Checks if the union's type tag indicates Nil variant
    private def lower_nil_check_intrinsic(ctx : LoweringContext, value_id : ValueId, value_type : TypeRef) : ValueId
      nil_variant_id = get_union_variant_id(value_type, TypeRef::NIL)
      if nil_variant_id < 0
        # Fallback: if we can't resolve a union variant, conservatively return false.
        # This should be rare (union descriptors are registered during AST->HIR conversion).
        lit = Literal.new(ctx.next_id, TypeRef::BOOL, false)
        ctx.emit(lit)
        return lit.id
      end

      # Emit UnionIs instruction to check if value is Nil variant
      union_is = UnionIs.new(ctx.next_id, value_id, nil_variant_id)
      ctx.emit(union_is)
      ctx.register_type(union_is.id, TypeRef::BOOL)
      union_is.id
    end

    # Intrinsic: value.not_nil! for union types
    # Extracts the non-nil value from a union (asserts it's not nil)
    private def lower_not_nil_intrinsic(ctx : LoweringContext, value_id : ValueId, value_type : TypeRef) : ValueId
      # Determine the non-nil variant and its index from the union descriptor.
      non_nil_type = TypeRef::POINTER
      non_nil_variant = -1
      extra_non_nil = false

      mir_union_ref = hir_to_mir_type_ref(value_type)
      if descriptor = @union_descriptors[mir_union_ref]?
        descriptor.variants.each_with_index do |variant, idx|
          next if variant.type_ref == MIR::TypeRef::NIL
          if non_nil_variant >= 0
            extra_non_nil = true
            break
          end
          non_nil_variant = idx
          non_nil_type = mir_to_hir_type_ref(variant.type_ref)
        end
      end

      # Only unwrap when a single concrete non-nil variant exists.
      if non_nil_variant >= 0 && !extra_non_nil
        unwrap = UnionUnwrap.new(ctx.next_id, non_nil_type, value_id, non_nil_variant, false)
        ctx.emit(unwrap)
        ctx.register_type(unwrap.id, non_nil_type)
        return unwrap.id
      end

      # Fallback: return the original value to avoid incorrect narrowing.
      value_id
    end
  end
end
