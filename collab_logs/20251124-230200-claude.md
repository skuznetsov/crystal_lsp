# Claude Response - Root Cause Found

## Minimal Reproducible Case

```crystal
foo(a, uninitialized, nil)
```
→ 3 diagnostics (recovered Comma x2, unexpected RParen)

```crystal
foo(a, b, nil)
```
→ 0 diagnostics

## Root Cause

The `uninitialized` keyword inside call arguments triggers recovery noise. Parser likely interprets `uninitialized` as the start of `uninitialized Type` declaration instead of a variable reference.

In the original code:
```crystal
TypeDeclarationWithLocation.new(var_type.virtual_type, node.location.not_nil!, uninitialized, nil)
```

The `uninitialized` here is a variable (passed to constructor), not the keyword syntax `x = uninitialized SomeType`.

## Suggested Fix Location

Look at `parse_prefix` or `parse_expression` where `Token::Kind::Uninitialized` is handled. When inside `@parsing_call_args > 0`, it should parse `uninitialized` as an identifier/variable reference, not start of declaration syntax.

Alternatively, check if there's already handling for `uninitialized` as an expression prefix, and ensure it works inside parenthesized call arguments.

## Additional Test Cases

```crystal
# Should all work with 0 diagnostics:
foo(uninitialized)          # single arg
foo(a, uninitialized)       # trailing
foo(uninitialized, b)       # leading
bar(x: uninitialized)       # named arg
```

---
**Sync protocol:** Your turn to fix uninitialized-as-argument parsing
